Recipe name,Recipe description,Recipe type,Recipe source code,Recipe options
The name of the recipe.,The description of the recipe.,"Differentiate between Java and YAML recipes, as they may be two independent data sets used in LLM fine-tuning.",The full source code of the recipe.,JSON format of recipe options.
JUnit `assertInstanceOf` to AssertJ,Convert JUnit-style `assertInstanceOf()` to AssertJ's `assertThat().isInstanceOf()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class JUnitAssertInstanceOfToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_INSTANCE_OF_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertInstanceOf(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertInstanceOf` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertInstanceOf()` to AssertJ's `assertThat().isInstanceOf()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_INSTANCE_OF_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_INSTANCE_OF_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                Expression expected = mi.getArguments().get(0);
                Expression actual = mi.getArguments().get(1);
                if (mi.getArguments().size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isInstanceOf(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), method.getCoordinates().replace(), actual, expected);
                }

                Expression messageOrSupplier = mi.getArguments().get(2);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isInstanceOf(#{any()});"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), method.getCoordinates().replace(), actual, messageOrSupplier, expected);
            }
        });
    }
}
",{}
JUnit AssertThrows to AssertJ exceptionType,Convert `JUnit#AssertThrows` to `AssertJ#assertThatExceptionOfType` to allow for chained assertions on the thrown exception.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;
import java.util.Optional;

public class JUnitAssertThrowsToAssertExceptionType extends Recipe {

    private static final String JUNIT_ASSERTIONS = ""org.junit.jupiter.api.Assertions"";
    private static final String ASSERTIONS_FOR_CLASS_TYPES = ""org.assertj.core.api.AssertionsForClassTypes"";
    private static final MethodMatcher ASSERT_THROWS_MATCHER = new MethodMatcher(JUNIT_ASSERTIONS + "" assertThrows(..)"");

    @Override
    public String getDisplayName() {
        return ""JUnit AssertThrows to AssertJ exceptionType"";
    }

    @Override
    public String getDescription() {
        return ""Convert `JUnit#AssertThrows` to `AssertJ#assertThatExceptionOfType` to allow for chained assertions on the thrown exception."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_THROWS_MATCHER), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_THROWS_MATCHER.matches(mi)) {
                    return mi;
                }

                Optional<Boolean> hasReturnType = hasReturnType();

                if (!hasReturnType.isPresent()) {
                    return mi;
                }

                boolean returnActual = hasReturnType.get();

                maybeAddImport(ASSERTIONS_FOR_CLASS_TYPES, ""assertThatExceptionOfType"");
                maybeRemoveImport(JUNIT_ASSERTIONS + "".assertThrows"");
                maybeRemoveImport(JUNIT_ASSERTIONS);

                List<Expression> args = mi.getArguments();

                if (args.size() == 2) {
                    String code = ""assertThatExceptionOfType(#{any(java.lang.Class)}).isThrownBy(#{any(org.assertj.core.api.ThrowableAssert.ThrowingCallable)})"";
                    if (returnActual) {
                        code += "".actual()"";
                    }
                    return JavaTemplate.builder(code)
                            .staticImports(ASSERTIONS_FOR_CLASS_TYPES + "".assertThatExceptionOfType"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), args.get(0), args.get(1));
                }

                String code = ""assertThatExceptionOfType(#{any()}).as(#{any()}).isThrownBy(#{any(org.assertj.core.api.ThrowableAssert.ThrowingCallable)})"";
                if (returnActual) {
                    code += "".actual()"";
                }
                return JavaTemplate.builder(code)
                        .staticImports(ASSERTIONS_FOR_CLASS_TYPES + "".assertThatExceptionOfType"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), args.get(0), args.get(2), args.get(1));
            }

            /**
             * Check if there is a return type which would indicate the need for using
             * {@code .actual()} in the AssertJ call.
             * <p>
             * If the presence of a return type could not be determined then {@code Optional.empty()} is returned
             * and the current {@code J.MethodInvocation} should be used without further changes.
             *
             * @return {@code Optional.of(true)} if there is a return type otherwise {@code Optional.of(false)}.
             * If it could not be determined then {@code Optional.empty()}.
             */
            private Optional<Boolean> hasReturnType() {
                Object parent = getCursor().getParentTreeCursor().getValue();

                // These all have the method invocation return something
                if (parent instanceof J.Assignment ||
                        parent instanceof J.VariableDeclarations ||
                        parent instanceof J.VariableDeclarations.NamedVariable ||
                        parent instanceof J.Return ||
                        parent instanceof J.Ternary) {
                    return Optional.of(true);
                }

                if (parent instanceof J.Block) {
                    return Optional.of(false);
                }

                // Unknown parent type so not supported
                return Optional.empty();
            }
        });
    }
}
",{}
JUnit `assertTrue` to AssertJ,Convert JUnit-style `assertTrue()` to AssertJ's `assertThat().isTrue()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

public class JUnitAssertTrueToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_TRUE_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertTrue(boolean, ..)"");

    @Override
    public String getDisplayName() {
        return ""JUnit `assertTrue` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertTrue()` to AssertJ's `assertThat().isTrue()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_TRUE_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_TRUE_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                List<Expression> args = mi.getArguments();
                Expression actual = args.get(0);
                if (args.size() == 1) {
                    return JavaTemplate.builder(""assertThat(#{any(boolean)}).isTrue();"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual);
                }

                Expression message = args.get(1);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any(String)}).isTrue();"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message);
            }
        });
    }
}
",{}
JUnit `assertNull` to AssertJ,Convert JUnit-style `assertNull()` to AssertJ's `assertThat().isNull()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

public class JUnitAssertNullToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_NULL_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertNull(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertNull` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertNull()` to AssertJ's `assertThat().isNull()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_NULL_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_NULL_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                List<Expression> args = mi.getArguments();
                Expression actual = args.get(0);
                if (args.size() == 1) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isNull();"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual);
                }

                Expression message = args.get(1);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isNull();"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message);
            }
        });
    }
}
",{}
Simplify redundant AssertJ assertion chains,Removes redundant AssertJ assertions when chained methods already provide the same or stronger guarantees.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class SimplifyRedundantAssertJChains extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Simplify redundant AssertJ assertion chains"";
    }

    @Override
    public String getDescription() {
        return ""Removes redundant AssertJ assertions when chained methods already provide the same or stronger guarantees."";
    }

    // Matcher for isNotNull() method - use wildcard to match any AbstractAssert subclass
    private static final MethodMatcher isNotNullMatcher = new MethodMatcher(""org.assertj.core.api..* isNotNull()"");

    // Matchers for assertions that already imply non-null - use wildcards for flexibility
    private static final MethodMatcher[] nonNullImplyingMatchers = {
            // String assertions
            new MethodMatcher(""org.assertj.core.api..* isNotEmpty()""),
            new MethodMatcher(""org.assertj.core.api..* isEmpty()""),
            new MethodMatcher(""org.assertj.core.api..* isBlank()""),
            new MethodMatcher(""org.assertj.core.api..* isNotBlank()""),
            new MethodMatcher(""org.assertj.core.api..* hasSize(..)""),
            new MethodMatcher(""org.assertj.core.api..* contains(..)""),
            new MethodMatcher(""org.assertj.core.api..* startsWith(..)""),
            new MethodMatcher(""org.assertj.core.api..* endsWith(..)""),
            new MethodMatcher(""org.assertj.core.api..* matches(..)""),
            new MethodMatcher(""org.assertj.core.api..* isEqualToIgnoringCase(..)""),

            // More assertions that imply non-null - using wildcards consistently
            new MethodMatcher(""org.assertj.core.api..* containsOnly(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsExactly(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsAll(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsKey(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsKeys(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsValue(..)""),
            new MethodMatcher(""org.assertj.core.api..* containsEntry(..)""),
            new MethodMatcher(""org.assertj.core.api..* isPresent()""),
            new MethodMatcher(""org.assertj.core.api..* isNotPresent()""),
            new MethodMatcher(""org.assertj.core.api..* isTrue()""),
            new MethodMatcher(""org.assertj.core.api..* isFalse()""),
            new MethodMatcher(""org.assertj.core.api..* isNotEqualTo(..)""),
            new MethodMatcher(""org.assertj.core.api..* isNotSameAs(..)""),
            new MethodMatcher(""org.assertj.core.api..* isInstanceOf(..)""),
            new MethodMatcher(""org.assertj.core.api..* hasSameClassAs(..)""),
            new MethodMatcher(""org.assertj.core.api..* hasToString(..)""),
            new MethodMatcher(""org.assertj.core.api..* isZero()""),
            new MethodMatcher(""org.assertj.core.api..* isNotZero()""),
            new MethodMatcher(""org.assertj.core.api..* isPositive()""),
            new MethodMatcher(""org.assertj.core.api..* isNegative()""),
            new MethodMatcher(""org.assertj.core.api..* exists()""),
            new MethodMatcher(""org.assertj.core.api..* isFile()""),
            new MethodMatcher(""org.assertj.core.api..* isDirectory()""),
            new MethodMatcher(""org.assertj.core.api..* isRegularFile()""),
            new MethodMatcher(""org.assertj.core.api..* canRead()""),
            new MethodMatcher(""org.assertj.core.api..* canWrite()"")
    };
    // Matcher for isNotEmpty() preceded by isNotEmpty()
    private static final MethodMatcher isNotEmptyMatcher = new MethodMatcher(""org.assertj.core.api..* isNotEmpty()"");
    private static final MethodMatcher containsMatcher = new MethodMatcher(""org.assertj.core.api..* contains*(..)"");
    // Matcher for isPresent() preceded by another assertion
    private static final MethodMatcher isPresentMatcher = new MethodMatcher(""org.assertj.core.api..* isPresent()"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(isNotNullMatcher), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

                // Check if the select is a method invocation
                if (!(mi.getSelect() instanceof J.MethodInvocation)) {
                    return mi;
                }

                J.MethodInvocation select = (J.MethodInvocation) mi.getSelect();

                // Check for isNotNull() followed by an assertion that implies non-null
                if (isNotNullMatcher.matches(select)) {
                    for (MethodMatcher matcher : nonNullImplyingMatchers) {
                        if (matcher.matches(mi)) {
                            // Remove the redundant isNotNull() by returning the method with the select's select
                            return mi.withSelect(select.getSelect());
                        }
                    }
                }

                // Check for isNotEmpty() followed by contains()
                if (isNotEmptyMatcher.matches(select) && containsMatcher.matches(mi)) {
                    // Remove the redundant isNotEmpty()
                    return mi.withSelect(select.getSelect());
                }

                // Check for isPresent() followed by contains() (for Optional)
                if (isPresentMatcher.matches(select) && containsMatcher.matches(mi)) {
                    // Remove the redundant isPresent()
                    return mi.withSelect(select.getSelect());
                }

                return mi;
            }
        });
    }
}
",{}
JUnit `assertArrayEquals` to assertJ,Convert JUnit-style `assertArrayEquals()` to AssertJ's `assertThat().contains()` equivalents.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class JUnitAssertArrayEqualsToAssertThat extends Recipe {

    private static final String JUNIT = ""org.junit.jupiter.api.Assertions"";
    private static final String ASSERTJ = ""org.assertj.core.api.Assertions"";
    private static final MethodMatcher ASSERT_ARRAY_EQUALS_MATCHER = new MethodMatcher(JUNIT + "" assertArrayEquals(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertArrayEquals` to assertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertArrayEquals()` to AssertJ's `assertThat().contains()` equivalents."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_ARRAY_EQUALS_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation md = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_ARRAY_EQUALS_MATCHER.matches(md)) {
                    return md;
                }

                maybeAddImport(ASSERTJ, ""assertThat"", false);
                maybeRemoveImport(JUNIT);

                List<Expression> args = md.getArguments();
                Expression expected = args.get(0);
                Expression actual = args.get(1);
                if (args.size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{anyArray()}).containsExactly(#{anyArray()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), md.getCoordinates().replace(), actual, expected);
                }
                if (args.size() == 3 && isFloatingPointType(args.get(2))) {
                    maybeAddImport(ASSERTJ, ""within"", false);
                    // assert is using floating points with a delta and no message.
                    return JavaTemplate.builder(""assertThat(#{anyArray()}).containsExactly(#{anyArray()}, within(#{any()}));"")
                            .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), md.getCoordinates().replace(), actual, expected, args.get(2));
                }
                if (args.size() == 3) {
                    Expression message = args.get(2);
                    return JavaTemplate.builder(""assertThat(#{anyArray()}).as(#{any()}).containsExactly(#{anyArray()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), md.getCoordinates().replace(), actual, message, expected);
                }

                maybeAddImport(ASSERTJ, ""within"", false);

                // The assertEquals is using a floating point with a delta argument and a message.
                Expression message = args.get(3);
                return JavaTemplate.builder(""assertThat(#{anyArray()}).as(#{any()}).containsExactly(#{anyArray()}, within(#{}));"")
                        .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), md.getCoordinates().replace(), actual, message, expected, args.get(2));
            }

            /**
             * Returns true if the expression's type is either a primitive float/double or their object forms Float/Double
             *
             * @param expression The expression parsed from the original AST.
             * @return true if the type is a floating point number.
             */
            private boolean isFloatingPointType(Expression expression) {
                JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(expression.getType());
                if (fullyQualified != null) {
                    String typeName = fullyQualified.getFullyQualifiedName();
                    return ""java.lang.Double"".equals(typeName) || ""java.lang.Float"".equals(typeName);
                }

                JavaType.Primitive parameterType = TypeUtils.asPrimitive(expression.getType());
                return parameterType == JavaType.Primitive.Double || parameterType == JavaType.Primitive.Float;
            }
        });
    }
}
",{}
Simplify AssertJ assertions with `hasSize` argument,Simplify AssertJ assertions by replacing `hasSize` with `hasSameSizeAs` dedicated assertions.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import static java.util.Collections.singletonList;

public class SimplifyHasSizeAssertion extends Recipe {

    private static final MethodMatcher HAS_SIZE_MATCHER = new MethodMatcher(""org.assertj.core.api.* hasSize(int)"");

    private static final MethodMatcher CHAR_SEQUENCE_LENGTH_MATCHER = new MethodMatcher(""java.lang.CharSequence length()"", true);
    private static final MethodMatcher ITERABLE_SIZE_MATCHER = new MethodMatcher(""java.lang.Iterable size()"", true);
    private static final MethodMatcher MAP_SIZE_MATCHER = new MethodMatcher(""java.util.Map size()"", true);

    private static final String HAS_SAME_SIZE_AS = ""hasSameSizeAs"";

    @Override
    public String getDisplayName() {
        return ""Simplify AssertJ assertions with `hasSize` argument"";
    }

    @Override
    public String getDescription() {
        return ""Simplify AssertJ assertions by replacing `hasSize` with `hasSameSizeAs` dedicated assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(HAS_SIZE_MATCHER),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if (!HAS_SIZE_MATCHER.matches(mi)) {
                            return mi;
                        }

                        Expression expression = mi.getArguments().get(0);
                        if (expression instanceof J.MethodInvocation) {
                            if (CHAR_SEQUENCE_LENGTH_MATCHER.matches(expression) ||
                                    ITERABLE_SIZE_MATCHER.matches(expression) ||
                                    MAP_SIZE_MATCHER.matches(expression)) {
                                return updateMethodInvocation(mi, ((J.MethodInvocation) expression).getSelect());
                            }
                        } else if (expression instanceof J.FieldAccess) {
                            Expression target = ((J.FieldAccess) expression).getTarget();
                            if (target.getType() instanceof JavaType.Array) {
                                return updateMethodInvocation(mi, target);
                            }
                        }
                        return mi;
                    }

                    private J.MethodInvocation updateMethodInvocation(J.MethodInvocation mi, Expression argument) {
                        return mi.withMethodType(mi.getMethodType().withName(HAS_SAME_SIZE_AS))
                                .withName(mi.getName().withSimpleName(HAS_SAME_SIZE_AS))
                                .withArguments(singletonList(argument));
                    }
                });
    }
}
",{}
JUnit `assertEquals` to AssertJ,Convert JUnit-style `assertEquals()` to AssertJ's `assertThat().isEqualTo()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class JUnitAssertEqualsToAssertThat extends Recipe {

    private static final String JUNIT = ""org.junit.jupiter.api.Assertions"";
    private static final String ASSERTJ = ""org.assertj.core.api.Assertions"";
    private static final MethodMatcher ASSERT_EQUALS_MATCHER = new MethodMatcher(JUNIT + "" assertEquals(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertEquals` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertEquals()` to AssertJ's `assertThat().isEqualTo()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_EQUALS_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_EQUALS_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(ASSERTJ, ""assertThat"", false);
                maybeRemoveImport(JUNIT);

                List<Expression> args = mi.getArguments();
                Expression expected = args.get(0);
                Expression actual = args.get(1);
                if (args.size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isEqualTo(#{any()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, expected);
                }
                if (args.size() == 3 && !isFloatingPointType(args.get(2))) {
                    Expression message = args.get(2);
                    return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isEqualTo(#{any()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .imports(""java.util.function.Supplier"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, message, expected);
                }
                if (args.size() == 3) {
                    maybeAddImport(ASSERTJ, ""within"", false);
                    return JavaTemplate.builder(""assertThat(#{any()}).isCloseTo(#{any()}, within(#{any()}));"")
                            .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, expected, args.get(2));
                }

                maybeAddImport(ASSERTJ, ""within"", false);

                // The assertEquals is using a floating point with a delta argument and a message.
                Expression message = args.get(3);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isCloseTo(#{any()}, within(#{any()}));"")
                        .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                        .imports(""java.util.function.Supplier"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message, expected, args.get(2));
            }

            private boolean isFloatingPointType(Expression expression) {
                JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(expression.getType());
                if (fullyQualified != null) {
                    String typeName = fullyQualified.getFullyQualifiedName();
                    return ""java.lang.Double"".equals(typeName) || ""java.lang.Float"".equals(typeName);
                }

                JavaType.Primitive parameterType = TypeUtils.asPrimitive(expression.getType());
                return parameterType == JavaType.Primitive.Double || parameterType == JavaType.Primitive.Float;
            }
        });
    }
}
",{}
JUnit `assertFalse` to AssertJ,Convert JUnit-style `assertFalse()` to AssertJ's `assertThat().isFalse()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

public class JUnitAssertFalseToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_FALSE_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertFalse(boolean, ..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertFalse` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertFalse()` to AssertJ's `assertThat().isFalse()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_FALSE_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_FALSE_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                List<Expression> args = mi.getArguments();
                Expression actual = args.get(0);
                if (args.size() == 1) {
                    return JavaTemplate.builder(""assertThat(#{any(boolean)}).isFalse();"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual);
                }

                Expression message = args.get(1);
                return JavaTemplate.builder(""assertThat(#{any(boolean)}).as(#{any()}).isFalse();"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message);
            }
        });
    }
}
",{}
Collapse consecutive `assertThat` statements,Collapse consecutive `assertThat` statements into single `assertThat` chained statement. This recipe ignores `assertThat` statements that have method invocation as parameter.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.SemanticallyEqual;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

public class CollapseConsecutiveAssertThatStatements extends Recipe {
    private static final MethodMatcher ASSERT_THAT = new MethodMatcher(""org.assertj.core.api.Assertions assertThat(..)"");

    @Override
    public String getDisplayName() {
        return ""Collapse consecutive `assertThat` statements"";
    }

    @Override
    public String getDescription() {
        return ""Collapse consecutive `assertThat` statements into single `assertThat` chained statement. This recipe ignores `assertThat` statements that have method invocation as parameter."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_THAT), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                J.Block bl = super.visitBlock(block, ctx);

                List<Statement> statementsCollapsed = new ArrayList<>();
                for (List<Statement> group : getGroupedStatements(bl)) {
                    if (group.size() <= 1) {
                        statementsCollapsed.addAll(group);
                    } else {
                        statementsCollapsed.add(getCollapsedAssertThat(group));
                    }
                }

                return bl.withStatements(statementsCollapsed);
            }

            private List<List<Statement>> getGroupedStatements(J.Block bl) {
                List<Statement> originalStatements = bl.getStatements();
                List<List<Statement>> groupedStatements = new ArrayList<>();
                Expression currentActual = null; // The actual argument of the current group of assertThat statements
                List<Statement> currentGroup = new ArrayList<>();
                for (Statement statement : originalStatements) {
                    if (statement instanceof J.MethodInvocation) {
                        J.MethodInvocation assertion = (J.MethodInvocation) statement;
                        if (isGroupableAssertion(assertion)) {
                            J.MethodInvocation assertThat = (J.MethodInvocation) assertion.getSelect();
                            assert assertThat != null;
                            Expression actual = assertThat.getArguments().get(0);
                            if (currentActual == null || !SemanticallyEqual.areEqual(currentActual, actual)) {
                                // Conclude the previous group
                                groupedStatements.add(currentGroup);
                                currentGroup = new ArrayList<>();
                                currentActual = actual;
                            }
                            currentGroup.add(statement);
                            continue;
                        }
                    }

                    // Conclude the previous group, and start a new group
                    groupedStatements.add(currentGroup);
                    currentGroup = new ArrayList<>();
                    currentActual = null;
                    // The current statement should not be grouped with any other statement
                    groupedStatements.add(singletonList(statement));
                }
                if (!currentGroup.isEmpty()) {
                    // Conclude the last group
                    groupedStatements.add(currentGroup);
                }
                return groupedStatements;
            }

            private boolean isGroupableAssertion(J.MethodInvocation assertion) {
                // Only match method invocations where the select is an assertThat, containing a non-method call argument
                if (ASSERT_THAT.matches(assertion.getSelect())) {
                    J.MethodInvocation assertThat = (J.MethodInvocation) assertion.getSelect();
                    if (assertThat != null) {
                        Expression assertThatArgument = assertThat.getArguments().get(0);
                        if (!(assertThatArgument instanceof MethodCall)) {
                            JavaType assertThatType = assertThat.getType();
                            JavaType assertionType = assertion.getType();

                            // Check if both types are the same or if the assertion type is assignable to assertThat type
                            // This handles cases where assertion methods return the same type (for fluent chaining)
                            // but avoids collapsing when methods like extracting() change the assertion type
                            if (assertThatType != null && assertionType != null) {
                                // First check for exact type match
                                if (TypeUtils.isOfType(assertThatType, assertionType)) {
                                    return true;
                                }

                                // For generic types like AbstractIntegerAssert<?>, we need to check the raw types
                                JavaType.Parameterized assertThatFq = TypeUtils.asParameterized(assertThatType);
                                JavaType.Parameterized assertionFq = TypeUtils.asParameterized(assertionType);

                                // If assertionType is a generic wildcard, try to get its bound
                                if (assertionFq == null && assertionType instanceof JavaType.GenericTypeVariable) {
                                    JavaType.GenericTypeVariable genericType = (JavaType.GenericTypeVariable) assertionType;
                                    if (!genericType.getBounds().isEmpty()) {
                                        assertionFq = TypeUtils.asParameterized(genericType.getBounds().get(0));
                                    }
                                }

                                if (assertThatFq != null && assertionFq != null) {
                                    return TypeUtils.isOfType(assertThatFq.getType(), assertionFq.getType());
                                }
                            }
                            return false;
                        }
                    }
                }
                return false;
            }

            private J.MethodInvocation getCollapsedAssertThat(List<Statement> consecutiveAssertThatStatement) {
                assert !consecutiveAssertThatStatement.isEmpty();
                Space originalPrefix = consecutiveAssertThatStatement.get(0).getPrefix();
                String originalIndent = originalPrefix.getLastWhitespace().replaceAll(""^\\s+\n"", ""\n"");
                String chainedIndent = originalIndent + (originalIndent.contains(""\t"") ? ""\t\t"" : ""        "");
                J.MethodInvocation collapsed = null;
                for (Statement st : consecutiveAssertThatStatement) {
                    J.MethodInvocation assertion = (J.MethodInvocation) st;
                    J.MethodInvocation assertThat = (J.MethodInvocation) assertion.getSelect();
                    assert assertThat != null;
                    J.MethodInvocation newSelect = collapsed == null ? assertThat : collapsed;

                    collapsed = assertion.getPadding().withSelect(JRightPadded
                            .build((Expression) newSelect.withPrefix(Space.EMPTY))
                            .withAfter(Space.build(chainedIndent, ListUtils.map(st.getPrefix().getComments(), c -> c.withSuffix(chainedIndent)))));
                }
                return requireNonNull(collapsed).withPrefix(originalPrefix.withComments(emptyList()));
            }
        });
    }
}
",{}
Simplify AssertJ assertions with literal arguments,Simplify AssertJ assertions by replacing them with more expressive dedicated assertions.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

@AllArgsConstructor
@NoArgsConstructor
public class SimplifyAssertJAssertion extends Recipe {

    private static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.assertj.core.api.Assertions assertThat(..)"");

    @Option(displayName = ""AssertJ assertion"",
            description = ""The assertion method that should be replaced."",
            example = ""hasSize"",
            required = false)
    @Nullable
    String assertToReplace;

    @Option(displayName = ""Assertion argument literal"",
            description = ""The literal argument passed into the assertion to replace; use \""null\"" for `null`."",
            example = ""0"")
    String literalArgument;

    @Option(displayName = ""Dedicated assertion"",
            description = ""The zero argument assertion to adopt instead."",
            example = ""isEmpty"")
    String dedicatedAssertion;

    @Option(displayName = ""Required type"",
            description = ""The type of the actual assertion argument."",
            example = ""java.lang.String"")
    String requiredType;

    @Override
    public String getDisplayName() {
        return ""Simplify AssertJ assertions with literal arguments"";
    }

    @Override
    public String getDescription() {
        return ""Simplify AssertJ assertions by replacing them with more expressive dedicated assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        final MethodMatcher assertToReplace = new MethodMatcher(""org.assertj.core.api.* "" + this.assertToReplace + ""(..)"");
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

                // Match the end of the chain first, then the select to avoid matching the wrong method chain
                if (!assertToReplace.matches(mi) || !ASSERT_THAT_MATCHER.matches(mi.getSelect())) {
                    return mi;
                }

                // Compare argument with passed in literal
                if (!(mi.getArguments().get(0) instanceof J.Literal) ||
                    !literalArgument.equals(((J.Literal) mi.getArguments().get(0)).getValueSource())) { // Implies ""null"" is `null`
                    return mi;
                }

                // Check argument type of assertThat
                if (!TypeUtils.isAssignableTo(requiredType, ((J.MethodInvocation) mi.getSelect()).getArguments().get(0).getType())) {
                    return mi;
                }

                // Assume zero argument replacement method
                return JavaTemplate.builder(""#{any()}."" + dedicatedAssertion + ""()"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), mi.getSelect());
            }
        };
    }
}
","{
  ""literalArgument"": ""String field"",
  ""dedicatedAssertion"": ""String field"",
  ""requiredType"": ""String field""
}"
Adopt AssertJ Duration assertions,Adopt AssertJ `DurationAssert` assertions for more expressive messages.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.staticanalysis.SimplifyDurationCreationUnits;

import java.util.*;

import static org.openrewrite.Preconditions.or;

public class AdoptAssertJDurationAssertions extends Recipe {

    private static final String DURATION_ASSERT_HAS_LONG = ""org.assertj.core.api.AbstractDurationAssert has*(long)"";
    private static final String INTEGER_ASSERT_IS_EQUAL_TO = ""org.assertj.core.api.AbstractIntegerAssert isEqualTo(..)"";
    private static final String INTEGER_ASSERT_IS_GREATER_THAN = ""org.assertj.core.api.AbstractIntegerAssert isGreaterThan(..)"";
    private static final String INTEGER_ASSERT_IS_LESS_THAN = ""org.assertj.core.api.AbstractIntegerAssert isLessThan(..)"";
    private static final String LONG_ASSERT_IS_LESS_THAN = ""org.assertj.core.api.AbstractLongAssert isLessThan(..)"";
    private static final String LONG_ASSERT_IS_GREATER_THAN = ""org.assertj.core.api.AbstractLongAssert isGreaterThan(..)"";
    private static final String LONG_ASSERT_IS_EQUAL_TO = ""org.assertj.core.api.AbstractLongAssert isEqualTo(..)"";

    private static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.assertj.core.api.Assertions assertThat(..)"");
    private static final MethodMatcher GET_NANO_MATCHER = new MethodMatcher(""java.time.Duration getNano()"");
    private static final MethodMatcher GET_SECONDS_MATCHER = new MethodMatcher(""java.time.Duration getSeconds()"");
    private static final MethodMatcher AS_MATCHER = new MethodMatcher(""org.assertj.core.api.AbstractObjectAssert as(..)"");
    private static final MethodMatcher TIME_UNIT_MATCHERS = new MethodMatcher(DURATION_ASSERT_HAS_LONG, true);

    private static final List<MethodMatcher> IS_MATCHERS = Arrays.asList(
            new MethodMatcher(INTEGER_ASSERT_IS_EQUAL_TO, true),
            new MethodMatcher(INTEGER_ASSERT_IS_GREATER_THAN, true),
            new MethodMatcher(INTEGER_ASSERT_IS_LESS_THAN, true),

            new MethodMatcher(LONG_ASSERT_IS_EQUAL_TO, true),
            new MethodMatcher(LONG_ASSERT_IS_GREATER_THAN, true),
            new MethodMatcher(LONG_ASSERT_IS_LESS_THAN, true)
    );

    private static final Map<String, String> METHOD_MAP = new HashMap<String, String>() {{
        put(""getSeconds"", ""hasSeconds"");
        put(""getNano"", ""hasNanos"");

        put(""hasNanos"", ""hasMillis"");
        put(""hasMillis"", ""hasSeconds"");
        put(""hasSeconds"", ""hasMinutes"");
        put(""hasMinutes"", ""hasHours"");
        put(""hasHours"", ""hasDays"");

        put(""isGreaterThan"", ""isPositive"");
        put(""isLessThan"", ""isNegative"");
        put(""isEqualTo"", ""isZero"");
    }};

    @Override
    public String getDisplayName() {
        return ""Adopt AssertJ Duration assertions"";
    }

    @Override
    public String getDescription() {
        return ""Adopt AssertJ `DurationAssert` assertions for more expressive messages."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                or(
                        new UsesMethod<>(DURATION_ASSERT_HAS_LONG, true),
                        new UsesMethod<>(INTEGER_ASSERT_IS_EQUAL_TO, true),
                        new UsesMethod<>(INTEGER_ASSERT_IS_GREATER_THAN, true),
                        new UsesMethod<>(INTEGER_ASSERT_IS_LESS_THAN, true),
                        new UsesMethod<>(LONG_ASSERT_IS_EQUAL_TO, true),
                        new UsesMethod<>(LONG_ASSERT_IS_GREATER_THAN, true),
                        new UsesMethod<>(LONG_ASSERT_IS_LESS_THAN, true)
                ), new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if (TIME_UNIT_MATCHERS.matches(mi)) {
                            return simplifyTimeUnits(mi, ctx);
                        }
                        if (IS_MATCHERS.stream().anyMatch(matcher -> matcher.matches(mi))) {
                            return simplifyMultipleAssertions(mi, ctx);
                        }
                        return mi;
                    }

                    private J.MethodInvocation simplifyMultipleAssertions(J.MethodInvocation m, ExecutionContext ctx) {
                        Expression isEqualToArg = m.getArguments().get(0);
                        Expression select = m.getSelect();
                        List<Object> templateParameters = new ArrayList<>();
                        templateParameters.add(null);
                        Expression asDescription = null;

                        if (AS_MATCHER.matches(select)) {
                            asDescription = ((J.MethodInvocation) select).getArguments().get(0);
                            select = ((J.MethodInvocation) select).getSelect();
                            templateParameters.add(asDescription);
                        }

                        if (!ASSERT_THAT_MATCHER.matches(select)) {
                            return m;
                        }

                        Expression assertThatArgumentExpr = ((J.MethodInvocation) select).getArguments().get(0);
                        if (!(assertThatArgumentExpr instanceof J.MethodInvocation)) {
                            return m;
                        }
                        J.MethodInvocation assertThatArg = (J.MethodInvocation) assertThatArgumentExpr;

                        if (isZero(isEqualToArg) && checkIfRelatedToDuration(assertThatArg)) {
                            String formatted_template = formatTemplate(""assertThat(#{any()}).%s();"", m.getSimpleName(), asDescription);
                            templateParameters.set(0, assertThatArg);
                            return applyTemplate(ctx, m, formatted_template, templateParameters.toArray());
                        }

                        if (GET_NANO_MATCHER.matches(assertThatArg) || GET_SECONDS_MATCHER.matches(assertThatArg)) {
                            Expression assertThatArgSelect = assertThatArg.getSelect();
                            String methodName = assertThatArg.getSimpleName();
                            String formatted_template = formatTemplate(""assertThat(#{any()}).%s(#{any()});"", methodName, asDescription);
                            templateParameters.set(0, assertThatArgSelect);
                            templateParameters.add(isEqualToArg);

                            return applyTemplate(ctx, m, formatted_template, templateParameters.toArray());
                        }

                        return m;
                    }

                    private boolean isZero(Expression isEqualToArg) {
                        if (isEqualToArg instanceof J.Literal) {
                            J.Literal literal = (J.Literal) isEqualToArg;
                            return literal.getValue() instanceof Number && ((Number) literal.getValue()).longValue() == 0;
                        }
                        return false;
                    }

                    private J.MethodInvocation simplifyTimeUnits(J.MethodInvocation m, ExecutionContext ctx) {
                        Expression arg = m.getArguments().get(0);
                        Long argValue = SimplifyDurationCreationUnits.getConstantIntegralValue(arg);
                        if (argValue == null) {
                            return m;
                        }

                        List<Object> unitInfo = getUnitInfo(m.getSimpleName(), Math.toIntExact(argValue));
                        String methodName = (String) unitInfo.get(0);
                        int methodArg = (int) unitInfo.get(1);
                        if (!(m.getSimpleName().equals(methodName))) {
                            // update method invocation with new name and arg
                            String template = String.format(""#{any()}.%s(%d)"", methodName, methodArg);
                            return applyTemplate(ctx, m, template, m.getSelect());
                        }

                        return m;
                    }

                    private List<Object> getUnitInfo(String name, int argValue) {
                        final int timeLength;
                        if (""hasSeconds"".equals(name) || ""hasMinutes"".equals(name)) {
                            timeLength = 60;
                        } else if (""hasNanos"".equals(name) || ""hasMillis"".equals(name)) {
                            timeLength = 1000;
                        } else if (""hasHours"".equals(name)) {
                            timeLength = 24;
                        } else {
                            return Arrays.asList(name, argValue);
                        }

                        if (argValue % timeLength == 0) {
                            String newName = METHOD_MAP.get(name);
                            return getUnitInfo(newName, argValue / timeLength);
                        }
                        // returning name, newArg
                        return Arrays.asList(name, argValue);
                    }

                    private J.MethodInvocation applyTemplate(ExecutionContext ctx, J.MethodInvocation m, String template, Object... parameters) {
                        J.MethodInvocation invocation = JavaTemplate.builder(template)
                                .contextSensitive()
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                                .build()
                                .apply(getCursor(), m.getCoordinates().replace(), parameters);

                        // retain whitespace formatting
                        if (invocation.getPadding().getSelect() != null && m.getPadding().getSelect() != null) {
                            return invocation.getPadding()
                                    .withSelect(
                                            invocation.getPadding().getSelect()
                                                    .withAfter(m.getPadding().getSelect().getAfter())
                                    );
                        }
                        return invocation;
                    }

                    private boolean checkIfRelatedToDuration(J.MethodInvocation argument) {
                        if (argument.getSelect() != null) {
                            if (argument.getSelect() instanceof J.MethodInvocation) {
                                J.MethodInvocation selectMethod = (J.MethodInvocation) argument.getSelect();
                                return TypeUtils.isOfType(selectMethod.getType(), JavaType.buildType(""java.time.Duration""));
                            }
                        }
                        return false;
                    }

                    @SuppressWarnings(""ConstantValue"")
                    private String formatTemplate(String template, String methodName, Object asDescriptionArg) {
                        String replacementMethod = METHOD_MAP.get(methodName);
                        if (asDescriptionArg == null) {
                            return String.format(template, replacementMethod);
                        }
                        StringBuilder newTemplate = new StringBuilder(template);
                        newTemplate.insert(newTemplate.indexOf("")."") + 1, "".as(#{any()})"");
                        return String.format(newTemplate.toString(), replacementMethod);
                    }
                }
        );
    }
}
",{}
JUnit `assertNotEquals` to AssertJ,Convert JUnit-style `assertNotEquals()` to AssertJ's `assertThat().isNotEqualTo()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class JUnitAssertNotEqualsToAssertThat extends Recipe {

    private static final String JUNIT = ""org.junit.jupiter.api.Assertions"";
    private static final String ASSERTJ = ""org.assertj.core.api.Assertions"";
    private static final MethodMatcher ASSERT_NOT_EQUALS_MATCHER = new MethodMatcher(JUNIT + "" assertNotEquals(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertNotEquals` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertNotEquals()` to AssertJ's `assertThat().isNotEqualTo()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_NOT_EQUALS_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_NOT_EQUALS_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(ASSERTJ, ""assertThat"", false);
                maybeRemoveImport(JUNIT);

                List<Expression> args = mi.getArguments();
                Expression expected = args.get(0);
                Expression actual = args.get(1);
                if (args.size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isNotEqualTo(#{any()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, expected);
                }
                if (args.size() == 3 && isFloatingPointType(args.get(2))) {
                    maybeAddImport(ASSERTJ, ""within"", false);
                    return JavaTemplate.builder(""assertThat(#{any()}).isNotCloseTo(#{any()}, within(#{any()}));"")
                            .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, expected, args.get(2));
                }
                if (args.size() == 3) {
                    Expression message = args.get(2);
                    return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isNotEqualTo(#{any()});"")
                            .staticImports(ASSERTJ + "".assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, message, expected);
                }

                maybeAddImport(ASSERTJ, ""within"", false);

                Expression message = args.get(3);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isNotCloseTo(#{any()}, within(#{any()}));"")
                        .staticImports(ASSERTJ + "".assertThat"", ASSERTJ + "".within"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), method.getCoordinates().replace(), actual, message, expected, args.get(2));
            }

            private boolean isFloatingPointType(Expression expression) {
                JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(expression.getType());
                if (fullyQualified != null) {
                    String typeName = fullyQualified.getFullyQualifiedName();
                    return ""java.lang.Double"".equals(typeName) || ""java.lang.Float"".equals(typeName);
                }

                JavaType.Primitive parameterType = TypeUtils.asPrimitive(expression.getType());
                return parameterType == JavaType.Primitive.Double || parameterType == JavaType.Primitive.Float;
            }
        });
    }
}
",{}
JUnit `assertNotNull` to AssertJ,Convert JUnit-style `assertNotNull()` to AssertJ's `assertThat().isNotNull()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

public class JUnitAssertNotNullToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_NOT_NULL_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertNotNull(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertNotNull` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertNotNull()` to AssertJ's `assertThat().isNotNull()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_NOT_NULL_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_NOT_NULL_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                List<Expression> args = mi.getArguments();
                Expression actual = args.get(0);
                if (args.size() == 1) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isNotNull();"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual);

                }

                Expression message = args.get(1);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isNotNull();"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message);
            }
        });
    }
}
",{}
Convert try-catch-fail blocks to AssertJ's assertThatThrownBy,Replace try-catch blocks where the try block ends with a `fail()` statement and the catch block optionally ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.List;

public class JUnitTryFailToAssertThatThrownBy extends Recipe {

    private static final MethodMatcher ASSERTJ_FAIL_MATCHER = new MethodMatcher(""org.assertj.core.api.Assertions fail(..)"");
    private static final MethodMatcher JUPITER_FAIL_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions fail(..)"");
    private static final MethodMatcher JUNIT4_FAIL_MATCHER = new MethodMatcher(""org.junit.Assert fail(..)"");
    private static final MethodMatcher JUNIT_FAIL_MATCHER = new MethodMatcher(""junit.framework.Assert fail(..)"");

    private static final MethodMatcher ASSERT_EQUALS_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertEquals(..)"");
    private static final MethodMatcher JUNIT4_ASSERT_EQUALS_MATCHER = new MethodMatcher(""org.junit.Assert assertEquals(..)"");
    private static final MethodMatcher GET_MESSAGE_MATCHER = new MethodMatcher(""java.lang.Throwable getMessage()"", true);

    @Override
    public String getDisplayName() {
        return ""Convert try-catch-fail blocks to AssertJ's assertThatThrownBy"";
    }

    @Override
    public String getDescription() {
        return ""Replace try-catch blocks where the try block ends with a `fail()` statement and the catch block optionally "" +
                ""contains assertions, with AssertJ's `assertThatThrownBy()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitTry(J.Try tryBlock, ExecutionContext ctx) {
                J.Try try_ = (J.Try) super.visitTry(tryBlock, ctx);

                // Check if this is a simple try-catch block without resources or finally
                if (try_.getResources() != null || try_.getCatches().size() != 1 || try_.getFinally() != null) {
                    return try_;
                }

                // Check if the try block ends with a fail() call
                List<Statement> tryStatements = try_.getBody().getStatements();
                if (tryStatements.isEmpty() || !isFailMethod(tryStatements.get(tryStatements.size() - 1))) {
                    return try_;
                }

                // Get the catch block
                J.Try.Catch catchBlock = try_.getCatches().get(0);

                // Extract the exception type
                JavaType.FullyQualified exceptionFqType = TypeUtils.asFullyQualified(catchBlock.getParameter().getTree().getType());
                if (exceptionFqType == null) {
                    return try_;
                }
                String exceptionType = exceptionFqType.getClassName();

                // Extract assertions from catch block
                List<String> assertions = extractAssertions(catchBlock);

                // Only convert if:
                // - Catch block is empty (just a comment), or
                // - We can convert all statements in the catch block to assertions
                if (assertions.size() != catchBlock.getBody().getStatements().size()) {
                    return try_;
                }

                // Build the lambda body from try block statements (excluding the fail() call)
                List<Statement> lambdaStatements = new ArrayList<>(tryStatements.subList(0, tryStatements.size() - 1));

                // Generate the assertThatThrownBy code
                String template = buildTemplate(lambdaStatements, exceptionType, assertions);

                maybeRemoveImport(""org.assertj.core.api.Assertions.fail"");
                maybeRemoveImport(""org.junit.jupiter.api.Assertions.fail"");
                maybeRemoveImport(""org.junit.Assert.fail"");
                maybeRemoveImport(""junit.framework.Assert.fail"");

                // Remove assertEquals import if we converted it
                if (!assertions.isEmpty()) {
                    maybeRemoveImport(""org.junit.jupiter.api.Assertions.assertEquals"");
                    maybeRemoveImport(""org.junit.Assert.assertEquals"");
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThatThrownBy"");

                // Add import for the exception type if needed
                if (!exceptionFqType.getFullyQualifiedName().startsWith(""java.lang."")) {
                    maybeAddImport(exceptionFqType.getFullyQualifiedName());
                }

                return JavaTemplate.builder(template)
                        .contextSensitive()
                        .staticImports(""org.assertj.core.api.Assertions.assertThatThrownBy"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .<J.MethodInvocation>apply(getCursor(), try_.getCoordinates().replace(), lambdaStatements.toArray());
            }

            private boolean isFailMethod(Statement method) {
                if (method instanceof Expression) {
                    return ASSERTJ_FAIL_MATCHER.matches((Expression) method) ||
                            JUPITER_FAIL_MATCHER.matches((Expression) method) ||
                            JUNIT4_FAIL_MATCHER.matches((Expression) method) ||
                            JUNIT_FAIL_MATCHER.matches((Expression) method);
                }
                return false;
            }

            private List<String> extractAssertions(J.Try.Catch catchBlock) {
                List<String> assertions = new ArrayList<>();
                for (Statement statement : catchBlock.getBody().getStatements()) {
                    if (statement instanceof J.MethodInvocation) {
                        J.MethodInvocation mi = (J.MethodInvocation) statement;
                        if (ASSERT_EQUALS_MATCHER.matches(mi) || JUNIT4_ASSERT_EQUALS_MATCHER.matches(mi)) {
                            // Handle assertEquals for exception message
                            if (2 <= mi.getArguments().size()) {
                                Expression arg1 = mi.getArguments().get(0);
                                Expression arg2 = mi.getArguments().get(1);

                                // Check if one of the arguments is e.getMessage()
                                if (GET_MESSAGE_MATCHER.matches(arg1)) {
                                    if (arg2 instanceof J.Literal) {
                                        J.Literal literal = (J.Literal) arg2;
                                        if (literal.getValue() instanceof String) {
                                            assertions.add("".hasMessage(\"""" + literal.getValue() + ""\"")"");
                                        }
                                    }
                                } else if (GET_MESSAGE_MATCHER.matches(arg2)) {
                                    if (arg1 instanceof J.Literal) {
                                        J.Literal literal = (J.Literal) arg1;
                                        if (literal.getValue() instanceof String) {
                                            assertions.add("".hasMessage(\"""" + literal.getValue() + ""\"")"");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return assertions;
            }

            private String buildTemplate(List<Statement> lambdaStatements, String exceptionType, List<String> assertions) {
                StringBuilder template = new StringBuilder();
                template.append(""assertThatThrownBy(() -> "");

                if (lambdaStatements.size() == 1) {
                    // Single statement lambda
                    template.append(""#{any()}"");
                } else {
                    // Multi-statement lambda
                    template.append(""{\n"");
                    for (int i = 0; i < lambdaStatements.size(); i++) {
                        template.append(""    #{any()};"");
                        if (i < lambdaStatements.size() - 1) {
                            template.append(""\n"");
                        }
                    }
                    template.append(""\n}"");
                }

                template.append("").isInstanceOf("").append(exceptionType).append("".class)"");

                for (String assertion : assertions) {
                    template.append(assertion);
                }

                return template.toString();
            }
        };
    }
}
",{}
Simplify AssertJ chained assertions,Many AssertJ chained assertions have dedicated assertions that function the same. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import static java.util.Collections.singleton;

@AllArgsConstructor
@NoArgsConstructor
public class SimplifyChainedAssertJAssertion extends Recipe {

    @Option(displayName = ""AssertJ chained assertion"",
            description = ""The chained AssertJ assertion to move to dedicated assertion."",
            example = ""equals"",
            required = false)
    @Nullable
    String chainedAssertion;

    @Option(displayName = ""AssertJ replaced assertion"",
            description = ""The AssertJ assert that should be replaced."",
            example = ""isTrue"",
            required = false)
    @Nullable
    String assertToReplace;

    @Option(displayName = ""AssertJ replacement assertion"",
            description = ""The AssertJ method to migrate to."",
            example = ""isEqualTo"",
            required = false)
    @Nullable
    String dedicatedAssertion;

    @Option(displayName = ""Required type"",
            description = ""The type of the actual assertion argument."",
            example = ""java.lang.String"",
            required = false)
    @Nullable
    String requiredType;

    @Override
    public String getDisplayName() {
        return ""Simplify AssertJ chained assertions"";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S5838"");
    }

    @Override
    public String getDescription() {
        return ""Many AssertJ chained assertions have dedicated assertions that function the same. "" +
               ""It is best to use the dedicated assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher assertThatMatcher = new MethodMatcher(""org.assertj.core.api.Assertions assertThat(..)"");
        MethodMatcher chainedAssertMatcher = new MethodMatcher(""java..* "" + chainedAssertion + ""(..)"");
        MethodMatcher assertToReplace = new MethodMatcher(""org.assertj.core.api.* "" + this.assertToReplace + ""(..)"");

        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(methodInvocation, ctx);

                // assert has correct assertion
                if (!assertToReplace.matches(mi) || mi.getArguments().size() != 1 || !(mi.getSelect() instanceof J.MethodInvocation)) {
                    return mi;
                }

                // assertThat has method call
                J.MethodInvocation assertThat = (J.MethodInvocation) mi.getSelect();
                if (!assertThatMatcher.matches(assertThat) || !(assertThat.getArguments().get(0) instanceof J.MethodInvocation)) {
                    return mi;
                }

                J.MethodInvocation assertThatArg = (J.MethodInvocation) assertThat.getArguments().get(0);
                if (!chainedAssertMatcher.matches(assertThatArg)) {
                    return mi;
                }

                // Extract the actual argument for the new assertThat call
                Expression actual = assertThatArg.getSelect() != null ? assertThatArg.getSelect() : assertThatArg;
                if (!TypeUtils.isAssignableTo(requiredType, actual.getType())) {
                    return mi;
                }
                List<Expression> arguments = new ArrayList<>();
                arguments.add(actual);

                String template = getStringTemplateAndAppendArguments(assertThatArg, mi, arguments);
                return JavaTemplate.builder(String.format(template, dedicatedAssertion))
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5"", ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), arguments.toArray());
            }

            private String getStringTemplateAndAppendArguments(J.MethodInvocation assertThatArg, J.MethodInvocation methodToReplace, List<Expression> arguments) {
                Expression assertThatArgument = assertThatArg.getArguments().get(0);
                Expression methodToReplaceArgument = methodToReplace.getArguments().get(0);
                boolean assertThatArgumentIsEmpty = assertThatArgument instanceof J.Empty;
                boolean methodToReplaceArgumentIsEmpty = methodToReplaceArgument instanceof J.Empty;

                // If both arguments are empty, then the select is already added to the arguments list, and we use a minimal template
                if (assertThatArgumentIsEmpty && methodToReplaceArgumentIsEmpty) {
                    return ""assertThat(#{any()}).%s()"";
                }

                // If both arguments are not empty, then we add both to the arguments to the arguments list, and return a template with two arguments
                if (!assertThatArgumentIsEmpty && !methodToReplaceArgumentIsEmpty) {
                    // This should only happen for map assertions using a key and value
                    arguments.add(assertThatArgument);
                    arguments.add(methodToReplaceArgument);
                    return ""assertThat(#{any()}).%s(#{any()}, #{any()})"";
                }

                // If either argument is empty, we choose which one to add to the arguments list, and optionally extract the select
                arguments.add(extractEitherArgument(assertThatArgumentIsEmpty, assertThatArgument, methodToReplaceArgument));

                // Special case for Path.of() assertions
                if (""java.nio.file.Path"".equals(requiredType) && dedicatedAssertion.contains(""Raw"") &&
                    TypeUtils.isAssignableTo(""java.lang.String"", assertThatArgument.getType())) {
                    maybeAddImport(""java.nio.file.Path"");
                    return ""assertThat(#{any()}).%s(Path.of(#{any()}))"";
                }

                return ""assertThat(#{any()}).%s(#{any()})"";
            }

            private Expression extractEitherArgument(boolean assertThatArgumentIsEmpty, Expression assertThatArgument, Expression methodToReplaceArgument) {
                if (assertThatArgumentIsEmpty) {
                    return methodToReplaceArgument;
                }
                // Only on the assertThat argument do we possibly replace the argument with the select; such as list.size() -> list
                if (chainedAssertMatcher.matches(assertThatArgument)) {
                    return Objects.requireNonNull(((J.MethodInvocation) assertThatArgument).getSelect());
                }
                return assertThatArgument;
            }
        };
    }
}
",{}
JUnit fail to AssertJ,Convert JUnit-style `fail()` to AssertJ's `fail()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

import static java.util.Collections.nCopies;

public class JUnitFailToAssertJFail extends Recipe {

    private static final String JUNIT = ""org.junit.jupiter.api.Assertions"";
    private static final String ASSERTJ = ""org.assertj.core.api.Assertions"";
    private static final MethodMatcher FAIL_MATCHER = new MethodMatcher(JUNIT + "" fail(..)"");

    @Override
    public String getDisplayName() {
        return ""JUnit fail to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `fail()` to AssertJ's `fail()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(FAIL_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = method;
                if (!FAIL_MATCHER.matches(mi)) {
                    return mi;
                }

                List<Expression> args = mi.getArguments();
                if (args.size() == 1) {
                    // fail(), fail(String), fail(Supplier<String>), fail(Throwable)
                    if (args.get(0) instanceof J.Empty) {
                        mi = JavaTemplate.builder(ASSERTJ + "".fail(\""\"");"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                                .build()
                                .apply(getCursor(), mi.getCoordinates().replace());
                    } else if (args.get(0) instanceof J.Literal ||
                               TypeUtils.isAssignableTo(""java.lang.String"", args.get(0).getType())) {
                        mi = JavaTemplate.builder(ASSERTJ + "".fail(#{any()});"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                                .build()
                                .apply(getCursor(), mi.getCoordinates().replace(), args.get(0));
                    } else {
                        mi = JavaTemplate.builder(ASSERTJ + "".fail(\""\"", #{any()});"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                                .build()
                                .apply(getCursor(), mi.getCoordinates().replace(), args.get(0));
                    }
                } else {
                    // fail(String, Throwable)
                    String anyArgs = String.join("","", nCopies(args.size(), ""#{any()}""));
                    mi = JavaTemplate.builder(ASSERTJ + "".fail("" + anyArgs + "");"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), args.toArray());
                }

                doAfterVisit(new RemoveUnusedImports().getVisitor());
                doAfterVisit(new UnqualifiedMethodInvocations());
                return mi;
            }

            class UnqualifiedMethodInvocations extends JavaIsoVisitor<ExecutionContext> {
                private final MethodMatcher INTERNAL_FAIL_MATCHER = new MethodMatcher(ASSERTJ + "" fail(..)"");

                @Override
                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                    J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                    if (!INTERNAL_FAIL_MATCHER.matches(mi)) {
                        return mi;
                    }

                    maybeAddImport(ASSERTJ, ""fail"", false);
                    maybeRemoveImport(JUNIT + "".fail"");

                    List<Expression> arguments = mi.getArguments();
                    String anyArgs = String.join("","", nCopies(arguments.size(), ""#{any()}""));
                    return JavaTemplate.builder(""fail("" + anyArgs + "");"")
                            .staticImports(ASSERTJ + "".fail"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), arguments.toArray());
                }
            }
        });
    }
}
",{}
JUnit `assertSame` to AssertJ,Convert JUnit-style `assertSame()` to AssertJ's `assertThat().isSameAs()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.assertj;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

public class JUnitAssertSameToAssertThat extends Recipe {

    private static final MethodMatcher ASSERT_SAME_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertSame(..)"", true);

    @Override
    public String getDisplayName() {
        return ""JUnit `assertSame` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit-style `assertSame()` to AssertJ's `assertThat().isSameAs()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_SAME_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (!ASSERT_SAME_MATCHER.matches(mi)) {
                    return mi;
                }

                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);
                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");

                List<Expression> args = mi.getArguments();
                Expression expected = args.get(0);
                Expression actual = args.get(1);
                if (args.size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isSameAs(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), actual, expected);
                }

                Expression message = args.get(2);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any()}).isSameAs(#{any()});"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), actual, message, expected);
            }
        });
    }
}
",{}
Migrate JUnit JRE conditions,This recipe will:\n,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit6;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.trait.Literal;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class MinimumJreConditions extends Recipe {

    private static final String JRE_IMPORT = ""org.junit.jupiter.api.condition.JRE"";
    private static final String ENABLED_ON_JRE = ""org.junit.jupiter.api.condition.EnabledOnJre"";
    private static final String DISABLED_ON_JRE = ""org.junit.jupiter.api.condition.DisabledOnJre"";
    private static final String ENABLED_FOR_JRE_RANGE = ""org.junit.jupiter.api.condition.EnabledForJreRange"";
    private static final String DISABLED_FOR_JRE_RANGE = ""org.junit.jupiter.api.condition.DisabledForJreRange"";
    private static final Annotated.Matcher ENABLED_JRE_MATCHER = new Annotated.Matcher(""@"" + ENABLED_ON_JRE);
    private static final Annotated.Matcher DISABLED_JRE_MATCHER = new Annotated.Matcher(""@"" + DISABLED_ON_JRE);
    private static final Annotated.Matcher ENABLED_JRE_RANGE_MATCHER = new Annotated.Matcher(""@"" + ENABLED_FOR_JRE_RANGE);
    private static final Annotated.Matcher DISABLED_JRE_RANGE_MATCHER = new Annotated.Matcher(""@"" + DISABLED_FOR_JRE_RANGE);
    private static final List<Annotated.Matcher> TEST_ANNOTATION_MATCHERS = Arrays.asList(
            new Annotated.Matcher(""@org.junit.jupiter.api.Test""),
            new Annotated.Matcher(""@org.junit.jupiter.api.TestFactory""),
            new Annotated.Matcher(""@org.junit.jupiter.api.TestTemplate""),
            new Annotated.Matcher(""@org.junit.jupiter.api.RepeatedTest""),
            new Annotated.Matcher(""@org.junit.jupiter.params.ParameterizedTest"")
    );

    @Option(displayName = ""JRE version"", description = ""The minimum JRE version to use for test conditions."", example = ""17"")
    String javaVersion;

    @Override
    public String getDisplayName() {
        return ""Migrate JUnit JRE conditions"";
    }

    @Override
    public String getDescription() {
        return ""This recipe will:\n"" + "" - Remove tests that are only active on JREs that are below the specified version.\n"" + "" - Adjust ranges to use minimum the specified version."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                J.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
                if (cu != c) {
                    maybeRemoveImport(""org.junit.jupiter.api.Test"");
                    maybeRemoveImport(""org.junit.jupiter.api.TestFactory"");
                    maybeRemoveImport(""org.junit.jupiter.api.TestTemplate"");
                    maybeRemoveImport(""org.junit.jupiter.api.RepeatedTest"");
                    maybeRemoveImport(""org.junit.jupiter.params.ParameterizedTest"");
                    maybeRemoveImport(ENABLED_ON_JRE);
                    maybeRemoveImport(DISABLED_ON_JRE);
                    maybeRemoveImport(ENABLED_FOR_JRE_RANGE);
                    maybeRemoveImport(DISABLED_FOR_JRE_RANGE);
                }
                return c;
            }

            @Override
            public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
                boolean isUnitTest = false;
                List<String> enabledOnJre = null;
                List<String> disabledOnJre = null;
                Range enabledOnJreRange = null;
                Range disabledOnJreRange = null;
                Space prefix = Space.EMPTY;

                // First assemble all annotations to see if this is a unit test impacted with JRE conditional annotations
                for (J.Annotation ann : method.getLeadingAnnotations()) {
                    Cursor annotationCursor = new Cursor(getCursor(), ann);
                    if (TEST_ANNOTATION_MATCHERS.stream().anyMatch(matcher -> matcher.get(annotationCursor).isPresent())) {
                        isUnitTest = true;
                    }
                    Optional<Annotated> annotated = ENABLED_JRE_MATCHER.get(annotationCursor);
                    if (annotated.isPresent()) {
                        enabledOnJre = annotated.map(a -> getDefaultAttribute(a).map(this::extractVersionsFromAnnotationArgument)
                                        .orElseGet(() -> a.getAttribute(""versions"").map(Literal::getStrings).orElse(null)))
                                .orElse(null);
                        prefix = ann.getPrefix();
                    }
                    annotated = DISABLED_JRE_MATCHER.get(annotationCursor);
                    if (annotated.isPresent()) {
                        disabledOnJre = annotated.map(a -> getDefaultAttribute(a).map(this::extractVersionsFromAnnotationArgument)
                                        .orElseGet(() -> a.getAttribute(""versions"").map(Literal::getStrings).orElse(null)))
                                .orElse(null);
                        prefix = ann.getPrefix();
                    }
                    annotated = ENABLED_JRE_RANGE_MATCHER.get(annotationCursor);
                    if (annotated.isPresent()) {
                        enabledOnJreRange = annotated.map(Range::new).orElse(null);
                        prefix = ann.getPrefix();
                    }
                    annotated = DISABLED_JRE_RANGE_MATCHER.get(annotationCursor);
                    if (annotated.isPresent()) {
                        disabledOnJreRange = annotated.map(Range::new).orElse(null);
                        prefix = ann.getPrefix();
                    }
                }

                // Only act upon unit tests that have JRE conditions
                if (!isUnitTest || (enabledOnJre == null && disabledOnJre == null && enabledOnJreRange == null && disabledOnJreRange == null)) {
                    return m;
                }

                // Now transform the annotations to the correct results
                if (enabledOnJre != null) {
                    if (enabledOnJre.stream().allMatch(v -> compareVersions(v, javaVersion) < 0)) {
                        // Remove the test method if it is enabled on a JRE version lower than the specified version
                        maybeRemoveImport(JRE_IMPORT);
                        return null;
                    }
                    m = updateAnnotationVersions(m, enabledOnJre, ENABLED_ON_JRE, ctx);
                }
                if (disabledOnJre != null) {
                    if (disabledOnJre.stream().allMatch(v -> compareVersions(v, javaVersion) < 0)) {
                        m = removeAnnotation(m, DISABLED_ON_JRE, ctx);
                    } else {
                        m = updateAnnotationVersions(m, disabledOnJre, DISABLED_ON_JRE, ctx);
                    }
                }
                if (enabledOnJreRange != null) {
                    if (compareVersions(enabledOnJreRange.getMax(), javaVersion) < 0) {
                        // Remove the test method if it is enabled on a JRE range that ends before the specified version
                        maybeRemoveImport(JRE_IMPORT);
                        return null;
                    }
                    if (compareVersions(enabledOnJreRange.getMin(), javaVersion) <= 0 && enabledOnJreRange.getMaxNotation() == null) {
                        // The test is enabled for all versions from `javaVersion till end -> remove annotation
                        m = removeAnnotation(m, ENABLED_FOR_JRE_RANGE, ctx);
                    } else {
                        m = updateRangeStart(m, ENABLED_FOR_JRE_RANGE, enabledOnJreRange, ctx);
                    }
                }
                if (disabledOnJreRange != null) {
                    if (compareVersions(disabledOnJreRange.getMax(), javaVersion) < 0) {
                        m = removeAnnotation(m, DISABLED_FOR_JRE_RANGE, ctx);
                    } else if (compareVersions(disabledOnJreRange.getMin(), javaVersion) <= 0 && disabledOnJreRange.getMaxNotation() == null) {
                        // The test is disabled for all versions from `javaVersion` till end -> remove test
                        maybeRemoveImport(JRE_IMPORT);
                        return null;
                    } else {
                        m = updateRangeStart(m, DISABLED_FOR_JRE_RANGE, disabledOnJreRange, ctx);
                    }
                }

                replaceSingleVersionRangeWithEquivalentAnnotation(enabledOnJreRange, ENABLED_FOR_JRE_RANGE, ENABLED_ON_JRE);
                replaceSingleVersionRangeWithEquivalentAnnotation(disabledOnJreRange, DISABLED_FOR_JRE_RANGE, DISABLED_ON_JRE);

                if (m != method) {
                    return simplifySingleValueAnnotationAttributeArrays(m, prefix);
                }
                return method;
            }

            private J.MethodDeclaration removeAnnotation(J.MethodDeclaration m, String annotationType, ExecutionContext ctx) {
                RemoveAnnotation removeAnnotation = new RemoveAnnotation(""@"" + annotationType);
                maybeRemoveImport(JRE_IMPORT);
                return removeAnnotation.getVisitor().visitMethodDeclaration(m, ctx);
            }

            private J.MethodDeclaration updateAnnotationVersions(J.MethodDeclaration m, List<String> versions, String annotationType, ExecutionContext ctx) {
                if (versions.stream().anyMatch(v -> compareVersions(v, javaVersion) < 0)) {
                    // Update the annotation to only include JRE versions that are greater than or equal to the specified version
                    AddOrUpdateAnnotationAttribute updatedVersions = new AddOrUpdateAnnotationAttribute(annotationType, ""versions"", versions.stream().filter(v -> compareVersions(v, javaVersion) >= 0).collect(joining("", "")), null, false, false);
                    m = (J.MethodDeclaration) updatedVersions.getVisitor().visitNonNull(m, ctx, getCursor().getParent());
                }
                return m;
            }

            // Return a method declaration with a new range only if the start is below requested java version.
            // If the start version would be equal to the end version, then no updated method is returned as this is handled in a later phase
            private J.MethodDeclaration updateRangeStart(J.MethodDeclaration m, String annotationtype, Range range, ExecutionContext ctx) {
                if (compareVersions(range.getMin(), javaVersion) <= 0 && compareVersions(range.getMax(), javaVersion) != 0) {
                    // Update the range to start at the specified version
                    String attributeName = range.getMinNotation() == RangeNotation.VERSION ? ""minVersion"" : ""min"";
                    RemoveAnnotationAttribute updatedRange = new RemoveAnnotationAttribute(annotationtype, attributeName);
                    m = (J.MethodDeclaration) updatedRange.getVisitor().visitNonNull(m, ctx, getCursor().getParent());
                }
                return m;
            }

            // If the range is resulting in a single version after updating (current max is the new min), then we can replace the range annotation with a single version annotation.
            private void replaceSingleVersionRangeWithEquivalentAnnotation(@Nullable Range range, String rangeAnnotationType, String singleVersionAnnotationType) {
                if (range != null && compareVersions(range.getMax(), javaVersion) == 0) {
                    doAfterVisit(new ChangeType(rangeAnnotationType, singleVersionAnnotationType, false).getVisitor());
                    doAfterVisit(new RemoveAnnotationAttribute(singleVersionAnnotationType, ""min"").getVisitor());
                    doAfterVisit(new RemoveAnnotationAttribute(singleVersionAnnotationType, ""minVersion"").getVisitor());
                    doAfterVisit(new RemoveAnnotationAttribute(singleVersionAnnotationType, ""max"").getVisitor());
                    doAfterVisit(new RemoveAnnotationAttribute(singleVersionAnnotationType, ""maxVersion"").getVisitor());
                    String attributeName = range.getNotation() == RangeNotation.VERSION ? ""versions"" : ""value"";
                    String newValue = formatJreValue(javaVersion, range.getNotation());
                    doAfterVisit(new AddOrUpdateAnnotationAttribute(singleVersionAnnotationType, attributeName, newValue, null, false, false).getVisitor());
                }
            }

            private J.MethodDeclaration simplifySingleValueAnnotationAttributeArrays(J.MethodDeclaration m, Space prefix) {
                return m.withLeadingAnnotations(ListUtils.map(m.getLeadingAnnotations(), ann -> {
                    Cursor parentCursor = getCursor().getParent();
                    if (ENABLED_JRE_MATCHER.get(ann, parentCursor).isPresent() ||
                            DISABLED_JRE_MATCHER.get(ann, parentCursor).isPresent() ||
                            ENABLED_JRE_RANGE_MATCHER.get(ann, parentCursor).isPresent() ||
                            DISABLED_JRE_RANGE_MATCHER.get(ann, parentCursor).isPresent()) {
                        ann = ann
                                .withArguments(ListUtils.map(ann.getArguments(), arg -> {
                                    if (arg instanceof J.Assignment) {
                                        J.Assignment ass = (J.Assignment) arg;
                                        if (ass.getAssignment() instanceof J.NewArray) {
                                            List<Expression> initializer = ((J.NewArray) ass.getAssignment()).getInitializer();
                                            if (initializer != null && initializer.size() == 1 && !(initializer.get(0) instanceof J.Empty)) {
                                                return ass.withAssignment(initializer.get(0).withPrefix(ass.getAssignment().getPrefix()));
                                            }
                                        }
                                    }
                                    return arg;
                                }))
                                .withPrefix(prefix);
                    }
                    return ann;
                }));
            }

            private List<String> extractVersionsFromAnnotationArgument(Expression expression) {
                if (expression instanceof J.NewArray) {
                    List<Expression> initializer = ((J.NewArray) expression).getInitializer();
                    if (initializer == null) {
                        return emptyList();
                    }
                    return initializer.stream().map(Objects::toString).collect(toList());
                }
                return singletonList(expression.toString());
            }
        };
    }

    private static Optional<Expression> getDefaultAttribute(Annotated annotated) {
        if (annotated.getTree().getArguments() == null) {
            return Optional.empty();
        }
        for (Expression argument : annotated.getTree().getArguments()) {
            if (!(argument instanceof J.Assignment)) {
                return Optional.of(argument);
            }
        }
        return getAttribute(annotated, ""value"");
    }

    private static Optional<Expression> getAttribute(Annotated annotated, String attribute) {
        if (annotated.getTree().getArguments() == null) {
            return Optional.empty();
        }
        for (Expression argument : annotated.getTree().getArguments()) {
            if (argument instanceof J.Assignment) {
                J.Assignment assignment = (J.Assignment) argument;
                if (assignment.getVariable() instanceof J.Identifier &&
                        ((J.Identifier) assignment.getVariable()).getSimpleName().equals(attribute)) {
                    return Optional.of(assignment.getAssignment());
                }
            }
        }
        return Optional.empty();
    }

    private static int compareVersions(String version1, String version2) {
        String numericVersion1 = fromJREVersion(version1);
        String numericVersion2 = fromJREVersion(version2);
        int v1 = Integer.parseInt(numericVersion1.replaceAll(""\\D"", """"));
        int v2 = Integer.parseInt(numericVersion2.replaceAll(""\\D"", """"));

        int comparison = Integer.compare(v1, v2);
        if (comparison == 0) {
            return comparison;
        }
        return comparison / Math.abs(comparison);
    }

    private static String fromJREVersion(String version) {
        if (version.startsWith(""JRE."")) {
            version = version.substring(4);
        }
        if (version.startsWith(""JAVA_"")) {
            return version.substring(5);
        }
        if (""OTHER"".equals(version)) {
            return String.valueOf(Integer.MAX_VALUE);
        }
        return version;
    }

    private static String formatJreValue(String version, @Nullable RangeNotation notation) {
        if (notation == null) {
            return version;
        }
        switch (notation) {
            case JRE:
                return ""JRE.JAVA_"" + version;
            case STATIC_JRE:
                return ""JAVA_"" + version;
            case VERSION:
            default:
                return version;
        }
    }

    @Getter
    @ToString
    private static final class Range {
        private final String min;

        @Nullable
        private final RangeNotation minNotation;

        private final String max;

        @Nullable
        private final RangeNotation maxNotation;

        public Range(Annotated annotated) {
            Optional<String> minAttribute = getAttribute(annotated, ""min"").map(Objects::toString);
            Optional<String> minVersionAttribute = getAttribute(annotated, ""minVersion"").map(Objects::toString);
            Optional<String> maxAttribute = getAttribute(annotated, ""max"").map(Objects::toString);
            Optional<String> maxVersionAttribute = getAttribute(annotated, ""maxVersion"").map(Objects::toString);
            String min = minAttribute.orElse(minVersionAttribute.orElse(null));
            String max = maxAttribute.orElse(maxVersionAttribute.orElse(null));
            this.min = min == null ? ""0"" : min;
            this.max = max == null ? String.valueOf(Integer.MAX_VALUE) : max;
            this.minNotation = minAttribute
                    .map(it -> it.startsWith(""JRE."") ? RangeNotation.JRE : RangeNotation.STATIC_JRE)
                    .orElse(minVersionAttribute.map(__ -> RangeNotation.VERSION).orElse(null));
            this.maxNotation = maxAttribute
                    .map(it -> it.startsWith(""JRE."") ? RangeNotation.JRE : RangeNotation.STATIC_JRE)
                    .orElse(maxVersionAttribute.map(__ -> RangeNotation.VERSION).orElse(null));
        }

        private RangeNotation getNotation() {
            if (minNotation == null && maxNotation == null) {
                return RangeNotation.VERSION;
            }
            if (maxNotation == null) {
                return minNotation;
            }
            return maxNotation;
        }
    }

    enum RangeNotation {
        JRE, STATIC_JRE, VERSION
    }
}
","{
  ""javaVersion"": ""String field""
}"
Migrate from Hamcrest `instanceOf` matcher to JUnit 5,Migrate from Hamcrest `instanceOf` and `isA` matcher to JUnit5 `assertInstanceOf` assertion.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.ArrayList;
import java.util.List;

public class HamcrestInstanceOfToJUnit5 extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate from Hamcrest `instanceOf` matcher to JUnit 5"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from Hamcrest `instanceOf` and `isA` matcher to JUnit5 `assertInstanceOf` assertion."";
    }

    private static final MethodMatcher INSTANCE_OF_MATCHER = new MethodMatcher(""org.hamcrest.Matchers instanceOf(..)"");
    private static final MethodMatcher IS_A_MATCHER = new MethodMatcher(""org.hamcrest.Matchers isA(..)"");
    private static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(.., org.hamcrest.Matcher)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> preconditions = Preconditions.and(
                new UsesMethod<>(ASSERT_THAT_MATCHER),
                Preconditions.or(
                        new UsesMethod<>(INSTANCE_OF_MATCHER),
                        new UsesMethod<>(IS_A_MATCHER)));
        return Preconditions.check(preconditions, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation mi, ExecutionContext ctx) {
                if (ASSERT_THAT_MATCHER.matches(mi)) {
                    Expression reason;
                    Expression examinedObject;
                    Expression hamcrestMatcher;

                    if (mi.getArguments().size() == 2) {
                        reason = null;
                        examinedObject = mi.getArguments().get(0);
                        hamcrestMatcher = mi.getArguments().get(1);
                    } else if (mi.getArguments().size() == 3) {
                        reason = mi.getArguments().get(0);
                        examinedObject = mi.getArguments().get(1);
                        hamcrestMatcher = mi.getArguments().get(2);
                    } else {
                        return mi;
                    }

                    J.MethodInvocation matcherInvocation = (J.MethodInvocation) hamcrestMatcher;
                    while (""not"".equals(matcherInvocation.getSimpleName())) {
                        maybeRemoveImport(""org.hamcrest.Matchers.not"");
                        maybeRemoveImport(""org.hamcrest.CoreMatchers.not"");
                        matcherInvocation = (J.MethodInvocation) new RemoveNotMatcherVisitor().visit(matcherInvocation, ctx);
                    }

                    if (INSTANCE_OF_MATCHER.matches(matcherInvocation) || IS_A_MATCHER.matches(matcherInvocation)) {
                        boolean logicalContext = RemoveNotMatcherVisitor.getLogicalContext(matcherInvocation, ctx);

                        String templateString = (logicalContext ?
                                ""assertInstanceOf(#{any(java.lang.Class)}, #{any(java.lang.Object)}"" :
                                ""assertFalse(#{any(java.lang.Class)}.isAssignableFrom(#{any(java.lang.Object)}.getClass())"") +
                                (reason == null ? "")"" : "", #{any(java.lang.String)})"");

                        JavaTemplate template = JavaTemplate.builder(templateString)
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                .staticImports(""org.junit.jupiter.api.Assertions."" + (logicalContext ? ""assertInstanceOf"" : ""assertFalse""))
                                .build();

                        maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");
                        maybeRemoveImport(""org.hamcrest.Matchers.instanceOf"");
                        maybeRemoveImport(""org.hamcrest.CoreMatchers.instanceOf"");
                        maybeRemoveImport(""org.hamcrest.Matchers.isA"");
                        maybeRemoveImport(""org.hamcrest.CoreMatchers.isA"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", logicalContext ? ""assertInstanceOf"" : ""assertFalse"");

                        List<Expression> arguments = new ArrayList<>();
                        arguments.add(matcherInvocation.getArguments().get(0));
                        arguments.add(examinedObject);
                        if (reason != null) {
                            arguments.add(reason);
                        }

                        return template.apply(getCursor(), mi.getCoordinates().replace(), arguments.toArray());
                    }
                }
                return super.visitMethodInvocation(mi, ctx);
            }
        });
    }
}
",{}
Migrate Hamcrest `not(Matcher)` to AssertJ,Migrate from Hamcrest `not(Matcher)` to AssertJ assertions.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.ArrayList;
import java.util.List;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

@NoArgsConstructor
@AllArgsConstructor
public class HamcrestNotMatcherToAssertJ extends Recipe {

    @Option(displayName = ""Hamcrest Matcher"",
            description = ""The Hamcrest `not(Matcher)` to migrate to JUnit5."",
            example = ""equalTo"",
            required = false)
    @Nullable
    String notMatcher;

    @Option(displayName = ""AssertJ Assertion"",
            description = ""The AssertJ method to migrate to."",
            example = ""isNotEqualTo"",
            required = false)
    @Nullable
    String assertion;

    @Override
    public String getDisplayName() {
        return ""Migrate Hamcrest `not(Matcher)` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from Hamcrest `not(Matcher)` to AssertJ assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(""org.hamcrest.*Matchers "" + notMatcher + ""(..)""), new MigrateToAssertJVisitor());
    }

    private class MigrateToAssertJVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(..)"");
        private final MethodMatcher NOT_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers not(org.hamcrest.Matcher)"");
        private final MethodMatcher MATCHERS_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers "" + notMatcher + ""(..)"");
        private final MethodMatcher SUB_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers *(org.hamcrest.Matcher)"");

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (ASSERT_THAT_MATCHER.matches(mi)) {
                Expression notMethodInvocation = mi.getArguments().get(mi.getArguments().size() - 1);
                if (!NOT_MATCHER.matches(notMethodInvocation)) {
                    return mi;
                }
                Expression matcherArgument = ((J.MethodInvocation) notMethodInvocation).getArguments().get(0);
                if (mi.getArguments().size() == 2) {
                    return handleTwoArgumentCase(mi, matcherArgument, ctx);
                }
                if (mi.getArguments().size() == 3) {
                    return handleThreeArgumentCase(mi, matcherArgument, ctx);
                }
            }
            return mi;
        }

        private J.MethodInvocation handleTwoArgumentCase(J.MethodInvocation mi, Expression matcherArgument, ExecutionContext ctx) {
            Expression actualArgument = mi.getArguments().get(0);
            if (!MATCHERS_MATCHER.matches(matcherArgument) || SUB_MATCHER.matches(matcherArgument)) {
                return mi;
            }
            String actual = typeToIndicator(actualArgument.getType());
            List<Expression> originalArguments = ((J.MethodInvocation) matcherArgument).getArguments().stream()
                    .filter(a -> !(a instanceof J.Empty))
                    .collect(toList());
            String argumentsTemplate = originalArguments.stream()
                    .map(a -> typeToIndicator(a.getType()))
                    .collect(joining("", ""));
            JavaTemplate template = JavaTemplate.builder(String.format(""assertThat(%s).%s(%s)"",
                            actual, assertion, argumentsTemplate))
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                    .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                    .build();
            maybeRemoveImport(""org.hamcrest.Matchers.not"");
            maybeRemoveImport(""org.hamcrest.Matchers."" + notMatcher);
            maybeRemoveImport(""org.hamcrest.CoreMatchers.not"");
            maybeRemoveImport(""org.hamcrest.CoreMatchers."" + notMatcher);
            maybeRemoveImport(""org.hamcrest.MatcherAssert"");
            maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");
            maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"");

            List<Expression> templateArguments = new ArrayList<>();
            templateArguments.add(actualArgument);
            templateArguments.addAll(originalArguments);
            return template.apply(getCursor(), mi.getCoordinates().replace(), templateArguments.toArray());
        }

        private J.MethodInvocation handleThreeArgumentCase(J.MethodInvocation mi, Expression matcherArgument, ExecutionContext ctx) {
            Expression reasonArgument = mi.getArguments().get(0);
            Expression actualArgument = mi.getArguments().get(1);
            if (!MATCHERS_MATCHER.matches(matcherArgument) || SUB_MATCHER.matches(matcherArgument)) {
                return mi;
            }
            String actual = typeToIndicator(actualArgument.getType());
            List<Expression> originalArguments = ((J.MethodInvocation) matcherArgument).getArguments().stream()
                    .filter(a -> !(a instanceof J.Empty))
                    .collect(toList());
            String argumentsTemplate = originalArguments.stream()
                    .map(a -> typeToIndicator(a.getType()))
                    .collect(joining("", ""));
            JavaTemplate template = JavaTemplate.builder(String.format(""assertThat(%s).as(#{any(String)}).%s(%s)"",
                            actual, assertion, argumentsTemplate))
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                    .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                    .build();
            maybeRemoveImport(""org.hamcrest.Matchers.not"");
            maybeRemoveImport(""org.hamcrest.Matchers."" + notMatcher);
            maybeRemoveImport(""org.hamcrest.MatcherAssert"");
            maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");
            maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"");

            List<Expression> templateArguments = new ArrayList<>();
            templateArguments.add(actualArgument);
            templateArguments.add(reasonArgument);
            templateArguments.addAll(originalArguments);
            return template.apply(getCursor(), mi.getCoordinates().replace(), templateArguments.toArray());
        }

        private String typeToIndicator(JavaType type) {
            String str = type instanceof JavaType.Primitive || type.toString().startsWith(""java."") ?
                    type.toString().replaceAll(""<.*>"", """") : ""java.lang.Object"";
            return String.format(""#{any(%s)}"", str);
        }
    }
}
",{}
Remove Hamcrest `is(Matcher)`,Remove Hamcrest `is(Matcher)` ahead of migration.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class RemoveIsMatcher extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove Hamcrest `is(Matcher)`"";
    }

    @Override
    public String getDescription() {
        return ""Remove Hamcrest `is(Matcher)` ahead of migration."";
    }

    static final MethodMatcher IS_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers is(org.hamcrest.Matcher)"");
    static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_THAT_MATCHER), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation mi, ExecutionContext ctx) {
                if (ASSERT_THAT_MATCHER.matches(mi)) {
                    getCursor().putMessage(""ASSERT_THAT"", mi);
                } else if (IS_MATCHER.matches(mi) && getCursor().pollNearestMessage(""ASSERT_THAT"") != null) {
                    maybeRemoveImport(""org.hamcrest.Matchers.is"");
                    maybeRemoveImport(""org.hamcrest.CoreMatchers.is"");
                    return mi.getArguments().get(0).withPrefix(mi.getPrefix());
                }
                return super.visitMethodInvocation(mi, ctx);
            }
        });
    }
}
",{}
Migrate Hamcrest `is(Object)` to AssertJ,Migrate Hamcrest `is(Object)` to AssertJ `Assertions.assertThat(..)`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class HamcrestIsMatcherToAssertJ extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate Hamcrest `is(Object)` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Migrate Hamcrest `is(Object)` to AssertJ `Assertions.assertThat(..)`."";
    }

    static final MethodMatcher IS_OBJECT_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers is(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(IS_OBJECT_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {

                // Switch between one or the other depending on whether actual argument is an array or not
                List<Expression> arguments = methodInvocation.getArguments();
                String replacement = 2 <= arguments.size() &&
                                     TypeUtils.asArray(arguments.get(arguments.size() - 2).getType()) != null ?
                        ""containsExactly"" : ""isEqualTo"";
                doAfterVisit(new HamcrestMatcherToAssertJ(""is"", replacement, null).getVisitor());

                return super.visitMethodInvocation(methodInvocation, ctx);
            }
        });
    }
}
",{}
"Migrate Hamcrest `assertThat(boolean, Matcher)` to AssertJ","Replace Hamcrest `assertThat(String, boolean)` with AssertJ `assertThat(boolean).as(String).isTrue()`.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class AssertThatBooleanToAssertJ extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate Hamcrest `assertThat(boolean, Matcher)` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Replace Hamcrest `assertThat(String, boolean)` with AssertJ `assertThat(boolean).as(String).isTrue()`."";
    }

    private static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(String, boolean)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (ASSERT_THAT_MATCHER.matches(mi)) {
                    Expression reasonArgument = mi.getArguments().get(0);
                    Expression booleanArgument = mi.getArguments().get(1);
                    maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");
                    maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"");
                    return JavaTemplate.builder(""assertThat(#{any(boolean)}).as(#{any(String)}).isTrue()"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), booleanArgument, reasonArgument);
                }
                return mi;
            }
        };
    }
}
",{}
Migrate from Hamcrest `Matcher` to JUnit 5,Migrate from Hamcrest `Matcher` to JUnit 5 assertions.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiFunction;

public class HamcrestMatcherToJUnit5 extends Recipe {

    private static final MethodMatcher MATCHER_ASSERT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(.., org.hamcrest.Matcher)"");

    @Override
    public String getDisplayName() {
        return ""Migrate from Hamcrest `Matcher` to JUnit 5"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from Hamcrest `Matcher` to JUnit 5 assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesMethod<>(MATCHER_ASSERT_MATCHER),
                new MigrationFromHamcrestVisitor());
    }

    enum Replacement {
        EQUALTO(""equalTo"", ""assertEquals"", ""assertNotEquals"", ""#{any(java.lang.Object)}, #{any(java.lang.Object)}"", ""examinedObjThenMatcherArgs""),
        EMPTYARRAY(""emptyArray"", ""assertEquals"", ""assertNotEquals"", ""0, #{anyArray(java.lang.Object)}.length"", ""examinedObjOnly""),
        HASENTRY(""hasEntry"", ""assertEquals"", ""assertNotEquals"", ""#{any(java.lang.Object)}, #{any(java.util.Map)}.get(#{any(java.lang.Object)})"", ""matcher1ExaminedObjMatcher0""),
        HASSIZE(""hasSize"", ""assertEquals"", ""assertNotEquals"", ""#{any(java.util.Collection)}.size(), #{any(double)}"", ""examinedObjThenMatcherArgs""),
        HASTOSTRING(""hasToString"", ""assertEquals"", ""assertNotEquals"", ""#{any(java.lang.Object)}.toString(), #{any(java.lang.String)}"", ""examinedObjThenMatcherArgs""),
        CLOSETO(""closeTo"", ""assertTrue"", ""assertFalse"", ""Math.abs(#{any(double)} - #{any(double)}) < #{any(double)}"", ""examinedObjThenMatcherArgs""),
        CONTAINSSTRING(""containsString"", ""assertTrue"", ""assertFalse"", ""#{any(java.lang.String)}.contains(#{any(java.lang.String)}"", ""examinedObjThenMatcherArgs""),
        EMPTY(""empty"", ""assertTrue"", ""assertFalse"", ""#{any(java.util.Collection)}.isEmpty()"", ""examinedObjOnly""),
        ENDSWITH(""endsWith"", ""assertTrue"", ""assertFalse"", ""#{any(java.lang.String)}.endsWith(#{any(java.lang.String)})"", ""examinedObjThenMatcherArgs""),
        EQUALTOIGNORINGCASE(""equalToIgnoringCase"", ""assertTrue"", ""assertFalse"", ""#{any(java.lang.String)}.equalsIgnoreCase(#{any(java.lang.String)})"", ""examinedObjThenMatcherArgs""),
        GREATERTHAN(""greaterThan"", ""assertTrue"", ""assertFalse"", ""#{any(double)} > #{any(double)}"", ""examinedObjThenMatcherArgs""),
        GREATERTHANOREQUALTO(""greaterThanOrEqualTo"", ""assertTrue"", ""assertFalse"", ""#{any(double)} >= #{any(double)}"", ""examinedObjThenMatcherArgs""),
        HASKEY(""hasKey"", ""assertTrue"", ""assertFalse"", ""#{any(java.util.Map)}.containsKey(#{any(java.lang.Object)})"", ""examinedObjThenMatcherArgs""),
        HASVALUE(""hasValue"", ""assertTrue"", ""assertFalse"", ""#{any(java.util.Map)}.containsValue(#{any(java.lang.Object)})"", ""examinedObjThenMatcherArgs""),
        LESSTHAN(""lessThan"", ""assertTrue"", ""assertFalse"", ""#{any(double)} < #{any(double)}"", ""examinedObjThenMatcherArgs""),
        LESSTHANOREQUALTO(""lessThanOrEqualTo"", ""assertTrue"", ""assertFalse"", ""#{any(double)} <= #{any(double)}"", ""examinedObjThenMatcherArgs""),
        STARTSWITH(""startsWith"", ""assertTrue"", ""assertFalse"", ""#{any(java.lang.String)}.startsWith(#{any(java.lang.String)})"", ""examinedObjThenMatcherArgs""),
        TYPECOMPATIBLEWITH(""typeCompatibleWith"", ""assertTrue"", ""assertFalse"", ""#{any(java.lang.Class)}.isAssignableFrom(#{any(java.lang.Class)})"", ""matcherArgsThenExaminedObj""),
        NOTNULLVALUE(""notNullValue"", ""assertNotNull"", ""assertNull"", ""#{any(java.lang.Object)}"", ""examinedObjOnly""),
        NULLVALUE(""nullValue"", ""assertNull"", ""assertNotNull"", ""#{any(java.lang.Object)}"", ""examinedObjOnly""),
        SAMEINSTANCE(""sameInstance"", ""assertSame"", ""assertNotSame"", ""#{any(java.lang.Object)}, #{any(java.lang.Object)}"", ""examinedObjThenMatcherArgs""),
        THEINSTANCE(""theInstance"", ""assertSame"", ""assertNotSame"", ""#{any(java.lang.Object)}, #{any(java.lang.Object)}"", ""examinedObjThenMatcherArgs""),
        EMPTYITERABLE(""emptyIterable"", ""assertFalse"", ""assertTrue"", ""#{any(java.lang.Iterable)}.iterator().hasNext()"", ""examinedObjOnly"");

        final String hamcrest, junitPositive, junitNegative, template;
        final String argumentsMethod;

        private static final Map<String, BiFunction<Expression, J.MethodInvocation, List<Expression>>> methods = new HashMap<>();

        static {
            methods.put(""examinedObjThenMatcherArgs"", (ex, matcher) -> {
                List<Expression> arguments = matcher.getArguments();
                arguments.add(0, ex);
                return arguments;
            });
            methods.put(""matcherArgsThenExaminedObj"", (ex, matcher) -> {
                List<Expression> arguments = matcher.getArguments();
                arguments.add(ex);
                return arguments;
            });
            methods.put(""examinedObjOnly"", (ex, matcher) -> {
                List<Expression> arguments = new ArrayList<>();
                arguments.add(ex);
                return arguments;
            });
            methods.put(""matcher1ExaminedObjMatcher0"", (ex, matcher) -> {
                List<Expression> arguments = new ArrayList<>();
                arguments.add(matcher.getArguments().get(1));
                arguments.add(ex);
                arguments.add(matcher.getArguments().get(0));
                return arguments;
            });
        }

        Replacement(String hamcrest, String junitPositive, String junitNegative, String template, String argumentsMethod) {
            this.hamcrest = hamcrest;
            this.junitPositive = junitPositive;
            this.junitNegative = junitNegative;
            this.template = template;
            this.argumentsMethod = argumentsMethod;
        }
    }

    private static class MigrationFromHamcrestVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

            if (MATCHER_ASSERT_MATCHER.matches(mi)) {
                Expression reason;
                Expression examinedObject;
                Expression hamcrestMatcher;

                if (mi.getArguments().size() == 2) {
                    reason = null;
                    examinedObject = mi.getArguments().get(0);
                    hamcrestMatcher = mi.getArguments().get(1);
                } else if (mi.getArguments().size() == 3) {
                    reason = mi.getArguments().get(0);
                    examinedObject = mi.getArguments().get(1);
                    hamcrestMatcher = mi.getArguments().get(2);
                } else {
                    return mi;
                }

                if (hamcrestMatcher instanceof J.MethodInvocation) {
                    J.MethodInvocation matcherInvocation = (J.MethodInvocation) hamcrestMatcher;
                    maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");

                    while (""not"".equals(matcherInvocation.getSimpleName())) {
                        maybeRemoveImport(""org.hamcrest.Matchers.not"");
                        maybeRemoveImport(""org.hamcrest.CoreMatchers.not"");
                        matcherInvocation = (J.MethodInvocation) new RemoveNotMatcherVisitor().visit(matcherInvocation, ctx);
                    }

                    //we do not handle nested matchers
                    if (!(matcherInvocation.getArguments().get(0) instanceof J.Empty)) {
                        if ((matcherInvocation.getArguments().get(0).getType()).toString().startsWith(""org.hamcrest"")) {
                            return mi;
                        }
                    }

                    boolean logicalContext = RemoveNotMatcherVisitor.getLogicalContext(matcherInvocation, ctx);

                    Replacement replacement;
                    try {
                        replacement = Replacement.valueOf(matcherInvocation.getSimpleName().toUpperCase());
                    } catch (IllegalArgumentException e) {
                        return mi;
                    }
                    String assertion = logicalContext ? replacement.junitPositive : replacement.junitNegative;
                    String templateString = assertion + ""("" + replacement.template + (reason == null ? "")"" : "", #{any(java.lang.String)})"");
                    JavaTemplate template = JavaTemplate.builder(templateString)
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                            .staticImports(""org.junit.jupiter.api.Assertions."" + assertion)
                            .build();

                    maybeRemoveImport(""org.hamcrest.Matchers."" + replacement.hamcrest);
                    maybeRemoveImport(""org.hamcrest.CoreMatchers."" + replacement.hamcrest);
                    maybeAddImport(""org.junit.jupiter.api.Assertions"", assertion);

                    List<Expression> arguments = Replacement.methods.get(replacement.argumentsMethod).apply(examinedObject, matcherInvocation);
                    if (reason != null) {
                        arguments.add(reason);
                    }

                    return template.apply(getCursor(), method.getCoordinates().replace(), arguments.toArray());
                }
            }
            return mi;
        }
    }
}
",{}
Migrate from Hamcrest `Matcher` to AssertJ,Migrate from Hamcrest `Matcher` to AssertJ assertions.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.List;

import static java.util.stream.Collectors.joining;

@NoArgsConstructor
@AllArgsConstructor
public class HamcrestMatcherToAssertJ extends Recipe {

    @Option(displayName = ""Hamcrest matcher"",
            description = ""The Hamcrest `Matcher` to migrate to JUnit5."",
            example = ""equalTo"",
            required = false)
    @Nullable
    String matcher;

    @Option(displayName = ""AssertJ assertion"",
            description = ""The AssertJ method to migrate to."",
            example = ""isEqualTo"",
            required = false)
    @Nullable
    String assertion;

    @Option(displayName = ""Argument type"",
            description = ""The type of the argument to the Hamcrest `Matcher`."",
            example = ""java.math.BigDecimal"",
            required = false)
    @Nullable
    String argumentType;

    @Override
    public String getDisplayName() {
        return ""Migrate from Hamcrest `Matcher` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from Hamcrest `Matcher` to AssertJ assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(""org.hamcrest.*Matchers "" + matcher + ""(..)""), new MigrateToAssertJVisitor());
    }

    private class MigrateToAssertJVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher assertThatMatcher = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(..)"");
        private final MethodMatcher matchersMatcher = new MethodMatcher(""org.hamcrest.*Matchers "" + matcher + ""(..)"");
        private final MethodMatcher subMatcher = new MethodMatcher(""org.hamcrest.*Matchers *(org.hamcrest.Matcher)"");

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (assertThatMatcher.matches(mi)) {
                return replace(mi, ctx);
            }
            return mi;
        }

        private J.MethodInvocation replace(J.MethodInvocation mi, ExecutionContext ctx) {
            List<Expression> mia = mi.getArguments();
            Expression reasonArgument = mia.size() == 3 ? mia.get(0) : null;
            Expression actualArgument = mia.get(mia.size() - 2);
            Expression matcherArgument = mia.get(mia.size() - 1);
            if (!matchersMatcher.matches(matcherArgument) || subMatcher.matches(matcherArgument)) {
                return mi;
            }
            if (argumentType != null && !TypeUtils.isOfClassType(actualArgument.getType(), argumentType)) {
                return mi;
            }

            String actual = typeToIndicator(actualArgument.getType());
            J.MethodInvocation matcherArgumentMethod = (J.MethodInvocation) matcherArgument;
            JavaTemplate template = JavaTemplate.builder(String.format(
                            ""assertThat(%s)"" +
                            (reasonArgument != null ? "".as(#{any(String)})"" : """") +
                            "".%s(%s)"",
                            actual, assertion, getArgumentsTemplate(matcherArgumentMethod)))
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""assertj-core-3""))
                    .staticImports(
                            ""org.assertj.core.api.Assertions.assertThat"",
                            ""org.assertj.core.api.Assertions.within"")
                    .build();
            maybeRemoveImport(""org.hamcrest.Matchers."" + matcher);
            maybeRemoveImport(""org.hamcrest.CoreMatchers."" + matcher);
            maybeRemoveImport(""org.hamcrest.MatcherAssert"");
            maybeRemoveImport(""org.hamcrest.MatcherAssert.assertThat"");
            maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"");
            maybeAddImport(""org.assertj.core.api.Assertions"", ""within"");

            List<Expression> templateArguments = new ArrayList<>();
            templateArguments.add(actualArgument);
            if (reasonArgument != null) {
                templateArguments.add(reasonArgument);
            }
            for (Expression originalArgument : matcherArgumentMethod.getArguments()) {
                if (!(originalArgument instanceof J.Empty)) {
                    templateArguments.add(originalArgument);
                }
            }
            return template.apply(getCursor(), mi.getCoordinates().replace(), templateArguments.toArray());
        }

        private final MethodMatcher CLOSE_TO_MATCHER = new MethodMatcher(""org.hamcrest.Matchers closeTo(..)"");

        private String getArgumentsTemplate(J.MethodInvocation matcherArgument) {
            List<Expression> methodArguments = matcherArgument.getArguments();
            if (CLOSE_TO_MATCHER.matches(matcherArgument)) {
                return String.format(""%s, within(%s)"",
                        typeToIndicator(methodArguments.get(0).getType()),
                        typeToIndicator(methodArguments.get(1).getType()));
            }
            return methodArguments.stream()
                    .filter(a -> !(a instanceof J.Empty))
                    .map(a -> typeToIndicator(a.getType()))
                    .collect(joining("", ""));
        }

        private String typeToIndicator(JavaType type) {
            if (type instanceof JavaType.Array) {
                type = ((JavaType.Array) type).getElemType();
                String str = type instanceof JavaType.Primitive || type.toString().startsWith(""java."") ?
                        type.toString().replaceAll(""<.*>"", """") : ""java.lang.Object"";
                return String.format(""#{anyArray(%s)}"", str);
            }
            if (type instanceof JavaType.Primitive || type.toString().startsWith(""java."")) {
                return ""#{any()}"";
            }
            return ""#{any(java.lang.Object)}"";
        }
    }
}
",{}
Migrate `anyOf` Hamcrest Matcher to AssertJ,Migrate the `anyOf` Hamcrest Matcher to AssertJ's `satisfiesAnyOf` assertion.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.hamcrest;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.List;

import static java.util.stream.Collectors.joining;

public class HamcrestOfMatchersToAssertJ extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate `anyOf` Hamcrest Matcher to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Migrate the `anyOf` Hamcrest Matcher to AssertJ's `satisfiesAnyOf` assertion."";
    }

    private static final MethodMatcher ASSERT_THAT_MATCHER = new MethodMatcher(""org.hamcrest.MatcherAssert assertThat(..)"");
    private static final MethodMatcher ANY_OF_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers anyOf(..)"");
    private static final MethodMatcher ALL_OF_MATCHER = new MethodMatcher(""org.hamcrest.*Matchers allOf(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesMethod<>(ANY_OF_MATCHER),
                new UsesMethod<>(ALL_OF_MATCHER)
        ), new AnyOfToAssertJVisitor());
    }

    private static class AnyOfToAssertJVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(methodInvocation, ctx);
            List<Expression> arguments = mi.getArguments();
            Expression ofExpression = arguments.get(arguments.size() - 1);
            boolean allOfMatcherMatches = ALL_OF_MATCHER.matches(ofExpression);
            if (!ASSERT_THAT_MATCHER.matches(mi) || !(ANY_OF_MATCHER.matches(ofExpression) || allOfMatcherMatches)) {
                return mi;
            }

            // Skip anyOf(Iterable)
            List<Expression> anyOfArguments = ((J.MethodInvocation) ofExpression).getArguments();
            if (TypeUtils.isAssignableTo(""java.lang.Iterable"", anyOfArguments.get(0).getType())) {
                return mi;
            }

            StringBuilder template = new StringBuilder();
            List<Expression> parameters = new ArrayList<>();

            // assertThat(actual)
            template.append(""assertThat(#{any()})\n"");
            parameters.add(arguments.get(arguments.size() - 2));

            // .as(""..."")
            if (arguments.size() == 3) {
                template.append("".as(#{any(java.lang.String)})\n"");
                parameters.add(arguments.get(0));
            }

            // .satisfiesAnyOf(...) or .satisfies(...)
            template.append(allOfMatcherMatches ? "".satisfies(\n"" : "".satisfiesAnyOf(\n"");
            template.append(anyOfArguments.stream()
                    .map(arg -> ""arg -> assertThat(arg, #{any()})"")
                    .collect(joining("",\n"")));
            parameters.addAll(anyOfArguments);
            template.append(""\n);"");

            maybeRemoveImport(""org.hamcrest.Matchers.anyOf"");
            maybeRemoveImport(""org.hamcrest.Matchers.allOf"");
            maybeRemoveImport(""org.hamcrest.CoreMatchers.anyOf"");
            maybeRemoveImport(""org.hamcrest.CoreMatchers.allOf"");
            maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"");
            return JavaTemplate.builder(template.toString())
                    .contextSensitive()
                    .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx,
                            ""assertj-core-3"",
                            ""hamcrest-3"",
                            ""junit-jupiter-api-5""))
                    .build()
                    .apply(getCursor(), mi.getCoordinates().replace(), parameters.toArray());
        }
    }
}
",{}
Convert JMockit `@Mocked` and `@Injectable` annotated arguments,Convert JMockit `@Mocked` and `@Injectable` annotated arguments into Mockito statements.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.jmockit;

import lombok.EqualsAndHashCode;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;

import java.util.ArrayList;
import java.util.List;

import static org.openrewrite.java.testing.jmockit.JMockitUtils.getJavaParser;

@EqualsAndHashCode(callSuper = false)
public class JMockitAnnotatedArgumentToMockito extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Convert JMockit `@Mocked` and `@Injectable` annotated arguments"";
    }

    @Override
    public String getDescription() {
        return ""Convert JMockit `@Mocked` and `@Injectable` annotated arguments into Mockito statements."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(""mockit.Mocked"", false),
                        new UsesType<>(""mockit.Injectable"", false)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDeclaration, ExecutionContext ctx) {
                        J.MethodDeclaration md = super.visitMethodDeclaration(methodDeclaration, ctx);

                        List<Statement> parameters = md.getParameters();
                        if (!parameters.isEmpty() && !(parameters.get(0) instanceof J.Empty)) {
                            maybeRemoveImport(""mockit.Injectable"");
                            maybeRemoveImport(""mockit.Mocked"");
                            maybeAddImport(""org.mockito.Mockito"");

                            // Create lists to store the mocked parameters and the new type parameters
                            List<J.VariableDeclarations> mockedParameter = new ArrayList<>();

                            // Remove any mocked parameters from the method declaration
                            md = md.withParameters(ListUtils.map(parameters, parameter -> {
                                if (parameter instanceof J.VariableDeclarations) {
                                    J.VariableDeclarations variableDeclarations = (J.VariableDeclarations) parameter;
                                    // Check if the parameter has the annotation ""mockit.Mocked or mockit.Injectable""
                                    if (!FindAnnotations.find(variableDeclarations, ""mockit.Injectable"").isEmpty() ||
                                        !FindAnnotations.find(variableDeclarations, ""mockit.Mocked"").isEmpty() ) {
                                        mockedParameter.add(variableDeclarations);
                                        return null;
                                    }
                                }
                                return parameter;
                            }));

                            // Add mocked parameters as statements to the method declaration
                            if (!mockedParameter.isEmpty()) {
                                JavaTemplate addStatementsTemplate = JavaTemplate.builder(""#{} #{} = Mockito.mock(#{}.class);\n"")
                                        .javaParser(getJavaParser(ctx))
                                        .imports(""org.mockito.Mockito"")
                                        .contextSensitive()
                                        .build();
                                // Retain argument order by iterating in reverse
                                for (int i = mockedParameter.size() - 1; i >= 0; i--) {
                                    J.VariableDeclarations variableDeclarations = mockedParameter.get(i);
                                    // Apply the template and update the method declaration
                                    md = addStatementsTemplate.apply(updateCursor(md),
                                            md.getBody().getCoordinates().firstStatement(),
                                            variableDeclarations.getTypeExpression().toString(),
                                            variableDeclarations.getVariables().get(0).getSimpleName(),
                                            variableDeclarations.getTypeExpression().toString());
                                }
                            }
                        }
                        return md;
                    }
                }
        );
    }
}
",{}
Rewrite JMockit ,Rewrites JMockit `,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.jmockit;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.openrewrite.java.testing.jmockit.JMockitBlockType.getSupportedTypesStr;
import static org.openrewrite.java.testing.jmockit.JMockitBlockType.values;

@Value
@EqualsAndHashCode(callSuper = false)
public class JMockitBlockToMockito extends Recipe {

    private static final String SUPPORTED_TYPES = getSupportedTypesStr();

    @Override
    public String getDisplayName() {
        return ""Rewrite JMockit "" + SUPPORTED_TYPES;
    }

    @Override
    public String getDescription() {
        return ""Rewrites JMockit `"" + SUPPORTED_TYPES + ""` blocks to Mockito statements."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        @SuppressWarnings(""rawtypes"")
        UsesType[] usesTypes = Arrays.stream(values()).map(blockType -> new UsesType<>(blockType.getFqn(), false)).toArray(UsesType[]::new);
        return Preconditions.check(Preconditions.or(usesTypes), new RewriteJMockitBlockVisitor());
    }

    private static class RewriteJMockitBlockVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDeclaration, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(methodDeclaration, ctx);
            if (md.getBody() == null) {
                return md;
            }
            // rewrite the statements that are not mock expectations or verifications
            SetupStatementsRewriter ssr = new SetupStatementsRewriter(this, md.getBody());
            J.Block methodBody = ssr.rewriteMethodBody();
            List<Statement> statements = methodBody.getStatements();

            int verificationsInOrderIdx = 0;
            int bodyStatementIndex = 0;
            // iterate over each statement in the method body, find JMockit blocks and rewrite them
            while (bodyStatementIndex < statements.size()) {
                Statement s = statements.get(bodyStatementIndex);
                Optional<JMockitBlockType> blockTypeOpt = JMockitUtils.getJMockitBlock(s);
                if (blockTypeOpt.isPresent()) {
                    JMockitBlockType blockType = blockTypeOpt.get();
                    JMockitBlockRewriter blockRewriter = new JMockitBlockRewriter(this, ctx, methodBody,
                            ((J.NewClass) s), bodyStatementIndex, blockType, verificationsInOrderIdx);
                    methodBody = blockRewriter.rewriteMethodBody();
                    statements = methodBody.getStatements();
                    // if the block rewrite failed, skip the next statement
                    if (blockRewriter.isRewriteFailed()) {
                        bodyStatementIndex++;
                    } else {
                        if (blockType == JMockitBlockType.VerificationsInOrder) {
                            verificationsInOrderIdx++;
                        }
                    }
                } else {
                    bodyStatementIndex++;
                }
            }
            return md.withBody(methodBody);
        }
    }
}
",{}
Rewrite JMockit MockUp to Mockito statements,Rewrites JMockit `MockUp` blocks to Mockito statements. This recipe will not rewrite private methods in MockUp.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.jmockit;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.staticanalysis.LambdaBlockToExpression;
import org.openrewrite.staticanalysis.VariableReferences;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.stream.Collectors.*;
import static org.openrewrite.java.testing.jmockit.JMockitUtils.MOCKITO_ALL_IMPORT;
import static org.openrewrite.java.testing.jmockit.JMockitUtils.getJavaParser;
import static org.openrewrite.java.testing.mockito.MockitoUtils.maybeAddMethodWithAnnotation;
import static org.openrewrite.java.tree.Flag.Private;
import static org.openrewrite.java.tree.Flag.Static;

public class JMockitMockUpToMockito extends Recipe {

    private static final String JMOCKIT_MOCKUP_IMPORT = ""mockit.MockUp"";
    private static final String JMOCKIT_MOCK_IMPORT = ""mockit.Mock"";
    private static final String MOCKITO_MATCHER_IMPORT = ""org.mockito.ArgumentMatchers.*"";
    private static final String MOCKITO_DELEGATEANSWER_IMPORT = ""org.mockito.AdditionalAnswers.delegatesTo"";
    private static final String MOCKITO_STATIC_PREFIX = ""mockStatic"";
    private static final String MOCKITO_STATIC_IMPORT = ""org.mockito.MockedStatic"";
    private static final String MOCKITO_MOCK_PREFIX = ""mock"";
    private static final String MOCKITO_CONSTRUCTION_PREFIX = ""mockCons"";
    private static final String MOCKITO_CONSTRUCTION_IMPORT = ""org.mockito.MockedConstruction"";

    @Override
    public String getDisplayName() {
        return ""Rewrite JMockit MockUp to Mockito statements"";
    }

    @Override
    public String getDescription() {
        return ""Rewrites JMockit `MockUp` blocks to Mockito statements. This recipe will not rewrite private methods in MockUp."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(JMOCKIT_MOCKUP_IMPORT, false), new JMockitMockUpToMockitoVisitor());
    }

    private static class JMockitMockUpToMockitoVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final Map<String, J.Identifier> tearDownMocks = new HashMap<>();

        /**
         * Handle at class level because need to handle the case where when there is a MockUp in a setup method, and we
         * need to close the migrated mockCons in the teardown, yet the teardown method comes before the setup method
         */
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            // Handle @Before/@BeforeEach mockUp
            Set<J.MethodDeclaration> mds = TreeVisitor.collect(
                            new JavaIsoVisitor<ExecutionContext>() {
                                @Override
                                public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
                                    if (isSetUpMethod(md)) {
                                        return SearchResult.found(md);
                                    }
                                    return super.visitMethodDeclaration(md, ctx);
                                }
                            },
                            classDecl,
                            new HashSet<>()
                    )
                    .stream()
                    .filter(J.MethodDeclaration.class::isInstance)
                    .map(J.MethodDeclaration.class::cast)
                    .collect(toSet());
            if (mds.isEmpty()) {
                return super.visitClassDeclaration(classDecl, ctx);
            }

            AtomicReference<J.ClassDeclaration> cdRef = new AtomicReference<>(classDecl);
            mds.forEach(md -> md.getBody()
                    .getStatements()
                    .stream()
                    .filter(this::isMockUpStatement)
                    .map(J.NewClass.class::cast)
                    .forEach(newClass -> {
                        String className = ((J.ParameterizedType) newClass.getClazz()).getTypeParameters().get(0).toString();

                        Map<J.MethodDeclaration, JavaType.Method> mockedMethods = getMockUpMethods(newClass);

                        // Add mockStatic field
                        if (mockedMethods.values().stream().anyMatch(m -> m.getFlags().contains(Static))) {
                            cdRef.set(JavaTemplate.builder(""private MockedStatic #{};"")
                                    .contextSensitive()
                                    .javaParser(getJavaParser(ctx))
                                    .imports(MOCKITO_STATIC_IMPORT)
                                    .staticImports(MOCKITO_ALL_IMPORT)
                                    .build()
                                    .apply(
                                            new Cursor(getCursor().getParentOrThrow(), cdRef.get()),
                                            cdRef.get().getBody().getCoordinates().firstStatement(),
                                            MOCKITO_STATIC_PREFIX + className
                                    ));
                            J.VariableDeclarations mockField = (J.VariableDeclarations) cdRef.get().getBody().getStatements().get(0);
                            J.Identifier mockFieldId = mockField.getVariables().get(0).getName();
                            tearDownMocks.put(MOCKITO_STATIC_PREFIX + className, mockFieldId);
                        }
                        // Add mockConstruction field
                        if (mockedMethods.values().stream().anyMatch(m -> !m.getFlags().contains(Static))) {
                            cdRef.set(JavaTemplate.builder(""private MockedConstruction #{};"")
                                    .contextSensitive()
                                    .javaParser(getJavaParser(ctx))
                                    .imports(MOCKITO_CONSTRUCTION_IMPORT)
                                    .staticImports(MOCKITO_ALL_IMPORT)
                                    .build()
                                    .apply(
                                            updateCursor(cdRef.get()),
                                            cdRef.get().getBody().getCoordinates().firstStatement(),
                                            MOCKITO_CONSTRUCTION_PREFIX + className
                                    ));
                            J.VariableDeclarations mockField = (J.VariableDeclarations) cdRef.get().getBody().getStatements().get(0);
                            J.Identifier mockFieldId = mockField.getVariables().get(0).getName();
                            tearDownMocks.put(MOCKITO_CONSTRUCTION_PREFIX + className, mockFieldId);
                        }
                    }));

            J.ClassDeclaration cd = maybeAddMethodWithAnnotation(this, cdRef.get(), ctx, true, ""tearDown"",
                    ""@org.junit.After"",
                    ""@After"",
                    ""junit-4"",
                    ""org.junit.After"",
                    """");

            return super.visitClassDeclaration(cd, ctx);
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
            J.MethodDeclaration md = methodDecl;
            if (md.getBody() == null) {
                return md;
            }
            if (isTearDownMethod(md)) {
                for (J.Identifier id : tearDownMocks.values()) {
                    String type = TypeUtils.asFullyQualified(id.getFieldType().getType()).getFullyQualifiedName();
                    md = JavaTemplate.builder(""#{any("" + type + "")}.closeOnDemand();"")
                            .contextSensitive()
                            .javaParser(getJavaParser(ctx))
                            .imports(MOCKITO_STATIC_IMPORT, MOCKITO_CONSTRUCTION_IMPORT)
                            .staticImports(MOCKITO_ALL_IMPORT)
                            .build()
                            .apply(
                                    updateCursor(md),
                                    md.getBody().getCoordinates().lastStatement(),
                                    id
                            );
                }
                return md;
            }

            boolean isBeforeTest = isSetUpMethod(md);
            List<String> varDeclarationInTry = new ArrayList<>();
            List<String> mockStaticMethodInTry = new ArrayList<>();
            List<String> mockConstructionMethodInTry = new ArrayList<>();
            List<Statement> encloseStatements = new ArrayList<>();
            List<Statement> residualStatements = new ArrayList<>();
            for (Statement statement : md.getBody().getStatements()) {
                if (!isMockUpStatement(statement)) {
                    encloseStatements.add(statement);
                    continue;
                }

                J.NewClass newClass = (J.NewClass) statement;

                // Only discard @Mock method declarations
                residualStatements.addAll(newClass
                        .getBody()
                        .getStatements()
                        .stream()
                        .filter(s -> {
                            if (s instanceof J.MethodDeclaration) {
                                return ((J.MethodDeclaration) s).getLeadingAnnotations().stream()
                                        .noneMatch(o -> TypeUtils.isOfClassType(o.getType(), JMOCKIT_MOCK_IMPORT));
                            }
                            return true;
                        })
                        .collect(toList())
                );

                JavaType mockType = ((J.ParameterizedType) newClass.getClazz()).getTypeParameters().get(0).getType();
                String className = ((J.ParameterizedType) newClass.getClazz()).getTypeParameters().get(0).toString();

                Map<J.MethodDeclaration, JavaType.Method> mockedMethods = getMockUpMethods(newClass);

                // Add MockStatic
                Map<J.MethodDeclaration, JavaType.Method> mockedPublicStaticMethods = mockedMethods
                        .entrySet()
                        .stream()
                        .filter(m -> m.getValue().getFlags().contains(Static))
                        .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
                if (!mockedPublicStaticMethods.isEmpty()) {
                    if (isBeforeTest) {
                        String tpl = getMockStaticDeclarationInBefore(className) +
                                     getMockStaticMethods((JavaType.Class) mockType, className, mockedPublicStaticMethods);

                        md = JavaTemplate.builder(tpl)
                                .contextSensitive()
                                .javaParser(getJavaParser(ctx))
                                .imports(MOCKITO_STATIC_IMPORT)
                                .staticImports(MOCKITO_ALL_IMPORT)
                                .build()
                                .apply(
                                        updateCursor(md),
                                        statement.getCoordinates().after(),
                                        tearDownMocks.get(MOCKITO_STATIC_PREFIX + className)
                                );
                    } else {
                        varDeclarationInTry.add(getMockStaticDeclarationInTry(className));
                        mockStaticMethodInTry.add(getMockStaticMethods((JavaType.Class) mockType, className, mockedPublicStaticMethods));
                    }

                    maybeAddImport(MOCKITO_STATIC_IMPORT);
                }

                // Add MockConstruction
                Map<J.MethodDeclaration, JavaType.Method> mockedPublicMethods = mockedMethods
                        .entrySet()
                        .stream()
                        .filter(m -> !m.getValue().getFlags().contains(Static))
                        .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
                if (!mockedPublicMethods.isEmpty()) {
                    if (isBeforeTest) {
                        String tpl = getMockConstructionMethods(className, mockedPublicMethods) +
                                     getMockConstructionDeclarationInBefore(className);

                        md = JavaTemplate.builder(tpl)
                                .contextSensitive()
                                .javaParser(getJavaParser(ctx))
                                .imports(MOCKITO_STATIC_IMPORT)
                                .staticImports(MOCKITO_ALL_IMPORT, MOCKITO_DELEGATEANSWER_IMPORT)
                                .build()
                                .apply(
                                        updateCursor(md),
                                        statement.getCoordinates().after(),
                                        tearDownMocks.get(MOCKITO_CONSTRUCTION_PREFIX + className)
                                );
                    } else {
                        varDeclarationInTry.add(getMockConstructionDeclarationInTry(className));
                        mockConstructionMethodInTry.add(getMockConstructionMethods(className, mockedPublicMethods));
                    }

                    maybeAddImport(MOCKITO_CONSTRUCTION_IMPORT);
                    maybeAddImport(""org.mockito.Answers"", ""CALLS_REAL_METHODS"", false);
                    maybeAddImport(""org.mockito.AdditionalAnswers"", ""delegatesTo"", false);
                }

                List<Statement> statements = md.getBody().getStatements();
                statements.remove(statement);
                md = md.withBody(md.getBody().withStatements(statements));
            }

            if (!varDeclarationInTry.isEmpty()) {
                String tpl = String.join("""", mockConstructionMethodInTry) +
                             ""try ("" +
                             String.join("";"", varDeclarationInTry) +
                             "") {"" +
                             String.join("";"", mockStaticMethodInTry) +
                             ""}"";

                J.MethodDeclaration residualMd = md.withBody(md.getBody().withStatements(residualStatements));
                residualMd = JavaTemplate.builder(tpl)
                        .contextSensitive()
                        .javaParser(getJavaParser(ctx))
                        .imports(MOCKITO_STATIC_IMPORT, MOCKITO_CONSTRUCTION_IMPORT)
                        .staticImports(MOCKITO_ALL_IMPORT, MOCKITO_MATCHER_IMPORT, MOCKITO_MATCHER_IMPORT, MOCKITO_DELEGATEANSWER_IMPORT)
                        .build()
                        .apply(updateCursor(residualMd), residualMd.getBody().getCoordinates().lastStatement());

                List<Statement> mdStatements = residualMd.getBody().getStatements();
                J.Try try_ = (J.Try) mdStatements.get(mdStatements.size() - 1);

                List<Statement> tryStatements = try_.getBody().getStatements();
                tryStatements.addAll(encloseStatements);
                try_ = try_.withBody(try_.getBody().withStatements(tryStatements));

                mdStatements.set(mdStatements.size() - 1, try_);
                md = md.withBody(residualMd.getBody().withStatements(mdStatements));
            }

            maybeAddImport(MOCKITO_ALL_IMPORT.replace("".*"", """"), ""*"", false);
            maybeRemoveImport(JMOCKIT_MOCK_IMPORT);
            maybeRemoveImport(JMOCKIT_MOCKUP_IMPORT);

            doAfterVisit(new LambdaBlockToExpression().getVisitor());
            return maybeAutoFormat(methodDecl, md, ctx);
        }

        private String getMatcher(JavaType s) {
            maybeAddImport(MOCKITO_MATCHER_IMPORT.replace("".*"", """"), ""*"", false);
            if (s instanceof JavaType.Primitive) {
                switch (s.toString()) {
                    case ""int"":
                        return ""anyInt()"";
                    case ""long"":
                        return ""anyLong()"";
                    case ""double"":
                        return ""anyDouble()"";
                    case ""float"":
                        return ""anyFloat()"";
                    case ""short"":
                        return ""anyShort()"";
                    case ""byte"":
                        return ""anyByte()"";
                    case ""char"":
                        return ""anyChar()"";
                    case ""boolean"":
                        return ""anyBoolean()"";
                }
            } else if (s instanceof JavaType.Array) {
                String elem = TypeUtils.asArray(s).getElemType().toString();
                return ""nullable("" + elem + ""[].class)"";
            }
            return ""nullable("" + TypeUtils.asFullyQualified(s).getClassName() + "".class)"";
        }

        private String getAnswerBody(J.MethodDeclaration md) {
            Set<String> usedVariables = new HashSet<>();
            new JavaIsoVisitor<Set<String>>() {
                @Override
                public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, Set<String> ctx) {
                    Cursor scope = getCursor().dropParentUntil((is) -> is instanceof J.ClassDeclaration || is instanceof J.Block || is instanceof J.MethodDeclaration || is instanceof J.ForLoop || is instanceof J.ForEachLoop || is instanceof J.ForLoop.Control || is instanceof J.ForEachLoop.Control || is instanceof J.Case || is instanceof J.Try || is instanceof J.Try.Resource || is instanceof J.Try.Catch || is instanceof J.MultiCatch || is instanceof J.Lambda || is instanceof JavaSourceFile);
                    if (!VariableReferences.findRhsReferences(scope.getValue(), variable.getName()).isEmpty()) {
                        ctx.add(variable.getSimpleName());
                    }
                    return super.visitVariable(variable, ctx);
                }
            }.visit(md, usedVariables);

            StringBuilder sb = new StringBuilder();
            List<Statement> parameters = md.getParameters();
            for (int i = 0; i < parameters.size(); i++) {
                if (!(parameters.get(i) instanceof J.VariableDeclarations)) {
                    continue;
                }
                J.VariableDeclarations vd = (J.VariableDeclarations) parameters.get(i);
                String className;
                if (vd.getType() instanceof JavaType.Primitive) {
                    className = vd.getType().toString();
                } else {
                    className = vd.getTypeAsFullyQualified().getClassName();
                }
                String varName = vd.getVariables().get(0).getName().getSimpleName();
                if (usedVariables.contains(varName)) {
                    sb.append(className).append("" "").append(varName)
                            .append("" = invocation.getArgument("").append(i).append("");"");
                }
            }

            boolean hasReturn = false;
            for (Statement s : md.getBody().getStatements()) {
                hasReturn |= s instanceof J.Return;
                sb.append(s.print(getCursor())).append("";"");
            }
            // Avoid syntax error
            if (!hasReturn) {
                sb.append(""return null;"");
            }
            return sb.toString();
        }

        private String getCallRealMethod(JavaType.Method m) {
            return ""("" +
                   m.getParameterTypes()
                           .stream()
                           .map(this::getMatcher)
                           .collect(joining("", "")) +
                   "")).thenCallRealMethod();"";
        }

        private String getMockStaticDeclarationInBefore(String className) {
            return ""#{any("" + MOCKITO_STATIC_IMPORT + "")}"" +
                   "" = mockStatic("" + className + "".class);"";
        }

        private String getMockStaticDeclarationInTry(String className) {
            return ""MockedStatic "" + MOCKITO_STATIC_PREFIX + className +
                   "" = mockStatic("" + className + "".class)"";
        }

        private String getMockStaticMethods(JavaType.Class clazz, String className, Map<J.MethodDeclaration, JavaType.Method> mockedMethods) {
            StringBuilder tpl = new StringBuilder();

            // To generate predictable method order
            List<J.MethodDeclaration> keys = mockedMethods.keySet().stream()
                    .sorted(Comparator.comparing(o -> o.print(getCursor())))
                    .collect(toList());
            for (J.MethodDeclaration m : keys) {
                tpl.append(""mockStatic"").append(className)
                        .append("".when(() -> "").append(className).append(""."").append(m.getSimpleName()).append(""("")
                        .append(m.getParameters()
                                .stream()
                                .filter(J.VariableDeclarations.class::isInstance)
                                .map(J.VariableDeclarations.class::cast)
                                .map(J.VariableDeclarations::getType)
                                .map(this::getMatcher)
                                .collect(joining("", ""))
                        )
                        .append("")).thenAnswer(invocation -> {"")
                        .append(getAnswerBody(m))
                        .append(""});"");
            }

            // Call real method for non private, static methods
            clazz.getMethods()
                    .stream()
                    .filter(m -> !m.isConstructor())
                    .filter(m -> !m.getFlags().contains(Private))
                    .filter(m -> m.getFlags().contains(Static))
                    .filter(m -> !mockedMethods.containsValue(m))
                    .forEach(m -> tpl.append(""mockStatic"").append(className).append("".when(() -> "")
                            .append(className).append(""."").append(m.getName())
                            .append(getCallRealMethod(m))
                            .append("");"")
                    );

            return tpl.toString();
        }

        private String getMockConstructionDeclarationInBefore(String className) {
            return ""#{any("" + MOCKITO_CONSTRUCTION_IMPORT + "")}"" +
                   "" = mockConstructionWithAnswer("" + className + "".class, delegatesTo("" + MOCKITO_MOCK_PREFIX + className + ""));"";
        }

        private String getMockConstructionDeclarationInTry(String className) {
            return ""MockedConstruction "" + MOCKITO_CONSTRUCTION_PREFIX + className +
                   "" = mockConstructionWithAnswer("" + className + "".class, delegatesTo("" + MOCKITO_MOCK_PREFIX + className + ""))"";
        }

        private String getMockConstructionMethods(String className, Map<J.MethodDeclaration, JavaType.Method> mockedMethods) {
            StringBuilder tpl = new StringBuilder()
                    .append(className)
                    .append("" "")
                    .append(MOCKITO_MOCK_PREFIX).append(className)
                    .append("" = mock("").append(className).append("".class, CALLS_REAL_METHODS);"");

            mockedMethods
                    .keySet()
                    .stream()
                    .sorted(Comparator.comparing(o -> o.print(getCursor())))
                    .forEach(m -> tpl.append(""doAnswer(invocation -> {"")
                            .append(getAnswerBody(m))
                            .append(""}).when("").append(MOCKITO_MOCK_PREFIX).append(className).append("")."").append(m.getSimpleName()).append(""("")
                            .append(m.getParameters()
                                    .stream()
                                    .filter(J.VariableDeclarations.class::isInstance)
                                    .map(J.VariableDeclarations.class::cast)
                                    .map(J.VariableDeclarations::getType)
                                    .map(this::getMatcher)
                                    .collect(joining("", ""))
                            )
                            .append("");""));

            return tpl.toString();
        }

        private boolean isMockUpStatement(Tree tree) {
            return tree instanceof J.NewClass &&
                   ((J.NewClass) tree).getClazz() != null &&
                   TypeUtils.isOfClassType(((J.NewClass) tree).getClazz().getType(), JMOCKIT_MOCKUP_IMPORT);
        }

        private boolean isSetUpMethod(J.MethodDeclaration md) {
            return md
                    .getLeadingAnnotations()
                    .stream()
                    .anyMatch(o -> TypeUtils.isOfClassType(o.getType(), ""org.junit.Before""));
        }

        private boolean isTearDownMethod(J.MethodDeclaration md) {
            return md
                    .getLeadingAnnotations()
                    .stream()
                    .anyMatch(o -> TypeUtils.isOfClassType(o.getType(), ""org.junit.After""));
        }

        private Map<J.MethodDeclaration, JavaType.Method> getMockUpMethods(J.NewClass newClass) {
            JavaType mockType = ((J.ParameterizedType) newClass.getClazz()).getTypeParameters().get(0).getType();
            return newClass.getBody()
                    .getStatements()
                    .stream()
                    .filter(J.MethodDeclaration.class::isInstance)
                    .map(J.MethodDeclaration.class::cast)
                    .filter(s -> s.getLeadingAnnotations().stream()
                            .anyMatch(o -> TypeUtils.isOfClassType(o.getType(), JMOCKIT_MOCK_IMPORT)))
                    .map(method -> {
                        Optional<JavaType.Method> found = TypeUtils.findDeclaredMethod(
                                TypeUtils.asFullyQualified(mockType),
                                method.getSimpleName(),
                                method.getMethodType().getParameterTypes()
                        );
                        if (found.isPresent()) {
                            JavaType.Method m = found.get();
                            if (!m.getFlags().contains(Private)) {
                                return new AbstractMap.SimpleEntry<>(method, found.get());
                            }
                        }
                        return null;
                    })
                    .filter(Objects::nonNull)
                    .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
        }
    }
}
",{}
TestNG `assertNotEquals` to AssertJ,Convert TestNG-style `assertNotEquals()` to AssertJ's `assertThat().isNotEqualTo()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.testng;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class TestNgAssertNotEqualsToAssertThat extends Recipe {

    @Override
    public String getDisplayName() {
        return ""TestNG `assertNotEquals` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert TestNG-style `assertNotEquals()` to AssertJ's `assertThat().isNotEqualTo()`."";
    }

    private static final MethodMatcher TESTNG_ASSERT_METHOD = new MethodMatcher(""org.testng.Assert assertNotEquals(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(TESTNG_ASSERT_METHOD), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (!TESTNG_ASSERT_METHOD.matches(method)) {
                    return method;
                }

                List<Expression> args = method.getArguments();

                Expression expected = args.get(1);
                Expression actual = args.get(0);

                if (args.size() == 2) {
                    method = JavaTemplate.builder(""assertThat(#{any()}).isNotEqualTo(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    actual,
                                    expected
                            );
                } else if (args.size() == 3 && !isFloatingPointType(args.get(2))) {
                    Expression message = args.get(2);
                    method = JavaTemplate.builder(""assertThat(#{any()}).as(#{any(String)}).isNotEqualTo(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    actual,
                                    message,
                                    expected
                            );
                } else if (args.size() == 3) {
                    method = JavaTemplate.builder(""assertThat(#{any()}).isNotCloseTo(#{any()}, within(#{any()}));"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"", ""org.assertj.core.api.Assertions.within"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    actual,
                                    expected,
                                    args.get(2)
                            );
                    maybeAddImport(""org.assertj.core.api.Assertions"", ""within"", false);
                } else {
                    Expression message = args.get(3);
                    method = JavaTemplate.builder(""assertThat(#{any()}).as(#{any(String)}).isNotCloseTo(#{any()}, within(#{any()}));"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"", ""org.assertj.core.api.Assertions.within"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    actual,
                                    message,
                                    expected,
                                    args.get(2)
                            );

                    maybeAddImport(""org.assertj.core.api.Assertions"", ""within"", false);
                }

                //Make sure there is a static import for ""org.assertj.core.api.Assertions.assertThat"" (even if not referenced)
                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);

                // Remove import for ""org.testng.Assert"" if no longer used.
                maybeRemoveImport(""org.testng.Assert"");

                return method;
            }

            private boolean isFloatingPointType(Expression expression) {
                JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(expression.getType());
                if (fullyQualified != null) {
                    String typeName = fullyQualified.getFullyQualifiedName();
                    return ""java.lang.Double"".equals(typeName) || ""java.lang.Float"".equals(typeName);
                }

                JavaType.Primitive parameterType = TypeUtils.asPrimitive(expression.getType());
                return parameterType == JavaType.Primitive.Double || parameterType == JavaType.Primitive.Float;
            }
        });
    }

}
",{}
TestNG `assertEquals` to AssertJ,Convert TestNG-style `assertEquals()` to AssertJ's `assertThat().isEqualTo()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.testng;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class TestNgAssertEqualsToAssertThat extends Recipe {

    @Override
    public String getDisplayName() {
        return ""TestNG `assertEquals` to AssertJ"";
    }

    @Override
    public String getDescription() {
        return ""Convert TestNG-style `assertEquals()` to AssertJ's `assertThat().isEqualTo()`."";
    }

    private static final MethodMatcher TESTNG_ASSERT_METHOD = new MethodMatcher(""org.testng.Assert assertEquals(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(TESTNG_ASSERT_METHOD), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (!TESTNG_ASSERT_METHOD.matches(method)) {
                    return method;
                }

                List<Expression> args = method.getArguments();
                Expression expected = args.get(1);
                Expression actual = args.get(0);

                //always add the import (even if not referenced)
                maybeAddImport(""org.assertj.core.api.Assertions"", ""assertThat"", false);

                // Remove import for ""org.testng.Assert"" if no longer used.
                maybeRemoveImport(""org.testng.Assert"");

                if (args.size() == 2) {
                    return JavaTemplate.builder(""assertThat(#{any()}).isEqualTo(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), method.getCoordinates().replace(), actual, expected);
                }
                if (args.size() == 3 && !isFloatingPointType(args.get(2))) {
                    Expression message = args.get(2);
                    return JavaTemplate.builder(""assertThat(#{any()}).as(#{any(String)}).isEqualTo(#{any()});"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"")
                            .imports(""java.util.function.Supplier"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    actual,
                                    message,
                                    expected
                            );
                }
                if (args.size() == 3) {
                    //always add the import (even if not referenced)
                    maybeAddImport(""org.assertj.core.api.Assertions"", ""within"", false);
                    return JavaTemplate.builder(""assertThat(#{any()}).isCloseTo(#{any()}, within(#{any()}));"")
                            .staticImports(""org.assertj.core.api.Assertions.assertThat"", ""org.assertj.core.api.Assertions.within"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""assertj-core-3""))
                            .build()
                            .apply(getCursor(), method.getCoordinates().replace(), actual, expected, args.get(2));

                }

                // The assertEquals is using a floating point with a delta argument and a message.
                Expression message = args.get(3);

                //always add the import (even if not referenced)
                maybeAddImport(""org.assertj.core.api.Assertions"", ""within"", false);
                return JavaTemplate.builder(""assertThat(#{any()}).as(#{any(String)}).isCloseTo(#{any()}, within(#{any()}));"")
                        .staticImports(""org.assertj.core.api.Assertions.assertThat"", ""org.assertj.core.api.Assertions.within"")
                        .imports(""java.util.function.Supplier"")
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""assertj-core-3""))
                        .build()
                        .apply(
                                getCursor(),
                                method.getCoordinates().replace(),
                                actual,
                                message,
                                expected,
                                args.get(2)
                        );
            }

            private boolean isFloatingPointType(Expression expression) {

                JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(expression.getType());
                if (fullyQualified != null) {
                    String typeName = fullyQualified.getFullyQualifiedName();
                    return ""java.lang.Double"".equals(typeName) || ""java.lang.Float"".equals(typeName);
                }

                JavaType.Primitive parameterType = TypeUtils.asPrimitive(expression.getType());
                return parameterType == JavaType.Primitive.Double || parameterType == JavaType.Primitive.Float;
            }
        });
    }

}
",{}
Find unit tests,Produces a data table showing how methods are used in unit tests.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.search;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Getter;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.IsLikelyNotTest;
import org.openrewrite.java.search.IsLikelyTest;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


public class FindUnitTests extends ScanningRecipe<FindUnitTests.Accumulator> {

    private transient @Nullable Accumulator acc = new Accumulator();
    transient FindUnitTestTable unitTestTable = new FindUnitTestTable(this);

    public FindUnitTests() {
    }

    @JsonIgnore
    @SuppressWarnings(""unused"") // used by downstream modules
    public FindUnitTests(Accumulator acc) {
        this.acc = acc;
    }

    @Override
    public String getDisplayName() {
        return ""Find unit tests"";
    }

    @Override
    public String getDescription() {
        return ""Produces a data table showing how methods are used in unit tests."";
    }

    @Getter
    public static class Accumulator {
        private final Map<String, AccumulatorValue> unitTestsByKey = new HashMap<>();

        public void addMethodInvocation(String clazz, String testName, String testBody, J.MethodInvocation invocation) {
            String key = clazz + ""#"" + testName;
            AccumulatorValue value = unitTestsByKey.get(key);
            if (value == null) {
                UnitTest unitTest = new UnitTest(clazz, testName, testBody);
                value = new AccumulatorValue(unitTest, new HashSet<>());
                unitTestsByKey.put(key, value);
            }
            value.getMethodInvocations().add(invocation);
        }
    }


    @Value
    public static class AccumulatorValue {
        UnitTest unitTest;
        Set<J.MethodInvocation> methodInvocations;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        if (acc != null) {
            return acc;
        }
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        JavaVisitor<ExecutionContext> scanningVisitor = new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                // Identify the method declaration that encloses this invocation
                J.MethodDeclaration methodDeclaration = getCursor().firstEnclosing(J.MethodDeclaration.class);
                if (methodDeclaration != null &&
                        methodDeclaration.getLeadingAnnotations().stream()
                                .filter(o -> o.getAnnotationType() instanceof J.Identifier)
                                .anyMatch(o -> ""Test"".equals(o.getSimpleName()))) {
                    String clazz = getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class)
                            .getType().getFullyQualifiedName();

                    String testName = methodDeclaration.getSimpleName();

                    String testBody = methodDeclaration.printTrimmed(getCursor());

                    acc.addMethodInvocation(clazz, testName, testBody, method);
                }
                return super.visitMethodInvocation(method, ctx);
            }
        };

        return Preconditions.check(new IsLikelyTest().getVisitor(), scanningVisitor);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        JavaVisitor<ExecutionContext> tableRowVisitor = new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodDeclaration(J.MethodDeclaration methodDeclaration, ExecutionContext ctx) {
                // Iterate over each stored AccumulatorValue
                for (AccumulatorValue value : acc.getUnitTestsByKey().values()) {
                    UnitTest unitTest = value.getUnitTest();
                    for (J.MethodInvocation invocation : value.getMethodInvocations()) {
                        // If the invoked method name matches the current methodDeclaration's name,
                        // we assume we've found ""usage"" of that method inside the test
                        if (invocation.getSimpleName().equals(methodDeclaration.getSimpleName())) {
                            unitTestTable.insertRow(ctx, new FindUnitTestTable.Row(
                                    methodDeclaration.getName().toString(),
                                    methodDeclaration.getSimpleName(),
                                    invocation.printTrimmed(getCursor()),
                                    unitTest.getClazz(),
                                    unitTest.getUnitTestName()
                            ));
                        }
                    }
                }
                SearchResult.found(methodDeclaration);
                return super.visitMethodDeclaration(methodDeclaration, ctx);
            }
        };

        return Preconditions.check(new IsLikelyNotTest().getVisitor(), tableRowVisitor);
    }
}
",{}
Migrate JUnit 4 lifecycle annotations to JUnit Jupiter,"Replace JUnit 4's `@Before`, `@BeforeClass`, `@After`, and `@AfterClass` annotations with their JUnit Jupiter equivalents.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

public class UpdateBeforeAfterAnnotations extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate JUnit 4 lifecycle annotations to JUnit Jupiter"";
    }

    @Override
    public String getDescription() {
        return ""Replace JUnit 4's `@Before`, `@BeforeClass`, `@After`, and `@AfterClass` annotations with their JUnit Jupiter equivalents."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                        new UsesType<>(""org.junit.BeforeClass"", false),
                        new UsesType<>(""org.junit.Before"", false),
                        new UsesType<>(""org.junit.After"", false),
                        new UsesType<>(""org.junit.AfterClass"", false)
                ),
                new UpdateBeforeAfterAnnotationsVisitor());
    }

    public static class UpdateBeforeAfterAnnotationsVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J preVisit(J tree, ExecutionContext ctx) {
            stopAfterPreVisit();
            doAfterVisit(new ChangeType(""org.junit.Before"", ""org.junit.jupiter.api.BeforeEach"", true).getVisitor());
            doAfterVisit(new ChangeType(""org.junit.After"", ""org.junit.jupiter.api.AfterEach"", true).getVisitor());
            doAfterVisit(new ChangeType(""org.junit.BeforeClass"", ""org.junit.jupiter.api.BeforeAll"", true).getVisitor());
            doAfterVisit(new ChangeType(""org.junit.AfterClass"", ""org.junit.jupiter.api.AfterAll"", true).getVisitor());
            return tree;
        }
    }
}
",{}
JUnit 4 `@RunWith(Enclosed.class)` to JUnit Jupiter `@Nested`,"Removes the `Enclosed` specification from a class, with `Nested` added to its inner classes by `AddMissingNested`.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class EnclosedToNested extends Recipe {
    private static final String ENCLOSED = ""org.junit.experimental.runners.Enclosed"";
    private static final String RUN_WITH = ""org.junit.runner.RunWith"";
    private static final String RUN_WITH_ENCLOSED = String.format(""@%s(%s.class)"", RUN_WITH, ENCLOSED);

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `@RunWith(Enclosed.class)` to JUnit Jupiter `@Nested`"";
    }

    @Override
    public String getDescription() {
        return ""Removes the `Enclosed` specification from a class, with `Nested` added to its inner classes by `AddMissingNested`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(ENCLOSED, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                maybeRemoveImport(ENCLOSED);
                maybeRemoveImport(RUN_WITH);
                return (J.ClassDeclaration) new RemoveAnnotationVisitor(new AnnotationMatcher(RUN_WITH_ENCLOSED)).visitNonNull(cd, ctx);
            }
        });
    }
}
",{}
Make `@TempDir` fields non final,Make JUnit 5's `org.junit.jupiter.api.io.TempDir` fields non final.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.J.Modifier.Type;

import java.time.Duration;
import java.util.Iterator;

public class TempDirNonFinal extends Recipe {

    private static final AnnotationMatcher TEMPDIR_ANNOTATION_MATCHER = new AnnotationMatcher(
            ""@org.junit.jupiter.api.io.TempDir"");

    @Override
    public String getDisplayName() {
        return ""Make `@TempDir` fields non final"";
    }

    @Override
    public String getDescription() {
        return ""Make JUnit 5's `org.junit.jupiter.api.io.TempDir` fields non final."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.jupiter.api.io.TempDir"", false), new TempDirVisitor());
    }

    private static class TempDirVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations varDecls = super.visitVariableDeclarations(multiVariable, ctx);
            if (varDecls.getLeadingAnnotations().stream().anyMatch(TEMPDIR_ANNOTATION_MATCHER::matches) &&
                varDecls.hasModifier(Type.Final) && isField(getCursor())) {
                return maybeAutoFormat(varDecls, varDecls.withModifiers(ListUtils
                                .map(varDecls.getModifiers(), modifier -> modifier.getType() == Type.Final ? null : modifier)),
                        ctx, getCursor().getParentOrThrow());
            }
            return varDecls;
        }
    }

    // copied from org.openrewrite.java.search.FindFieldsOfType.isField(Cursor), should probably become part of the API
    private static boolean isField(Cursor cursor) {
        Iterator<Object> path = cursor.getPath();
        while (path.hasNext()) {
            Object o = path.next();
            if (o instanceof J.MethodDeclaration) {
                return false;
            }
            if (o instanceof J.ClassDeclaration) {
                return true;
            }
        }
        return true;
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }
}
",{}
JUnit 4 `@Rule Timeout` to JUnit Jupiter's `Timeout`,Replace usages of JUnit 4's `@Rule Timeout` with JUnit 5 `Timeout` class annotation.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Comparator;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public class TimeoutRuleToClassAnnotation extends Recipe {

    private static final MethodMatcher TIMEOUT_CONSTRUCTOR_MATCHER = new MethodMatcher(""org.junit.rules.Timeout <constructor>(..)"");
    private static final MethodMatcher MILLIS_SECONDS_MATCHER = new MethodMatcher(""org.junit.rules.Timeout *(long)"");

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `@Rule Timeout` to JUnit Jupiter's `Timeout`"";
    }

    @Override
    public String getDescription() {
        return ""Replace usages of JUnit 4's `@Rule Timeout` with JUnit 5 `Timeout` class annotation."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.rules.Timeout"", false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

                AtomicReference<@Nullable Expression> initializer = new AtomicReference<>();

                cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                    if (statement instanceof J.VariableDeclarations) {
                        //noinspection ConstantConditions
                        if (TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getTypeExpression().getType(),
                                ""org.junit.rules.Timeout"")) {
                            List<J.VariableDeclarations.NamedVariable> variables = ((J.VariableDeclarations) statement).getVariables();
                            if (!variables.isEmpty()) {
                                Expression timeoutInitializer = variables.get(0).getInitializer();
                                if (TIMEOUT_CONSTRUCTOR_MATCHER.matches(timeoutInitializer) ||
                                        MILLIS_SECONDS_MATCHER.matches(timeoutInitializer)) {
                                    initializer.set(timeoutInitializer);
                                    return null;
                                }
                            }
                        }
                    }
                    return statement;
                })));

                Expression initializerValue = initializer.get();
                if (initializerValue != null) {
                    maybeRemoveImport(""org.junit.Rule"");
                    maybeRemoveImport(""org.junit.rules.Timeout"");
                    return insertTimeoutAnnotation(initializerValue, cd, ctx);
                }
                return cd;
            }

            private J.ClassDeclaration insertTimeoutAnnotation(Expression ex, J.ClassDeclaration cd, ExecutionContext ctx) {
                String template;
                Object[] params;
                if (TIMEOUT_CONSTRUCTOR_MATCHER.matches(ex)) {
                    List<Expression> arguments = ((J.NewClass) ex).getArguments();
                    if (arguments.size() == 2) {
                        template = ""@Timeout(value = #{any(long)}, unit = #{any(java.util.concurrent.TimeUnit)})"";
                        params = new Object[]{arguments.get(0), arguments.get(1)};
                    } else {
                        template = ""@Timeout(value = #{any(long)}, unit = TimeUnit.MILLISECONDS)"";
                        params = new Object[]{arguments.get(0)};
                    }
                } else if (MILLIS_SECONDS_MATCHER.matches(ex)) {
                    String simpleName = ((J.MethodInvocation) ex).getSimpleName();
                    String units = ""millis"".equals(simpleName) ? ""MILLISECONDS"" : ""SECONDS"";
                    template = ""@Timeout(value = #{any(long)}, unit = TimeUnit."" + units + "")"";
                    params = new Object[]{((J.MethodInvocation) ex).getArguments().get(0)};
                } else {
                    return cd;
                }

                maybeAddImport(""org.junit.jupiter.api.Timeout"");
                maybeAddImport(""java.util.concurrent.TimeUnit"");
                return JavaTemplate.builder(template)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""hamcrest-3""))
                        .imports(""org.junit.jupiter.api.Timeout"",
                                ""java.util.concurrent.TimeUnit"")
                        .build()
                        .apply(updateCursor(cd),
                                cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)),
                                params);
            }
        });
    }
}
",{}
Replace `fail()` in `try-catch` blocks with `Assertions.assertDoesNotThrow(() -> { ... })`,Replace `try-catch` blocks where `catch` merely contains a `fail()` for `fail(String)` statement ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;

import static java.util.Collections.singleton;

public class RemoveTryCatchFailBlocks extends Recipe {
    private static final MethodMatcher ASSERT_FAIL_NO_ARG = new MethodMatcher(""org.junit.jupiter.api.Assertions fail()"");
    private static final MethodMatcher ASSERT_FAIL_STRING_ARG = new MethodMatcher(""org.junit.jupiter.api.Assertions fail(String)"");
    private static final MethodMatcher ASSERT_FAIL_THROWABLE_ARG = new MethodMatcher(""org.junit.jupiter.api.Assertions fail(.., Throwable)"");
    private static final MethodMatcher GET_MESSAGE_MATCHER = new MethodMatcher(""java.lang.Throwable getMessage()"");

    @Override
    public String getDisplayName() {
        return ""Replace `fail()` in `try-catch` blocks with `Assertions.assertDoesNotThrow(() -> { ... })`"";
    }

    @Override
    public String getDescription() {
        return ""Replace `try-catch` blocks where `catch` merely contains a `fail()` for `fail(String)` statement "" +
               ""with `Assertions.assertDoesNotThrow(() -> { ... })`."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S3658"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(""org.junit.jupiter.api.Assertions fail(..)"", false), new RemoveTryCatchBlocksFromUnitsTestsVisitor());
    }

    private static class RemoveTryCatchBlocksFromUnitsTestsVisitor extends JavaVisitor<ExecutionContext> {
        @Override
        public J visitTry(J.Try jtry, ExecutionContext ctx) {
            J.Try try_ = (J.Try) super.visitTry(jtry, ctx);
            // only one catch block, such that we know it's safe to apply this recipe, and doesn't have resources
            if (try_.getResources() != null || try_.getCatches().size() != 1 || try_.getFinally() != null) {
                return try_;
            }

            // Skip if any return is found, since we can't return from `assertDoesNotThrow`
            AtomicBoolean returnFound = new AtomicBoolean(false);
            new JavaIsoVisitor<AtomicBoolean>() {
                @Override
                public J.Return visitReturn(J.Return _return, AtomicBoolean atomicBoolean) {
                    atomicBoolean.set(true);
                    return _return;
                }
            }.visit(try_, returnFound, getCursor().getParentOrThrow());
            if (returnFound.get()) {
                return try_;
            }

            /*
            Only one statement in the catch block, which is a fail(), with no or a simple String argument.
            We would not want to convert for instance fail(cleanUpAndReturnMessage()) might still have side
            effects that we don't want to remove.
             */
            J.Try.Catch catchBlock = try_.getCatches().get(0);
            if (catchBlock.getBody().getStatements().size() != 1) {
                return try_;
            }
            Statement statement = catchBlock.getBody().getStatements().get(0);
            if (!(statement instanceof J.MethodInvocation)) {
                return try_;
            }
            J.MethodInvocation failCall = (J.MethodInvocation) statement;
            if (!ASSERT_FAIL_NO_ARG.matches(failCall) &&
                    !ASSERT_FAIL_STRING_ARG.matches(failCall) &&
                    !ASSERT_FAIL_THROWABLE_ARG.matches(failCall)) {
                return try_;
            }

            // Only replace known cases
            Expression failCallArgument = failCall.getArguments().get(0);
            if (failCallArgument instanceof J.Empty) {
                return replaceWithAssertDoesNotThrowWithoutStringExpression(ctx, try_);
            }
            if (failCallArgument instanceof J.MethodInvocation && GET_MESSAGE_MATCHER.matches(failCallArgument)) {
                return replaceWithAssertDoesNotThrowWithoutStringExpression(ctx, try_);
            }
            if (failCallArgument instanceof J.Literal) {
                return replaceWithAssertDoesNotThrowWithStringExpression(ctx, try_, failCallArgument);
            }
            if (isException(failCallArgument)) {
                return replaceWithAssertDoesNotThrowWithoutStringExpression(ctx, try_);
            }
            if (failCallArgument instanceof J.Binary) {
                J.Binary binaryArg = (J.Binary) failCallArgument;
                Expression left = binaryArg.getLeft();
                Expression right = binaryArg.getRight();
                // Rewrite fail(""message: "" + e), fail(""message: "" + e.getMessage())
                if (left instanceof J.Literal && (GET_MESSAGE_MATCHER.matches(right) || isException(right))) {
                    return replaceWithAssertDoesNotThrowWithStringExpression(ctx, try_, left);
                }
            }

            // Fall back to making no change at all
            return try_;
        }

        private static boolean isException(Expression expression) {
            return expression instanceof J.Identifier && TypeUtils.isAssignableTo(""java.lang.Throwable"", expression.getType());
        }

        private J.MethodInvocation replaceWithAssertDoesNotThrowWithoutStringExpression(ExecutionContext ctx, J.Try try_) {
            maybeAddImport(""org.junit.jupiter.api.Assertions"");
            maybeRemoveCatchTypes(try_);
            return JavaTemplate.builder(""Assertions.assertDoesNotThrow(() -> #{any()})"")
                    .contextSensitive()
                    .imports(""org.junit.jupiter.api.Assertions"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(getCursor(), try_.getCoordinates().replace(), try_.getBody());
        }

        private void maybeRemoveCatchTypes(J.Try try_) {
            maybeRemoveImport(""org.junit.jupiter.api.Assertions.fail"");
            JavaType catchType = try_.getCatches().get(0).getParameter().getTree().getType();
            if (catchType != null) {
                Stream.of(catchType)
                        .flatMap(t -> t instanceof JavaType.MultiCatch ? ((JavaType.MultiCatch) t).getThrowableTypes().stream() : Stream.of(t))
                        .map(TypeUtils::asFullyQualified)
                        .filter(Objects::nonNull)
                        .forEach(t -> maybeRemoveImport(t.getFullyQualifiedName()));
            }
        }

        private J.MethodInvocation replaceWithAssertDoesNotThrowWithStringExpression(ExecutionContext ctx, J.Try try_, Expression failCallArgument) {
            // Retain the fail(String) call argument
            maybeAddImport(""org.junit.jupiter.api.Assertions"");
            maybeRemoveCatchTypes(try_);
            return JavaTemplate.builder(""Assertions.assertDoesNotThrow(() -> #{any()}, #{any(String)})"")
                    .imports(""org.junit.jupiter.api.Assertions"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(getCursor(), try_.getCoordinates().replace(), try_.getBody(), failCallArgument);
        }
    }
}
",{}
Applies JUnit 5 `assertThrows` on last statement in lambda block only,Applies JUnit 5 `assertThrows` on last statement in lambda block only. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.VariableNameUtils;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.staticanalysis.LambdaBlockToExpression;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;


public class AssertThrowsOnLastStatement extends Recipe {

    private static final Pattern NUMBER_SUFFIX_PATTERN = Pattern.compile(""^(.+?)(\\d+)$"");

    @Override
    public String getDisplayName() {
        return ""Applies JUnit 5 `assertThrows` on last statement in lambda block only"";
    }

    @Override
    public String getDescription() {
        return ""Applies JUnit 5 `assertThrows` on last statement in lambda block only. "" +
                ""In rare cases may cause compilation errors if the lambda uses effectively non final variables. "" +
                ""In some cases, tests might fail if earlier statements in the lambda block throw exceptions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher assertThrowsMatcher = new MethodMatcher(
                ""org.junit.jupiter.api.Assertions assertThrows(java.lang.Class, org.junit.jupiter.api.function.Executable, ..)"");
        return Preconditions.check(new UsesMethod<>(assertThrowsMatcher), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(methodDecl, ctx);
                if (m.getBody() == null) {
                    return m;
                }
                doAfterVisit(new LambdaBlockToExpression().getVisitor());
                return m.withBody(m.getBody().withStatements(ListUtils.flatMap(m.getBody().getStatements(), methodStatement -> {
                    J statementToCheck = methodStatement;
                    final J.VariableDeclarations assertThrowsWithVarDec;
                    final J.VariableDeclarations.NamedVariable assertThrowsVar;

                    if (methodStatement instanceof J.VariableDeclarations) {
                        assertThrowsWithVarDec = (J.VariableDeclarations) methodStatement;
                        List<J.VariableDeclarations.NamedVariable> assertThrowsNamedVars = assertThrowsWithVarDec.getVariables();
                        if (assertThrowsNamedVars.size() != 1) {
                            return methodStatement;
                        }

                        // has variable declaration for assertThrows eg Throwable ex = assertThrows(....)
                        assertThrowsVar = assertThrowsNamedVars.get(0);
                        statementToCheck = assertThrowsVar.getInitializer();
                    } else {
                        assertThrowsWithVarDec = null;
                        assertThrowsVar = null;
                    }

                    if (!(statementToCheck instanceof J.MethodInvocation)) {
                        return methodStatement;
                    }

                    J.MethodInvocation methodInvocation = (J.MethodInvocation) statementToCheck;
                    if (!assertThrowsMatcher.matches(methodInvocation)) {
                        return methodStatement;
                    }

                    List<Expression> arguments = methodInvocation.getArguments();
                    if (arguments.size() <= 1) {
                        return methodStatement;
                    }

                    Expression arg = arguments.get(1);
                    if (!(arg instanceof J.Lambda)) {
                        return methodStatement;
                    }

                    J.Lambda lambda = (J.Lambda) arg;
                    if (!(lambda.getBody() instanceof J.Block)) {
                        return methodStatement;
                    }

                    J.Block body = (J.Block) lambda.getBody();
                    List<Statement> lambdaStatements = body.getStatements();

                    // TODO Check to see if last line in lambda does not use a non-final variable

                    // move all the statements from the body into before the method invocation, except last one
                    return ListUtils.flatMap(lambdaStatements, (idx, lambdaStatement) -> {
                        if (idx < lambdaStatements.size() - 1) {
                            return lambdaStatement.withPrefix(methodStatement.getPrefix().withComments(emptyList()));
                        }

                        List<Statement> variableAssignments = new ArrayList<>();
                        Space prefix = methodStatement.getPrefix().withComments(emptyList());
                        final Statement newLambdaStatement = extractExpressionArguments(lambdaStatement, variableAssignments, prefix);
                        J.MethodInvocation newAssertThrows = methodInvocation.withArguments(
                                ListUtils.map(arguments, (argIdx, argument) -> {
                                    // The second argument is the lambda which is tested.
                                    if (argIdx == 1) {
                                        // Only retain the last statement in the lambda block
                                        return lambda.withBody(body.withStatements(singletonList(newLambdaStatement)));
                                    }
                                    return argument;
                                })
                        );

                        if (assertThrowsWithVarDec == null) {
                            variableAssignments.add(newAssertThrows);
                            return variableAssignments;
                        }

                        J.VariableDeclarations.NamedVariable newAssertThrowsVar = assertThrowsVar.withInitializer(newAssertThrows);
                        variableAssignments.add(assertThrowsWithVarDec.withVariables(singletonList(newAssertThrowsVar)));
                        return variableAssignments;
                    });
                })));
            }

            private Statement extractExpressionArguments(Statement lambdaStatement, List<Statement> precedingVars, Space varPrefix) {
                if (lambdaStatement instanceof J.MethodInvocation) {
                    J.MethodInvocation mi = (J.MethodInvocation) lambdaStatement;
                    Map<String, Integer> generatedVariableSuffixes = new HashMap<>();
                    return mi.withArguments(ListUtils.map(mi.getArguments(), e -> {
                        if (e instanceof J.Identifier || e instanceof J.Literal || e instanceof J.Empty || e == null) {
                            return e;
                        }

                        Object variableTypeShort = ""Object"";
                        JavaType variableTypeFqn = null;
                        if (e.getType() instanceof JavaType.Primitive) {
                            variableTypeShort = e.getType().toString();
                            variableTypeFqn = e.getType();
                        } else if (e.getType() instanceof JavaType.FullyQualified) {
                            JavaType.FullyQualified aClass = (JavaType.FullyQualified) e.getType();
                            variableTypeShort = aClass.getClassName();
                            variableTypeFqn = aClass;
                            maybeAddImport(aClass.getFullyQualifiedName(), false);
                        }

                        Cursor c = new Cursor(getCursor(), lambdaStatement);
                        J.VariableDeclarations varDecl = JavaTemplate.builder(""#{} #{} = #{any()};"")
                                .build()
                                .apply(c, lambdaStatement.getCoordinates().replace(), variableTypeShort, getVariableName(e, generatedVariableSuffixes), e);
                        precedingVars.add(varDecl.withPrefix(varPrefix).withType(variableTypeFqn));
                        return varDecl.getVariables().get(0).getName().withPrefix(e.getPrefix()).withType(variableTypeFqn);
                    }));
                }
                return lambdaStatement;
            }

            private String getVariableName(Expression e, Map<String, Integer> generatedVariableSuffixes) {
                String variableName;
                if (e instanceof J.MethodInvocation) {
                    String name = ((J.MethodInvocation) e).getSimpleName();
                    name = name.replaceAll(""^get"", """");
                    name = name.replaceAll(""^is"", """");
                    name = StringUtils.uncapitalize(name);
                    variableName = VariableNameUtils.generateVariableName(!name.isEmpty() ? name : ""x"", getCursor(), VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER);
                } else {
                    variableName = VariableNameUtils.generateVariableName(""x"", getCursor(), VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER);
                }
                return ensureUniqueVariableName(variableName, generatedVariableSuffixes);
            }

            private String ensureUniqueVariableName(String variableName, Map<String, Integer> generatedVariableSuffixes) {
                Set<String> existingVariablesInScope = VariableNameUtils.findNamesInScope(getCursor());
                Matcher matcher = NUMBER_SUFFIX_PATTERN.matcher(variableName);
                if (matcher.matches()) {
                    String prefix = matcher.group(1);
                    int suffix = Integer.parseInt(matcher.group(2));
                    generatedVariableSuffixes.putIfAbsent(prefix, suffix);
                    variableName = prefix;
                }
                if (generatedVariableSuffixes.containsKey(variableName)) {
                    int suffix = generatedVariableSuffixes.get(variableName);
                    while (existingVariablesInScope.contains(variableName + suffix)) {
                        suffix++;
                    }
                    generatedVariableSuffixes.put(variableName, suffix + 1);
                    variableName += suffix;
                } else {
                    generatedVariableSuffixes.put(variableName, 1);
                }
                return variableName;
            }
        });
    }
}
",{}
Migrate JUnit 4 `TestCase` to JUnit Jupiter,Convert JUnit 4 `TestCase` to JUnit Jupiter.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.Markers;

import java.util.Comparator;
import java.util.List;

public class MigrateJUnitTestCase extends Recipe {

    private static final AnnotationMatcher JUNIT_TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.Test"");
    private static final AnnotationMatcher JUNIT_AFTER_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.*After*"");
    private static final AnnotationMatcher JUNIT_BEFORE_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.*Before*"");

    private static boolean isSupertypeTestCase(JavaType.@Nullable FullyQualified fullyQualified) {
        if (fullyQualified == null || fullyQualified.getSupertype() == null || ""java.lang.Object"".equals(fullyQualified.getFullyQualifiedName())) {
            return false;
        }

        JavaType.FullyQualified fqType = TypeUtils.asFullyQualified(fullyQualified);
        if (fqType != null && ""junit.framework.TestCase"".equals(fqType.getFullyQualifiedName())) {
            return true;
        }
        return isSupertypeTestCase(fullyQualified.getSupertype());
    }

    @Override
    public String getDisplayName() {
        return ""Migrate JUnit 4 `TestCase` to JUnit Jupiter"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit 4 `TestCase` to JUnit Jupiter."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                        new UsesType<>(""junit.framework.TestCase"", false),
                        new UsesType<>(""junit.framework.Assert"", false)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                        J.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
                        doAfterVisit(new TestCaseVisitor());
                        // ChangeType for org.junit.Assert method invocations because TestCase extends org.junit.Assert
                        doAfterVisit(new ChangeType(""junit.framework.TestCase"", ""org.junit.Assert"", true).getVisitor());
                        doAfterVisit(new ChangeType(""junit.framework.Assert"", ""org.junit.Assert"", true).getVisitor());
                        doAfterVisit(new AssertToAssertions.AssertToAssertionsVisitor());
                        doAfterVisit(new UseStaticImport(""org.junit.jupiter.api.Assertions assert*(..)"").getVisitor());
                        doAfterVisit(new UseStaticImport(""org.junit.jupiter.api.Assertions fail*(..)"").getVisitor());
                        return c;
                    }

                    @SuppressWarnings(""ConstantConditions"")
                    @Override
                    public  J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if ((mi.getSelect() != null && TypeUtils.isOfClassType(mi.getSelect().getType(), ""junit.framework.TestCase"")) ||
                            (mi.getMethodType() != null && TypeUtils.isOfClassType(mi.getMethodType().getDeclaringType(), ""junit.framework.TestCase""))) {
                            String name = mi.getSimpleName();
                            // setUp and tearDown will be invoked via Before and After annotations
                            if (""setUp"".equals(name) || ""tearDown"".equals(name)) {
                                return null;
                            }
                            if (""setName"".equals(name)) {
                                mi = mi.withPrefix(mi.getPrefix().withComments(ListUtils.concat(mi.getPrefix().getComments(), new TextComment(false, """", """", Markers.EMPTY))));
                            }
                        }
                        return mi;
                    }
                });
    }

    private static class TestCaseVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final AnnotationMatcher OVERRIDE_ANNOTATION_MATCHER = new AnnotationMatcher(""@java.lang.Override"");

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            if (!isSupertypeTestCase(classDecl.getType())) {
                return classDecl;
            }
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            if (cd.getExtends() != null && cd.getExtends().getType() != null) {
                JavaType.FullyQualified fullQualifiedExtension = TypeUtils.asFullyQualified(cd.getExtends().getType());
                if (fullQualifiedExtension != null && ""junit.framework.TestCase"".equals(fullQualifiedExtension.getFullyQualifiedName())) {
                    cd = cd.withExtends(null);
                }
            }
            maybeRemoveImport(""junit.framework.TestCase"");
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            updateCursor(md);
            if (md.getSimpleName().startsWith(""test"") && md.getLeadingAnnotations().stream().noneMatch(JUNIT_TEST_ANNOTATION_MATCHER::matches)) {
                md = updateMethodDeclarationAnnotationAndModifier(md, ""@Test"", ""org.junit.jupiter.api.Test"", ctx);
            } else if (""setUp"".equals(md.getSimpleName()) && md.getLeadingAnnotations().stream().noneMatch(JUNIT_BEFORE_ANNOTATION_MATCHER::matches)) {
                md = updateMethodDeclarationAnnotationAndModifier(md, ""@BeforeEach"", ""org.junit.jupiter.api.BeforeEach"", ctx);
            } else if (""tearDown"".equals(md.getSimpleName()) && md.getLeadingAnnotations().stream().noneMatch(JUNIT_AFTER_ANNOTATION_MATCHER::matches)) {
                md = updateMethodDeclarationAnnotationAndModifier(md, ""@AfterEach"", ""org.junit.jupiter.api.AfterEach"", ctx);
            }
            return md;
        }

        private J.MethodDeclaration updateMethodDeclarationAnnotationAndModifier(J.MethodDeclaration methodDeclaration, String annotation, String fullyQualifiedAnnotation, ExecutionContext ctx) {
            J.MethodDeclaration md = methodDeclaration;
            if (FindAnnotations.find(methodDeclaration.withBody(null), ""@"" + fullyQualifiedAnnotation).isEmpty()) {
                md = JavaTemplate.builder(annotation)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                        .imports(fullyQualifiedAnnotation).build()
                        .apply(getCursor(), methodDeclaration.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                md = maybeAddPublicModifier(md);
                md = maybeRemoveOverrideAnnotation(md);
                maybeAddImport(fullyQualifiedAnnotation);
            }
            return md;
        }

        private J.MethodDeclaration maybeAddPublicModifier(J.MethodDeclaration md) {
            List<J.Modifier> modifiers = ListUtils.map(md.getModifiers(), modifier -> {
                if (modifier.getType() == J.Modifier.Type.Protected) {
                    return modifier.withType(J.Modifier.Type.Public);
                }
                return modifier;
            });
            return md.withModifiers(modifiers);
        }

        private J.MethodDeclaration maybeRemoveOverrideAnnotation(J.MethodDeclaration md) {
            return md.withLeadingAnnotations(ListUtils.map(md.getLeadingAnnotations(), annotation -> {
                if (OVERRIDE_ANNOTATION_MATCHER.matches(annotation)) {
                    return null;
                }
                return annotation;
            }));
        }
    }
}
",{}
Remove JUnit 4 `@RunWith` annotations that do not require an `@ExtendsWith` replacement,Some JUnit 4 `@RunWith` annotations do not require replacement with an equivalent JUnit Jupiter `@ExtendsWith` annotation. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotation;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveObsoleteRunners extends Recipe {
    @Option(displayName = ""Obsolete Runners"",
            description = ""The fully qualified class names of the JUnit 4 runners to be removed."",
            example = ""org.junit.runners.JUnit4"")
    List<String> obsoleteRunners;

    @Override
    public String getDisplayName() {
        return ""Remove JUnit 4 `@RunWith` annotations that do not require an `@ExtendsWith` replacement"";
    }

    @Override
    public String getDescription() {
        return ""Some JUnit 4 `@RunWith` annotations do not require replacement with an equivalent JUnit Jupiter `@ExtendsWith` annotation. "" +
                ""This can be used to remove those runners that either do not have a JUnit Jupiter equivalent or do not require a replacement as part of JUnit 4 to 5 migration."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        @SuppressWarnings(""unchecked"") TreeVisitor<?, ExecutionContext> check =
                Preconditions.or(obsoleteRunners.stream().map(r -> new UsesType<>(r, false)).toArray(UsesType[]::new));
        return Preconditions.check(check, new RemoveObsoleteRunnersVisitor());
    }

    public class RemoveObsoleteRunnersVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            for (String runner : obsoleteRunners) {
                //noinspection ConstantConditions
                doAfterVisit(new RemoveAnnotation(""@org.junit.runner.RunWith("" + runner + "".class)"").getVisitor());
                maybeRemoveImport(runner);
            }
            maybeRemoveImport(""org.junit.runner.RunWith"");
            return classDecl;
        }
    }
}
",{}
Add missing `@ParameterizedTest` annotation when `@ValueSource` is used or ,Add missing `@ParameterizedTest` annotation when `@ValueSource` is used or ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaCoordinates;

import java.util.List;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toList;

public class AddParameterizedTestAnnotation extends Recipe {
    private static final AnnotationMatcher TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.Test"");
    private static final AnnotationMatcher PARAM_TEST_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.params.ParameterizedTest"");
    private static final List<AnnotationMatcher> SOURCE_ANNOTATIONS = Stream.of(
            ""ValueSource"",
            ""CsvSource"",
            ""MethodSource"",
            ""NullSource"",
            ""EmptySource"",
            ""NullAndEmptySource"",
            ""EnumSource"",
            ""CsvFileSource"",
            ""ArgumentsSource""
    ).map(annotation -> new AnnotationMatcher(""@org.junit.jupiter.params.provider."" + annotation)).collect(toList());

    @Override
    public String getDisplayName() {
        return ""Add missing `@ParameterizedTest` annotation when `@ValueSource` is used or "" +
               ""replace `@Test` with `@ParameterizedTest`"";
    }

    @Override
    public String getDescription() {
        return ""Add missing `@ParameterizedTest` annotation when `@ValueSource` is used or "" +
               ""replace `@Test` with `@ParameterizedTest`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.jupiter.params.provider.*"", false), new AnnotatedMethodVisitor());
    }

    private static class AnnotatedMethodVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(md, ctx);

            // Return early if already annotated with @ParameterizedTest or not annotated with any @...Source annotation
            if (m.getLeadingAnnotations().stream().anyMatch(PARAM_TEST_MATCHER::matches) ||
                m.getLeadingAnnotations().stream().noneMatch(ann -> SOURCE_ANNOTATIONS.stream().anyMatch(matcher -> matcher.matches(ann)))) {
                return m;
            }

            // Add parameterized test annotation at the start
            JavaCoordinates coordinates = m.getCoordinates().addAnnotation((o1, o2) -> -1);
            m = JavaTemplate.builder(""@ParameterizedTest"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-params-5""))
                    .imports(""org.junit.jupiter.params.ParameterizedTest"")
                    .build()
                    .apply(getCursor(), coordinates);
            maybeAddImport(""org.junit.jupiter.params.ParameterizedTest"");

            // Remove @Test annotation if present
            maybeRemoveImport(""org.junit.jupiter.api.Test"");
            return new RemoveAnnotationVisitor(TEST_ANNOTATION_MATCHER).visitMethodDeclaration(m, ctx);
        }
    }
}
",{}
JUnit 4 `@RunWith(Parameterized.class)` to JUnit Jupiter parameterized tests,Convert JUnit 4 parameterized runner the JUnit Jupiter parameterized test equivalent.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.stream.Collectors.*;
import static org.openrewrite.Tree.randomId;

public class ParameterizedRunnerToParameterized extends Recipe {
    private static final AnnotationMatcher RUN_WITH_PARAMETERS = new AnnotationMatcher(""@org.junit.runner.RunWith(org.junit.runners.Parameterized.class)"");
    private static final AnnotationMatcher JUNIT_TEST = new AnnotationMatcher(""@org.junit.Test"");
    private static final AnnotationMatcher JUPITER_TEST = new AnnotationMatcher(""@org.junit.jupiter.api.Test"");
    private static final AnnotationMatcher PARAMETERS = new AnnotationMatcher(""@org.junit.runners.Parameterized$Parameters"");
    private static final AnnotationMatcher BEFORE = new AnnotationMatcher(""@org.junit.Before"");
    private static final AnnotationMatcher PARAMETER = new AnnotationMatcher(""@org.junit.runners.Parameterized$Parameter"");
    private static final AnnotationMatcher PARAMETERIZED_TEST = new AnnotationMatcher(""@org.junit.jupiter.params.ParameterizedTest"");

    private static final String PARAMETERS_ANNOTATION_ARGUMENTS = ""parameters-annotation-args"";
    private static final String CONSTRUCTOR_ARGUMENTS = ""constructor-args"";
    private static final String FIELD_INJECTION_ARGUMENTS = ""field-injection-args"";
    private static final String PARAMETERS_METHOD_NAME = ""parameters-method-name"";
    private static final String BEFORE_METHOD_NAME = ""before-method-name"";

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `@RunWith(Parameterized.class)` to JUnit Jupiter parameterized tests"";
    }

    @Override
    public String getDescription() {
        return ""Convert JUnit 4 parameterized runner the JUnit Jupiter parameterized test equivalent."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.runners.Parameterized"", false), new ParameterizedRunnerVisitor());
    }

    private static class ParameterizedRunnerVisitor extends JavaIsoVisitor<ExecutionContext> {
        @SuppressWarnings(""unchecked"")
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            Map<String, Object> params = getCursor().pollMessage(classDecl.getId().toString());
            if (params != null) {
                String parametersMethodName = (String) params.get(PARAMETERS_METHOD_NAME);
                List<Expression> parametersAnnotationArguments = (List<Expression>) params.get(PARAMETERS_ANNOTATION_ARGUMENTS);
                List<Statement> constructorParams = (List<Statement>) params.get(CONSTRUCTOR_ARGUMENTS);
                Map<Integer, Statement> fieldInjectionParams = (Map<Integer, Statement>) params.get(FIELD_INJECTION_ARGUMENTS);
                String initMethodName = ""init"" + cd.getSimpleName();
                String beforeMethodName = (String) params.getOrDefault(BEFORE_METHOD_NAME, null);

                // Constructor Injected Test
                if (parametersMethodName != null && constructorParams != null && constructorParams.stream().anyMatch(org.openrewrite.java.tree.J.VariableDeclarations.class::isInstance)) {
                    doAfterVisit(new ParameterizedRunnerToParameterizedTestsVisitor(classDecl, parametersMethodName, initMethodName, parametersAnnotationArguments, constructorParams, true, beforeMethodName, ctx));
                }

                // Field Injected Test
                else if (parametersMethodName != null && fieldInjectionParams != null) {
                    List<Statement> fieldParams = new ArrayList<>(fieldInjectionParams.values());
                    doAfterVisit(new ParameterizedRunnerToParameterizedTestsVisitor(classDecl, parametersMethodName, initMethodName, parametersAnnotationArguments, fieldParams, false, beforeMethodName, ctx));
                }
            }
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            Cursor classDeclCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
            Map<String, Object> params = classDeclCursor.computeMessageIfAbsent(((J.ClassDeclaration) classDeclCursor.getValue()).getId().toString(), v -> new HashMap<>());
            if (m.isConstructor()) {
                params.put(CONSTRUCTOR_ARGUMENTS, m.getParameters());
            }
            for (J.Annotation annotation : service(AnnotationService.class).getAllAnnotations(getCursor())) {
                if (PARAMETERS.matches(annotation)) {
                    params.put(PARAMETERS_ANNOTATION_ARGUMENTS, annotation.getArguments());
                    params.put(PARAMETERS_METHOD_NAME, method.getSimpleName());
                    break;
                }
                if (BEFORE.matches(annotation)) {
                    params.put(BEFORE_METHOD_NAME, method.getSimpleName());
                }
            }
            return m;
        }

        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations variableDeclarations = super.visitVariableDeclarations(multiVariable, ctx);
            Cursor classDeclCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
            J.Annotation parameterAnnotation = null;
            Integer position = 0;
            for (J.Annotation leadingAnnotation : service(AnnotationService.class).getAllAnnotations(getCursor())) {
                if (PARAMETER.matches(leadingAnnotation)) {
                    parameterAnnotation = leadingAnnotation;
                    if (parameterAnnotation.getArguments() != null && !(parameterAnnotation.getArguments().get(0) instanceof J.Empty)) {
                        J positionArg = parameterAnnotation.getArguments().get(0);
                        if (positionArg instanceof J.Assignment) {
                            position = (Integer) ((J.Literal) ((J.Assignment) positionArg).getAssignment()).getValue();
                        } else {
                            position = (Integer) ((J.Literal) positionArg).getValue();
                        }
                    }
                    break;
                }
            }

            if (parameterAnnotation != null) {
                // the variableDeclaration will be used for a method parameter set the prefix to empty and remove any comments
                J.VariableDeclarations variableForInitMethod = variableDeclarations.withLeadingAnnotations(new ArrayList<>()).withModifiers(new ArrayList<>()).withPrefix(Space.EMPTY);
                if (variableForInitMethod.getTypeExpression() != null) {
                    variableForInitMethod = variableForInitMethod.withTypeExpression(variableForInitMethod.getTypeExpression().withPrefix(Space.EMPTY).withComments(new ArrayList<>()));
                }
                Map<String, TreeMap<Integer, Statement>> params = classDeclCursor.computeMessageIfAbsent(((J.ClassDeclaration) classDeclCursor.getValue()).getId().toString(), v -> new HashMap<>());
                params.computeIfAbsent(FIELD_INJECTION_ARGUMENTS, v -> new TreeMap<>()).put(position, variableForInitMethod);
            }
            return variableDeclarations;
        }
    }

    private static class ParameterizedRunnerToParameterizedTestsVisitor extends JavaIsoVisitor<ExecutionContext> {

        private final J.ClassDeclaration scope;
        private final String initMethodName;
        private final List<Statement> parameterizedTestMethodParameters;

        @Nullable
        private final List<Expression> parameterizedTestAnnotationParameters;

        private final String initStatementParamString;

        private final JavaTemplate parameterizedTestTemplate;
        private final JavaTemplate methodSourceTemplate;
        private final JavaTemplate initMethodStatementTemplate;

        @Nullable
        private final JavaTemplate initMethodDeclarationTemplate;

        public ParameterizedRunnerToParameterizedTestsVisitor(J.ClassDeclaration scope,
                                                              String parametersMethodName,
                                                              String initMethodName,
                                                              @Nullable List<Expression> parameterizedTestAnnotationParameters,
                                                              List<Statement> parameterizedTestMethodParameters,
                                                              boolean isConstructorInjection,
                                                              @Nullable String beforeMethodName,
                                                              ExecutionContext ctx) {
            this.scope = scope;
            this.initMethodName = initMethodName;

            this.parameterizedTestMethodParameters = parameterizedTestMethodParameters.stream()
                    .map(mp -> mp.withPrefix(Space.EMPTY).withComments(new ArrayList<>()))
                    .map(Statement.class::cast)
                    .collect(toList());

            initStatementParamString = parameterizedTestMethodParameters.stream()
                    .filter(J.VariableDeclarations.class::isInstance)
                    .map(J.VariableDeclarations.class::cast)
                    .map(v -> v.getVariables().get(0).getSimpleName())
                    .collect(joining("", ""));

            // build @ParameterizedTest(#{}) template
            this.parameterizedTestAnnotationParameters = parameterizedTestAnnotationParameters;
            String parameterizedTestAnnotationTemplate = parameterizedTestAnnotationParameters != null ?
                    ""@ParameterizedTest(#{any()})"" :
                    ""@ParameterizedTest"";

            JavaParser.Builder<?, ?> javaParserBuilder = JavaParser.fromJavaVersion()
                    .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""junit-jupiter-params-5"");

            this.parameterizedTestTemplate = JavaTemplate.builder(parameterizedTestAnnotationTemplate)
                    .javaParser(javaParserBuilder)
                    .imports(""org.junit.jupiter.params.ParameterizedTest"")
                    .build();

            // build @MethodSource(""..."") template
            this.methodSourceTemplate = JavaTemplate.builder(""@MethodSource(\"""" + parametersMethodName + ""\"")"")
                    .javaParser(javaParserBuilder)
                    .imports(""org.junit.jupiter.params.provider.MethodSource"")
                    .build();

            // build init-method with parameters template
            this.initMethodStatementTemplate = JavaTemplate.builder(initMethodName + ""(#{});"")
                    .contextSensitive()
                    .javaParser(javaParserBuilder)
                    .build();

            // If this is not a constructor injected test then build a javaTemplate for a new init-method
            if (!isConstructorInjection) {
                final StringBuilder initMethodTemplate = new StringBuilder(""public void "").append(initMethodName).append(""() {\n"");
                final List<String> initStatementParams = new ArrayList<>();
                for (Statement parameterizedTestMethodParameter : parameterizedTestMethodParameters) {
                    J.VariableDeclarations vd = (J.VariableDeclarations) parameterizedTestMethodParameter;
                    if (vd.getTypeExpression() != null && vd.getVariables().size() == 1) {
                        initStatementParams.add(vd.getVariables().get(0).getSimpleName());
                    } else {
                        throw new AssertionError(""Expected VariableDeclarations with TypeExpression and single Variable, got ["" + parameterizedTestMethodParameter + ""]"");
                    }
                }

                for (String p : initStatementParams) {
                    initMethodTemplate.append(""    this."").append(p).append("" = "").append(p).append("";\n"");
                }
                if (beforeMethodName != null) {
                    initMethodTemplate.append(""    this."").append(beforeMethodName).append(""();\n"");
                }

                initMethodTemplate.append(""}"");
                this.initMethodDeclarationTemplate = JavaTemplate.builder(initMethodTemplate.toString())
                        .contextSensitive()
                        .javaParser(javaParserBuilder)
                        .build();
            } else {
                this.initMethodDeclarationTemplate = null;
            }
        }

        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            J.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
            if (c != cu) {
                doAfterVisit(new RemoveAnnotationVisitor(PARAMETERS));
                doAfterVisit(new RemoveAnnotationVisitor(PARAMETER));
                doAfterVisit(new RemoveAnnotationVisitor(RUN_WITH_PARAMETERS));

                maybeRemoveImport(""org.junit.Test"");
                maybeRemoveImport(""org.junit.runner.RunWith"");
                maybeRemoveImport(""org.junit.runners.Parameterized"");
                maybeRemoveImport(""org.junit.runners.Parameterized.Parameters"");
                maybeRemoveImport(""org.junit.runners.Parameterized.Parameter"");
                maybeRemoveImport(""org.junit.jupiter.api.Test"");
                maybeAddImport(""org.junit.jupiter.params.ParameterizedTest"");
                maybeAddImport(""org.junit.jupiter.params.provider.MethodSource"");
            }
            return c;
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            if (!scope.isScope(classDecl)) {
                return cd;
            }

            if (initMethodDeclarationTemplate != null) {
                cd = initMethodDeclarationTemplate.apply(updateCursor(cd), cd.getBody().getCoordinates().lastStatement());
                J.Block finalBody = cd.getBody();
                cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), stmt -> {
                    if (stmt instanceof J.MethodDeclaration) {
                        J.MethodDeclaration md = (J.MethodDeclaration) stmt;
                        if (md.getName().getSimpleName().equals(initMethodName)) {
                            J.Block body = md.getBody(); // Preserve body formatting
                            return autoFormat(md.withParameters(parameterizedTestMethodParameters).withBody(null),
                                    ctx, new Cursor(getCursor(), finalBody)).withBody(body);
                        }
                    }
                    return stmt;
                })));
            }

            // if a constructor was converted to an init method then remove final modifiers from any associated field variables.
            final Set<String> fieldNames = getCursor().pollMessage(""INIT_VARS"");
            if (fieldNames != null && !fieldNames.isEmpty()) {
                J.Block finalBody = cd.getBody();
                cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                    if (statement instanceof J.VariableDeclarations) {
                        J.VariableDeclarations varDecls = (J.VariableDeclarations) statement;
                        if (varDecls.getVariables().stream().anyMatch(it -> fieldNames.contains(it.getSimpleName())) &&
                                (varDecls.hasModifier(J.Modifier.Type.Final))) {
                            varDecls = varDecls.withModifiers(ListUtils.map(varDecls.getModifiers(), mod -> mod.getType() == J.Modifier.Type.Final ? null : mod));
                            statement = maybeAutoFormat(statement, varDecls, ctx, new Cursor(getCursor(), finalBody));
                        }
                    }
                    return statement;
                })));
            }
            return cd;
        }

        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations vdecls = super.visitVariableDeclarations(multiVariable, ctx);
            if (!getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).isScopeInPath(scope)) {
                return vdecls;
            }

            final AtomicReference<Space> annoPrefix = new AtomicReference<>();
            vdecls = vdecls.withLeadingAnnotations(ListUtils.map(vdecls.getLeadingAnnotations(), anno -> {
                if (PARAMETER.matches(anno)) {
                    annoPrefix.set(anno.getPrefix());
                    return null;
                }
                return anno;
            }));
            if (annoPrefix.get() != null) {
                vdecls = vdecls.withPrefix(annoPrefix.get());
            }
            return vdecls;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            if (!getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).isScopeInPath(scope)) {
                return m;
            }
            // Replace @Test with @ParameterizedTest
            m = m.withLeadingAnnotations(ListUtils.map(m.getLeadingAnnotations(), annotation -> {
                if (JUPITER_TEST.matches(annotation) || JUNIT_TEST.matches(annotation)) {
                    List<Comment> annotationComments = annotation.getComments();
                    if (parameterizedTestAnnotationParameters == null) {
                        annotation = parameterizedTestTemplate.apply(
                                new Cursor(getCursor(), annotation),
                                annotation.getCoordinates().replace()
                        );
                    } else {
                        annotation = parameterizedTestTemplate.apply(
                                new Cursor(getCursor(), annotation),
                                annotation.getCoordinates().replace(),
                                parameterizedTestAnnotationParameters.get(0)
                        );
                    }
                    if (!annotationComments.isEmpty()) {
                        annotation = annotation.withComments(annotationComments);
                    }
                }
                return annotation;
            }));

            // Add @MethodSource, insert test init statement, add test method parameters
            if (m.getLeadingAnnotations().stream().anyMatch(PARAMETERIZED_TEST::matches)) {
                m = methodSourceTemplate.apply(
                        updateCursor(m),
                        m.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))
                );
                assert m.getBody() != null;
                JavaCoordinates newStatementCoordinates = !m.getBody().getStatements().isEmpty() ? m.getBody().getStatements().get(0).getCoordinates().before() : m.getBody().getCoordinates().lastStatement();
                m = initMethodStatementTemplate.apply(updateCursor(m), newStatementCoordinates, initStatementParamString);
                m = maybeAutoFormat(m, m.withParameters(parameterizedTestMethodParameters), m.getName(), ctx, getCursor().getParentTreeCursor());
            }

            // Change constructor to test init method
            if (initMethodDeclarationTemplate == null && m.isConstructor()) {
                m = m.withName(m.getName().withSimpleName(initMethodName));
                m = maybeAutoFormat(m, m.withReturnTypeExpression(new J.Primitive(randomId(), Space.EMPTY, Markers.EMPTY, JavaType.Primitive.Void)),
                        m.getName(), ctx, getCursor().getParentTreeCursor());

                // converting a constructor to a void init method may require removing final modifiers from field vars.
                if (m.getBody() != null) {
                    Set<String> fieldNames = m.getBody().getStatements().stream()
                            .filter(J.Assignment.class::isInstance).map(J.Assignment.class::cast)
                            .map(it -> {
                                if (it.getVariable() instanceof J.FieldAccess) {
                                    return ((J.FieldAccess) it.getVariable()).getName().getSimpleName();
                                }
                                return it.getVariable() instanceof J.Identifier ? ((J.Identifier) it.getVariable()).getSimpleName() : null;
                            })
                            .collect(toSet());
                    getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).putMessage(""INIT_VARS"", fieldNames);

                    // Remove any potential super call
                    m = m.withBody(m.getBody().withStatements(ListUtils.mapFirst(m.getBody().getStatements(),
                            stmt -> stmt instanceof J.MethodInvocation &&
                                    ""super"".equals(((J.MethodInvocation) stmt).getSimpleName()) ?
                                    null : stmt)));
                }
            }
            return m;
        }
    }
}
",{}
"assertTrue(x instanceof y) to assertInstanceOf(y.class, x)","Migration of JUnit4 (or potentially JUnit5) test case in form of assertTrue(x instanceof y) to assertInstanceOf(y.class, x).",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypedTree;

public class AssertTrueInstanceofToAssertInstanceOf extends Recipe {
    @Override
    public String getDisplayName() {
        return ""assertTrue(x instanceof y) to assertInstanceOf(y.class, x)"";
    }

    @Override
    public String getDescription() {
        return ""Migration of JUnit4 (or potentially JUnit5) test case in form of assertTrue(x instanceof y) to assertInstanceOf(y.class, x)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                MethodMatcher junit5Matcher = new MethodMatcher(""org.junit.jupiter.api.Assertions assertTrue(boolean, ..)"");
                MethodMatcher junit4Matcher = new MethodMatcher(""org.junit.Assert assertTrue(.., boolean)"");

                TypedTree clazz;
                Expression expression;
                Expression reason;

                if (junit5Matcher.matches(mi)) {
                    maybeRemoveImport(""org.junit.jupiter.api.Assertions.assertTrue"");
                    Expression argument = mi.getArguments().get(0);
                    if (mi.getArguments().size() == 1) {
                        reason = null;
                    } else if (mi.getArguments().size() == 2) {
                        reason = mi.getArguments().get(1);
                    } else {
                        return mi;
                    }

                    if (argument instanceof J.InstanceOf) {
                        J.InstanceOf instanceOf = (J.InstanceOf) argument;
                        expression = instanceOf.getExpression();
                        clazz = (TypedTree) instanceOf.getClazz();
                    } else {
                        return mi;
                    }
                } else if (junit4Matcher.matches(mi)) {
                    maybeRemoveImport(""org.junit.Assert.assertTrue"");
                    Expression argument;
                    if (mi.getArguments().size() == 1) {
                        reason = null;
                        argument = mi.getArguments().get(0);
                    } else if (mi.getArguments().size() == 2) {
                        reason = mi.getArguments().get(0);
                        argument = mi.getArguments().get(1);
                    } else {
                        return mi;
                    }

                    if (argument instanceof J.InstanceOf) {
                        J.InstanceOf instanceOf = (J.InstanceOf) argument;
                        expression = instanceOf.getExpression();
                        clazz = (TypedTree) instanceOf.getClazz();
                    } else {
                        return mi;
                    }
                } else {
                    return mi;
                }


                JavaTemplate template = JavaTemplate
                    .builder(""assertInstanceOf(#{any(java.lang.Object)}.class, #{any(java.lang.Object)}"" + (reason != null ? "", #{any(java.lang.String)})"" : "")""))
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5"", ""junit-4""))
                    .staticImports(""org.junit.jupiter.api.Assertions.assertInstanceOf"")
                    .imports(String.valueOf(clazz.getType()))
                    .build();

                J rawClazz = clazz instanceof J.ParameterizedType ? ((J.ParameterizedType) clazz).getClazz() : clazz;
                J.MethodInvocation methodd = reason != null ?
                    template.apply(getCursor(), mi.getCoordinates().replace(), rawClazz, expression, reason) :
                    template.apply(getCursor(), mi.getCoordinates().replace(), rawClazz, expression);
                maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertInstanceOf"");
                return methodd;
            }
        };
    }
}
",{}
Migrate from JUnit 4 `@FixedMethodOrder` to JUnit 5 `@TestMethodOrder`,JUnit optionally allows test method execution order to be specified. This replaces JUnit 4 test execution ordering annotations with JUnit 5 replacements.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

import java.util.Set;

public class UseTestMethodOrder extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate from JUnit 4 `@FixedMethodOrder` to JUnit 5 `@TestMethodOrder`"";
    }

    @Override
    public String getDescription() {
        return ""JUnit optionally allows test method execution order to be specified. This replaces JUnit 4 test execution ordering annotations with JUnit 5 replacements."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.FixMethodOrder"", false), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = classDecl;

                //noinspection DataFlowIssue
                Set<J.Annotation> methodOrders = FindAnnotations.find(cd.withBody(null), ""@org.junit.FixMethodOrder"");

                if (!methodOrders.isEmpty()) {
                    maybeAddImport(""org.junit.jupiter.api.TestMethodOrder"");
                    maybeRemoveImport(""org.junit.FixMethodOrder"");
                    maybeRemoveImport(""org.junit.runners.MethodSorters"");

                    cd = JavaTemplate.builder(""@TestMethodOrder(MethodName.class)"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                            .imports(""org.junit.jupiter.api.TestMethodOrder"",
                                    ""org.junit.jupiter.api.MethodOrderer.*"")
                            .build()
                            .apply(getCursor(), methodOrders.iterator().next().getCoordinates().replace());
                    maybeAddImport(""org.junit.jupiter.api.MethodOrderer.MethodName"");
                }

                return super.visitClassDeclaration(cd, ctx);
            }
        });
    }
}
",{}
JUnit TestName @Rule to JUnit Jupiter TestInfo,Replace usages of JUnit 4's `@Rule TestName` with JUnit 5's TestInfo.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.List;

public class TestRuleToTestInfo extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit TestName @Rule to JUnit Jupiter TestInfo"";
    }

    @Override
    public String getDescription() {
        return ""Replace usages of JUnit 4's `@Rule TestName` with JUnit 5's TestInfo."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.rules.TestName"", false), new TestRuleToTestInfoVisitor());
    }

    private static class TestRuleToTestInfoVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final MethodMatcher TEST_NAME_GET_NAME = new MethodMatcher(""org.junit.rules.TestName getMethodName()"");
        private static final AnnotationMatcher RULE_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.Rule"");
        private static final AnnotationMatcher JUNIT_BEFORE_MATCHER = new AnnotationMatcher(""@org.junit.Before"");
        private static final AnnotationMatcher JUPITER_BEFORE_EACH_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.BeforeEach"");

        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            J.CompilationUnit compilationUnit = super.visitCompilationUnit(cu, ctx);
            maybeRemoveImport(""org.junit.Rule"");
            maybeRemoveImport(""org.junit.rules.TestName"");
            maybeAddImport(""org.junit.jupiter.api.TestInfo"");
            doAfterVisit(new JavaVisitor<ExecutionContext>() {
                @Override
                public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                    J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                    if (TEST_NAME_GET_NAME.matches(mi) && mi.getSelect() != null) {
                        return mi.getSelect().withPrefix(Space.format("" ""));
                    }
                    return mi;
                }
            });
            doAfterVisit(new ChangeType(""org.junit.rules.TestName"", ""java.lang.String"", true).getVisitor());
            doAfterVisit(new ChangeType(""org.junit.Before"", ""org.junit.jupiter.api.BeforeEach"", true).getVisitor());
            return compilationUnit;
        }

        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations varDecls = super.visitVariableDeclarations(multiVariable, ctx);
            if (varDecls.getType() != null && TypeUtils.isOfClassType(varDecls.getType(), ""org.junit.rules.TestName"")) {
                varDecls = varDecls.withLeadingAnnotations(ListUtils.map(varDecls.getLeadingAnnotations(), anno -> {
                    if (RULE_ANNOTATION_MATCHER.matches(anno)) {
                        return null;
                    }
                    return anno;
                }));
                getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).putMessage(""has-testName-rule"", varDecls);
            }
            return varDecls;
        }

        @Override
        public  J.@Nullable NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass nc = super.visitNewClass(newClass, ctx);
            if (TypeUtils.isOfClassType(nc.getType(), ""org.junit.rules.TestName"")) {
                //noinspection ConstantConditions
                return null;
            }
            return nc;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (md.getLeadingAnnotations().stream().anyMatch(anno -> JUNIT_BEFORE_MATCHER.matches(anno) || JUPITER_BEFORE_EACH_MATCHER.matches(anno))) {
                getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).putMessage(""before-method"", md);
            }
            return md;
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            J.VariableDeclarations varDecls = getCursor().pollMessage(""has-testName-rule"");
            J.MethodDeclaration beforeMethod = getCursor().pollMessage(""before-method"");
            if (varDecls != null) {
                String testMethodStatement = ""Optional<Method> testMethod = testInfo.getTestMethod();\n"" +
                                             ""if (testMethod.isPresent()) {\n"" +
                                             ""    this.#{} = testMethod.get().getName();\n"" +
                                             ""}"";
                if (beforeMethod == null) {
                    String t = ""@BeforeEach\n"" +
                               ""public void setup(TestInfo testInfo) {"" + testMethodStatement + ""}"";
                    cd = JavaTemplate.builder(t)
                            .contextSensitive()
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                            .imports(""org.junit.jupiter.api.TestInfo"",
                                    ""org.junit.jupiter.api.BeforeEach"",
                                    ""java.util.Optional"",
                                    ""java.lang.reflect.Method"")
                            .build()
                            .apply(
                                    updateCursor(cd),
                                    cd.getBody().getCoordinates().lastStatement(),
                                    varDecls.getVariables().get(0).getName().getSimpleName()
                            );
                    maybeAddImport(""java.lang.reflect.Method"");
                    maybeAddImport(""java.util.Optional"");
                    maybeAddImport(""org.junit.jupiter.api.BeforeEach"");
                } else {
                    doAfterVisit(new BeforeMethodToTestInfoVisitor(beforeMethod, varDecls, testMethodStatement));
                }
            }
            return cd;
        }
    }

    private static class BeforeMethodToTestInfoVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final J.MethodDeclaration beforeMethod;
        private final J.VariableDeclarations varDecls;
        private final String testMethodStatement;

        private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                return JavaParser.fromJavaVersion()
                        .classpathFromResources(ctx, ""junit-jupiter-api-5"");
        }

        public BeforeMethodToTestInfoVisitor(J.MethodDeclaration beforeMethod, J.VariableDeclarations varDecls, String testMethodStatement) {
            this.beforeMethod = beforeMethod;
            this.varDecls = varDecls;
            this.testMethodStatement = testMethodStatement;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (md.getId().equals(beforeMethod.getId())) {
                md = JavaTemplate.builder(""TestInfo testInfo"")
                        .contextSensitive()
                        .javaParser(javaParser(ctx))
                        .imports(""org.junit.jupiter.api.TestInfo"",
                                ""org.junit.jupiter.api.BeforeEach"",
                                ""java.util.Optional"",
                                ""java.lang.reflect.Method"")
                        .build()
                        .apply(updateCursor(md), md.getCoordinates().replaceParameters());

                //noinspection ConstantConditions
                md = maybeAutoFormat(
                        md,
                        JavaTemplate.builder(testMethodStatement)
                                .contextSensitive()
                                .javaParser(javaParser(ctx))
                                .imports(""org.junit.jupiter.api.TestInfo"",
                                        ""java.util.Optional"",
                                        ""java.lang.reflect.Method"")
                                .build()
                                .apply(
                                        updateCursor(md),
                                        md.getBody().getCoordinates().lastStatement(),
                                        varDecls.getVariables().get(0).getName().getSimpleName()),
                        ctx,
                        getCursor().getParent()
                );

                // Make sure the testName is initialized first in case any other piece of the method body references it
                assert md.getBody() != null;
                if (md.getBody().getStatements().size() > 2) {
                    List<Statement> statements = md.getBody().getStatements();
                    List<Statement> reorderedStatements = new ArrayList<>(statements.size());
                    reorderedStatements.addAll(statements.subList(statements.size() - 2, statements.size()));
                    reorderedStatements.addAll(statements.subList(0, statements.size() - 2));
                    md = md.withBody(md.getBody().withStatements(reorderedStatements));
                }
                maybeAddImport(""java.lang.reflect.Method"");
                maybeAddImport(""java.util.Optional"");
            }
            return md;
        }
    }
}
",{}
Use JUnit Jupiter `@TempDir`,Translates JUnit 4's `org.junit.rules.TemporaryFolder` into JUnit 5's `org.junit.jupiter.api.io.TempDir`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

public class TemporaryFolderToTempDir extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use JUnit Jupiter `@TempDir`"";
    }

    @Override
    public String getDescription() {
        return ""Translates JUnit 4's `org.junit.rules.TemporaryFolder` into JUnit 5's `org.junit.jupiter.api.io.TempDir`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.junit.rules.TemporaryFolder"", false),
                new TemporaryFolderToTempDirVisitor());
    }
}

class TemporaryFolderToTempDirVisitor extends JavaVisitor<ExecutionContext> {

    private static final String TEMPORARY_FOLDER = ""org.junit.rules.TemporaryFolder"";
    private static final String TEMP_DIR = ""org.junit.jupiter.api.io.TempDir"";
    private static final AnnotationMatcher CLASS_RULE = new AnnotationMatcher(""@org.junit.ClassRule"");
    private static final AnnotationMatcher RULE = new AnnotationMatcher(""@org.junit.Rule"");
    private static final MethodMatcher NEW_TEMPORARY_FOLDER = new MethodMatcher(TEMPORARY_FOLDER + ""<constructor>()"");
    private static final MethodMatcher NEW_TEMPORARY_FOLDER_WITH_ARG = new MethodMatcher(TEMPORARY_FOLDER + ""<constructor>(java.io.File)"");

    @Override
    public J visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
        J.CompilationUnit c = (J.CompilationUnit) super.visitCompilationUnit(cu, ctx);
        if (c != cu) {
            c = (J.CompilationUnit) new ChangeType(
                    ""org.junit.rules.TemporaryFolder"", ""java.io.File"", true).getVisitor()
                    .visit(c, ctx);
            maybeAddImport(""java.io.File"");
            maybeAddImport(""java.nio.file.Files"");
            maybeAddImport(""org.junit.jupiter.api.io.TempDir"");
            maybeRemoveImport(""org.junit.ClassRule"");
            maybeRemoveImport(""org.junit.Rule"");
            maybeRemoveImport(""org.junit.rules.TemporaryFolder"");
        }
        return c;
    }

    @Override
    public J visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
        J.VariableDeclarations mv = (J.VariableDeclarations) super.visitVariableDeclarations(multiVariable, ctx);
        if (!TypeUtils.isOfClassType(multiVariable.getTypeAsFullyQualified(), TEMPORARY_FOLDER)) {
            return mv;
        }
        mv = mv.withTypeExpression(toFileIdentifier(mv.getTypeExpression()));
        return (J.VariableDeclarations) new Annotated.Matcher(""@org.junit.*Rule"")
                .asVisitor(a -> JavaTemplate.builder(""@TempDir"")
                        .imports(TEMP_DIR)
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                        .build()
                        .apply(a.getCursor(), a.getTree().getCoordinates().replace()))
                .visitNonNull(mv, ctx, getCursor().getParentOrThrow());
    }

    @Override
    public @Nullable J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
        if (NEW_TEMPORARY_FOLDER.matches(newClass)) {
            return hasRuleAnnotation() ? null : JavaTemplate.builder(""Files.createTempDirectory(\""junit\"").toFile()"")
                    .imports(""java.nio.file.Files"")
                    .build()
                    .apply(getCursor(), newClass.getCoordinates().replace());
        }
        if (NEW_TEMPORARY_FOLDER_WITH_ARG.matches(newClass)) {
            return hasRuleAnnotation() ? null : JavaTemplate.builder(""Files.createTempDirectory(#{any(java.io.File)}.toPath(), \""junit\"").toFile()"")
                    .imports(""java.nio.file.Files"")
                    .build()
                    .apply(getCursor(), newClass.getCoordinates().replace(), newClass.getArguments().get(0));
        }
        return super.visitNewClass(newClass, ctx);
    }

    @Override
    public @Nullable J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
        J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
        updateCursor(mi);
        if (mi.getSelect() != null && mi.getMethodType() != null &&
                TypeUtils.isOfClassType(mi.getMethodType().getDeclaringType(), ""org.junit.rules.TemporaryFolder"")) {
            switch (mi.getSimpleName()) {
                case ""newFile"":
                    return convertToNewFile(mi, ctx);
                case ""newFolder"":
                    doAfterVisit(new AddNewFolderOrFileMethod(mi, FileOrFolder.FOLDER, getCursor().firstEnclosing(J.ClassDeclaration.class)));
                    break;
                case ""create"":
                    //noinspection ConstantConditions
                    return null;
                case ""getRoot"":
                    return mi.getSelect().withPrefix(mi.getPrefix());
                default:
                    return mi;
            }
        }
        return mi;
    }

    private J.Identifier toFileIdentifier(TypeTree typeTree) {
        JavaType.ShallowClass fileType = JavaType.ShallowClass.build(""java.io.File"");
        return new J.Identifier(randomId(), typeTree.getPrefix(), Markers.EMPTY, emptyList(), fileType.getClassName(), fileType, null);
    }

    private boolean hasRuleAnnotation() {
        J.VariableDeclarations vd = getCursor().firstEnclosing(J.VariableDeclarations.class);
        if (vd == null) {
            return false;
        }
        return vd.getLeadingAnnotations().stream().anyMatch(anno -> CLASS_RULE.matches(anno) || RULE.matches(anno));
    }

    private J convertToNewFile(J.MethodInvocation mi, ExecutionContext ctx) {
        if (mi.getSelect() == null) {
            return mi;
        }
        List<Expression> args = mi.getArguments().stream().filter(arg -> !(arg instanceof J.Empty)).collect(toList());
        if (args.isEmpty()) {
            J tempDir = mi.getSelect().withType(JavaType.ShallowClass.build(""java.io.File""));
            return JavaTemplate.builder(""File.createTempFile(\""junit\"", null, #{any(java.io.File)})"")
                    .imports(""java.io.File"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(getCursor(), mi.getCoordinates().replace(), tempDir);
        }
        doAfterVisit(new AddNewFolderOrFileMethod(mi, FileOrFolder.FILE, getCursor().firstEnclosing(J.ClassDeclaration.class)));
        return mi;
    }
}

@RequiredArgsConstructor
class AddNewFolderOrFileMethod extends JavaIsoVisitor<ExecutionContext> {
    private final J.MethodInvocation methodInvocation;
    private final FileOrFolder fileOrFolder;
    private final J.ClassDeclaration enclosingClass;

    private boolean hasClassType(Statement j, @Nullable String classType) {
        if (classType == null) {
            return false;
        }

        if (!(j instanceof J.VariableDeclarations)) {
            return false;
        }

        J.VariableDeclarations variable = (J.VariableDeclarations) j;

        if (variable.getTypeExpression() == null) {
            return false;
        }

        return TypeUtils.isOfClassType(variable.getTypeExpression().getType(), classType);
    }

    @Override
    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
        if (!cd.isScope(enclosingClass)) {
            return cd;
        }
        JavaType.Method newMethodDeclaration = getMethodDeclaration(cd, fileOrFolder).orElse(null);

        if (newMethodDeclaration == null) {
            cd = JavaTemplate.builder(fileOrFolder.template)
                    .contextSensitive()
                    .imports(""java.io.File"", ""java.io.IOException"")
                    .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(updateCursor(cd), cd.getBody().getCoordinates().lastStatement());
            newMethodDeclaration = ((J.MethodDeclaration) cd.getBody().getStatements().get(cd.getBody().getStatements().size() - 1)).getMethodType();
            maybeAddImport(""java.io.File"");
            maybeAddImport(""java.io.IOException"");
        }
        assert (newMethodDeclaration != null);
        doAfterVisit(new TranslateNewFolderOrFileMethodInvocation(methodInvocation, newMethodDeclaration, fileOrFolder));
        return cd;
    }

    private Optional<JavaType.Method> getMethodDeclaration(J.ClassDeclaration cd, FileOrFolder fileOrFolder) {
        return cd.getBody().getStatements().stream()
                .filter(J.MethodDeclaration.class::isInstance)
                .map(J.MethodDeclaration.class::cast)
                .filter(m -> {
                    List<Statement> params = m.getParameters();
                    return fileOrFolder.methodName.equals(m.getSimpleName()) &&
                            params.size() == 2 &&
                            hasClassType(params.get(0), ""java.io.File"") &&
                            hasClassType(params.get(1), ""java.lang.String"");
                }).map(J.MethodDeclaration::getMethodType).filter(Objects::nonNull).findAny();
    }
}

@RequiredArgsConstructor
class TranslateNewFolderOrFileMethodInvocation extends JavaVisitor<ExecutionContext> {
    final J.MethodInvocation methodScope;
    final JavaType.Method newMethodType;
    final FileOrFolder fileOrFolder;

    @Override
    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
        J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
        if (!mi.isScope(methodScope)) {
            return mi;
        }
        if (mi.getSelect() != null) {
            mi = fileOrFolder == FileOrFolder.FOLDER ? toNewFolder(mi, ctx) : toNewFile(mi, ctx);
            mi = mi.withMethodType(newMethodType);
            J.ClassDeclaration parentClass = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).getValue();
            mi = mi.withName(mi.getName().withType(parentClass.getType()));
        }
        return mi;
    }

    private J.MethodInvocation toNewFolder(J.MethodInvocation mi, ExecutionContext ctx) {
        J tempDir = mi.getSelect().withType(JavaType.ShallowClass.build(""java.io.File""));
        List<Expression> args = mi.getArguments().stream().filter(arg -> !(arg instanceof J.Empty)).collect(toList());
        if (args.isEmpty()) {
            return JavaTemplate.builder(""newFolder(#{any(java.io.File)}, \""junit\"")"")
                    .imports(""java.io.File"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(updateCursor(mi), mi.getCoordinates().replace(), tempDir);
        }

        if (args.size() == 1) {
            return JavaTemplate.builder(""newFolder(#{any(java.io.File)}, #{any(java.lang.String)})"")
                    .imports(""java.io.File"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .build()
                    .apply(
                            updateCursor(mi),
                            mi.getCoordinates().replace(),
                            tempDir,
                            args.get(0)
                    );
        }

        StringBuilder sb = new StringBuilder(""newFolder(#{any(java.io.File)}"");
        args.forEach(arg -> sb.append("", #{any(java.lang.String)}""));
        sb.append("")"");
        List<Object> templateArgs = new ArrayList<>(args);
        templateArgs.add(0, tempDir);
        return JavaTemplate.builder(sb.toString())
                .contextSensitive()
                .imports(""java.io.File"")
                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                .build()
                .apply(
                        updateCursor(mi),
                        mi.getCoordinates().replace(),
                        templateArgs.toArray()
                );
    }

    private J.MethodInvocation toNewFile(J.MethodInvocation mi, ExecutionContext ctx) {
        J tempDir = mi.getSelect().withType(JavaType.ShallowClass.build(""java.io.File""));
        List<Expression> args = mi.getArguments().stream().filter(arg -> !(arg instanceof J.Empty)).collect(toList());
        if (args.size() != 1) {
            return mi; // unexpected
        }
        return JavaTemplate.builder(""newFile(#{any(java.io.File)}, #{any(java.lang.String)})"")
                .imports(""java.io.File"")
                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                .build()
                .apply(updateCursor(mi), mi.getCoordinates().replace(), tempDir, args.get(0));
    }
}

@RequiredArgsConstructor
enum FileOrFolder {
    FILE(""newFile"", ""private static File newFile(File parent, String child) throws IOException {\n"" +
            ""    File result = new File(parent, child);\n"" +
            ""    result.createNewFile();\n"" +
            ""    return result;\n"" +
            ""}""),
    FOLDER(""newFolder"", ""private static File newFolder(File root, String... subDirs) throws IOException {\n"" +
            ""    String subFolder = String.join(\""/\"", subDirs);\n"" +
            ""    File result = new File(root, subFolder);\n"" +
            ""    if(!result.mkdirs()) {\n"" +
            ""        throw new IOException(\""Couldn't create folders \"" + root);\n"" +
            ""    }\n"" +
            ""    return result;\n"" +
            ""}"");

    final String methodName;
    final String template;
}
",{}
Migrate JUnit 4 `@Test` annotations to JUnit 5,Update usages of JUnit 4's `@org.junit.Test` annotation to JUnit 5's `org.junit.jupiter.api.Test` annotation.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindImports;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markup;
import org.openrewrite.staticanalysis.LambdaBlockToExpression;

import java.util.Comparator;
import java.util.List;
import java.util.Set;

import static java.util.Collections.emptyList;

public class UpdateTestAnnotation extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate JUnit 4 `@Test` annotations to JUnit 5"";
    }

    @Override
    public String getDescription() {
        return ""Update usages of JUnit 4's `@org.junit.Test` annotation to JUnit 5's `org.junit.jupiter.api.Test` annotation."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(""org.junit.Test"", false),
                new FindImports(""org.junit.Test"", null).getVisitor()
        ), new UpdateTestAnnotationVisitor());
    }

    private static class UpdateTestAnnotationVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final AnnotationMatcher JUNIT4_TEST = new AnnotationMatcher(""@org.junit.Test"");

        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            J.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
            Set<NameTree> nameTreeSet = c.findType(""org.junit.Test"");
            if (!nameTreeSet.isEmpty()) {
                // Update other references like `Test.class`.
                c = (J.CompilationUnit) new ChangeType(""org.junit.Test"", ""org.junit.jupiter.api.Test"", true)
                        .getVisitor().visitNonNull(c, ctx);
            }

            maybeRemoveImport(""org.junit.Test"");
            doAfterVisit(new JavaIsoVisitor<ExecutionContext>() {
                @Override
                public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                    J.CompilationUnit c = cu;
                    c = c.withClasses(ListUtils.map(c.getClasses(), clazz -> (J.ClassDeclaration) visit(clazz, ctx)));
                    // take one more pass over the imports now that we've had a chance to add warnings to all
                    // uses of @Test through the rest of the source file
                    return c.withImports(ListUtils.map(c.getImports(), anImport -> (J.Import) visit(anImport, ctx)));
                }

                @Override
                public J.Import visitImport(J.Import anImport, ExecutionContext ctx) {
                    if (""org.junit.Test"".equals(anImport.getTypeName())) {
                        return Markup.error(anImport, new IllegalStateException(""This import should have been removed by this recipe.""));
                    }
                    return anImport;
                }

                @Override
                public JavaType visitType(@Nullable JavaType javaType, ExecutionContext ctx) {
                    if (TypeUtils.isOfClassType(javaType, ""org.junit.Test"")) {
                        getCursor().putMessageOnFirstEnclosing(J.class, ""danglingTestRef"", true);
                    }
                    return javaType;
                }

                @Override
                public J postVisit(J tree, ExecutionContext ctx) {
                    if (getCursor().getMessage(""danglingTestRef"", false)) {
                        return Markup.warn(tree, new IllegalStateException(""This still has a type of `org.junit.Test`""));
                    }
                    return tree;
                }
            });
            return c;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            ChangeTestAnnotation cta = new ChangeTestAnnotation();
            J.MethodDeclaration m = (J.MethodDeclaration) cta.visitNonNull(method, ctx, getCursor().getParentOrThrow());
            if (m != method) {
                JavaParser.Builder<?, ?> javaParser = JavaParser.fromJavaVersion()
                        .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""apiguardian-api-1.1"");
                if (cta.expectedException != null) {
                    m = JavaTemplate.builder(""org.junit.jupiter.api.function.Executable o = () -> #{};"")
                            .javaParser(javaParser)
                            .build()
                            .apply(
                                    updateCursor(m),
                                    m.getCoordinates().replaceBody(),
                                    m.getBody()
                            );

                    assert m.getBody() != null;
                    J.Lambda lambda = (J.Lambda) ((J.VariableDeclarations) m.getBody().getStatements().get(0))
                            .getVariables().get(0).getInitializer();

                    assert lambda != null;

                    if (cta.expectedException instanceof J.FieldAccess &&
                        TypeUtils.isAssignableTo(""org.junit.Test$None"", ((J.FieldAccess) cta.expectedException).getTarget().getType())) {
                        m = JavaTemplate.builder(""assertDoesNotThrow(#{any(org.junit.jupiter.api.function.Executable)});"")
                                .javaParser(javaParser)
                                .staticImports(""org.junit.jupiter.api.Assertions.assertDoesNotThrow"")
                                .build()
                                .apply(updateCursor(m), m.getCoordinates().replaceBody(), lambda);
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertDoesNotThrow"");
                    } else {
                        m = JavaTemplate.builder(""assertThrows(#{any(java.lang.Class)}, #{any(org.junit.jupiter.api.function.Executable)});"")
                                .javaParser(javaParser)
                                .staticImports(""org.junit.jupiter.api.Assertions.assertThrows"")
                                .build()
                                .apply(updateCursor(m), m.getCoordinates().replaceBody(), cta.expectedException, lambda);
                        // Only remove the throws clause for the specific exception being tested
                        m = removeSpecificThrowsClause(m, cta.expectedException);
                        // Unconditionally add the import for assertThrows, got a report where the above template adds the method successfully
                        // but with missing type attribution for assertThrows so the import was missing
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertThrows"", false);
                    }
                }
                if (cta.timeout != null) {
                    m = JavaTemplate.builder(""@Timeout(value = #{any(long)}, unit = TimeUnit.MILLISECONDS)"")
                            .javaParser(javaParser)
                            .imports(""org.junit.jupiter.api.Timeout"", ""java.util.concurrent.TimeUnit"")
                            .build()
                            .apply(
                                    updateCursor(m),
                                    m.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)),
                                    cta.timeout
                            );
                    maybeAddImport(""org.junit.jupiter.api.Timeout"");
                    maybeAddImport(""java.util.concurrent.TimeUnit"");
                }
                maybeAddImport(""org.junit.jupiter.api.Test"");

                doAfterVisit(new LambdaBlockToExpression().getVisitor());
            }

            return super.visitMethodDeclaration(m, ctx);
        }

        private J.MethodDeclaration removeSpecificThrowsClause(J.MethodDeclaration method, Expression expectedException) {
            List<NameTree> thrown = method.getThrows();
            if (thrown == null || thrown.isEmpty()) {
                return method;
            }

            // Extract the exception type from the expected exception expression
            // This should always be a `J.FieldAccess` of the form MyException.class
            JavaType expectedType = null;
            if (expectedException instanceof J.FieldAccess) {
                J.FieldAccess fa = (J.FieldAccess) expectedException;
                expectedType = fa.getTarget().getType();
            }

            if (expectedType == null) {
                return method;
            }

            // Filter out only the exception that matches the expected exception
            final JavaType finalExpectedType = expectedType;
            List<NameTree> filteredThrows = ListUtils.map(thrown, throwClause -> {
                JavaType throwType = throwClause.getType();
                if (throwType != null && TypeUtils.isAssignableTo(finalExpectedType, throwType)) {
                    return null;
                }
                return throwClause;
            });

            // If all throws were removed, return empty list, otherwise keep the remaining ones
            if (filteredThrows.isEmpty() || filteredThrows.stream().allMatch(t -> t == null)) {
                return method.withThrows(emptyList());
            }

            return method.withThrows(filteredThrows);
        }

        private static class ChangeTestAnnotation extends JavaIsoVisitor<ExecutionContext> {
            @Nullable
            Expression expectedException;

            @Nullable
            Expression timeout;

            boolean found;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                   return JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""apiguardian-api-1.1"");
            }

            @Override
            public J.Annotation visitAnnotation(J.Annotation a, ExecutionContext ctx) {
                if (!found && JUNIT4_TEST.matches(a)) {
                    // While unlikely, it's possible that a method has an inner class/lambda/etc. with methods that have test annotations
                    // Avoid considering any but the first test annotation found
                    found = true;
                    if (a.getArguments() != null) {
                        for (Expression arg : a.getArguments()) {
                            if (!(arg instanceof J.Assignment)) {
                                continue;
                            }
                            J.Assignment assign = (J.Assignment) arg;
                            String assignParamName = ((J.Identifier) assign.getVariable()).getSimpleName();
                            Expression e = assign.getAssignment();
                            if (""expected"".equals(assignParamName)) {
                                expectedException = e;
                            } else if (""timeout"".equals(assignParamName)) {
                                timeout = e;
                            }
                        }
                    }

                    if (a.getAnnotationType() instanceof J.FieldAccess) {
                        a = JavaTemplate.builder(""@org.junit.jupiter.api.Test"")
                                .javaParser(javaParser(ctx))
                                .build()
                                .apply(getCursor(), a.getCoordinates().replace());
                    } else {
                        a = a.withArguments(null)
                                .withType(JavaType.ShallowClass.build(""org.junit.jupiter.api.Test""));
                    }
                }
                return a;
            }
        }
    }
}
",{}
Use wiremock extension,"As of 2.31.0, wiremock [supports JUnit 5](https://wiremock.org/docs/junit-jupiter/) via an extension.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.dependencies.UpgradeDependencyVersion;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class UseWiremockExtension extends Recipe {

    private static final MethodMatcher newWiremockRule = new MethodMatcher(""com.github.tomakehurst.wiremock.junit.WireMockRule <constructor>(..)"");

    @Override
    public String getDisplayName() {
        return ""Use wiremock extension"";
    }

    @Override
    public String getDescription() {
        return ""As of 2.31.0, wiremock [supports JUnit 5](https://wiremock.org/docs/junit-jupiter/) via an extension."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""com.github.tomakehurst.wiremock.junit.WireMockRule"", false), new JavaVisitor<ExecutionContext>() {

            @Override
            public J preVisit(J tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    doAfterVisit(new ChangeType(""com.github.tomakehurst.wiremock.junit.WireMockRule"",
                            ""com.github.tomakehurst.wiremock.junit5.WireMockExtension"", true).getVisitor());
                }
                return tree;
            }

            @SuppressWarnings(""ConcatenationWithEmptyString"")
            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J.NewClass n = (J.NewClass) super.visitNewClass(newClass, ctx);
                if (newWiremockRule.matches(n)) {
                    maybeAddImport(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"");
                    doAfterVisit(new ChangeType(""org.junit.Rule"", ""org.junit.jupiter.api.extension.RegisterExtension"", true)
                            .getVisitor());

                    Expression arg = n.getArguments().get(0);

                    JavaParser.Builder<?, ?> wiremockParser = JavaParser.fromJavaVersion()
                            .dependsOn(
                                    //language=java
                                    ""package com.github.tomakehurst.wiremock.junit5;"" +
                                            ""import com.github.tomakehurst.wiremock.core.Options;"" +
                                            ""public class WireMockExtension {"" +
                                            ""  public native static Builder newInstance();"" +
                                            ""  public static class Builder {"" +
                                            ""    public native Builder options(Options options);"" +
                                            ""    public native Builder failOnUnmatchedRequests(boolean failOnUnmatched);"" +
                                            ""    public native WireMockExtension build();"" +
                                            ""  }"" +
                                            ""}"",
                                    //language=java
                                    ""package com.github.tomakehurst.wiremock.core;"" +
                                            ""public class WireMockConfiguration implements Options {"" +
                                            ""  public static native WireMockConfiguration options();"" +
                                            ""  public native WireMockConfiguration port(int portNumber);"" +
                                            ""  public native WireMockConfiguration dynamicPort();"" +
                                            ""  public native WireMockConfiguration httpsPort(Integer httpsPort);"" +
                                            ""  public native WireMockConfiguration dynamicHttpsPort();"" +
                                            ""}"",
                                    //language=java
                                    ""package com.github.tomakehurst.wiremock.core;"" +
                                            ""public interface Options {}"");

                    if (arg instanceof J.Empty) {
                        String newWiremockExtension = ""WireMockExtension.newInstance().build()"";
                        return JavaTemplate.builder(newWiremockExtension)
                                .imports(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"")
                                .javaParser(wiremockParser)
                                .build()
                                .apply(getCursor(), n.getCoordinates().replace());
                    }
                    JavaType.Class optsType = JavaType.ShallowClass.build(""com.github.tomakehurst.wiremock.core.Options"");
                    if (TypeUtils.isAssignableTo(optsType, arg.getType())) {
                        String newWiremockExtension = ""WireMockExtension.newInstance()"" +
                                "".options(#{any(com.github.tomakehurst.wiremock.core.Options)})"";
                        if (n.getArguments().size() > 1) {
                            newWiremockExtension += "".failOnUnmatchedRequests(#{any(boolean)})"";
                            return JavaTemplate.builder(newWiremockExtension + "".build()"")
                                    .imports(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"")
                                    .javaParser(wiremockParser)
                                    .build()
                                    .apply(
                                            updateCursor(n),
                                            n.getCoordinates().replace(),
                                            arg,
                                            n.getArguments().get(1)
                                    );
                        }
                        return JavaTemplate.builder(newWiremockExtension + "".build()"")
                                .imports(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"")
                                .javaParser(wiremockParser)
                                .build()
                                .apply(updateCursor(n), n.getCoordinates().replace(), arg);
                    }
                    maybeAddImport(""com.github.tomakehurst.wiremock.core.WireMockConfiguration"");

                    String newWiremockExtension = ""WireMockExtension.newInstance().options(WireMockConfiguration.options().port(#{any(int)})"";
                    if (n.getArguments().size() > 1) {
                        newWiremockExtension += "".httpsPort(#{any(java.lang.Integer)})"";
                        return JavaTemplate.builder(newWiremockExtension + "").build()"")
                                .imports(""com.github.tomakehurst.wiremock.core.WireMockConfiguration"")
                                .imports(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"")
                                .javaParser(wiremockParser)
                                .build()
                                .apply(
                                        updateCursor(n),
                                        n.getCoordinates().replace(),
                                        arg,
                                        n.getArguments().get(1)
                                );
                    }
                    return JavaTemplate.builder(newWiremockExtension + "").build()"")
                            .imports(""com.github.tomakehurst.wiremock.core.WireMockConfiguration"")
                            .imports(""com.github.tomakehurst.wiremock.junit5.WireMockExtension"")
                            .javaParser(wiremockParser)
                            .build()
                            .apply(updateCursor(n), n.getCoordinates().replace(), arg);
                }

                return n;
            }
        });
    }

    @Override
    public List<Recipe> getRecipeList() {
        return singletonList(new UpgradeDependencyVersion(""com.github.tomakehurst"", ""wiremock*"",
                ""2.x"", null, true, emptyList()));
    }
}
",{}
"Add missing `@BeforeEach`, `@AfterEach`, `@Test` to overriding methods","Adds `@BeforeEach`, `@AfterEach`, `@Test` to methods overriding superclass methods if the annotations are present on the superclass method.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType.FullyQualified;
import org.openrewrite.java.tree.JavaType.Method;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.Comparator;
import java.util.Optional;
import java.util.function.Predicate;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddMissingTestBeforeAfterAnnotations extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add missing `@BeforeEach`, `@AfterEach`, `@Test` to overriding methods"";
    }

    @Override
    public String getDescription() {
        return ""Adds `@BeforeEach`, `@AfterEach`, `@Test` to methods overriding superclass methods if the annotations are present on the superclass method."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (classDecl.getExtends() != null) {
                    // Only classes that extend other classes can have override methods with missing annotations
                    return SearchResult.found(classDecl);
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }
        }, new AddMissingTestBeforeAfterAnnotationsVisitor());
    }

    private static class AddMissingTestBeforeAfterAnnotationsVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (!method.hasModifier(J.Modifier.Type.Static) && !method.isConstructor()) {
                Method currMethod = method.getMethodType();
                Optional<Method> superMethod = TypeUtils.findOverriddenMethod(currMethod);
                while (superMethod.isPresent()) {
                    method = maybeAddMissingAnnotation(method, superMethod.get(), LifecyleAnnotation.BEFORE_EACH, ctx);
                    method = maybeAddMissingAnnotation(method, superMethod.get(), LifecyleAnnotation.AFTER_EACH, ctx);
                    method = maybeAddMissingAnnotation(method, superMethod.get(), LifecyleAnnotation.TEST, ctx);
                    currMethod = superMethod.get();
                    superMethod = TypeUtils.findOverriddenMethod(currMethod);
                }
            }
            return super.visitMethodDeclaration(method, ctx);
        }

        private J.MethodDeclaration maybeAddMissingAnnotation(J.MethodDeclaration method, Method superMethod, LifecyleAnnotation la, ExecutionContext ctx) {
            if (la.needsAnnotation(method, superMethod)) {
                maybeAddImport(la.newAnnotation);
                return JavaTemplate.builder(la.newAnnotationSimple)
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                        .imports(la.newAnnotation)
                        .build()
                        .apply(getCursor(), method.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
            }
            return method;
        }
    }

    enum LifecyleAnnotation {
        BEFORE_EACH(""org.junit.Before"", ""org.junit.jupiter.api.BeforeEach""),
        AFTER_EACH(""org.junit.After"", ""org.junit.jupiter.api.AfterEach""),
        TEST(""org.junit.Test"", ""org.junit.jupiter.api.Test"");

        String newAnnotation;
        String newAnnotationSimple;
        private AnnotationMatcher newAnnotationMatcher;
        private Predicate<FullyQualified> newAnnotationPredicate;
        private Predicate<FullyQualified> oldAnnotationPredicate;

        LifecyleAnnotation(String oldAnnotation, String newAnnotation) {
            this.newAnnotation = newAnnotation;
            this.newAnnotationSimple = ""@"" + newAnnotation.substring(newAnnotation.lastIndexOf(""."") + 1);
            this.newAnnotationMatcher = new AnnotationMatcher(""@"" + newAnnotation);
            this.newAnnotationPredicate = n -> TypeUtils.isOfClassType(n, newAnnotation);
            this.oldAnnotationPredicate = n -> TypeUtils.isOfClassType(n, oldAnnotation);
        }

        boolean needsAnnotation(J.MethodDeclaration method, Method superMethod) {
            boolean superMethodHasAnnotation = superMethod.getAnnotations().stream().anyMatch(oldAnnotationPredicate.or(newAnnotationPredicate));
            return superMethodHasAnnotation && !method.getAllAnnotations().stream().anyMatch(newAnnotationMatcher::matches);
        }
    }
}
",{}
Make lifecycle methods non private,"Make JUnit 5's `@AfterAll`, `@AfterEach`, `@BeforeAll` and `@BeforeEach` non private.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.J.MethodDeclaration;
import org.openrewrite.java.tree.J.Modifier.Type;

import java.time.Duration;
import java.util.Arrays;
import java.util.List;

import static java.util.stream.Collectors.toList;

public class LifecycleNonPrivate extends Recipe {

    private static final List<String> ANNOTATION_TYPES = Arrays.asList(
            ""org.junit.jupiter.api.AfterAll"",
            ""org.junit.jupiter.api.AfterEach"",
            ""org.junit.jupiter.api.BeforeAll"",
            ""org.junit.jupiter.api.BeforeEach"");

    @SuppressWarnings(""unchecked"")
    private static final TreeVisitor<?, ExecutionContext> PRECONDITION =
            Preconditions.or(ANNOTATION_TYPES.stream().map(r -> new UsesType<>(r, false)).toArray(UsesType[]::new));

    @Override
    public String getDisplayName() {
        return ""Make lifecycle methods non private"";
    }

    @Override
    public String getDescription() {
        return ""Make JUnit 5's `@AfterAll`, `@AfterEach`, `@BeforeAll` and `@BeforeEach` non private."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(PRECONDITION, new LifecycleNonPrivateVisitor());
    }

    private static class LifecycleNonPrivateVisitor extends JavaIsoVisitor<ExecutionContext> {
        final List<AnnotationMatcher> lifeCycleAnnotationMatchers = ANNOTATION_TYPES.stream()
                .map(annoFqn -> ""@"" + annoFqn).map(AnnotationMatcher::new).collect(toList());

        @Override
        public J.MethodDeclaration visitMethodDeclaration(MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);

            if (J.Modifier.hasModifier(md.getModifiers(), Type.Private) &&
                    md.getLeadingAnnotations().stream().anyMatch(ann -> lifeCycleAnnotationMatchers.stream()
                    .anyMatch(matcher -> matcher.matches(ann)))) {
                return maybeAutoFormat(md,
                        md.withModifiers(ListUtils.map(md.getModifiers(),
                                modifier -> modifier.getType() == Type.Private ? null : modifier)),
                        ctx, getCursor().getParentOrThrow());
            }
            return md;
        }
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

}
",{}
Replace `@CsvSource` with `@ValueSource` for single method arguments,Replaces JUnit 5's `@CsvSource` annotation with `@ValueSource` when the parameterized test has only a single method argument.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.trait.Literal;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;
import java.util.Optional;

import static org.openrewrite.java.tree.JavaType.Primitive;

public class CsvSourceToValueSource extends Recipe {
    private static final AnnotationMatcher CSV_SOURCE_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.params.provider.CsvSource"");
    private static final AnnotationMatcher VALUE_SOURCE_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.params.provider.ValueSource"");

    @Override
    public String getDisplayName() {
        return ""Replace `@CsvSource` with `@ValueSource` for single method arguments"";
    }

    @Override
    public String getDescription() {
        return ""Replaces JUnit 5's `@CsvSource` annotation with `@ValueSource` when the parameterized test has only a single method argument."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.junit.jupiter.params.provider.CsvSource"", false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                        // Check if method has exactly one parameter
                        if (m.getParameters().size() != 1 || m.getParameters().get(0) instanceof J.Empty) {
                            return m;
                        }

                        // Check if parameter is ArgumentsAccessor or uses @AggregateWith or similar meta annotations
                        J.VariableDeclarations param = (J.VariableDeclarations) m.getParameters().get(0);
                        if (TypeUtils.isAssignableTo(""org.junit.jupiter.params.aggregator.ArgumentsAccessor"", param.getType()) ||
                                !param.getLeadingAnnotations().isEmpty()) {
                            return m;
                        }

                        // Find @CsvSource annotation
                        for (J.Annotation annotation : m.getLeadingAnnotations()) {
                            Optional<Annotated> annotated = new Annotated.Matcher(CSV_SOURCE_MATCHER).get(annotation, getCursor());
                            if (annotated.isPresent() && annotation.getArguments() != null && annotation.getArguments().size() == 1) {
                                // Get the parameter type
                                String paramType = getParameterType((J.VariableDeclarations) m.getParameters().get(0));
                                if (paramType == null) {
                                    return m;
                                }

                                // For Strings, merely swap out the annotation
                                if (""String"".equals(paramType)) {
                                    maybeRemoveImport(""org.junit.jupiter.params.provider.CsvSource"");
                                    maybeAddImport(""org.junit.jupiter.params.provider.ValueSource"");
                                    Expression templateArg = annotation.getArguments().get(0) instanceof J.Assignment ?
                                            ((J.Assignment) annotation.getArguments().get(0)).getAssignment() :
                                            annotation.getArguments().get(0);
                                    J.MethodDeclaration updated = JavaTemplate.builder(""@ValueSource(strings = {})"")
                                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-params-5""))
                                            .imports(""org.junit.jupiter.params.provider.ValueSource"")
                                            .build()
                                            .apply(getCursor(), annotation.getCoordinates().replace());
                                    // Retain formatting by swapping in the original argument
                                    return updated.withLeadingAnnotations(ListUtils.map(updated.getLeadingAnnotations(), ann ->
                                            VALUE_SOURCE_MATCHER.matches(ann) ?
                                                    ann.withArguments(ListUtils.map(ann.getArguments(),
                                                            arg -> ((J.Assignment) arg).withAssignment(templateArg.withPrefix(Space.SINGLE_SPACE)))) :
                                                    ann));
                                }

                                Optional<Literal> valueAttribute = annotated.get().getDefaultAttribute(""value"");
                                if (!valueAttribute.isPresent()) {
                                    return m;
                                }
                                List<String> values = valueAttribute.get().getStrings();
                                // Extract values from CsvSource
                                if (values.isEmpty()) {
                                    return m;
                                }

                                // Build a new ValueSource annotation
                                String valueSourceAnnotationTemplate = buildValueSourceAnnotation(paramType, values);
                                if (valueSourceAnnotationTemplate == null) {
                                    return m;
                                }

                                // Replace the annotation
                                maybeRemoveImport(""org.junit.jupiter.params.provider.CsvSource"");
                                maybeAddImport(""org.junit.jupiter.params.provider.ValueSource"");
                                return JavaTemplate.builder(valueSourceAnnotationTemplate)
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-params-5""))
                                        .imports(""org.junit.jupiter.params.provider.ValueSource"")
                                        .build()
                                        .apply(getCursor(), annotation.getCoordinates().replace());
                            }
                        }

                        return m;
                    }

                    private @Nullable String buildValueSourceAnnotation(String paramType, List<String> values) {
                        String attributeName;
                        String formattedValues;

                        switch (paramType) {
                            case ""int"":
                            case ""Integer"":
                                attributeName = ""ints"";
                                formattedValues = format(values);
                                break;
                            case ""long"":
                            case ""Long"":
                                attributeName = ""longs"";
                                formattedValues = formatLongValues(values);
                                break;
                            case ""double"":
                            case ""Double"":
                                attributeName = ""doubles"";
                                formattedValues = format(values);
                                break;
                            case ""float"":
                            case ""Float"":
                                attributeName = ""floats"";
                                formattedValues = formatFloatValues(values);
                                break;
                            case ""boolean"":
                            case ""Boolean"":
                                attributeName = ""booleans"";
                                formattedValues = format(values);
                                break;
                            case ""char"":
                            case ""Character"":
                                attributeName = ""chars"";
                                formattedValues = formatCharValues(values);
                                break;
                            case ""byte"":
                            case ""Byte"":
                                attributeName = ""bytes"";
                                formattedValues = format(values);
                                break;
                            case ""short"":
                            case ""Short"":
                                attributeName = ""shorts"";
                                formattedValues = format(values);
                                break;
                            default:
                                return null;
                        }

                        if (values.size() == 1) {
                            return ""@ValueSource("" + attributeName + "" = "" + formattedValues + "")"";
                        }
                        return ""@ValueSource("" + attributeName + "" = {"" + formattedValues + ""})"";
                    }

                    private String format(List<String> values) {
                        return String.join("", "", values.stream()
                                .map(String::trim)
                                .toArray(String[]::new));
                    }

                    private String formatLongValues(List<String> values) {
                        return String.join("", "", values.stream()
                                .map(v -> v.trim().endsWith(""L"") || v.trim().endsWith(""l"") ? v.trim() : v.trim() + ""L"")
                                .toArray(String[]::new));
                    }

                    private String formatFloatValues(List<String> values) {
                        return String.join("", "", values.stream()
                                .map(v -> v.trim().endsWith(""f"") || v.trim().endsWith(""F"") ? v.trim() : v.trim() + ""f"")
                                .toArray(String[]::new));
                    }

                    private String formatCharValues(List<String> values) {
                        return String.join("", "", values.stream()
                                .map(v -> ""'"" + v.trim() + ""'"")
                                .toArray(String[]::new));
                    }

                    private @Nullable String getParameterType(J.VariableDeclarations param) {
                        if (param.getType() == null) {
                            return null;
                        }
                        if (param.getTypeAsFullyQualified() != null) {
                            // Boxed primitive types
                            return param.getTypeAsFullyQualified().getClassName();
                        }
                        if (param.getType() instanceof Primitive) {
                            Primitive primitive = (Primitive) param.getType();
                            switch (primitive) {
                                case Boolean:
                                    return ""boolean"";
                                case Byte:
                                    return ""byte"";
                                case Char:
                                    return ""char"";
                                case Double:
                                    return ""double"";
                                case Float:
                                    return ""float"";
                                case Int:
                                    return ""int"";
                                case Long:
                                    return ""long"";
                                case Short:
                                    return ""short"";
                            }
                        }

                        return null;
                    }
                });
    }

}
",{}
Add Hamcrest JUnit dependency,Add Hamcrest JUnit dependency only if JUnit 4's `assertThat` or `assumeThat` is used.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.dependencies.AddDependency;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;

import java.util.concurrent.atomic.AtomicBoolean;

public class AddHamcrestJUnitDependency extends ScanningRecipe<AtomicBoolean> {

    @Override
    public String getDisplayName() {
        return ""Add Hamcrest JUnit dependency"";
    }

    @Override
    public String getDescription() {
        return ""Add Hamcrest JUnit dependency only if JUnit 4's `assertThat` or `assumeThat` is used."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        // No need to scan for AddDependency, as we'll unconditionally add the dependency if we find a match below
        MethodMatcher methodMatcher = new MethodMatcher(""org.junit.Ass* *That(..)"");
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof JavaSourceFile && !acc.get()) {
                    for (JavaType.Method type : ((JavaSourceFile) tree).getTypesInUse().getUsedMethods()) {
                        if (methodMatcher.matches(type)) {
                            acc.set(true);
                        }
                    }
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        if (acc.get()) {
            // We can unconditionally add the dependency here
            return new AddDependency(
                    ""org.hamcrest"",
                    ""hamcrest-junit"",
                    ""2.x"",
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    ""test"",
                    null,
                    null,
                    null,
                    true
            ).getVisitor();
        }
        return TreeVisitor.noop();
    }
}
",{}
JUnit 4 `MockitoJUnit` to JUnit Jupiter `MockitoExtension`,Replaces `MockitoJUnit` rules with `MockitoExtension`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.format.AutoFormatVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.FindFieldsOfType;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.toList;

/**
 * Replaces JUnit 4 MockitoJUnit rules with JUnit MockitoExtension.
 * <p>
 * Supported MockitoJUnit methods:
 * #rule()
 * #testRule()
 * <p>
 * Does not currently support @Incubating MockitoJUnit.collector().
 *
 * @implNote collector() is designed to aggregate multiple verifications into a single output.
 * Refactoring the method may be fairly complex and would likely benefit from being a separate recipe.
 * <p>
 * Must be run in the JUnit 5 suite.
 */
public class MockitoJUnitToMockitoExtension extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `MockitoJUnit` to JUnit Jupiter `MockitoExtension`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `MockitoJUnit` rules with `MockitoExtension`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                        new UsesType<>(""org.mockito.junit.MockitoTestRule"", false),
                        new UsesType<>(""org.mockito.junit.MockitoRule"", false)
                ),
                new MockitoRuleToMockitoExtensionVisitor());
    }

    public static class MockitoRuleToMockitoExtensionVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final String MOCKITO_RULE_INVOCATION_KEY = ""mockitoRuleInvocation"";
        private static final String MOCKITO_TEST_RULE_INVOCATION_KEY = ""mockitoTestRuleInvocation"";
        private static final String STRICTNESS_KEY = ""strictness"";

        private static final String EXTEND_WITH_MOCKITO_EXTENSION = ""@org.junit.jupiter.api.extension.ExtendWith(org.mockito.junit.jupiter.MockitoExtension.class)"";
        private static final String RUN_WITH_MOCKITO_JUNIT_RUNNER = ""@org.junit.runner.RunWith(org.mockito.runners.MockitoJUnitRunner.class)"";

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            Set<J.VariableDeclarations> mockitoFields = FindFieldsOfType.find(cd, ""org.mockito.junit.MockitoRule"");
            mockitoFields.addAll(FindFieldsOfType.find(cd, ""org.mockito.junit.MockitoTestRule""));

            if (!mockitoFields.isEmpty()) {
                List<Statement> statements = new ArrayList<>(cd.getBody().getStatements());
                statements.removeAll(mockitoFields);
                cd = cd.withBody(cd.getBody().withStatements(statements));

                maybeRemoveImport(""org.mockito.junit.MockitoRule"");
                maybeRemoveImport(""org.mockito.junit.MockitoTestRule"");

                maybeRemoveImport(""org.junit.Rule"");
                maybeRemoveImport(""org.mockito.junit.MockitoJUnit"");
                maybeRemoveImport(""org.mockito.quality.Strictness"");

                //noinspection DataFlowIssue
                if (classDecl.getBody().getStatements().size() != cd.getBody().getStatements().size() &&
                    (FindAnnotations.find(classDecl.withBody(null), RUN_WITH_MOCKITO_JUNIT_RUNNER).isEmpty() &&
                     FindAnnotations.find(classDecl.withBody(null), EXTEND_WITH_MOCKITO_EXTENSION).isEmpty())) {
                    String strictness = getCursor().pollMessage(STRICTNESS_KEY);

                    cd = JavaTemplate.builder(""@ExtendWith(MockitoExtension.class)"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""mockito-junit-jupiter-3.12""))
                            .imports(""org.junit.jupiter.api.extension.ExtendWith"", ""org.mockito.junit.jupiter.MockitoExtension"")
                            .build()
                            .apply(updateCursor(cd), cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));

                    maybeAddImport(""org.junit.jupiter.api.extension.ExtendWith"");
                    maybeAddImport(""org.mockito.junit.jupiter.MockitoExtension"");

                    if (strictness == null) {
                        // As we are in a Rule, and rules where always warn by default,
                        // we cannot use junit5 Strictness.STRICT_STUBS during migration
                        strictness = ""Strictness.WARN"";
                    }
                    if (!strictness.contains(""STRICT_STUBS"")) {
                        cd = JavaTemplate.builder(""@MockitoSettings(strictness = "" + strictness + "")"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""mockito-junit-jupiter-3.12"", ""mockito-core-3.12""))
                                .imports(""org.mockito.junit.jupiter.MockitoSettings"", ""org.mockito.quality.Strictness"")
                                .build()
                                .apply(updateCursor(cd), cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                        maybeAddImport(""org.mockito.junit.jupiter.MockitoSettings"");
                        maybeAddImport(""org.mockito.quality.Strictness"");
                    }
                }
            }

            return cd;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (method.getMethodType() != null) {
                String key = null;
                if (TypeUtils.isOfClassType(method.getMethodType().getDeclaringType(), ""org.mockito.junit.MockitoRule"")) {
                    key = MOCKITO_RULE_INVOCATION_KEY;
                } else if (TypeUtils.isOfClassType(method.getMethodType().getDeclaringType(), ""org.mockito.junit.MockitoTestRule"")) {
                    key = MOCKITO_TEST_RULE_INVOCATION_KEY;
                }
                if (key != null) {
                    getCursor().putMessageOnFirstEnclosing(J.MethodDeclaration.class, key, method);
                    String strictness = null;
                    switch (method.getSimpleName()) {
                        case ""strictness"":
                            strictness = method.getArguments().get(0).toString();
                            break;
                        case ""silent"":
                            strictness = ""Strictness.LENIENT"";
                            break;
                    }
                    if (strictness != null) {
                        strictness = strictness.startsWith(""Strictness."") ? strictness : ""Strictness."" + strictness;
                        getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, STRICTNESS_KEY, strictness);
                    }
                }
            }

            return method;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(methodDecl, ctx);

            final J.MethodInvocation mockitoRuleInvocation = getCursor().pollMessage(MOCKITO_RULE_INVOCATION_KEY);
            final J.MethodInvocation mockitoTestRuleInvocation = getCursor().pollMessage(MOCKITO_TEST_RULE_INVOCATION_KEY);

            if ((mockitoRuleInvocation != null || mockitoTestRuleInvocation != null) && m.getBody() != null) {
                final List<Statement> filteredStatements = m.getBody().getStatements().stream()
                        .filter(it -> !isTargetMethodInvocation(it))
                        .collect(toList());

                m = m.withBody((J.Block) new AutoFormatVisitor<ExecutionContext>()
                        .visit(m.getBody().withStatements(filteredStatements), ctx, getCursor()));
            }

            return m;
        }

        private static boolean isTargetMethodInvocation(Statement statement) {
            if (!(statement instanceof J.MethodInvocation)) {
                return false;
            }
            final J.MethodInvocation m = (J.MethodInvocation) statement;
            if (m.getMethodType() == null) {
                return false;
            }

            return TypeUtils.isOfClassType(m.getMethodType().getDeclaringType(), ""org.mockito.junit.MockitoRule"") ||
                   TypeUtils.isOfClassType(m.getMethodType().getDeclaringType(), ""org.mockito.junit.MockitoTestRule"");
        }

    }
}
",{}
JUnit 4 `Assert` To JUnit Jupiter `Assertions`,Change JUnit 4's `org.junit.Assert` into JUnit Jupiter's `org.junit.jupiter.api.Assertions`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.ChangeMethodTargetToStatic;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static java.util.Collections.emptyList;

public class AssertToAssertions extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `Assert` To JUnit Jupiter `Assertions`"";
    }

    @Override
    public String getDescription() {
        return ""Change JUnit 4's `org.junit.Assert` into JUnit Jupiter's `org.junit.jupiter.api.Assertions`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.Assert"", false), new AssertToAssertionsVisitor());
    }

    public static class AssertToAssertionsVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType ASSERTION_TYPE = JavaType.buildType(""org.junit.Assert"");

        private static final List<String> JUNIT_ASSERT_METHOD_NAMES = Arrays.asList(
                ""assertArrayEquals"", ""assertEquals"", ""assertFalse"", ""assertNotEquals"", ""assertNotNull"", ""assertNotSame"",
                ""assertNull"", ""assertSame"", ""assertThrows"", ""assertTrue"", ""fail"");

        @Override
        public @Nullable J preVisit(J tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile c = (JavaSourceFile) tree;
                boolean hasWildcardAssertImport = false;
                for (J.Import imp : c.getImports()) {
                    if (""org.junit.Assert.*"".equals(imp.getQualid().toString())) {
                        hasWildcardAssertImport = true;
                        break;
                    }
                }
                if (hasWildcardAssertImport) {
                    maybeAddImport(""org.junit.jupiter.api.Assertions"", ""*"", false);
                    maybeRemoveImport(""org.junit.Assert.*"");
                }
            }
            return tree;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (!isJunitAssertMethod(m)) {
                return m;
            }
            doAfterVisit(new ChangeMethodTargetToStatic(""org.junit.Assert "" + m.getSimpleName() + ""(..)"",
                    ""org.junit.jupiter.api.Assertions"", null, null, true)
                    .getVisitor());

            List<JRightPadded<Expression>> args = m.getPadding().getArguments().getPadding().getElements();
            Expression firstArg = args.get(0).getElement();
            // Suppress arg-switching for Assertions.assertEquals(String, String)
            if (args.size() == 2) {
                if (""assertSame"".equals(m.getSimpleName()) ||
                    ""assertNotSame"".equals(m.getSimpleName()) ||
                    ""assertEquals"".equals(m.getSimpleName()) ||
                    ""assertNotEquals"".equals(m.getSimpleName())) {
                    return m;
                }
            }
            if (""fail"".equals(m.getSimpleName())) {
                return m;
            }

            if (TypeUtils.isString(firstArg.getType())) {
                // Move the first arg to be the last argument

                List<JRightPadded<Expression>> newArgs = new ArrayList<>(args);
                JRightPadded<Expression> first = newArgs.remove(0);
                JRightPadded<Expression> lastArg = args.get(args.size() - 1);
                boolean lastArgComments = !lastArg.getAfter().getComments().isEmpty();

                newArgs = ListUtils.mapFirst(newArgs, e -> e.withElement(e.getElement().withPrefix(first.getElement().getPrefix())));
                newArgs = ListUtils.mapLast(newArgs, e -> e.withAfter(Space.EMPTY));
                newArgs.add(first
                        .withElement(first.getElement()
                                .withPrefix(lastArgComments ?
                                        lastArg.getAfter().withComments(ListUtils.mapLast(
                                                lastArg.getAfter().getComments(),
                                                c -> c.withSuffix(lastArg.getElement().getPrefix().getWhitespace()))
                                        ) :
                                        lastArg.getElement().getPrefix()
                                )
                        )
                        .withAfter(lastArgComments ? Space.build(lastArg.getAfter().getLastWhitespace(), emptyList()) : lastArg.getAfter())
                );

                m = m.getPadding().withArguments(
                        m.getPadding().getArguments().getPadding().withElements(newArgs)
                );
            }

            return m;
        }

        private static boolean isJunitAssertMethod(J.MethodInvocation method) {
            if (method.getMethodType() != null && TypeUtils.isOfType(ASSERTION_TYPE, method.getMethodType().getDeclaringType())) {
                return !""assertThat"".equals(method.getSimpleName());
            }
            if (method.getMethodType() == null && JUNIT_ASSERT_METHOD_NAMES.contains(method.getSimpleName())) {
                return true;
            }
            if (!(method.getSelect() instanceof J.Identifier)) {
                return false;
            }
            J.Identifier receiver = (J.Identifier) method.getSelect();
            if (!(receiver.getType() instanceof JavaType.FullyQualified)) {
                return false;
            }
            JavaType.FullyQualified receiverType = (JavaType.FullyQualified) receiver.getType();
            return ""org.junit.Assert"".equals(receiverType.getFullyQualifiedName());
        }
    }
}
",{}
Use JUnit5's `assertSame` or `assertNotSame` instead of `assertTrue(... == ...)`,Prefers the usage of `assertSame` or `assertNotSame` methods instead of using of vanilla `assertTrue` ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.ArrayList;
import java.util.List;

public class UseAssertSame extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use JUnit5's `assertSame` or `assertNotSame` instead of `assertTrue(... == ...)`"";
    }

    @Override
    public String getDescription() {
        return ""Prefers the usage of `assertSame` or `assertNotSame` methods instead of using of vanilla `assertTrue` "" +
               ""or `assertFalse` with a boolean comparison."";
    }

    private static final MethodMatcher ASSERT_TRUE_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertTrue(..)"");
    private static final MethodMatcher ASSERT_FALSE_MATCHER = new MethodMatcher(""org.junit.jupiter.api.Assertions assertFalse(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaIsoVisitor<ExecutionContext> visitor = new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(methodInvocation, ctx);
                if (!ASSERT_TRUE_MATCHER.matches(mi) && !ASSERT_FALSE_MATCHER.matches(mi)) {
                    return mi;
                }
                if (mi.getMethodType() == null) {
                    return mi;
                }

                Expression firstArgument = mi.getArguments().get(0);
                if (!(firstArgument instanceof J.Binary)) {
                    return mi;
                }
                J.Binary binary = (J.Binary) firstArgument;
                if (binary.getOperator() != J.Binary.Type.Equal && binary.getOperator() != J.Binary.Type.NotEqual) {
                    return mi;
                }
                List<Expression> newArguments = new ArrayList<>();
                newArguments.add(binary.getLeft());
                newArguments.add(binary.getRight());
                newArguments.addAll(mi.getArguments().subList(1, mi.getArguments().size()));

                String newMethodName = binary.getOperator() == J.Binary.Type.Equal == ASSERT_TRUE_MATCHER.matches(mi) ?
                        ""assertSame"" : ""assertNotSame"";

                maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                maybeAddImport(""org.junit.jupiter.api.Assertions"", newMethodName);

                JavaType.Method newType = assertSameMethodType(mi, newMethodName);
                return mi.withName(mi.getName().withSimpleName(newMethodName).withType(newType))
                        .withMethodType(newType)
                        .withArguments(newArguments);
            }

            private JavaType.Method assertSameMethodType(J.MethodInvocation mi, String newMethodName) {
                JavaType.Method assertTrue = mi.getMethodType();
                assert assertTrue != null;
                int parameterCount = assertTrue.getParameterTypes().size();
                JavaType.FullyQualified assertions = assertTrue.getDeclaringType();
                for (JavaType.Method method : assertions.getMethods()) {
                    if (""assertSame"".equals(method.getName()) && method.getParameterNames().size() == parameterCount + 1 &&
                        assertTrue.getParameterTypes().get(parameterCount - 1).equals(method.getParameterTypes().get(parameterCount))) {
                        return method;
                    }
                }
                // fallback when type attribution was stubbed
                return assertTrue.withName(newMethodName);
            }
        };
        return Preconditions.check(
                Preconditions.or(
                        new UsesMethod<>(ASSERT_TRUE_MATCHER),
                        new UsesMethod<>(ASSERT_FALSE_MATCHER)),
                visitor);
    }

}
",{}
JUnit 4 `@Category` to JUnit Jupiter `@Tag`,"Transforms the JUnit 4 `@Category`, which can list multiple categories, into one `@Tag` annotation per category listed.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.Set;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

public class CategoryToTag extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `@Category` to JUnit Jupiter `@Tag`"";
    }

    @Override
    public String getDescription() {
        return ""Transforms the JUnit 4 `@Category`, which can list multiple categories, into one `@Tag` annotation per category listed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.experimental.categories.Category"", false), new CategoryToTagVisitor());
    }

    public static class CategoryToTagVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.Class tagType = JavaType.ShallowClass.build(""org.junit.jupiter.api.Tag"");

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            Set<J.Annotation> categoryAnnotations = FindAnnotations.find(cd, ""@"" + ""org.junit.experimental.categories.Category"");
            if (!categoryAnnotations.isEmpty()) {
                cd = cd.withLeadingAnnotations(cd.getLeadingAnnotations().stream()
                        .flatMap(this::categoryAnnotationToTagAnnotations)
                        .collect(toList()));
                maybeRemoveImport(""org.junit.experimental.categories.Category"");
                maybeAddImport(tagType);
            }
            return maybeAutoFormat(classDecl, cd, cd.getName(), ctx, getCursor().getParentTreeCursor());
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            Set<J.Annotation> categoryAnnotations = FindAnnotations.find(m, ""@"" + ""org.junit.experimental.categories.Category"");
            if (!categoryAnnotations.isEmpty()) {
                m = m.withLeadingAnnotations(m.getLeadingAnnotations().stream()
                        .flatMap(this::categoryAnnotationToTagAnnotations)
                        .collect(toList()));

                maybeRemoveImport(""org.junit.experimental.categories.Category"");
                maybeAddImport(tagType);
            }
            return maybeAutoFormat(method, m, m.getName(), ctx, getCursor().getParentTreeCursor());
        }

        private Stream<J.Annotation> categoryAnnotationToTagAnnotations(J.Annotation maybeCategory) {
            if (maybeCategory.getArguments() != null && TypeUtils.isOfClassType(maybeCategory.getAnnotationType().getType(), ""org.junit.experimental.categories.Category"")) {
                Expression annotationArgument = maybeCategory.getArguments().iterator().next();
                if (annotationArgument instanceof J.Assignment) {
                    annotationArgument = ((J.Assignment) annotationArgument).getAssignment();
                }

                Stream<J.FieldAccess> categories = Stream.empty();
                if (annotationArgument instanceof J.NewArray) {
                    J.NewArray argArray = (J.NewArray) annotationArgument;
                    if (argArray.getInitializer() != null) {
                        categories = argArray.getInitializer().stream()
                                .map(J.FieldAccess.class::cast);
                    }
                }
                if (annotationArgument instanceof J.FieldAccess) {
                    categories = Stream.of((J.FieldAccess) annotationArgument);
                }
                return categories.map(category -> {
                    String targetName = convertToTagName(category);
                    J.Annotation tagAnnotation = new J.Annotation(
                            randomId(),
                            Space.EMPTY,
                            Markers.EMPTY,
                            new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), tagType.getClassName(), tagType, null),
                            JContainer.build(Space.EMPTY,
                                    singletonList(
                                            new JRightPadded<>(
                                                    new J.Literal(
                                                            randomId(),
                                                            Space.EMPTY,
                                                            Markers.EMPTY,
                                                            targetName,
                                                            ""\"""" + targetName + ""\"""",
                                                            null,
                                                            JavaType.Primitive.String
                                                    ),
                                                    Space.EMPTY,
                                                    Markers.EMPTY
                                            )
                                    ),
                                    Markers.EMPTY
                            )
                    );
                    maybeRemoveImport(TypeUtils.asFullyQualified(category.getTarget().getType()));
                    return tagAnnotation;
                });
            }
            return Stream.of(maybeCategory);
        }

        private static String convertToTagName(J.FieldAccess category) {
            if (category.getTarget() instanceof J.Identifier) {
                return ((J.Identifier) category.getTarget()).getSimpleName();
            }
            if (category.getTarget() instanceof J.FieldAccess) {
                return ((J.FieldAccess) category.getTarget()).getSimpleName();
            }
            return category.getTarget().toString();
        }
    }
}
",{}
Cleanup JUnit imports,Removes unused `org.junit` import symbols.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

public class CleanupJUnitImports extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Cleanup JUnit imports"";
    }

    @Override
    public String getDescription() {
        return ""Removes unused `org.junit` import symbols."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(""org.junit.*"", false),
                new UsesType<>(""junit.*"", false)
        ), new CleanupJUnitImportsVisitor());
    }

    public static class CleanupJUnitImportsVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J preVisit(J tree, ExecutionContext ctx) {
            stopAfterPreVisit();
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile c = (JavaSourceFile) tree;
                for (J.Import imp : c.getImports()) {
                    String packageName = imp.getPackageName();
                    if (packageName.startsWith(""junit"") || (packageName.startsWith(""org.junit"") && !packageName.contains(""jupiter""))) {
                        maybeRemoveImport(imp.getTypeName());
                    }
                }
            }
            return tree;
        }
    }
}
",{}
JUnit 5 inner test classes should be annotated with `@Nested`,Adds `@Nested` to inner classes that contain JUnit 5 tests.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.time.Duration;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddMissingNested extends Recipe {
    private static final String NESTED = ""org.junit.jupiter.api.Nested"";
    private static final List<String> TEST_ANNOTATIONS = Arrays.asList(
            ""org.junit.jupiter.api.Test"",
            ""org.junit.jupiter.api.TestTemplate"",
            ""org.junit.jupiter.api.RepeatedTest"",
            ""org.junit.jupiter.params.ParameterizedTest"",
            ""org.junit.jupiter.api.TestFactory"");

    @SuppressWarnings(""unchecked"")
    private static final TreeVisitor<?, ExecutionContext> PRECONDITION =
            Preconditions.or(TEST_ANNOTATIONS.stream().map(r -> new UsesType<>(r, false)).toArray(UsesType[]::new));

    @Override
    public String getDisplayName() {
        return ""JUnit 5 inner test classes should be annotated with `@Nested`"";
    }

    @Override
    public String getDescription() {
        return ""Adds `@Nested` to inner classes that contain JUnit 5 tests."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S5790"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(PRECONDITION, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                cd = cd.withBody((J.Block) new AddNestedAnnotationVisitor().visitNonNull(cd.getBody(), ctx, updateCursor(cd)));
                maybeAddImport(NESTED);
                return cd;
            }
        });
    }

    public static class AddNestedAnnotationVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            if (cd.hasModifier(J.Modifier.Type.Abstract) ||
                    cd.getKind() == J.ClassDeclaration.Kind.Type.Annotation ||
                    classDecl.getLeadingAnnotations().stream()
                            .anyMatch(a -> TypeUtils.isOfClassType(a.getType(), NESTED)) ||
                    !hasTestMethods(cd)) {
                return cd;
            }
            cd = JavaTemplate.builder(""@Nested"")
                    .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .imports(NESTED)
                    .build()
                    .apply(getCursor(), cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
            cd.getModifiers().removeIf(modifier -> modifier.getType() == J.Modifier.Type.Static);
            return maybeAutoFormat(classDecl, cd, ctx);
        }

        private static boolean hasTestMethods(final J.ClassDeclaration cd) {
            return TEST_ANNOTATIONS.stream().anyMatch(ann -> !FindAnnotations.find(cd, ""@"" + ann).isEmpty());
        }
    }
}
",{}
Pragmatists `@RunWith(JUnitParamsRunner.class)` to JUnit Jupiter `@Parameterized` tests,Convert Pragmatists Parameterized test to the JUnit Jupiter ParameterizedTest equivalent.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.trait.Literal;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.*;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.joining;

/**
 * Converts Pragmatists JUnitParamsRunner tests to their JUnit 5 ParameterizedTest and associated MethodSource equivalent
 * <a href=""https://github.com/Pragmatists/JUnitParams"">...</a>
 * Supports the following conversions
 * `@Parameters` annotation without arguments and default `parametersFor...` init-method exists
 * `@Parameters(method = ""..."")` annotation with defined method references
 * `@Parameters(named = ""..."")` and associated `@NamedParameter` init-method
 * Unsupported tests are identified with a comment on the associated `@Parameters(...)` annotation.
 */
public class JUnitParamsRunnerToParameterized extends Recipe {

    private static final AnnotationMatcher RUN_WITH_JUNIT_PARAMS_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.runner.RunWith(junitparams.JUnitParamsRunner.class)"");
    private static final AnnotationMatcher JUNIT_TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.Test"");
    private static final AnnotationMatcher JUPITER_TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.Test"");

    private static final AnnotationMatcher PARAMETERS_MATCHER = new AnnotationMatcher(""@junitparams.Parameters"");
    private static final AnnotationMatcher TEST_CASE_NAME_MATCHER = new AnnotationMatcher(""@junitparams.naming.TestCaseName"");
    private static final AnnotationMatcher NAMED_PARAMETERS_MATCHER = new AnnotationMatcher(""@junitparams.NamedParameters"");
    private static final AnnotationMatcher CONVERTER_MATCHER = new AnnotationMatcher(""@junitparams.converters.Param"");

    private static final String INIT_METHOD_REFERENCES = ""init-method-references"";
    private static final String CSV_PARAMS = ""csv-params"";
    private static final String PARAMETERS_FOR_PREFIX = ""parametersFor"";
    private static final String PARAMETERIZED_TESTS = ""parameterized-tests"";
    private static final String INIT_METHODS_MAP = ""named-parameters-map"";
    private static final String CONVERSION_NOT_SUPPORTED = ""conversion-not-supported"";

    @Override
    public String getDisplayName() {
        return ""Pragmatists `@RunWith(JUnitParamsRunner.class)` to JUnit Jupiter `@Parameterized` tests"";
    }

    @Override
    public String getDescription() {
        return ""Convert Pragmatists Parameterized test to the JUnit Jupiter ParameterizedTest equivalent."";
    }

    private static String junitParamsDefaultInitMethodName(String methodName) {
        return PARAMETERS_FOR_PREFIX + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""junitparams.*"", false), new ParameterizedTemplateVisitor());
    }

    private static class ParameterizedTemplateVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            Set<String> initMethods = getCursor().computeMessageIfAbsent(INIT_METHOD_REFERENCES, v -> new HashSet<>());
            Boolean hasCsvParams = getCursor().getMessage(CSV_PARAMS);
            if (!initMethods.isEmpty() || Boolean.TRUE.equals(hasCsvParams)) {
                doAfterVisit(new ParametersNoArgsImplicitMethodSource(initMethods,
                        getCursor().computeMessageIfAbsent(INIT_METHODS_MAP, v -> new HashMap<>()),
                        getCursor().computeMessageIfAbsent(CONVERSION_NOT_SUPPORTED, v -> new HashSet<>()),
                        getCursor().computeMessageIfAbsent(PARAMETERIZED_TESTS, v -> new HashSet<>()),
                        ctx));
            }
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            Cursor classDeclCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
            // methods having names starting with parametersFor... are init methods
            if (m.getSimpleName().startsWith(PARAMETERS_FOR_PREFIX)) {
                classDeclCursor.computeMessageIfAbsent(INIT_METHOD_REFERENCES, v -> new HashSet<>()).add(m.getSimpleName());
            }
            return m;
        }

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation anno = super.visitAnnotation(annotation, ctx);
            Cursor classDeclCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
            if (PARAMETERS_MATCHER.matches(anno)) {
                Annotated annotated = new Annotated.Matcher(PARAMETERS_MATCHER).require(annotation, getCursor().getParentOrThrow());
                String annotationArgumentValue = getAnnotationArgumentForInitMethod(annotated, ""method"", ""named"");
                classDeclCursor.computeMessageIfAbsent(PARAMETERIZED_TESTS, v -> new HashSet<>())
                        .add(getCursor().firstEnclosing(J.MethodDeclaration.class).getSimpleName());
                if (annotationArgumentValue != null) {
                    for (String method : annotationArgumentValue.split("","")) {
                        classDeclCursor.computeMessageIfAbsent(INIT_METHOD_REFERENCES, v -> new HashSet<>()).add(method);
                    }
                } else if (isSupportedCsvParam(annotated)) {
                    anno = getCsVParamTemplate(ctx).apply(updateCursor(anno), anno.getCoordinates().replace(), anno.getArguments().get(0));
                    classDeclCursor.putMessage(CSV_PARAMS, Boolean.TRUE);
                } else if (anno.getArguments() != null && !anno.getArguments().isEmpty()) {
                    // This conversion is not supported add a comment to the annotation and the method name to the not supported list
                    String comment = "" JunitParamsRunnerToParameterized conversion not supported"";
                    if (anno.getComments().stream().noneMatch(c -> c.printComment(getCursor()).endsWith(comment))) {
                        anno = anno.withComments(ListUtils.concat(anno.getComments(), new TextComment(false, comment,
                                ""\n"" + anno.getPrefix().getIndent(), Markers.EMPTY)));
                    }
                    J.MethodDeclaration m = getCursor().dropParentUntil(J.MethodDeclaration.class::isInstance).getValue();
                    Set<String> unsupportedMethods = classDeclCursor.computeMessageIfAbsent(CONVERSION_NOT_SUPPORTED, v -> new HashSet<>());
                    unsupportedMethods.add(m.getSimpleName());
                    unsupportedMethods.add(junitParamsDefaultInitMethodName(m.getSimpleName()));
                }
            } else if (NAMED_PARAMETERS_MATCHER.matches(annotation)) {
                Annotated annotated = new Annotated.Matcher(NAMED_PARAMETERS_MATCHER).require(annotation, getCursor().getParentOrThrow());
                Optional<Literal> value = annotated.getDefaultAttribute(""value"");
                if (value.isPresent()) {
                    J.MethodDeclaration m = getCursor().dropParentUntil(J.MethodDeclaration.class::isInstance).getValue();
                    classDeclCursor.computeMessageIfAbsent(INIT_METHOD_REFERENCES, v -> new HashSet<>()).add(m.getSimpleName());
                    classDeclCursor.computeMessageIfAbsent(INIT_METHODS_MAP, v -> new HashMap<>()).put(value.get().getString(), m.getSimpleName());
                }
            } else if (TEST_CASE_NAME_MATCHER.matches(anno)) {
                Annotated annotated = new Annotated.Matcher(TEST_CASE_NAME_MATCHER).require(annotation, getCursor().getParentOrThrow());
                // test name for ParameterizedTest argument
                Optional<Literal> value = annotated.getDefaultAttribute(""value"");
                if (value.isPresent()) {
                    Object testNameArg = value.get().getString();
                    String testName = testNameArg != null ? testNameArg.toString() : ""{method}({params}) [{index}]"";
                    J.MethodDeclaration md = getCursor().dropParentUntil(J.MethodDeclaration.class::isInstance).getValue();
                    classDeclCursor.computeMessageIfAbsent(INIT_METHODS_MAP, v -> new HashMap<>()).put(md.getSimpleName(), testName);
                }
            }
            return anno;
        }

        private @Nullable String getAnnotationArgumentForInitMethod(Annotated annotated, String... variableNames) {
            for (String variableName : variableNames) {
                Optional<Literal> attribute = annotated.getAttribute(variableName);
                if (attribute.isPresent()) {
                    return attribute.get().getString();
                }
            }
            return null;
        }

        private boolean isSupportedCsvParam(Annotated annotated) {
            if (annotated.getTree().getArguments() == null || annotated.getTree().getArguments().size() != 1) {
                return false;
            }
            Optional<Literal> value = annotated.getDefaultAttribute(""value"");
            return value.isPresent() &&
                    value.get().isArray() &&
                    !doTestParamsHaveCustomConverter(getCursor().firstEnclosing(J.MethodDeclaration.class));
        }

        private boolean doTestParamsHaveCustomConverter(J.@Nullable MethodDeclaration method) {
            if (method == null) {
                return false;
            }
            return method.getParameters().stream()
                    .filter(param -> param instanceof J.VariableDeclarations)
                    .map(J.VariableDeclarations.class::cast)
                    .anyMatch(v -> v.getLeadingAnnotations().stream().anyMatch(CONVERTER_MATCHER::matches));
        }

        private static JavaTemplate getCsVParamTemplate(ExecutionContext ctx) {
            return JavaTemplate.builder(""@CsvSource(#{any(java.lang.String[])})"")
                    .imports(""org.junit.jupiter.params.provider.CsvSource"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-params""))
                    .build();
        }
    }

    /***
     * Case 1.
     * - Test has Parameters annotation without arguments and initMethods has match
     * case 2.
     * - Test has Parameters(method = ""..."") annotation with defined method source
     * case 3.
     * - Test has Parameters(named = ""..."") and NamedParameters annotation
     */
    private static class ParametersNoArgsImplicitMethodSource extends JavaIsoVisitor<ExecutionContext> {

        private final Set<String> initMethods;
        private final Set<String> unsupportedConversions;
        private final Set<String> parameterizedTests;
        private final Map<String, String> initMethodReferences;

        private final JavaTemplate parameterizedTestTemplate;
        private final JavaTemplate parameterizedTestTemplateWithName;
        private final JavaTemplate methodSourceTemplate;

        public ParametersNoArgsImplicitMethodSource(Set<String> initMethods, Map<String, String> initMethodReferences, Set<String> unsupportedConversions, Set<String> parameterizedTests, ExecutionContext ctx) {
            this.initMethods = initMethods;
            this.initMethodReferences = initMethodReferences;
            this.unsupportedConversions = unsupportedConversions;
            this.parameterizedTests = parameterizedTests;

            // build @ParameterizedTest template
            JavaParser.Builder<?, ?> javaParser = JavaParser.fromJavaVersion()
                    .classpathFromResources(ctx, ""junit-jupiter-api-5"", ""hamcrest-3"", ""junit-jupiter-params-5"");
            this.parameterizedTestTemplate = JavaTemplate.builder(""@ParameterizedTest"")
                    .javaParser(javaParser)
                    .imports(""org.junit.jupiter.params.ParameterizedTest"").build();
            // build @ParameterizedTest(#{}) template
            this.parameterizedTestTemplateWithName = JavaTemplate.builder(""@ParameterizedTest(name = \""#{}\"")"")
                    .javaParser(javaParser)
                    .imports(""org.junit.jupiter.params.ParameterizedTest"").build();
            // build @MethodSource(""..."") template
            this.methodSourceTemplate = JavaTemplate.builder(""@MethodSource(#{})"")
                    .javaParser(javaParser)
                    .imports(""org.junit.jupiter.params.provider.MethodSource"").build();
        }

        @SuppressWarnings(""SpellCheckingInspection"")
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            // Remove @RunWith(JUnitParamsRunner.class) annotation
            doAfterVisit(new RemoveAnnotationVisitor(RUN_WITH_JUNIT_PARAMS_ANNOTATION_MATCHER));
            List<String> methodNames = getCursor().getMessage(MakeMethodStatic.REFERENCED_METHODS, emptyList());
            if (cd.getType() != null && !methodNames.isEmpty()) {
                doAfterVisit(new MakeMethodStatic(cd.getType(), methodNames));
            }

            // Update Imports
            maybeRemoveImport(""org.junit.Test"");
            maybeRemoveImport(""org.junit.jupiter.api.Test"");
            maybeRemoveImport(""org.junit.runner.RunWith"");
            maybeRemoveImport(""junitparams.JUnitParamsRunner"");
            maybeRemoveImport(""junitparams.Parameters"");
            maybeRemoveImport(""junitparams.NamedParameters"");
            maybeRemoveImport(""junitparams.naming.TestCaseName"");
            maybeAddImport(""org.junit.jupiter.params.ParameterizedTest"");
            maybeAddImport(""org.junit.jupiter.params.provider.MethodSource"");
            maybeAddImport(""org.junit.jupiter.params.provider.CsvSource"");
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (unsupportedConversions.contains(method.getSimpleName())) {
                return method;
            }
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            final String paramTestName = initMethodReferences.get(m.getSimpleName());

            List<J.Annotation> annotations = ListUtils.map(m.getLeadingAnnotations(), anno -> {
                if (TEST_CASE_NAME_MATCHER.matches(anno) || NAMED_PARAMETERS_MATCHER.matches(anno)) {
                    return null;
                }
                anno = maybeReplaceTestAnnotation(new Cursor(getCursor(), anno), paramTestName);
                return maybeReplaceParametersAnnotation(new Cursor(getCursor(), anno), method.getSimpleName());
            });
            m = m.withLeadingAnnotations(annotations);

            // If the method is an init-method then add a static modifier if necessary
            if (initMethods.contains(m.getSimpleName()) || initMethodReferences.containsValue(m.getSimpleName())) {
                Cursor enclosingCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
                enclosingCursor.computeMessageIfAbsent(MakeMethodStatic.REFERENCED_METHODS, k -> new ArrayList<>()).add(m.getSimpleName());
            }
            return maybeAutoFormat(method, m, m.getName(), ctx, getCursor().getParentTreeCursor());
        }

        private J.Annotation maybeReplaceTestAnnotation(Cursor anno, @Nullable String parameterizedTestArgument) {
            if (JUPITER_TEST_ANNOTATION_MATCHER.matches(anno.getValue()) || JUNIT_TEST_ANNOTATION_MATCHER.matches(anno.getValue())) {
                if (!parameterizedTests.contains(anno.firstEnclosing(J.MethodDeclaration.class).getSimpleName())) {
                    return anno.getValue();
                }
                if (parameterizedTestArgument == null) {
                    return parameterizedTestTemplate.apply(anno, ((J.Annotation) anno.getValue()).getCoordinates().replace());
                }
                return parameterizedTestTemplateWithName.apply(anno, ((J.Annotation) anno.getValue()).getCoordinates().replace(),
                        parameterizedTestArgument);
            }
            return anno.getValue();
        }

        private J.Annotation maybeReplaceParametersAnnotation(Cursor anno, String methodName) {
            if (PARAMETERS_MATCHER.matches(anno.getValue())) {
                String initMethodName = junitParamsDefaultInitMethodName(methodName);
                if (initMethods.contains(initMethodName)) {
                    return methodSourceTemplate.apply(anno, ((J.Annotation) anno.getValue()).getCoordinates().replace(), ""\"""" + initMethodName + ""\"""");
                }
                String annotationArg = getAnnotationArgumentValueForMethodTemplate(anno.getValue());
                if (annotationArg != null) {
                    return methodSourceTemplate.apply(anno, ((J.Annotation) anno.getValue()).getCoordinates().replace(), annotationArg);
                }
            }
            return anno.getValue();
        }

        private @Nullable String getAnnotationArgumentValueForMethodTemplate(J.Annotation anno) {
            String annotationArgumentValue = null;
            if (anno.getArguments() != null && anno.getArguments().size() == 1) {
                Expression annoArg = anno.getArguments().get(0);
                if (annoArg instanceof J.Literal) {
                    annotationArgumentValue = (String) ((J.Literal) annoArg).getValue();
                } else if (annoArg instanceof J.Assignment && (((J.Assignment) annoArg).getAssignment()) instanceof J.Literal) {
                    annotationArgumentValue = (String) ((J.Literal) ((J.Assignment) annoArg).getAssignment()).getValue();
                }
            }
            if (initMethodReferences.containsKey(annotationArgumentValue)) {
                annotationArgumentValue = initMethodReferences.get(annotationArgumentValue);
            }

            if (annotationArgumentValue != null) {
                String[] methodRefs = annotationArgumentValue.split("","");
                if (methodRefs.length > 1) {
                    String methods = Arrays.stream(methodRefs).map(mref -> ""\"""" + mref + ""\"""").collect(joining("", ""));
                    annotationArgumentValue = ""{"" + methods + ""}"";
                } else {
                    annotationArgumentValue = ""\"""" + annotationArgumentValue + ""\"""";
                }
            }
            return annotationArgumentValue;
        }

    }

    @RequiredArgsConstructor
    private static class MakeMethodStatic extends JavaIsoVisitor<ExecutionContext> {

        private static final String REFERENCED_METHODS = ""referencedMethods"";

        private final JavaType.FullyQualified classType;
        private final List<String> methodNames;

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDeclaration, ExecutionContext ctx) {
            if (classDeclaration.getType() != classType) {
                return classDeclaration;
            }
            J.ClassDeclaration cd = super.visitClassDeclaration(classDeclaration, ctx);
            List<String> methodNames = getCursor().getMessage(REFERENCED_METHODS, emptyList());
            if (!methodNames.isEmpty()) {
                doAfterVisit(new MakeMethodStatic(classType, methodNames));
            }
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (!methodNames.contains(method.getSimpleName()) ||
                    method.hasModifier(J.Modifier.Type.Static) ||
                    method.getMethodType() == null ||
                    method.getMethodType().getDeclaringType() != classType) {
                return method;
            }
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            J.Modifier staticModifier = new J.Modifier(Tree.randomId(), Space.SINGLE_SPACE, Markers.EMPTY, null, J.Modifier.Type.Static, new ArrayList<>());
            return m.withModifiers(ListUtils.concat(m.getModifiers(), staticModifier));
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodDeclaration enclosingMethod = getCursor().firstEnclosing(J.MethodDeclaration.class);
            if (enclosingMethod != null &&
                    method.getMethodType() != null &&
                    methodNames.contains(enclosingMethod.getSimpleName()) &&
                    method.getMethodType().getDeclaringType() == classType) {
                Cursor classCursor = getCursor().dropParentUntil(j -> j instanceof J.ClassDeclaration);
                classCursor.computeMessageIfAbsent(REFERENCED_METHODS, k -> new ArrayList<>()).add(method.getSimpleName());
            }
            return super.visitMethodInvocation(method, ctx);
        }
    }
}
",{}
OkHttp 3.x `MockWebServer` `@Rule` To 4.x `MockWebServer`,Replace usages of okhttp3 3.x `@Rule` MockWebServer with 4.x `MockWebServer`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.dependencies.UpgradeDependencyVersion;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

/**
 * Recipe for converting JUnit 4 okhttp3 MockWebServer Rules with their JUnit 5 equivalent.
 * Note this recipe upgrades okhttp3 to version 4.x there are a few backwards incompatible changes:
 * https://square.github.io/okhttp/upgrading_to_okhttp_4/#backwards-incompatible-changes
 * <p>
 * - If MockWebServer Rule exists remove the Rule annotation and update okhttp3 to version 4.x
 * - If AfterEach method exists insert a close statement for the MockWebServer and throws for IOException
 * - If AfterEach does not exist then insert new afterEachTest method closing MockWebServer
 */
@SuppressWarnings({""JavadocLinkAsPlainText""})
public class UpdateMockWebServer extends Recipe {
    private static final AnnotationMatcher RULE_MATCHER = new AnnotationMatcher(""@org.junit.Rule"");
    private static final AnnotationMatcher AFTER_EACH_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.AfterEach"");
    private static final String AFTER_EACH_FQN = ""org.junit.jupiter.api.AfterEach"";
    private static final String MOCK_WEB_SERVER_FQN = ""okhttp3.mockwebserver.MockWebServer"";
    private static final String IO_EXCEPTION_FQN = ""java.io.IOException"";
    private static final String MOCK_WEBSERVER_VARIABLE = ""mock-web-server-variable"";
    private static final String AFTER_EACH_METHOD = ""after-each-method"";

    @Override
    public String getDisplayName() {
        return ""OkHttp 3.x `MockWebServer` `@Rule` To 4.x `MockWebServer`"";
    }

    @Override
    public String getDescription() {
        return ""Replace usages of okhttp3 3.x `@Rule` MockWebServer with 4.x `MockWebServer`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new UsesType<>(""org.junit.Rule"", false),
                        new UsesType<>(""okhttp3.mockwebserver.MockWebServer"", false)
                ),
                new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                        final J.Identifier mockWebServerVariable = getCursor().pollMessage(MOCK_WEBSERVER_VARIABLE);
                        final J.MethodDeclaration afterEachMethod = getCursor().pollMessage(AFTER_EACH_METHOD);
                        if (mockWebServerVariable != null) {
                            if (afterEachMethod == null) {
                                cd = JavaTemplate.builder(""@AfterEach\nvoid afterEachTest() throws IOException {#{any(okhttp3.mockwebserver.MockWebServer)}.close();\n}"")
                                        .contextSensitive()
                                        .imports(AFTER_EACH_FQN, MOCK_WEB_SERVER_FQN, IO_EXCEPTION_FQN)
                                        .javaParser(JavaParser.fromJavaVersion()
                                                .classpathFromResources(ctx, ""junit-4"", ""junit-jupiter-api-5"", ""apiguardian-api-1.1"",
                                                        ""mockwebserver-3.14""))
                                        .build()
                                        .apply(
                                                updateCursor(cd),
                                                cd.getBody().getCoordinates().lastStatement(),
                                                mockWebServerVariable
                                        );
                                maybeAddImport(AFTER_EACH_FQN);
                                maybeAddImport(IO_EXCEPTION_FQN);
                            } else {
                                for (Statement statement : cd.getBody().getStatements()) {
                                    if (statement == afterEachMethod) {
                                        cd = JavaTemplate.builder(""#{any(okhttp3.mockwebserver.MockWebServer)}.close();"")
                                                .contextSensitive()
                                                .imports(AFTER_EACH_FQN, MOCK_WEB_SERVER_FQN, IO_EXCEPTION_FQN)
                                                .javaParser(JavaParser.fromJavaVersion()
                                                        .classpathFromResources(ctx, ""junit-4"", ""junit-jupiter-api-5"", ""apiguardian-api-1.1"",
                                                                ""mockwebserver-3.14""))
                                                .build()
                                                .apply(
                                                        updateCursor(cd),
                                                        requireNonNull(afterEachMethod.getBody()).getCoordinates().lastStatement(),
                                                        mockWebServerVariable
                                                );
                                    }
                                }

                                cd = autoFormat(cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                                    if (statement.isScope(afterEachMethod)) {
                                        J.MethodDeclaration method = (J.MethodDeclaration) statement;
                                        if (method.getBody() != null) {
                                            if (method.getThrows() == null || method.getThrows().stream()
                                                    .noneMatch(n -> TypeUtils.isOfClassType(n.getType(), IO_EXCEPTION_FQN))) {
                                                J.Identifier ioExceptionIdent = new J.Identifier(Tree.randomId(),
                                                        Space.format("" ""),
                                                        Markers.EMPTY,
                                                        emptyList(),
                                                        ""IOException"",
                                                        JavaType.ShallowClass.build(IO_EXCEPTION_FQN),
                                                        null);
                                                method = method.withThrows(ListUtils.concat(method.getThrows(), ioExceptionIdent));
                                                maybeAddImport(IO_EXCEPTION_FQN);
                                            }
                                        }
                                        statement = method;
                                    }
                                    return statement;
                                }))), ctx);
                            }

                            maybeRemoveImport(""org.junit.Rule"");
                        }
                        return cd;
                    }

                    @Override
                    public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                        J.VariableDeclarations variableDeclarations = super.visitVariableDeclarations(multiVariable, ctx);
                        JavaType.FullyQualified fieldType = variableDeclarations.getTypeAsFullyQualified();
                        if (TypeUtils.isOfClassType(fieldType, ""okhttp3.mockwebserver.MockWebServer"")) {
                            variableDeclarations = variableDeclarations.withLeadingAnnotations(ListUtils.map(variableDeclarations.getLeadingAnnotations(), annotation -> {
                                if (RULE_MATCHER.matches(annotation)) {
                                    return null;
                                }
                                return annotation;
                            }));
                            if (variableDeclarations.getLeadingAnnotations().isEmpty()) {
                                variableDeclarations = variableDeclarations.withModifiers(Space.formatFirstPrefix(
                                        variableDeclarations.getModifiers(), Space.EMPTY));
                            }
                        }
                        if (multiVariable != variableDeclarations) {
                            getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, MOCK_WEBSERVER_VARIABLE, variableDeclarations.getVariables().get(0).getName());
                        }
                        return variableDeclarations;
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                        for (J.Annotation annotation : md.getLeadingAnnotations()) {
                            if (AFTER_EACH_MATCHER.matches(annotation)) {
                                getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, AFTER_EACH_METHOD, md);
                                break;
                            }
                        }
                        return md;
                    }
                });
    }

    @Override
    public List<Recipe> getRecipeList() {
        return singletonList(new UpgradeDependencyVersion(""com.squareup.okhttp3"", ""mockwebserver"", ""4.X"",
                null, false, emptyList()));
    }
}
",{}
Remove duplicates uses of @TestTemplate implementations for a single method,Remove duplicates uses of @TestTemplate implementations for a single method.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

public class RemoveDuplicateTestTemplates extends Recipe {
    private static final AnnotationMatcher TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.Test"");
    private static final AnnotationMatcher REPEATED_TEST_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.RepeatedTest"");

    @Override
    public String getDisplayName() {
        return ""Remove duplicates uses of @TestTemplate implementations for a single method"";
    }

    @Override
    public String getDescription() {
        return ""Remove duplicates uses of @TestTemplate implementations for a single method."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.junit.jupiter.api.RepeatedTest"", false),
                new RemoveDuplicateTestTemplateVisitor());
    }

    private static class RemoveDuplicateTestTemplateVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(md, ctx);
            // first check if @Test or @RepeatedTest is present, else return early
            if (m.getLeadingAnnotations().stream().anyMatch(TEST_ANNOTATION_MATCHER::matches) &&
                m.getLeadingAnnotations().stream().anyMatch(REPEATED_TEST_ANNOTATION_MATCHER::matches)) {
                maybeRemoveImport(""org.junit.jupiter.api.Test"");
                return new RemoveAnnotationVisitor(TEST_ANNOTATION_MATCHER).visitMethodDeclaration(m, ctx);
            }
            return m;
        }
    }
}
",{}
Add JUnit Jupiter dependencies,Adds JUnit Jupiter dependencies to a Maven or Gradle project. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.dependencies.AddDependency;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddJupiterDependencies extends ScanningRecipe<AddDependency.Accumulator> {
    @Override
    public String getDisplayName() {
        return ""Add JUnit Jupiter dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Adds JUnit Jupiter dependencies to a Maven or Gradle project. "" +
               ""Junit Jupiter can be added either with the artifact junit-jupiter, or both of junit-jupiter-api and junit-jupiter-engine. "" +
               ""This adds \""junit-jupiter\"" dependency unless \""junit-jupiter-api\"" or \""junit-jupiter-engine\"" are already present."";
    }

    @Override
    public AddDependency.Accumulator getInitialValue(ExecutionContext ctx) {
        return addJupiterDependency().getInitialValue(ctx);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AddDependency.Accumulator acc) {
        return addJupiterDependency().getScanner(acc);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AddDependency.Accumulator acc) {
        AddJupiterGradle gv = new AddJupiterGradle(acc);
        AddJupiterMaven mv = new AddJupiterMaven(acc);
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx, Cursor parent) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile s = (SourceFile) tree;
                if (gv.isAcceptable(s, ctx)) {
                    s = (SourceFile) gv.visitNonNull(s, ctx);
                }
                if (mv.isAcceptable(s, ctx)) {
                    s = (SourceFile) mv.visitNonNull(s, ctx);
                }
                return s;
            }
        };
    }

    private static AddDependency addJupiterDependency() {
        return new AddDependency(""org.junit.jupiter"", ""junit-jupiter"", ""5.x"", null,
                ""org.junit..*"", null, null, null, null, null,
                null, null, null, null);
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class AddJupiterGradle extends GroovyIsoVisitor<ExecutionContext> {
        AddDependency.Accumulator acc;

        @Override
        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit t, ExecutionContext ctx) {
            Optional<GradleProject> maybeGp = t.getMarkers().findFirst(GradleProject.class);
            if (!maybeGp.isPresent()) {
                return t;
            }
            GradleProject gp = maybeGp.get();
            GradleDependencyConfiguration trc = gp.getConfiguration(""testRuntimeClasspath"");
            if (trc == null) {
                return t;
            }
            ResolvedDependency jupiterApi = trc.findResolvedDependency(""org.junit.jupiter"", ""junit-jupiter-api"");
            if (jupiterApi == null) {
                t = (G.CompilationUnit) addJupiterDependency().getVisitor(acc)
                        .visitNonNull(t, ctx);
            }

            return t;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class AddJupiterMaven extends MavenIsoVisitor<ExecutionContext> {
        AddDependency.Accumulator acc;

        @Override
        public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
            Xml.Document d = document;
            List<ResolvedDependency> jupiterApi = getResolutionResult().findDependencies(""org.junit.jupiter"", ""junit-jupiter-api"", null);
            if (jupiterApi.isEmpty()) {
                d = (Xml.Document) addJupiterDependency().getVisitor(acc)
                        .visitNonNull(d, ctx);
            }
            return d;
        }
    }
}
",{}
JUnit 4 `@RunWith` to JUnit Jupiter `@ExtendWith`,Replace runners with the JUnit Jupiter extension equivalent.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.List;

@SuppressWarnings(""DuplicatedCode"")
@Value
@EqualsAndHashCode(callSuper = false)
public class RunnerToExtension extends Recipe {

    @Option(displayName = ""Runners"",
            description = ""The fully qualified class names of the JUnit 4 runners to replace. Sometimes several runners are replaced by a single JUnit Jupiter extension."",
            example = ""[ org.springframework.test.context.junit4.SpringRunner ]"")
    List<String> runners;

    @Option(displayName = ""Extension"",
            description = ""The fully qualified class names of the JUnit Jupiter extension."",
            example = ""org.springframework.test.context.junit.jupiter.SpringExtension"")
    String extension;


    @JsonCreator
    public RunnerToExtension(@JsonProperty(""runners"") List<String> runners, @JsonProperty(""extension"") String extension) {
        this.runners = runners;
        this.extension = extension;
    }

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `@RunWith` to JUnit Jupiter `@ExtendWith`"";
    }

    @Override
    public String getDescription() {
        return ""Replace runners with the JUnit Jupiter extension equivalent."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        @SuppressWarnings(""unchecked"") TreeVisitor<?, ExecutionContext> precondition =
                Preconditions.or(runners.stream().map(r -> new UsesType<>(r, false)).toArray(UsesType[]::new));
        return Preconditions.check(precondition, new JavaIsoVisitor<ExecutionContext>() {
            private final JavaType.Class extensionType = JavaType.ShallowClass.build(extension);

            @Nullable
            private JavaTemplate extendsWithTemplate;

            private JavaTemplate getExtendsWithTemplate(ExecutionContext ctx) {
                if (extendsWithTemplate == null) {
                    extendsWithTemplate = JavaTemplate.builder(""@ExtendWith(#{}.class)"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""junit-jupiter-api-5"")
                                    .dependsOn(""package "" + extensionType.getPackageName() + "";\n"" +
                                               ""import org.junit.jupiter.api.extension.Extension;\n"" +
                                               ""public class "" + extensionType.getClassName() + "" implements Extension {}""))
                            .imports(""org.junit.jupiter.api.extension.ExtendWith"",
                                    ""org.junit.jupiter.api.extension.Extension"",
                                    extension)
                            .build();
                }
                return extendsWithTemplate;
            }

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

                for (String runner : runners) {
                    //noinspection ConstantConditions
                    for (J.Annotation runWith : FindAnnotations.find(classDecl.withBody(null), ""@org.junit.runner.RunWith("" + runner + "".class)"")) {
                        cd = getExtendsWithTemplate(ctx).apply(
                                updateCursor(cd),
                                runWith.getCoordinates().replace(),
                                extensionType.getClassName()
                        );
                        maybeAddImport(""org.junit.jupiter.api.extension.ExtendWith"");
                        maybeAddImport(extension);
                        maybeRemoveImport(""org.junit.runner.RunWith"");
                        maybeRemoveImport(runner);
                    }
                }

                return cd;
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);

                for (String runner : runners) {
                    for (J.Annotation runWith : FindAnnotations.find(method.withBody(null), ""@org.junit.runner.RunWith("" + runner + "".class)"")) {
                        md = getExtendsWithTemplate(ctx).apply(
                                updateCursor(md),
                                runWith.getCoordinates().replace(),
                                extensionType.getClassName()
                        );
                        maybeAddImport(""org.junit.jupiter.api.extension.ExtendWith"");
                        maybeAddImport(extension);
                        maybeRemoveImport(""org.junit.runner.RunWith"");
                        maybeRemoveImport(runner);
                    }
                }

                return md;
            }
        });
    }
}
","{
  ""extension"": ""String field""
}"
Migrate JUnit 4 environmentVariables rule to JUnit 5 system stubs extension,Replaces usage of the JUnit 4 `@Rule EnvironmentVariables` with the JUnit 5-compatible ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.tree.*;

import static java.util.Comparator.comparing;
import static org.openrewrite.java.testing.junit5.Junit4Utils.CLASS_RULE;
import static org.openrewrite.java.testing.junit5.Junit4Utils.RULE;

/**
 * A recipe to replace JUnit 4's EnvironmentVariables rule from contrib with the JUnit 5-compatible
 * `SystemStubsExtension` and `EnvironmentVariables` from the System Stubs library.
 */
public class EnvironmentVariables extends Recipe {
    public static final String ENVIRONMENT_VARIABLES = ""org.junit.contrib.java.lang.system.EnvironmentVariables"";
    public static final String ENVIRONMENT_VARIABLES_STUB = ""uk.org.webcompere.systemstubs.environment.EnvironmentVariables"";
    public static final String SYSTEM_STUBS_EXTENSION = ""uk.org.webcompere.systemstubs.jupiter.SystemStubsExtension"";
    public static final String SYSTEM_STUB = ""uk.org.webcompere.systemstubs.jupiter.SystemStub"";
    private static final String EXTEND_WITH = ""org.junit.jupiter.api.extension.ExtendWith"";

    @Override
    public @NonNull String getDisplayName() {
        return ""Migrate JUnit 4 environmentVariables rule to JUnit 5 system stubs extension"";
    }

    @Override
    public @NonNull String getDescription() {
        return ""Replaces usage of the JUnit 4 `@Rule EnvironmentVariables` with the JUnit 5-compatible "" +
                ""`SystemStubsExtension` and `@SystemStub EnvironmentVariables` from the System Stubs "" +
                ""library."";
    }

    @Override
    public @NonNull TreeVisitor<?, ExecutionContext> getVisitor() {
        return new EnvironmentVariablesVisitor();
    }

    private static class EnvironmentVariablesVisitor extends JavaVisitor<ExecutionContext> {

        private static final String HAS_ENV_VAR_RULE = ""hasEnvVarRule"";
        private static final MethodMatcher ENV_VAR_CLEAR =
                new MethodMatcher(ENVIRONMENT_VARIABLES + "" clear(String[])"");

        @Override
        public @NonNull J visitCompilationUnit(
                J.@NonNull CompilationUnit cu, @NonNull ExecutionContext ctx) {
            maybeRemoveImport(RULE);
            maybeRemoveImport(CLASS_RULE);
            maybeRemoveImport(ENVIRONMENT_VARIABLES);
            maybeAddImport(SYSTEM_STUBS_EXTENSION);
            maybeAddImport(SYSTEM_STUB);
            maybeAddImport(EXTEND_WITH);
            maybeAddImport(ENVIRONMENT_VARIABLES_STUB);
            return super.visitCompilationUnit(cu, ctx);
        }

        @Override
        public @NonNull J visitClassDeclaration(
                J.@NonNull ClassDeclaration classDecl, @NonNull ExecutionContext ctx) {
            J.ClassDeclaration cd = (J.ClassDeclaration) super.visitClassDeclaration(classDecl, ctx);
            Boolean hasEnvVarRule = getCursor().getMessage(HAS_ENV_VAR_RULE);

            if (!Boolean.TRUE.equals(hasEnvVarRule)) {
                return cd;
            }
            // Add @ExtendWith(SystemStubsExtension.class) annotation to class.
            return systemStubExtensionTemplate(ctx).apply(
                    updateCursor(cd),
                    cd.getCoordinates().addAnnotation(comparing(J.Annotation::getSimpleName)));
        }

        @Override
        public @NonNull J visitVariableDeclarations(
                J.@NonNull VariableDeclarations variableDecls, @NonNull ExecutionContext ctx) {
            // missing type attribution, possibly parsing error.
            if (variableDecls.getType() == null || !TypeUtils.isAssignableTo(ENVIRONMENT_VARIABLES, variableDecls.getType())) {
                return variableDecls;
            }
            J.VariableDeclarations vd = (J.VariableDeclarations) new Annotated.Matcher(""@org.junit.*Rule"").asVisitor(a ->
                            (new JavaIsoVisitor<ExecutionContext>() {
                                @Override
                                public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                                    return systemStubsTemplate(ctx).apply(updateCursor(annotation), annotation.getCoordinates().replace());
                                }
                            }).visit(a.getTree(), ctx, a.getCursor().getParentOrThrow()))
                    .visit(variableDecls, ctx, getCursor().getParentOrThrow());

            if (variableDecls != vd) {
                // put message to first enclosing ClassDeclaration, to inform that we have an env var rule.
                getCursor()
                        .dropParentUntil(c -> c instanceof J.ClassDeclaration)
                        .putMessage(HAS_ENV_VAR_RULE, true);
            }

            return super.visitVariableDeclarations(vd, ctx);
        }

        @Override
        public @Nullable J visitMethodInvocation(
                J.@NonNull MethodInvocation method, @NonNull ExecutionContext ctx) {

            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
            // Replace EnvironmentVariables.clear() with EnvironmentVariables.remove()
            if (ENV_VAR_CLEAR.matches(method) && m.getSelect() != null /* NullAway */) {
                int argCount = argCount(m);
                J j =
                        getEnvVarClearTemplate(ctx, argCount)
                                .apply(updateCursor(m), m.getCoordinates().replace(), (Object[]) getArgs(m, argCount));

                if (getCursor().getParentTreeCursor().getValue() instanceof J.Block &&
                        !(j instanceof Statement)) {
                    return null;
                }
                return j;
            }
            return m;
        }

        @Override
        public @Nullable JavaType visitType(@Nullable JavaType type, @NonNull ExecutionContext ctx) {
            if (type instanceof JavaType.FullyQualified) {
                String fullyQualifiedName = ((JavaType.FullyQualified) type).getFullyQualifiedName();
                if (ENVIRONMENT_VARIABLES.equals(fullyQualifiedName)) {
                    return JavaType.buildType(ENVIRONMENT_VARIABLES_STUB);
                }
            }
            return super.visitType(type, ctx);
        }

        private static JavaTemplate systemStubExtensionTemplate(ExecutionContext ctx) {
            return JavaTemplate.builder(""@ExtendWith(SystemStubsExtension.class)"")
                    .imports(EXTEND_WITH, SYSTEM_STUBS_EXTENSION)
                    .javaParser(
                            JavaParser.fromJavaVersion().classpathFromResources(ctx, ""system-stubs-jupiter"", ""junit-jupiter-api""))
                    .build();
        }

        private static JavaTemplate systemStubsTemplate(ExecutionContext ctx) {
            return JavaTemplate.builder(""@SystemStub"")
                    .imports(SYSTEM_STUB)
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""system-stubs-jupiter""))
                    .build();
        }

        private static JavaTemplate getEnvVarClearTemplate(ExecutionContext ctx, int argsSize) {
            StringBuilder template = new StringBuilder(""#{any("").append(ENVIRONMENT_VARIABLES_STUB).append("")}"");
            for (int i = 0; i < argsSize; i++) {
                template.append("".remove(#{any(java.lang.String)})"");
            }
            return JavaTemplate.builder(template.toString())
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""system-stubs-jupiter"", ""system-stubs-core""))
                    .build();
        }

        private static int argCount(J.MethodInvocation methodInvocation) {
            if (methodInvocation.getArguments().size() == 1) {
                // method call with empty args contains an element of type J.Empty in LST.
                return methodInvocation.getArguments().get(0) instanceof J.Empty ? 0 : 1;
            }
            return methodInvocation.getArguments().size();
        }

        private static Expression[] getArgs(J.MethodInvocation methodInvocation, int argCount) {
            Expression[] args = new Expression[argCount + 1];
            args[0] = methodInvocation.getSelect();
            for (int i = 0; i < argCount; i++) {
                args[i + 1] = methodInvocation.getArguments().get(i);
            }
            return args;
        }
    }
}
",{}
Gradle `Test` use JUnit Jupiter,By default Gradle's `Test` tasks use JUnit 4. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.GradleParser;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Objects.requireNonNull;
import static org.openrewrite.internal.ListUtils.concat;

@Value
@EqualsAndHashCode(callSuper = false)
public class GradleUseJunitJupiter extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Gradle `Test` use JUnit Jupiter"";
    }

    @Override
    public String getDescription() {
        return ""By default Gradle's `Test` tasks use JUnit 4. "" +
                ""Gradle `Test` tasks must be configured with `useJUnitPlatform()` to run JUnit Jupiter tests. "" +
                ""This recipe adds the `useJUnitPlatform()` method call to the `Test` task configuration."";
    }

    private static final String USE_JUNIT_PLATFORM_PATTERN = ""org.gradle.api.tasks.testing.Test useJUnitPlatform()"";
    private static final MethodMatcher USE_JUNIT_PLATFORM_MATCHER = new MethodMatcher(USE_JUNIT_PLATFORM_PATTERN);
    private static final MethodMatcher USE_JUNIT4_MATCHER = new MethodMatcher(""org.gradle.api.tasks.testing.Test useJUnit()"");
    private static final MethodMatcher USE_JUNIT4_ALTERNATE_MATCHER = new MethodMatcher(""RewriteTestSpec useJUnit()"");
    private static final MethodMatcher TEST_DSL_MATCHER = new MethodMatcher(""RewriteGradleProject test(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit compilationUnit, ExecutionContext ctx) {
                if (!IsBuildGradle(compilationUnit) || !hasJavaBasePlugin(compilationUnit) || containsJUnitPlatformInvocation(compilationUnit)) {
                    return compilationUnit;
                }
                // If anywhere in the tree there is a useJunit() we can swap it out for useJUnitPlatform() and be done in one step
                G.CompilationUnit cu = (G.CompilationUnit) new UpdateExistingUseJunit4()
                        .visitNonNull(compilationUnit, ctx, requireNonNull(getCursor().getParent()));
                if (cu != compilationUnit) {
                    return cu;
                }
                // No useJUnit(), but there might already be configuration of a Test task, add useJUnitPlatform() to it
                cu = (G.CompilationUnit) new AddJUnitPlatformToExistingTestDsl()
                        .visitNonNull(cu, ctx, requireNonNull(getCursor().getParent()));
                if (cu != compilationUnit) {
                    return cu;
                }

                // No existing test task configuration seems to exist, add a whole new one
                return (G.CompilationUnit) new AddUseJUnitPlatform()
                        .visitNonNull(cu, ctx, getCursor().getParent());
            }
        });
    }

    // Avoid adding a new test configuration to script plugins as it may be added too broadly to all scripts
    private static boolean IsBuildGradle(G.CompilationUnit compilationUnit) {
        return compilationUnit.getSourcePath().toString().endsWith(""build.gradle"");
    }

    private static Boolean hasJavaBasePlugin(G.CompilationUnit compilationUnit) {
        return compilationUnit.getMarkers().findFirst(GradleProject.class)
                .map(gp -> gp.getPlugins().stream().anyMatch(it ->
                        it.getFullyQualifiedClassName().contains(""org.gradle.api.plugins.JavaBasePlugin"")))
                .orElse(false);
    }

    private static boolean containsJUnitPlatformInvocation(G.CompilationUnit cu) {
        AtomicBoolean found = new AtomicBoolean(false);
        new GroovyIsoVisitor<AtomicBoolean>() {
            @Override
            public @Nullable J preVisit(J tree, AtomicBoolean found) {
                if (found.get()) {
                    stopAfterPreVisit();
                    return tree;
                }
                return super.preVisit(tree, found);
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation m, AtomicBoolean found) {
                // Groovy gradle scripts being weakly type-attributed means we will miss likely-correct changes if we are too strict
                if (""useJUnitPlatform"".equals(m.getSimpleName()) &&
                    (m.getArguments().isEmpty() ||
                     m.getArguments().size() == 1 &&
                     (m.getArguments().get(0) instanceof J.Empty || m.getArguments().get(0) instanceof J.Lambda))) {
                    found.set(true);
                    return m;
                }
                return super.visitMethodInvocation(m, found);
            }
        }.visit(cu, found);
        return found.get();
    }

    private static class UpdateExistingUseJunit4 extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            // Groovy gradle scripts being weakly type-attributed means we will miss changes if we are too strict
            if (""useJUnit"".equals(m.getSimpleName()) && (m.getArguments().isEmpty() || m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Empty)) {
                JavaType.Method useJUnitPlatformType = Optional.ofNullable(m.getMethodType())
                        .map(JavaType.Method::getDeclaringType)
                        .flatMap(declaringType -> declaringType.getMethods()
                                .stream()
                                .filter(method1 -> ""useJUnitPlatform"".equals(method1.getName()))
                                .findFirst())
                        .orElse(null);
                return m.withName(m.getName().withSimpleName(""useJUnitPlatform""))
                        .withMethodType(useJUnitPlatformType);
            }
            return m;
        }
    }

    private static class AddUseJUnitPlatform extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
            J.MethodInvocation task = createTaskUseJUnitPlatform(ctx, true).orElse(null);
            return cu.withStatements(concat(cu.getStatements(), task));
        }
    }

    private static class AddJUnitPlatformToExistingTestDsl extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            String mName = m.getSimpleName();
            // A non-exhaustive list of common ways by which the task may already be configured
            // test { }
            // tasks.withType(Test) { }
            // tasks.withType(Test).configureEach { }
            // tasks.named(""test"") { }
            // tasks.named(""test"", Test) { }
            switch (mName) {
                case ""test"":
                    if (!(m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda)) {
                        return m;
                    }
                    // Other DSLs may be named ""test"" so only assume it is `test {}` if it isn't enclosed in anything else
                    if (getCursor().getParentTreeCursor().firstEnclosing(J.MethodInvocation.class) != null) {
                        return m;
                    }
                    break;
                case ""named"":
                    if (m.getArguments().isEmpty()) {
                        return m;
                    }
                    if (!(m.getArguments().get(0) instanceof J.Literal && ""test"".equals(((J.Literal) m.getArguments().get(0)).getValue()))) {
                        return m;
                    }
                    // The final argument must be a J.Lambda
                    if (!(m.getArguments().get(m.getArguments().size() - 1) instanceof J.Lambda)) {
                        return m;
                    }
                    break;
                case ""withType"":
                    if (m.getSelect() == null ||
                            !TypeUtils.isOfClassType(m.getSelect().getType(), ""org.gradle.api.tasks.TaskContainer"") ||
                            !(m.getArguments().get(0) instanceof J.Identifier && ""Test"".equals(((J.Identifier) m.getArguments().get(0)).getSimpleName()))) {
                        return m;
                    }
                    break;
                case ""configureEach"":
                    if (m.getArguments().size() != 1 || !(m.getArguments().get(0) instanceof J.Lambda)) {
                        return m;
                    }
                    if (m.getSelect() == null || !(m.getSelect() instanceof J.MethodInvocation)) {
                        return m;
                    }
                    J.MethodInvocation select = (J.MethodInvocation) m.getSelect();
                    if (!""withType"".equals(select.getSimpleName()) ||
                            select.getArguments().size() != 1 ||
                            !(select.getArguments().get(0) instanceof J.Identifier) ||
                            !""Test"".equals(((J.Identifier) select.getArguments().get(0)).getSimpleName())) {
                        return m;
                    }
                    break;
                default:
                    return m;
            }

            return (J.MethodInvocation) new AddJUnitPlatformAsLastStatementInClosure()
                    .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));
        }
    }

    private static class AddJUnitPlatformAsLastStatementInClosure extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public J.Lambda visitLambda(J.Lambda l, ExecutionContext ctx) {
            if (!(l.getBody() instanceof J.Block)) {
                return l;
            }
            return createTaskUseJUnitPlatform(ctx, false)
                    .map(it -> (J.Lambda) it.getArguments().get(1))
                    .map(it -> (J.Block) it.getBody())
                    .map(it -> (J.Return) it.getStatements().get(0))
                    .map(it -> ((J.MethodInvocation) it.getExpression()))
                    .map(useJUnitPlatform -> {
                        J.Block b = (J.Block) l.getBody();
                        J.Lambda j = l.withBody(b.withStatements(concat(b.getStatements(), useJUnitPlatform)));
                        return autoFormat(j, ctx, requireNonNull(getCursor().getParent()));
                    })
                    .orElse(l);
        }
    }

    private static Optional<J.MethodInvocation> createTaskUseJUnitPlatform(ExecutionContext ctx, boolean forEachInvocation) {
        return GradleParser.builder()
                .build()
                .parse(ctx,
                        ""plugins {\n"" +
                                ""    id 'java'\n"" +
                                ""}\n"" +
                                ""tasks.withType(Test)"" + (forEachInvocation ? "".configureEach"" : """") + "" {\n"" +
                                ""    useJUnitPlatform()\n"" +
                                ""}"")
                .map(G.CompilationUnit.class::cast)
                .findFirst()
                .map(it -> (J.MethodInvocation) it.getStatements().get(1));
    }
}
",{}
JUnit 4 `ExpectedException` To JUnit Jupiter's `assertThrows()`,Replace usages of JUnit 4's `@Rule ExpectedException` with JUnit 5's `Assertions.assertThrows()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.junit5;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.staticanalysis.LambdaBlockToExpression;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static org.openrewrite.Tree.randomId;

/**
 * Replace usages of JUnit 4's @Rule ExpectedException with JUnit 5 Assertions.
 * <p>
 * Supported ExpectedException methods:
 * expect(java.lang.Class)
 * expect(org.hamcrest.Matcher)
 * expectMessage(java.lang.String)
 * expectMessage(org.hamcrest.Matcher)
 * expectCause(org.hamcrest.Matcher)
 * <p>
 * Does not currently support migration of ExpectedException.isAnyExceptionExpected().
 */
public class ExpectedExceptionToAssertThrows extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit 4 `ExpectedException` To JUnit Jupiter's `assertThrows()`"";
    }

    @Override
    public String getDescription() {
        return ""Replace usages of JUnit 4's `@Rule ExpectedException` with JUnit 5's `Assertions.assertThrows()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.junit.rules.ExpectedException"", false), new ExpectedExceptionToAssertThrowsVisitor());
    }

    private static class ExpectedExceptionToAssertThrowsVisitor extends JavaIsoVisitor<ExecutionContext> {

        private static final String FIRST_EXPECTED_EXCEPTION_METHOD_INVOCATION = ""firstExpectedExceptionMethodInvocation"";
        private static final String STATEMENTS_AFTER_EXPECT_EXCEPTION = ""statementsAfterExpectException"";
        private static final String HAS_MATCHER = ""hasMatcher"";
        private static final String EXCEPTION_CLASS = ""exceptionClass"";

        private static final MethodMatcher EXPECTED_EXCEPTION_ALL_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expect*(..)"");
        private static final MethodMatcher EXPECTED_EXCEPTION_CLASS_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expect(java.lang.Class)"");
        private static final MethodMatcher EXPECTED_MESSAGE_STRING_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expectMessage(java.lang.String)"");
        private static final MethodMatcher EXPECTED_MESSAGE_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expectMessage(org.hamcrest.Matcher)"");
        private static final MethodMatcher EXPECTED_EXCEPTION_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expect(org.hamcrest.Matcher)"");
        private static final MethodMatcher EXPECTED_EXCEPTION_CAUSE_MATCHER = new MethodMatcher(""org.junit.rules.ExpectedException expectCause(org.hamcrest.Matcher)"");

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

            cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                if (statement instanceof J.VariableDeclarations) {
                    //noinspection ConstantConditions
                    if (TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getTypeExpression().getType(),
                            ""org.junit.rules.ExpectedException"")) {
                        maybeRemoveImport(""org.junit.Rule"");
                        maybeRemoveImport(""org.junit.rules.ExpectedException"");
                        return null;
                    }
                }
                return statement;
            })));
            doAfterVisit(new LambdaBlockToExpression().getVisitor());
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            if (getCursor().pollMessage(""hasExpectException"") != null) {
                List<NameTree> thrown = m.getThrows();
                if (thrown != null && !thrown.isEmpty()) {
                    assert m.getBody() != null;
                    return m.withBody(m.getBody().withPrefix(thrown.get(0).getPrefix())).withThrows(emptyList());
                }
            }
            return m;
        }

        @Override
        public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
            J.Block b = super.visitBlock(block, ctx);
            List<Statement> statementsAfterExpectException = getCursor().pollMessage(STATEMENTS_AFTER_EXPECT_EXCEPTION);
            if (statementsAfterExpectException == null) {
                return b;
            }
            J.Block statementsAfterExpectExceptionBlock = new J.Block(randomId(), Space.EMPTY,
                    Markers.EMPTY, new JRightPadded<>(false, Space.EMPTY, Markers.EMPTY),
                    emptyList(), Space.format("" "")).withStatements(statementsAfterExpectException);
            String exceptionDeclParam = getCursor().pollMessage(HAS_MATCHER) != null ? ""Throwable exception = "" : """";
            Object exceptionClass = getCursor().pollMessage(EXCEPTION_CLASS);
            if (exceptionClass == null) {
                exceptionClass = ""Exception.class"";
            }

            maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertThrows"", false);
            Statement firstExpectedExceptionMethodInvocation = getCursor().getMessage(FIRST_EXPECTED_EXCEPTION_METHOD_INVOCATION);
            String templateString = exceptionClass instanceof String ? ""#{}assertThrows(#{}, () -> #{any()});"" : ""#{}assertThrows(#{any()}, () -> #{any()});"";
            b = JavaTemplate.builder(templateString)
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5"", ""hamcrest-3""))
                    .staticImports(""org.junit.jupiter.api.Assertions.assertThrows"")
                    .build()
                    .apply(
                            updateCursor(b),
                            firstExpectedExceptionMethodInvocation.getCoordinates().before(),
                            exceptionDeclParam,
                            exceptionClass,
                            statementsAfterExpectExceptionBlock
                    );
            Cursor updateCursor = updateCursor(b);
            AtomicBoolean removeStatement = new AtomicBoolean(false);
            J.Identifier exceptionIdentifier = new J.Identifier(Tree.randomId(),
                    Space.EMPTY,
                    Markers.EMPTY,
                    emptyList(),
                    ""exception"",
                    JavaType.ShallowClass.build(""java.lang.Throwable""),
                    null);
            b = b.withStatements(ListUtils.map(b.getStatements(), statement -> {
                if (statement instanceof J.MethodInvocation) {
                    if (EXPECTED_EXCEPTION_ALL_MATCHER.matches((J.MethodInvocation) statement)) {
                        removeStatement.set(true);
                        return getExpectExceptionTemplate((J.MethodInvocation) statement, ctx)
                                .<J.MethodInvocation>map(t -> t.apply(
                                        new Cursor(updateCursor, statement),
                                        statement.getCoordinates().replace(),
                                        exceptionIdentifier,
                                        ((J.MethodInvocation) statement).getArguments().get(0)))
                                .orElse(null);
                    }
                }
                return removeStatement.get() ? null : statement;
            }));
            Statement lastStatement = b.getStatements().get(b.getStatements().size() - 1);
            if (!findSuccessorStatements(new Cursor(updateCursor(b), lastStatement)).isEmpty()) {
                J.Return returnStatement = new J.Return(randomId(), b.getStatements().get(b.getStatements().size() - 1).getPrefix().withComments(emptyList()), Markers.EMPTY, null);
                return b.withStatements(ListUtils.concat(b.getStatements(), returnStatement));
            }
            return b;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (!EXPECTED_EXCEPTION_ALL_MATCHER.matches(method)) {
                return method;
            }
            getCursor().dropParentUntil(J.MethodDeclaration.class::isInstance).putMessage(""hasExpectException"", true);
            getCursor().dropParentUntil(J.Block.class::isInstance).computeMessageIfAbsent(FIRST_EXPECTED_EXCEPTION_METHOD_INVOCATION, k -> method);
            List<Statement> successorStatements = findSuccessorStatements(getCursor());
            getCursor().putMessageOnFirstEnclosing(J.Block.class, STATEMENTS_AFTER_EXPECT_EXCEPTION, successorStatements);
            if (EXPECTED_EXCEPTION_CLASS_MATCHER.matches(method)) {
                getCursor().putMessageOnFirstEnclosing(J.Block.class, EXCEPTION_CLASS, method.getArguments().get(0));
            } else {
                getCursor().putMessageOnFirstEnclosing(J.Block.class, HAS_MATCHER, true);
            }
            return method;
        }

        /**
         * From the current cursor point find all the next statements that can be executed in the current path.
         */
        private List<Statement> findSuccessorStatements(Cursor cursor) {
            if (cursor.firstEnclosing(J.MethodDeclaration.class) == null) {
                return emptyList();
            }
            List<Statement> successorStatements = new ArrayList<>();
            Cursor cursorJustBeforeBlock = getCursor();
            while (!(cursor.getValue() instanceof J.MethodDeclaration)) {
                if (!(cursor.getValue() instanceof J.Block)) {
                    cursorJustBeforeBlock = cursor;
                    cursor = cursor.getParentTreeCursor();
                    continue;
                }
                J.Block block = cursor.getValue();
                boolean found = false;
                for (Statement statement : block.getStatements()) {
                    if (found) {
                        successorStatements.add(statement);
                    } else if (statement == cursorJustBeforeBlock.getValue()) {
                        found = true;
                    }
                }
                cursor = cursor.getParentTreeCursor();
            }
            return successorStatements;
        }

        private Optional<JavaTemplate> getExpectExceptionTemplate(J.MethodInvocation method, ExecutionContext ctx) {
            String template;
            if (EXPECTED_MESSAGE_STRING_MATCHER.matches(method)) {
                maybeAddImport(""org.hamcrest.CoreMatchers"", ""containsString"");
                template = ""assertThat(#{any(java.lang.Throwable)}.getMessage(), containsString(#{any(java.lang.String)}))"";
            } else if (EXPECTED_MESSAGE_MATCHER.matches(method)) {
                template = ""assertThat(#{any(java.lang.Throwable)}.getMessage(), #{any(org.hamcrest.Matcher)})"";
            } else if (EXPECTED_EXCEPTION_MATCHER.matches(method)) {
                template = ""assertThat(#{any(java.lang.Throwable)}, #{any(org.hamcrest.Matcher)})"";
            } else if (EXPECTED_EXCEPTION_CAUSE_MATCHER.matches(method)) {
                template = ""assertThat(#{any(java.lang.Throwable)}.getCause(), #{any(org.hamcrest.Matcher)})"";
            } else {
                return Optional.empty();
            }
            maybeAddImport(""org.hamcrest.MatcherAssert"", ""assertThat"");
            return Optional.of(JavaTemplate.builder(template)
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5"", ""hamcrest-3""))
                    .staticImports(""org.hamcrest.MatcherAssert.assertThat"", ""org.hamcrest.CoreMatchers.containsString"")
                    .build());
        }
    }
}
",{}
Simplify `throws` statements of tests,Replace all thrown exception classes of test method signatures by `Exception`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.jetbrains.annotations.Contract;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.time.Duration;
import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class SimplifyTestThrows extends Recipe {

    private static final String FQN_JAVA_LANG_EXCEPTION = ""java.lang.Exception"";

    @Override
    public String getDisplayName() {
        return ""Simplify `throws` statements of tests"";
    }

    @Override
    public String getDescription() {
        return ""Replace all thrown exception classes of test method signatures by `Exception`."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(""org.junit.jupiter.api.Test"", false),
                        new UsesType<>(""org.junit.jupiter.api.TestTemplate"", false),
                        new UsesType<>(""org.junit.jupiter.api.RepeatedTest"", false),
                        new UsesType<>(""org.junit.jupiter.params.ParameterizedTest"", false),
                        new UsesType<>(""org.junit.jupiter.api.TestFactory"", false)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                        // reject invalid methods
                        if (TypeUtils.isOverride(m.getMethodType()) ||
                            !hasJUnit5MethodAnnotation(m) ||
                            throwsNothingOrExceptionOrThrowable(m.getThrows())) {
                            return m;
                        }

                        // remove imports of the old exceptions
                        for (NameTree t : m.getThrows()) {
                            JavaType.FullyQualified type = TypeUtils.asFullyQualified(t.getType());
                            if (type != null) {
                                maybeRemoveImport(type);
                            }
                        }

                        // overwrite the throws declarations
                        J.Identifier exceptionIdentifier = new J.Identifier(Tree.randomId(),
                                Space.SINGLE_SPACE,
                                Markers.EMPTY,
                                emptyList(),
                                ""Exception"",
                                JavaType.ShallowClass.build(FQN_JAVA_LANG_EXCEPTION),
                                null);
                        return m.withThrows(singletonList(exceptionIdentifier));
                    }

                    /**
                     * @return true if the method has no throws clause or only throws Exception
                     */
                    @Contract(""null -> true"")
                    private boolean throwsNothingOrExceptionOrThrowable(@Nullable List<NameTree> th) {
                        if (th == null || th.isEmpty()) {
                            return true;
                        }
                        return th.size() == 1 &&
                                (TypeUtils.isOfClassType(th.get(0).getType(), FQN_JAVA_LANG_EXCEPTION) ||
                                        TypeUtils.isOfClassType(th.get(0).getType(), ""java.lang.Throwable""));
                    }

                    private boolean hasJUnit5MethodAnnotation(J.MethodDeclaration method) {
                        for (J.Annotation a : method.getLeadingAnnotations()) {
                            if (TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.Test"") ||
                                TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestTemplate"") ||
                                TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.RepeatedTest"") ||
                                TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.params.ParameterizedTest"") ||
                                TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestFactory"")) {
                                return true;
                            }
                        }
                        return false;
                    }
                });
    }
}
",{}
Remove `test` prefix from JUnit 5 tests,"Remove `test` from methods with `@Test`, `@ParameterizedTest`, `@RepeatedTest` or `@TestFactory`. They no longer have to prefix test to be usable by JUnit 5.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.ChangeMethodName;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.J.MethodDeclaration;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

public class RemoveTestPrefix extends Recipe {

    private static final List<String> RESERVED_KEYWORDS = Arrays.asList(""abstract"", ""continue"", ""for"", ""new"", ""switch"",
            ""assert"", ""default"", ""if"", ""package"", ""synchronized"", ""boolean"", ""do"", ""goto"", ""private"", ""this"", ""break"",
            ""double"", ""implements"", ""protected"", ""throw"", ""byte"", ""else"", ""import"", ""public"", ""throws"", ""case"", ""enum"",
            ""instanceof"", ""return"", ""transient"", ""catch"", ""extends"", ""int"", ""short"", ""try"", ""char"", ""final"",
            ""interface"", ""static"", ""void"", ""class"", ""finally"", ""long"", ""strictfp"", ""volatile"", ""const"", ""float"",
            ""native"", ""super"", ""while"",
            // Non keywords that still result in an error
            ""null"", ""clone"", ""finalize"", ""hashCode"", ""notify"", ""notifyAll"", ""toString"", ""wait"");

    @Override
    public String getDisplayName() {
        return ""Remove `test` prefix from JUnit 5 tests"";
    }

    @Override
    public String getDescription() {
        return ""Remove `test` from methods with `@Test`, `@ParameterizedTest`, `@RepeatedTest` or `@TestFactory`. They no longer have to prefix test to be usable by JUnit 5."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(""org.junit.jupiter.api.Test"", false),
                        new UsesType<>(""org.junit.jupiter.api.TestTemplate"", false),
                        new UsesType<>(""org.junit.jupiter.api.RepeatedTest"", false),
                        new UsesType<>(""org.junit.jupiter.params.ParameterizedTest"", false),
                        new UsesType<>(""org.junit.jupiter.api.TestFactory"", false)
                ),
                new RemoveTestPrefixVisitor());
    }

    private static class RemoveTestPrefixVisitor extends JavaIsoVisitor<ExecutionContext> {

        private static final AnnotationMatcher ANNOTATION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.params.provider.MethodSource"");
        private static final String STATIC_IMPORTS = ""STATIC_IMPORTS"";

        @Override
        public J.Import visitImport(J.Import _import, ExecutionContext ctx) {
            J.Import anImport = super.visitImport(_import, ctx);
            if (anImport.isStatic()) {
                Set<String> staticImports = getCursor().getNearestMessage(STATIC_IMPORTS, new HashSet<>());
                staticImports.add(anImport.getQualid().getSimpleName());
                getCursor().putMessageOnFirstEnclosing(J.CompilationUnit.class, STATIC_IMPORTS, staticImports);
            }
            return anImport;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method,
                                                          ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

            // Quickly reject invalid methods
            String simpleName = method.getSimpleName();
            int nameLength = simpleName.length();
            if (nameLength < 5 ||
                    !simpleName.startsWith(""test"") ||
                    !(simpleName.charAt(4) == '_' || Character.isUpperCase(simpleName.charAt(4))) ||
                    TypeUtils.isOverride(method.getMethodType()) ||
                    !hasJUnit5MethodAnnotation(method)) {
                return m;
            }

            // Reject invalid start character
            boolean snakecase = simpleName.charAt(4) == '_' &&
                    5 < nameLength &&
                    Character.isAlphabetic(simpleName.charAt(5));
            if (!snakecase && !Character.isAlphabetic(simpleName.charAt(4))) {
                return m;
            }

            // Avoid reserved keywords
            String newMethodName = snakecase ?
                    NameCaseConvention.format(NameCaseConvention.LOWER_UNDERSCORE, simpleName.substring(5)) :
                    NameCaseConvention.format(NameCaseConvention.LOWER_CAMEL, simpleName.substring(4));
            if (RESERVED_KEYWORDS.contains(newMethodName)) {
                return m;
            }

            // Prevent conflicts with existing methods
            JavaType.Method type = m.getMethodType();
            if (type == null || methodExists(type, newMethodName)) {
                return m;
            }

            // Skip implied methodSource
            for (J.Annotation annotation : method.getLeadingAnnotations()) {
                if (ANNOTATION_MATCHER.matches(annotation) &&
                        (annotation.getArguments() == null || annotation.getArguments().isEmpty())) {
                    return m;
                }
            }

            // Skip when there's a conflicting static import
            if (getCursor().getNearestMessage(STATIC_IMPORTS, new HashSet<>()).contains(newMethodName)) {
                return m;
            }

            // Skip when calling a similarly named method
            AtomicBoolean skip = new AtomicBoolean(false);
            new JavaIsoVisitor<AtomicBoolean>() {
                @Override
                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean atomicBoolean) {
                    if (method.getName().getSimpleName().equals(newMethodName) && method.getSelect() == null) {
                        skip.set(true);
                    }
                    return super.visitMethodInvocation(method, atomicBoolean);
                }
            }.visitMethodDeclaration(m, skip);
            if (skip.get()) {
                return m;
            }

            // Rename method and return
            doAfterVisit(new ChangeMethodName(MethodMatcher.methodPattern(m), newMethodName, false, false).getVisitor());
            return m;
        }

        private boolean methodExists(JavaType.Method method, String newName) {
            return TypeUtils.findDeclaredMethod(method.getDeclaringType(), newName, method.getParameterTypes()).orElse(null) != null;
        }

        private static boolean hasJUnit5MethodAnnotation(MethodDeclaration method) {
            for (J.Annotation a : method.getLeadingAnnotations()) {
                if (TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.Test"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestTemplate"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.RepeatedTest"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.params.ParameterizedTest"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestFactory"")) {
                    return true;
                }
            }
            return false;
        }
    }

}
",{}
Replace JUnit `assertTrue(a == null)` to `assertNull(a)`,Using `assertNull(a)` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class AssertTrueNullToAssertNull extends Recipe {
    private static final MethodMatcher ASSERT_TRUE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertTrue(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertTrue(a == null)` to `assertNull(a)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertNull(a)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_TRUE), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_TRUE.matches(mi) && isEqualBinaryWithNull(mi)) {
                    J.Binary binary = (J.Binary) mi.getArguments().get(0);
                    Expression nonNullExpression = getNonNullExpression(binary);

                    StringBuilder sb = new StringBuilder();
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertNull"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertNull(#{any(java.lang.Object)}"");

                    Object[] args;
                    if (mi.getArguments().size() == 2) {
                        sb.append("", #{any()}"");
                        args = new J[]{nonNullExpression, mi.getArguments().get(1)};
                    } else {
                        args = new J[]{nonNullExpression};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertNull"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                .build();
                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private Expression getNonNullExpression(J.Binary binary) {
                if (binary.getRight() instanceof J.Literal) {
                    boolean isNull = ((J.Literal) binary.getRight()).getValue() == null;
                    if (isNull) {
                        return binary.getLeft();
                    }
                }
                return binary.getRight();
            }

            private boolean isEqualBinaryWithNull(J.MethodInvocation method) {
                if (method.getArguments().isEmpty()) {
                    return false;
                }

                final Expression firstArgument = method.getArguments().get(0);
                if (!(firstArgument instanceof J.Binary)) {
                    return false;
                }

                J.Binary binary = (J.Binary) firstArgument;
                if (binary.getOperator() != J.Binary.Type.Equal) {
                    return false;
                }
                return J.Literal.isLiteralValue(binary.getLeft(), null) ||
                        J.Literal.isLiteralValue(binary.getRight(), null);
            }
        });
    }
}
",{}
"Replace JUnit `assertNotEquals(false, <boolean>)` to `assertFalse(<boolean>)` / `assertTrue(<boolean>)`",Using `assertFalse` or `assertTrue` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

public class AssertNotEqualsBooleanToAssertBoolean extends Recipe {
    private static final MethodMatcher ASSERT_NOT_EQUALS = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertNotEquals(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertNotEquals(false, <boolean>)` to `assertFalse(<boolean>)` / `assertTrue(<boolean>)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertFalse` or `assertTrue` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_NOT_EQUALS.matches(mi) && isBooleanLiteral(mi)) {
                    StringBuilder sb = new StringBuilder();
                    String assertMethod = Boolean.parseBoolean(((J.Literal) mi.getArguments().get(0)).getValueSource()) ?
                            ""assertFalse"" : ""assertTrue"";
                    Expression assertion = mi.getArguments().get(1);
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", assertMethod);
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""#{}(#{any(java.lang.Boolean)}"");
                    Object[] args;
                    if (mi.getArguments().size() == 3) {
                        args = new Object[]{assertMethod, assertion, mi.getArguments().get(2)};
                        sb.append("", #{any()}"");
                    } else {
                        args = new Object[]{assertMethod, mi.getArguments().get(1)};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .staticImports(String.format(""org.junit.jupiter.api.Assertions.%s"", assertMethod))
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isBooleanLiteral(J.MethodInvocation method) {
                if (!method.getArguments().isEmpty() && method.getArguments().get(0) instanceof J.Literal) {
                    J.Literal literal = (J.Literal) method.getArguments().get(0);
                    return JavaType.Primitive.Boolean == literal.getType();
                }

                return false;
            }
        };
    }
}
",{}
Include an assertion in tests,"For tests not having any assertions, wrap the statements with JUnit Jupiter's `Assertions#assertDoesNotThrow(..)`.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.staticanalysis.kotlin.KotlinFileChecker;

import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.singleton;
import static java.util.Collections.singletonList;

@SuppressWarnings(""SimplifyStreamApiCallChains"")
@Value
@EqualsAndHashCode(callSuper = false)
public class TestsShouldIncludeAssertions extends Recipe {
    private static final List<String> TEST_ANNOTATIONS = singletonList(""org.junit.jupiter.api.Test"");

    private static final List<String> DEFAULT_ASSERTIONS = Arrays.asList(
            ""com.github.tomakehurst.wiremock.client.WireMock"",
            ""io.restassured"",
            ""mockit"",
            ""org.assertj.core.api"",
            ""org.easymock"",
            ""org.hamcrest.MatcherAssert"",
            ""org.jmock"",
            ""org.junit.Assert"", // rarely, the test annotation is junit 5 but the assert is junit 4
            ""org.junit.jupiter.api.Assertions"",
            ""org.mockito.Mockito.verify"",
            ""org.mockito.Mockito.verifyNoInteractions"",
            ""org.mockito.Mockito.verifyNoMoreInteractions"",
            ""org.mockito.Mockito.verifyZeroInteractions"",
            ""org.springframework.test.web.client.MockRestServiceServer.verify"",
            ""org.springframework.test.web.servlet.ResultActions"",
            ""reactor.test.StepVerifier""
    );

    @Option(displayName = ""Additional assertions"",
            description = ""A comma delimited list of packages and/or classes that will be identified as assertions. I.E. a common assertion utility `org.foo.TestUtil`."",
            example = ""org.foo.TestUtil, org.bar"",
            required = false)
    @Nullable
    String additionalAsserts;

    @Override
    public String getDisplayName() {
        return ""Include an assertion in tests"";
    }

    @Override
    public String getDescription() {
        return ""For tests not having any assertions, wrap the statements with JUnit Jupiter's `Assertions#assertDoesNotThrow(..)`."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S2699"");
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate()
                .and(Validated.required(""assertions"", DEFAULT_ASSERTIONS));
        if (validated.isValid()) {
            validated = validated.and(Validated.test(
                    ""assertions"",
                    ""Assertions must not be empty and at least contain org.junit.jupiter.api.Assertions"",
                    DEFAULT_ASSERTIONS,
                    a -> a.stream().filter(""org.junit.jupiter.api.Assertions""::equals).findAny().isPresent()));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new UsesType<>(""org.junit.jupiter.api.Test"", false),
                        Preconditions.not(new KotlinFileChecker<>())
                ),
                new TestShouldIncludeAssertionsVisitor(additionalAsserts));
    }

    private static class TestShouldIncludeAssertionsVisitor extends JavaIsoVisitor<ExecutionContext> {

        private final Map<String, Set<J.Block>> matcherPatternToClassInvocation = new HashMap<>();
        private final List<String> additionalAsserts;

        TestShouldIncludeAssertionsVisitor(@Nullable String additionalAsserts) {
            List<String> assertions = new ArrayList<>();
            if (additionalAsserts != null) {
                assertions.addAll(Arrays.asList(additionalAsserts.split("",\\s*"")));
            }
            this.additionalAsserts = assertions;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if ((!methodIsTest(method) || method.getBody() == null || method.getBody().getStatements().isEmpty()) ||
                    methodIsDisabled(method) ||
                    methodHasAssertion(method.getBody()) ||
                    methodInvocationInBodyContainsAssertion()) {
                return method;
            }

            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            J.Block body = md.getBody();
            if (body != null) {
                maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertDoesNotThrow"");
                md = JavaTemplate.builder(""assertDoesNotThrow(() -> #{any()});"")
                        .staticImports(""org.junit.jupiter.api.Assertions.assertDoesNotThrow"")
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                        .build()
                        .apply(updateCursor(md), md.getCoordinates().replaceBody(), body);
            }
            return md;
        }

        private boolean methodIsTest(J.MethodDeclaration methodDeclaration) {
            for (J.Annotation leadingAnnotation : methodDeclaration.getLeadingAnnotations()) {
                for (String testAnnotation : TEST_ANNOTATIONS) {
                    if (TypeUtils.isOfClassType(leadingAnnotation.getType(), testAnnotation)) {
                        return true;
                    }
                }
            }
            return false;
        }

        private boolean methodIsDisabled(J.MethodDeclaration methodDeclaration) {
            for (J.Annotation leadingAnnotation : methodDeclaration.getLeadingAnnotations()) {
                if (TypeUtils.isOfClassType(leadingAnnotation.getType(), ""org.junit.jupiter.api.Disabled"")) {
                    return true;
                }
            }
            return false;
        }

        private boolean methodHasAssertion(J.Block body) {
            AtomicBoolean hasAssertion = new AtomicBoolean(Boolean.FALSE);
            JavaIsoVisitor<AtomicBoolean> findAssertionVisitor = new JavaIsoVisitor<AtomicBoolean>() {
                @Override
                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean atomicBoolean) {
                    J.MethodInvocation mi = super.visitMethodInvocation(method, atomicBoolean);
                    if (isAssertion(mi)) {
                        atomicBoolean.set(Boolean.TRUE);
                    }
                    return mi;
                }
            };
            findAssertionVisitor.visit(body, hasAssertion);
            return hasAssertion.get();
        }

        private boolean methodInvocationInBodyContainsAssertion() {
            J.ClassDeclaration classDeclaration = getCursor().dropParentUntil(org.openrewrite.java.tree.J.ClassDeclaration.class::isInstance).getValue();

            JavaIsoVisitor<Set<MethodMatcher>> findMethodDeclarationsVisitor = new JavaIsoVisitor<Set<MethodMatcher>>() {
                @Override
                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Set<MethodMatcher> methodMatchers) {
                    J.MethodInvocation mi = super.visitMethodInvocation(method, methodMatchers);
                    if (classDeclaration.getType() != null && mi.getMethodType() != null) {
                        JavaType.Method mType = mi.getMethodType();
                        if (classDeclaration.getType().getFullyQualifiedName().equals(mType.getDeclaringType().getFullyQualifiedName())) {
                            methodMatchers.add(new MethodMatcher(mType));
                        }
                    }
                    return mi;
                }
            };

            Set<MethodMatcher> methodMatchers = new HashSet<>();
            findMethodDeclarationsVisitor.visit(classDeclaration, methodMatchers);
            Set<J.Block> methodBodies = new HashSet<>();

            methodMatchers.forEach(matcher -> {
                Set<J.Block> declarationBodies = matcherPatternToClassInvocation.computeIfAbsent(matcher.toString(),
                        k -> findMethodDeclarations(classDeclaration, matcher));
                methodBodies.addAll(declarationBodies);
            });
            return methodBodies.stream().anyMatch(this::methodHasAssertion);
        }

        private Set<J.Block> findMethodDeclarations(J.ClassDeclaration classDeclaration, MethodMatcher methodMatcher) {
            JavaIsoVisitor<Set<J.Block>> findMethodDeclarationVisitor = new JavaIsoVisitor<Set<J.Block>>() {
                @Override
                public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, Set<J.Block> blocks) {
                    J.MethodDeclaration m = super.visitMethodDeclaration(method, blocks);
                    if (methodMatcher.matches(m, classDeclaration)) {
                        if (m.getBody() != null) {
                            blocks.add(m.getBody());
                        }
                    }
                    return m;
                }
            };

            Set<J.Block> blocks = new HashSet<>();
            findMethodDeclarationVisitor.visit(classDeclaration, blocks);
            return blocks;
        }

        private boolean isAssertion(J.MethodInvocation methodInvocation) {
            if (methodInvocation.getMethodType() == null) {
                return false;
            }
            String fqt = methodInvocation.getMethodType().getDeclaringType().getFullyQualifiedName();
            for (String assertionClassOrPackage : DEFAULT_ASSERTIONS) {
                if (fqt.startsWith(assertionClassOrPackage)) {
                    return true;
                }
            }
            String methodFqn = methodInvocation.getMethodType().getDeclaringType().getFullyQualifiedName() + ""."" + methodInvocation.getSimpleName();
            for (String assertMethod : DEFAULT_ASSERTIONS) {
                if (assertMethod.equals(methodFqn)) {
                    return true;
                }
            }
            if (additionalAsserts != null) {
                for (String assertionClassOrPackage : additionalAsserts) {
                    if (fqt.startsWith(assertionClassOrPackage)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
",{}
Replace JUnit `assertFalse(!<boolean>)` to `assertTrue(<boolean>)`,Using `assertTrue` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;

public class AssertFalseNegationToAssertTrue extends Recipe {
    private static final MethodMatcher ASSERT_FALSE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertFalse(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertFalse(!<boolean>)` to `assertTrue(<boolean>)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertTrue` is simpler and more clear."";
    }


    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_FALSE.matches(method) && isUnaryOperatorNot(method)) {
                    StringBuilder sb = new StringBuilder();
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertTrue"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertTrue(#{any(java.lang.Boolean)}"");
                    J.Unary unary = (J.Unary) method.getArguments().get(0);

                    Object[] args;
                    if (method.getArguments().size() == 2) {
                        args = new Object[]{unary.getExpression(), mi.getArguments().get(1)};
                        sb.append("", #{any()}"");
                    } else {
                        args = new Object[]{unary.getExpression()};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertTrue"")
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return  t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isUnaryOperatorNot(J.MethodInvocation method) {
                if (!method.getArguments().isEmpty() && method.getArguments().get(0) instanceof J.Unary) {
                    J.Unary unary = (J.Unary) method.getArguments().get(0);
                    return unary.getOperator() == J.Unary.Type.Not;
                }

                return false;
            }
        };
    }
}
",{}
"Junit `assertTrue(a == b)` to `assertEquals(a,b)`","Using `assertEquals(a,b)` is simpler and more clear.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

public class AssertTrueComparisonToAssertEquals extends Recipe {
    private static final MethodMatcher ASSERT_TRUE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertTrue(..)"");

    @Override
    public String getDisplayName() {
        return ""Junit `assertTrue(a == b)` to `assertEquals(a,b)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertEquals(a,b)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_TRUE), new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_TRUE.matches(mi) && isEqualBinary(mi)) {
                    J.Binary binary = (J.Binary) mi.getArguments().get(0);
                    StringBuilder sb = new StringBuilder();
                    Object[] args;
                    if (mi.getSelect() != null) {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertEquals(#{any(java.lang.Object)}, #{any(java.lang.Object)}"");
                    if (mi.getArguments().size() == 2) {
                        sb.append("", #{any()}"");
                        args = new Object[]{binary.getLeft(), binary.getRight(), mi.getArguments().get(1)};
                    } else {
                        args = new Object[]{binary.getLeft(), binary.getRight()};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertEquals"");
                        t = JavaTemplate.builder(sb.toString())
                                .javaParser(javaParser(ctx))
                                .staticImports(""org.junit.jupiter.api.Assertions.assertEquals"")
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .javaParser(javaParser(ctx))
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .build();

                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isEqualBinary(J.MethodInvocation method) {

                if (method.getArguments().isEmpty()) {
                    return false;
                }

                final Expression firstArgument = method.getArguments().get(0);
                if (!(firstArgument instanceof J.Binary)) {
                    return false;
                }

                J.Binary binary = (J.Binary) firstArgument;
                J.Binary.Type operator = binary.getOperator();

                if (operator != J.Binary.Type.Equal) {
                    return false;
                }

                // Prevent breaking identity comparison.
                // Objects that are compared with == should not be compared with `.equals()` instead.
                // Out of the primitives == is not allowed when both are of type String
                return binary.getLeft().getType() instanceof JavaType.Primitive &&
                       binary.getRight().getType() instanceof JavaType.Primitive &&
                       !(binary.getLeft().getType() == JavaType.Primitive.String &&
                            binary.getRight().getType() == JavaType.Primitive.String);
            }
        });
    }
}
",{}
Replace JUnit `assertFalse(a == null)` to `assertNotNull(a)`,Using `assertNotNull(a)` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class AssertFalseNullToAssertNotNull extends Recipe {
    private static final MethodMatcher ASSERT_FALSE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertFalse(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertFalse(a == null)` to `assertNotNull(a)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertNotNull(a)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_FALSE), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_FALSE.matches(mi) && isEqualBinaryWithNull(mi)) {
                    J.Binary binary = (J.Binary) mi.getArguments().get(0);
                    Expression nonNullExpression = getNonNullExpression(binary);

                    StringBuilder sb = new StringBuilder();
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertNotNull"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertNotNull(#{any(java.lang.Object)}"");

                    Object[] args;
                    if (mi.getArguments().size() == 2) {
                        sb.append("", #{any()}"");
                        args = new J[]{nonNullExpression, mi.getArguments().get(1)};
                    } else {
                        args = new J[]{nonNullExpression};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertNotNull"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                .build();
                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private Expression getNonNullExpression(J.Binary binary) {
                if (binary.getRight() instanceof J.Literal) {
                    boolean isNull = ((J.Literal) binary.getRight()).getValue() == null;
                    if (isNull) {
                        return binary.getLeft();
                    }
                }
                return binary.getRight();
            }

            private boolean isEqualBinaryWithNull(J.MethodInvocation method) {
                if (method.getArguments().isEmpty()) {
                    return false;
                }

                final Expression firstArgument = method.getArguments().get(0);
                if (!(firstArgument instanceof J.Binary)) {
                    return false;
                }

                J.Binary binary = (J.Binary) firstArgument;
                if (binary.getOperator() != J.Binary.Type.Equal) {
                    return false;
                }
                return J.Literal.isLiteralValue(binary.getLeft(), null) ||
                        J.Literal.isLiteralValue(binary.getRight(), null);
            }
        });
    }
}
",{}
"Replace JUnit `assertFalse(a.equals(b))` to `assertNotEquals(a,b)`","Using `assertNotEquals(a,b)` is simpler and more clear.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class AssertFalseEqualsToAssertNotEquals extends Recipe {
    private static final MethodMatcher ASSERT_FALSE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertFalse(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertFalse(a.equals(b))` to `assertNotEquals(a,b)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertNotEquals(a,b)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_FALSE), new JavaVisitor<ExecutionContext>() {
            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_FALSE.matches(method) && isEquals(method.getArguments().get(0))) {
                    StringBuilder sb = new StringBuilder();
                    Object[] args;
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertNotEquals"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertNotEquals(#{any(java.lang.Object)}, #{any(java.lang.Object)}"");
                    if (mi.getArguments().size() == 2) {
                        sb.append("", #{any()}"");
                    }
                    sb.append("")"");

                    J.MethodInvocation s = (J.MethodInvocation) method.getArguments().get(0);
                    args = method.getArguments().size() == 2 ? new Object[]{s.getSelect(), s.getArguments().get(0), mi.getArguments().get(1)} : new Object[]{s.getSelect(), s.getArguments().get(0)};
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertNotEquals"")
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return  t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isEquals(Expression expr) {
                if (!(expr instanceof J.MethodInvocation)) {
                    return false;
                }

                J.MethodInvocation methodInvocation = (J.MethodInvocation) expr;

                return ""equals"".equals(methodInvocation.getName().getSimpleName()) &&
                        methodInvocation.getArguments().size() == 1;
            }
        });
    }
}
",{}
Assertion arguments should be passed in the correct order,"Assertions such as `org.junit.Assert.assertEquals` expect the first argument to be the expected value and the second argument to be the actual value; for `org.testng.Assert`, its the other way around.  This recipe detects `J.Literal`, `J.NewArray`, and `java.util.Iterable` arguments swapping them if necessary so that the error messages won't be confusing.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.Flag;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;

public class AssertionsArgumentOrder extends Recipe {

    private static final MethodMatcher[] jupiterAssertionMatchers = new MethodMatcher[]{
            new MethodMatcher(""org.junit.jupiter.api.Assertions assertArrayEquals(..)""),
            new MethodMatcher(""org.junit.jupiter.api.Assertions assertEquals(..)""),
            new MethodMatcher(""org.junit.jupiter.api.Assertions assertNotEquals(..)""),
            new MethodMatcher(""org.junit.jupiter.api.Assertions assertSame(..)""),
            new MethodMatcher(""org.junit.jupiter.api.Assertions assertNotSame(..)"")
    };

    private static final MethodMatcher[] junitAssertMatchers = new MethodMatcher[]{
            new MethodMatcher(""org.junit.Assert assertEquals(..)""),
            new MethodMatcher(""org.junit.Assert assertEquals(..)""),
            new MethodMatcher(""org.junit.Assert assertArrayEquals(..)""),
            new MethodMatcher(""org.junit.Assert assertSame(..)""),
            new MethodMatcher(""org.junit.Assert assertNotSame(..)""),
            new MethodMatcher(""org.junit.Assert assert*Null(String, Object)"")
    };

    private static final MethodMatcher[] junitAssertWithMessageMatchers = new MethodMatcher[]{
            new MethodMatcher(""org.junit.Assert assertEquals(String, ..)""),
            new MethodMatcher(""org.junit.Assert assertArrayEquals(String, ..)"")
    };
    private static final MethodMatcher jupiterAssertIterableEqualsMatcher = new MethodMatcher(""org.junit.jupiter.api.Assertions assertIterableEquals(..)"");

    // `assertNull(""message"", result())` should be `assertNull(result(), ""message"")`
    private static final MethodMatcher jupiterAssertNullMatcher = new MethodMatcher(""org.junit.jupiter.api.Assertions assert*Null(Object, String)"");

    private static final MethodMatcher[] testNgMatcher = new MethodMatcher[]{
            new MethodMatcher(""org.testng.Assert assertSame(..)""),
            new MethodMatcher(""org.testng.Assert assertNotSame(..)""),
            new MethodMatcher(""org.testng.Assert assertEquals(..)""),
            new MethodMatcher(""org.testng.Assert assertNotEquals(..)"")
    };

    private static final TreeVisitor<?, ExecutionContext> precondition;

    static {
        List<MethodMatcher> matchers = new ArrayList<>(Arrays.asList(jupiterAssertionMatchers));
        matchers.addAll(Arrays.asList(junitAssertMatchers));
        matchers.addAll(Arrays.asList(junitAssertWithMessageMatchers));
        matchers.add(jupiterAssertIterableEqualsMatcher);
        matchers.add(jupiterAssertNullMatcher);
        matchers.addAll(Arrays.asList(testNgMatcher));
        //noinspection unchecked
        precondition = Preconditions.or(matchers.stream().map(UsesMethod::new).toArray(TreeVisitor[]::new));
    }

    @Override
    public String getDisplayName() {
        return ""Assertion arguments should be passed in the correct order"";
    }

    @Override
    public String getDescription() {
        return ""Assertions such as `org.junit.Assert.assertEquals` expect the first argument to be the expected value and the second argument to be the actual value; for `org.testng.Assert`, its the other way around.  This recipe detects `J.Literal`, `J.NewArray`, and `java.util.Iterable` arguments swapping them if necessary so that the error messages won't be confusing."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S3415"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(precondition, new AssertionsArgumentOrderVisitor());
    }

    private static class AssertionsArgumentOrderVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher[] newListMatchers = new MethodMatcher[]{
                new MethodMatcher(""java.util.List of(..)""),
                new MethodMatcher(""java.util.Collections singleton(..)""),
                new MethodMatcher(""java.util.Collections empty()""),
                new MethodMatcher(""java.util.Arrays asList(..)""),
        };

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

            final Expression expected;
            final Expression actual;
            if (isJunitAssertEqualsWithMessage(mi)) {
                expected = mi.getArguments().get(1);
                actual = mi.getArguments().get(2);
            } else if (isJunitAssertion(mi) || isJupiterAssertion(mi)) {
                expected = mi.getArguments().get(0);
                actual = mi.getArguments().get(1);
            } else if (isTestNgAssertion(mi)) {
                expected = mi.getArguments().get(1);
                actual = mi.getArguments().get(0);
            } else {
                return mi;
            }

            if (!isCorrectOrder(expected, actual, mi)) {
                mi = maybeAutoFormat(mi, mi.withArguments(ListUtils.map(mi.getArguments(), arg -> {
                    if (arg.equals(actual)) {
                        return expected;
                    }
                    if (arg.equals(expected)) {
                        return actual;
                    }
                    return arg;
                })), ctx, getCursor().getParentOrThrow());
            }
            return mi;
        }

        private boolean isCorrectOrder(Expression expected, Expression actual, J.MethodInvocation mi) {
            if (jupiterAssertNullMatcher.matches(mi)) {
                return isConstant(actual, mi) || !isConstant(expected, mi);
            }
            return isConstant(expected, mi) || !isConstant(actual, mi);
        }

        private boolean isConstant(Expression expression, J.MethodInvocation mi) {
            if (expression instanceof J.Literal) {
                return true;
            }

            if (expression instanceof J.NewArray) {
                return true;
            }

            // static final field
            JavaType.Variable var = null;
            if (expression instanceof J.Identifier) {
                var = ((J.Identifier) expression).getFieldType();
            } else if (expression instanceof J.FieldAccess) {
                var = ((J.FieldAccess) expression).getName().getFieldType();
            }
            if (var != null) {
                return var.hasFlags(Flag.Static, Flag.Final);
            }

            if (jupiterAssertIterableEqualsMatcher.matches(mi)) {
                for (MethodMatcher iterableMatcher : newListMatchers) {
                    if (iterableMatcher.matches(expression)) {
                        return true;
                    }
                }
            }
            return false;
        }

        private boolean isJupiterAssertion(J.MethodInvocation mi) {
            for (MethodMatcher assertionMethodMatcher : jupiterAssertionMatchers) {
                if (assertionMethodMatcher.matches(mi)) {
                    return true;
                }
            }
            return jupiterAssertIterableEqualsMatcher.matches(mi) || jupiterAssertNullMatcher.matches(mi);
        }

        private boolean isTestNgAssertion(J.MethodInvocation mi) {
            for (MethodMatcher actExpMatcher : testNgMatcher) {
                if (actExpMatcher.matches(mi)) {
                    return true;
                }
            }
            return false;
        }

        private boolean isJunitAssertion(J.MethodInvocation mi) {
            for (MethodMatcher assertionMethodMatcher : junitAssertMatchers) {
                if (assertionMethodMatcher.matches(mi)) {
                    return true;
                }
            }
            return false;
        }

        private boolean isJunitAssertEqualsWithMessage(J.MethodInvocation mi) {
            for (MethodMatcher actExpMatcher : junitAssertWithMessageMatchers) {
                if (actExpMatcher.matches(mi)) {
                    return true;
                }
            }
            return false;
        }
    }
}
",{}
Replace JUnit `assertTrue(!<boolean>)` to `assertFalse(<boolean>)`,Using `assertFalse` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;

public class AssertTrueNegationToAssertFalse extends Recipe {
    private static final MethodMatcher ASSERT_TRUE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertTrue(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertTrue(!<boolean>)` to `assertFalse(<boolean>)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertFalse` is simpler and more clear."";
    }


    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_TRUE.matches(mi) && isUnaryOperatorNot(mi)) {
                    StringBuilder sb = new StringBuilder();
                    J.Unary unary = (J.Unary) mi.getArguments().get(0);
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertFalse"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertFalse(#{any(java.lang.Boolean)}"");
                    Object[] args;
                    if (mi.getArguments().size() == 2) {
                        args = new Object[]{unary.getExpression(), mi.getArguments().get(1)};
                        sb.append("", #{any()}"");
                    } else {
                        args = new Object[]{unary.getExpression()};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertFalse"")
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return  t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isUnaryOperatorNot(J.MethodInvocation method) {
                if (!method.getArguments().isEmpty() && method.getArguments().get(0) instanceof J.Unary) {
                    J.Unary unary = (J.Unary) method.getArguments().get(0);
                    return unary.getOperator() == J.Unary.Type.Not;
                }

                return false;
            }
        };
    }
}
",{}
Remove `public` visibility of JUnit 5 tests,"Remove `public` and optionally `protected` modifiers from methods with `@Test`, `@ParameterizedTest`, `@RepeatedTest`, `@TestFactory`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, or `@AfterAll`. They no longer have to be public visibility to be usable by JUnit 5.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.ChangeMethodAccessLevelVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.Flag;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;

@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class TestsShouldNotBePublic extends ScanningRecipe<TestsShouldNotBePublic.Accumulator> {

    @Option(displayName = ""Remove protected modifiers"",
            description = ""Also remove protected modifiers from test methods"",
            example = ""true"",
            required = false)
    @Nullable
    private Boolean removeProtectedModifiers;

    @Override
    public String getDisplayName() {
        return ""Remove `public` visibility of JUnit 5 tests"";
    }

    @Override
    public String getDescription() {
        return ""Remove `public` and optionally `protected` modifiers from methods with `@Test`, `@ParameterizedTest`, `@RepeatedTest`, `@TestFactory`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, or `@AfterAll`. They no longer have to be public visibility to be usable by JUnit 5."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S5786"");
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDeclaration, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDeclaration, ctx);
                if (cd.getExtends() != null) {
                    acc.extendedClasses.add(String.valueOf(cd.getExtends().getType()));
                }
                return cd;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TestsNotPublicVisitor(Boolean.TRUE.equals(removeProtectedModifiers), acc);
    }

    public static class Accumulator {
        Set<String> extendedClasses = new HashSet<>();
    }

    @RequiredArgsConstructor
    private static final class TestsNotPublicVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final Boolean orProtected;
        private final Accumulator acc;

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);

            if (c.getKind() != J.ClassDeclaration.Kind.Type.Interface &&
                    c.getModifiers().stream().anyMatch(mod -> mod.getType() == J.Modifier.Type.Public) &&
                    c.getModifiers().stream().noneMatch(mod -> mod.getType() == J.Modifier.Type.Abstract) &&
                    !acc.extendedClasses.contains(String.valueOf(c.getType()))) {
                boolean hasTestMethods = c.getBody().getStatements().stream()
                        .filter(org.openrewrite.java.tree.J.MethodDeclaration.class::isInstance)
                        .map(J.MethodDeclaration.class::cast)
                        .anyMatch(this::hasJUnit5MethodAnnotation);

                boolean hasPublicNonTestMethods = c.getBody().getStatements().stream()
                        .filter(org.openrewrite.java.tree.J.MethodDeclaration.class::isInstance)
                        .map(J.MethodDeclaration.class::cast)
                        .filter(m -> m.getModifiers().stream().anyMatch(mod -> mod.getType() == J.Modifier.Type.Public))
                        .anyMatch(method -> !hasJUnit5MethodAnnotation(method));

                boolean hasPublicVariableDeclarations = c.getBody().getStatements().stream()
                        .filter(org.openrewrite.java.tree.J.VariableDeclarations.class::isInstance)
                        .map(J.VariableDeclarations.class::cast)
                        .anyMatch(m -> m.getModifiers().stream().anyMatch(mod -> mod.getType() == J.Modifier.Type.Public));

                if (hasTestMethods && !hasPublicNonTestMethods && !hasPublicVariableDeclarations) {
                    // Remove public modifier and move associated comment
                    final List<Comment> modifierComments = new ArrayList<>();
                    List<J.Modifier> modifiers = ListUtils.map(c.getModifiers(), mod -> {
                        if (mod.getType() == J.Modifier.Type.Public) {
                            modifierComments.addAll(mod.getComments());
                            return null;
                        }

                        // copy access level modifier comment to next modifier if it exists
                        if (!modifierComments.isEmpty()) {
                            J.Modifier nextModifier = mod.withComments(ListUtils.concatAll(new ArrayList<>(modifierComments), mod.getComments()));
                            modifierComments.clear();
                            return nextModifier;
                        }
                        return mod;
                    });
                    // if no following modifier exists, add comments to method itself
                    if (!modifierComments.isEmpty()) {
                        c = c.withComments(ListUtils.concatAll(c.getComments(), modifierComments));
                    }
                    c = maybeAutoFormat(c, c.withModifiers(modifiers), c.getName(), ctx, getCursor().getParentTreeCursor());
                }
            }
            return c;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

            if (method.getMethodType() == null ||
                    method.getMethodType().getDeclaringType().hasFlags(Flag.Abstract, Flag.Public)) {
                return m;
            }

            if (m.hasModifier(J.Modifier.Type.Abstract) || TypeUtils.isOverride(method.getMethodType())) {
                return m;
            }

            if ((m.hasModifier(J.Modifier.Type.Public) || (orProtected && m.hasModifier(J.Modifier.Type.Protected))) &&
                hasJUnit5MethodAnnotation(m)) {
                // remove public modifier
                doAfterVisit(new ChangeMethodAccessLevelVisitor<>(new MethodMatcher(method), null));
            }

            return m;
        }

        private boolean hasJUnit5MethodAnnotation(J.MethodDeclaration method) {
            for (J.Annotation a : method.getLeadingAnnotations()) {
                if (TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.Test"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.RepeatedTest"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.params.ParameterizedTest"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestFactory"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.TestTemplate"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.AfterEach"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.BeforeEach"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.AfterAll"") ||
                        TypeUtils.isOfClassType(a.getType(), ""org.junit.jupiter.api.BeforeAll"")) {
                    return true;
                }
            }
            return false;
        }
    }
}
",{}
Test methods should have void return type,"Test methods annotated with `@Test`, `@ParameterizedTest`, `@RepeatedTest`, `@TestTemplate` ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import static java.util.Objects.requireNonNull;

public class TestMethodsShouldBeVoid extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Test methods should have void return type"";
    }

    @Override
    public String getDescription() {
        return ""Test methods annotated with `@Test`, `@ParameterizedTest`, `@RepeatedTest`, `@TestTemplate` "" +
                ""should have `void` return type. Non-void return types can cause test discovery issues, "" +
                ""and warnings as of JUnit 5.13+. This recipe changes the return type to `void` and removes `return` statements."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                // Check if method has a test annotation & body
                if (!hasTestAnnotation(m) || m.getBody() == null) {
                    return m;
                }

                // Check if return type is already void
                JavaType.Primitive voidType = JavaType.Primitive.Void;
                if (m.getReturnTypeExpression() == null || TypeUtils.isOfType(m.getReturnTypeExpression().getType(), voidType)) {
                    return m;
                }

                // Change return type to void
                m = m.withReturnTypeExpression(new J.Primitive(
                        m.getReturnTypeExpression().getId(),
                        m.getReturnTypeExpression().getPrefix(),
                        m.getReturnTypeExpression().getMarkers(),
                        JavaType.Primitive.Void
                ));

                // Update method type
                if (m.getMethodType() != null) {
                    m = m.withMethodType(m.getMethodType().withReturnType(voidType));
                }

                // Remove return statements that are not in nested classes or lambdas
                return m.withBody((J.Block) new RemoveDirectReturns().visitBlock(requireNonNull(m.getBody()), ctx));
            }

            private boolean hasTestAnnotation(J.MethodDeclaration method) {
                for (J.Annotation annotation : method.getLeadingAnnotations()) {
                    if (TypeUtils.isOfClassType(annotation.getType(), ""org.junit.Test"") ||
                            TypeUtils.isOfClassType(annotation.getType(), ""org.junit.jupiter.api.RepeatedTest"") ||
                            TypeUtils.isOfClassType(annotation.getType(), ""org.junit.jupiter.api.Test"") ||
                            TypeUtils.isOfClassType(annotation.getType(), ""org.junit.jupiter.api.TestTemplate"") ||
                            TypeUtils.isOfClassType(annotation.getType(), ""org.junit.jupiter.params.ParameterizedTest"")) {
                        return true;
                    }
                }
                return false;
            }
        };
    }

    private static class RemoveDirectReturns extends JavaVisitor<ExecutionContext> {
        @Override
        public J visitLambda(J.Lambda lambda, ExecutionContext ctx) {
            return lambda; // Retain nested returns
        }

        @Override
        public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            return newClass; // Retain nested returns
        }

        @Override
        public @Nullable J visitReturn(J.Return retrn, ExecutionContext ctx) {
            return retrn.getExpression() instanceof Statement ?
                    // Retain any side effects from expressions in return statements
                    retrn.getExpression().withPrefix(retrn.getPrefix()) :
                    // Remove any other return statements
                    null;
        }
    }
}
",{}
Remove empty tests without comments,Removes empty methods with a `@Test` annotation if the body does not have comments.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.FindEmptyMethods;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.J.MethodDeclaration;

import java.time.Duration;
import java.util.Set;

import static java.util.Collections.singleton;

public class RemoveEmptyTests extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove empty tests without comments"";
    }

    @Override
    public String getDescription() {
        return ""Removes empty methods with a `@Test` annotation if the body does not have comments."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S1186"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindEmptyMethods(false), new JavaVisitor<ExecutionContext>() {

            @Override
            public @Nullable J visitMethodDeclaration(MethodDeclaration method, ExecutionContext ctx) {
                if (hasTestAnnotation(method) && isEmptyMethod(method)) {
                    //noinspection ConstantConditions
                    return null;
                }
                return super.visitMethodDeclaration(method, ctx);
            }

            private boolean hasTestAnnotation(J.MethodDeclaration method) {
                return method.getLeadingAnnotations().stream()
                        .filter(o -> o.getAnnotationType() instanceof J.Identifier)
                        .anyMatch(o -> ""Test"".equals(o.getSimpleName()));
            }

            private boolean isEmptyMethod(J.MethodDeclaration method) {
                return !method.isConstructor() &&
                        (method.getBody() == null || method.getBody().getStatements().isEmpty() && method.getBody().getEnd().getComments().isEmpty());
            }
        });
    }
}
",{}
"Replace JUnit `assertTrue(a.equals(b))` to `assertEquals(a,b)`","Using `assertEquals(a,b)` is simpler and more clear.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class AssertTrueEqualsToAssertEquals extends Recipe {
    private static final MethodMatcher ASSERT_TRUE = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertTrue(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertTrue(a.equals(b))` to `assertEquals(a,b)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertEquals(a,b)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_TRUE), new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_TRUE.matches(mi) && isEquals(mi.getArguments().get(0))) {
                    StringBuilder sb = new StringBuilder();
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertEquals"");
                    } else {
                        sb.append(""Assertions."");
                    }
                    J.MethodInvocation s = (J.MethodInvocation) mi.getArguments().get(0);
                    sb.append(""assertEquals(#{any(java.lang.Object)},#{any(java.lang.Object)}"");
                    Object[] args;
                    if (mi.getArguments().size() == 2) {
                        args = new Object[]{s.getSelect(), s.getArguments().get(0), mi.getArguments().get(1)};
                        sb.append("", #{any()}"");
                    } else {
                        args = new Object[]{s.getSelect(), s.getArguments().get(0)};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .staticImports(""org.junit.jupiter.api.Assertions.assertEquals"")
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .imports(""org.junit.jupiter.api.Assertions.assertEquals"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return  t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isEquals(Expression expr) {
                if (!(expr instanceof J.MethodInvocation)) {
                    return false;
                }

                J.MethodInvocation methodInvocation = (J.MethodInvocation) expr;

                return ""equals"".equals(methodInvocation.getName().getSimpleName()) &&
                        methodInvocation.getArguments().size() == 1;
            }
        });
    }
}
",{}
"`assertEquals(a, null)` to `assertNull(a)`",Using `assertNull(a)` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

public class AssertEqualsNullToAssertNull extends Recipe {
    private static final MethodMatcher ASSERT_EQUALS = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertEquals(..)"");

    @Override
    public String getDisplayName() {
        return ""`assertEquals(a, null)` to `assertNull(a)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertNull(a)` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ASSERT_EQUALS), new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_EQUALS.matches(method) && hasNullLiteralArg(mi)) {
                    StringBuilder sb = new StringBuilder();
                    Object[] args;
                    if (mi.getSelect() != null) {
                        sb.append(""Assertions."");
                    }
                    sb.append(""assertNull(#{any(java.lang.Object)}"");
                    if (mi.getArguments().size() == 3) {
                        sb.append("", #{any()}"");
                        args = new Object[]{(isNullLiteral(mi.getArguments().get(0)) ? mi.getArguments().get(1) : mi.getArguments().get(0)), mi.getArguments().get(2)};
                    } else {
                        args = new Object[]{(isNullLiteral(mi.getArguments().get(0)) ? mi.getArguments().get(1) : mi.getArguments().get(0))};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (method.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", ""assertNull"");
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .javaParser(javaParser(ctx))
                                .staticImports(""org.junit.jupiter.api.Assertions.assertNull"").build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .contextSensitive()
                                .javaParser(javaParser(ctx))
                                .imports(""org.junit.jupiter.api.Assertions.assertNull"").build();
                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean hasNullLiteralArg(J.MethodInvocation method) {
                if (method.getArguments().size() > 1) {
                    return isNullLiteral(method.getArguments().get(0)) || isNullLiteral(method.getArguments().get(1));
                }
                return false;
            }

            private boolean isNullLiteral(Expression expr) {
                return expr.getType() == JavaType.Primitive.Null;
            }
        });
    }
}
",{}
"Replace JUnit `assertEquals(false, <boolean>)` to `assertFalse(<boolean>)` / `assertTrue(<boolean>)`",Using `assertFalse` or `assertTrue` is simpler and more clear.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

public class AssertEqualsBooleanToAssertBoolean extends Recipe {
    private static final MethodMatcher ASSERT_EQUALS = new MethodMatcher(
            ""org.junit.jupiter.api.Assertions assertEquals(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace JUnit `assertEquals(false, <boolean>)` to `assertFalse(<boolean>)` / `assertTrue(<boolean>)`"";
    }

    @Override
    public String getDescription() {
        return ""Using `assertFalse` or `assertTrue` is simpler and more clear."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {

            JavaParser.Builder<?, ?> javaParser = null;

            private JavaParser.Builder<?, ?> javaParser(ExecutionContext ctx) {
                if (javaParser == null) {
                    javaParser = JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""junit-jupiter-api-5"");
                }
                return javaParser;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ASSERT_EQUALS.matches(mi) && isBooleanLiteral(mi) &&
                        JavaType.Primitive.Boolean == mi.getArguments().get(1).getType()) {
                    StringBuilder sb = new StringBuilder();
                    String assertMethod = Boolean.parseBoolean(((J.Literal) mi.getArguments().get(0)).getValueSource()) ?
                            ""assertTrue"" : ""assertFalse"";
                    Expression assertion = mi.getArguments().get(1);
                    if (mi.getSelect() == null) {
                        maybeRemoveImport(""org.junit.jupiter.api.Assertions"");
                        maybeAddImport(""org.junit.jupiter.api.Assertions"", assertMethod);
                    } else {
                        sb.append(""Assertions."");
                    }
                    sb.append(""#{}(#{any(java.lang.Boolean)}"");
                    Object[] args;
                    if (mi.getArguments().size() == 3) {
                        args = new Object[]{assertMethod, assertion, mi.getArguments().get(2)};
                        sb.append("", #{any()}"");
                    } else {
                        args = new Object[]{assertMethod, mi.getArguments().get(1)};
                    }
                    sb.append("")"");
                    JavaTemplate t;
                    if (mi.getSelect() == null) {
                        t = JavaTemplate.builder(sb.toString())
                                .staticImports(String.format(""org.junit.jupiter.api.Assertions.%s"", assertMethod))
                                .javaParser(javaParser(ctx))
                                .build();
                    } else {
                        t = JavaTemplate.builder(sb.toString())
                                .imports(""org.junit.jupiter.api.Assertions"")
                                .javaParser(javaParser(ctx))
                                .build();
                    }
                    return t.apply(updateCursor(mi), mi.getCoordinates().replace(), args);
                }
                return mi;
            }

            private boolean isBooleanLiteral(J.MethodInvocation method) {
                if (!method.getArguments().isEmpty() && method.getArguments().get(0) instanceof J.Literal) {
                    J.Literal literal = (J.Literal) method.getArguments().get(0);
                    return JavaType.Primitive.Boolean == literal.getType();
                }

                return false;
            }
        };
    }
}
",{}
Add image argument to container constructor,"Set the image to use for a container explicitly if unset, rather than relying on the default image for the container class.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.testcontainers;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

import static java.util.Collections.singletonList;

@RequiredArgsConstructor
public class ExplicitContainerImage extends Recipe {
    @Option(displayName = ""Container class"",
            description = ""The fully qualified name of the container class to use."",
            example = ""org.testcontainers.containers.NginxContainer"")
    private final String containerClass;

    @Option(displayName = ""Image to use"",
            description = ""The image to use for the container."",
            example = ""nginx:1.9.4"")
    private final String image;

    @Option(displayName = ""Parse image"",
            description = ""Whether to call `DockerImageName.parse(image)`."",
            required = false)
    @Nullable
    private final Boolean parseImage;

    @Override
    public String getDisplayName() {
        return ""Add image argument to container constructor"";
    }

    @Override
    public String getDescription() {
        return ""Set the image to use for a container explicitly if unset, rather than relying on the default image for the container class."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        final MethodMatcher methodMatcher = new MethodMatcher(containerClass + "" <constructor>()"");
        return Preconditions.check(new UsesMethod<>(methodMatcher), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J.NewClass nc = super.visitNewClass(newClass, ctx);
                if (methodMatcher.matches(nc)) {
                    Expression constructorArgument = getConstructorArgument(nc, ctx);
                    return nc.withArguments(singletonList(constructorArgument))
                            .withMethodType(nc.getMethodType()
                                    .withParameterTypes(singletonList(constructorArgument.getType()))
                                    .withParameterNames(singletonList(""image"")));
                }
                return nc;
            }

            private Expression getConstructorArgument(J.NewClass newClass, ExecutionContext ctx) {
                if (parseImage != null && parseImage) {
                    maybeAddImport(""org.testcontainers.utility.DockerImageName"");
                    return JavaTemplate.builder(""DockerImageName.parse(\"""" + image + ""\"")"")
                            .imports(""org.testcontainers.utility.DockerImageName"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""testcontainers""))
                            .build()
                            .apply(getCursor(), newClass.getCoordinates().replace())
                            .withPrefix(Space.EMPTY);
                }
                return new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY, image, ""\"""" + image + ""\"""", null, JavaType.Primitive.String);
            }
        });
    }
}
","{
  ""containerClass"": ""String field"",
  ""image"": ""String field""
}"
Replace EasyMock `verify` calls with Mockito `verify` calls,Replace `EasyMock.verify(dependency)` with individual `Mockito.verify(dependency).method()` calls based on expected methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.easymock;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaCoordinates;
import org.openrewrite.java.tree.Statement;

import java.util.ArrayList;
import java.util.List;

import static java.lang.String.join;
import static java.util.Collections.nCopies;

public class EasyMockVerifyToMockitoVerify extends Recipe {

    private static final MethodMatcher VERIFY_MATCHER = new MethodMatcher(""org.easymock.EasyMock verify(..)"", true);
    private static final MethodMatcher EASY_MATCHER = new MethodMatcher(""org.easymock.EasyMock expect(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace EasyMock `verify` calls with Mockito `verify` calls"";
    }

    @Override
    public String getDescription() {
        return ""Replace `EasyMock.verify(dependency)` with individual `Mockito.verify(dependency).method()` calls based on expected methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(VERIFY_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                if (md.getBody() == null) {
                    return md;
                }

                maybeRemoveImport(""org.easymock.EasyMock.verify"");
                maybeAddImport(""org.mockito.Mockito"", ""verify"");

                int idx = 0;
                for (Statement statement : md.getBody().getStatements()) {
                    if (statement instanceof J.MethodInvocation) {
                        J.MethodInvocation m = (J.MethodInvocation) statement;
                        if (VERIFY_MATCHER.matches(m) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Identifier) {
                            J.Identifier dependency = (J.Identifier) m.getArguments().get(0);
                            List<Statement> statementsAboveVerify = md.getBody().getStatements().subList(0, idx);
                            List<J.MethodInvocation> expectedCalls = getExpectedCalls(dependency, statementsAboveVerify);

                            for (int i = 0, expectedCallsSize = expectedCalls.size(); i < expectedCallsSize; i++) {
                                J.MethodInvocation expectedMethod = expectedCalls.get(i);
                                List<Expression> parameters = expectedMethod.getArguments();
                                if (parameters.size() == 1 && parameters.get(0) instanceof J.Empty) {
                                    parameters.clear();
                                }
                                String anyArgs = join("","", nCopies(parameters.size(), ""#{any()}""));
                                parameters.add(0, dependency);
                                Statement currStatement = md.getBody().getStatements().get(idx);
                                JavaCoordinates coordinates = i == 0 ? currStatement.getCoordinates().replace() : currStatement.getCoordinates().after();
                                md = JavaTemplate.builder(""verify(#{any()})."" + expectedMethod.getSimpleName() + ""("" + anyArgs + "")"")
                                        .contextSensitive()
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-5""))
                                        .staticImports(""org.mockito.Mockito.verify"")
                                        .build()
                                        .apply(updateCursor(md), coordinates, parameters.toArray());
                                if (i != 0) {
                                    idx++;
                                }
                            }
                        }
                    }
                    idx++;
                }

                return md;
            }

            private List<J.MethodInvocation> getExpectedCalls(J.Identifier dependency, List<Statement> statementsAboveVerify) {
                List<J.MethodInvocation> expectedCalls = new ArrayList<>();
                for (Statement statement : statementsAboveVerify) {
                    if (statement instanceof J.MethodInvocation) {
                        J.MethodInvocation mi = (J.MethodInvocation) statement;
                        if (isExpectInvocation(mi, dependency)) {
                            expectedCalls.add((J.MethodInvocation) mi.getArguments().get(0));
                        } else if (isExpectAndReturnInvocation(mi, dependency)) {
                            expectedCalls.add((J.MethodInvocation) ((J.MethodInvocation) mi.getSelect()).getArguments().get(0));
                        }
                    }
                }
                return expectedCalls;
            }

            // match: expect(<dep>.someMethod());
            private boolean isExpectInvocation(J.MethodInvocation mi, J.Identifier dependency) {
                return EASY_MATCHER.matches(mi) &&
                        mi.getArguments().size() == 1 &&
                        mi.getArguments().get(0) instanceof J.MethodInvocation &&
                        ((J.MethodInvocation) mi.getArguments().get(0)).getSelect() instanceof J.Identifier &&
                        dependency.getSimpleName().equals(((J.Identifier) ((J.MethodInvocation) mi.getArguments().get(0)).getSelect()).getSimpleName());
            }

            // match: expect(<dep>.someMethod()).andReturn();
            private boolean isExpectAndReturnInvocation(J.MethodInvocation m, J.Identifier dependency) {
                return EASY_MATCHER.matches(m.getSelect()) &&
                        m.getSelect() instanceof J.MethodInvocation &&
                        isExpectInvocation((J.MethodInvocation) m.getSelect(), dependency);
            }
        });
    }
}
",{}
Migrate Test classes that extend `org.easymock.EasyMockSupport` to use Mockito,Modify test classes by removing extends EasyMockSupport and replacing EasyMock methods with Mockito equivalents.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.easymock;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

public class RemoveExtendsEasyMockSupport extends Recipe {

    private static final String EASYMOCK = ""org.easymock.EasyMockSupport"";

    @Override
    public String getDisplayName() {
        return ""Migrate Test classes that extend `org.easymock.EasyMockSupport` to use Mockito"";
    }

    @Override
    public String getDescription() {
        return ""Modify test classes by removing extends EasyMockSupport and replacing EasyMock methods with Mockito equivalents."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(EASYMOCK, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

                if (cd.getExtends() != null && TypeUtils.isAssignableTo(EASYMOCK, cd.getExtends().getType())) {
                    maybeRemoveImport(EASYMOCK);
                    cd = cd.withExtends(null);
                }
                return cd;
            }
        });
    }
}
",{}
Cleanup PowerMock imports,Removes unused `org.powermock` import symbols.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

public class CleanupPowerMockImports extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Cleanup PowerMock imports"";
    }

    @Override
    public String getDescription() {
        return ""Removes unused `org.powermock` import symbols."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.powermock..*"", false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J preVisit(J tree, ExecutionContext ctx) {
                        stopAfterPreVisit();
                        if (tree instanceof JavaSourceFile) {
                            for (J.Import _import : ((JavaSourceFile) tree).getImports()) {
                                if (_import.getPackageName().startsWith(""org.powermock"")) {
                                    maybeRemoveImport(_import.getPackageName() + ""."" + _import.getClassName());
                                }
                            }
                        }
                        return tree;
                    }
                });
    }
}
",{}
Replace `Mockito.when` on static (non mock) with try-with-resource with MockedStatic,Replace `Mockito.when` on static (non mock) with try-with-resource with MockedStatic as Mockito4 no longer allows this. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.java.VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER;
import static org.openrewrite.java.VariableNameUtils.generateVariableName;
import static org.openrewrite.java.tree.Flag.Static;

public class MockitoWhenOnStaticToMockStatic extends Recipe {
    private static final AnnotationMatcher JUNIT_4_ANNOTATION = new AnnotationMatcher(""org.junit.*"");
    private static final AnnotationMatcher JUNIT_5_ANNOTATION = new AnnotationMatcher(""org.junit.jupiter.api.*"");
    private static final AnnotationMatcher TESTNG_ANNOTATION = new AnnotationMatcher(""org.testng.annotations.*"");

    private static final AnnotationMatcher BEFORE = new AnnotationMatcher(""org..Before*"");
    private static final AnnotationMatcher BEFORE_CLASS = new AnnotationMatcher(""org..BeforeClass"");
    private static final AnnotationMatcher BEFORE_ALL = new AnnotationMatcher(""org..BeforeAll"");
    private static final AnnotationMatcher BEFORE_PARAM_CLASS_INV = new AnnotationMatcher(""org..BeforeParameterizedClassInvocation"");

    private static final MethodMatcher MOCKITO_WHEN = new MethodMatcher(""org.mockito.Mockito when(..)"");
    private static final TypeMatcher MOCKED_STATIC = new TypeMatcher(""org.mockito.MockedStatic"");

    private static final String DEFAULT_AFTER_METHOD = ""tearDown"";

    private int varCounter = 0;

    @Override
    public String getDisplayName() {
        return ""Replace `Mockito.when` on static (non mock) with try-with-resource with MockedStatic"";
    }

    @Override
    public String getDescription() {
        return ""Replace `Mockito.when` on static (non mock) with try-with-resource with MockedStatic as Mockito4 no longer allows this. "" +
                ""For JUnit 4/5 & TestNG: When `@Before*` is used, a `close` call is added to the corresponding `@After*` method. "" +
                ""This change moves away from implicit bytecode manipulation for static method stubbing, making mocking behavior more explicit and scoped to avoid unintended side effects."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(MOCKITO_WHEN), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                J.MethodDeclaration containingMethod = getCursor().firstEnclosing(J.MethodDeclaration.class);
                List<Statement> newStatements = isMethodDeclarationWithAnnotation(containingMethod, BEFORE) ?
                        maybeStatementsToMockedStatic(block, block.getStatements(), ctx) :
                        maybeWrapStatementsInTryWithResourcesMockedStatic(block, block.getStatements(), ctx);

                J.Block b = super.visitBlock(block.withStatements(newStatements), ctx);
                return maybeAutoFormat(block, b, ctx);
            }

            private List<Statement> maybeStatementsToMockedStatic(J.Block m, List<Statement> statements, ExecutionContext ctx) {
                List<Statement> list = new ArrayList<>();
                for (Statement statement : statements) {
                    J.MethodInvocation whenArg = getWhenArg(statement);
                    if (whenArg != null) {
                        String className = getClassNameFromInvocation(whenArg);
                        if (className != null) {
                            list.addAll(mockedStatic(m, (J.MethodInvocation) statement, className, whenArg, ctx));
                        }
                    } else {
                        list.add(statement);
                    }
                }
                return list;
            }

            private List<Statement> maybeWrapStatementsInTryWithResourcesMockedStatic(J.Block block, List<Statement> statements, ExecutionContext ctx) {
                AtomicBoolean restInTry = new AtomicBoolean(false);
                return ListUtils.map(statements, (index, statement) -> {
                    if (restInTry.get()) {
                        // Rest of the statements have ended up in the try block
                        return null;
                    }

                    J.MethodInvocation whenArg = getWhenArg(statement);
                    if (whenArg != null) {
                        String className = getClassNameFromInvocation(whenArg);
                        if (className != null) {
                            Optional<String> nameOfWrappingMockedStatic = tryGetMatchedWrappingResourceName(getCursor(), className);
                            if (nameOfWrappingMockedStatic.isPresent()) {
                                return reuseMockedStatic(block, (J.MethodInvocation) statement, nameOfWrappingMockedStatic.get(), whenArg, ctx);
                            }
                            J.Identifier staticMockedVariable = findMockedStaticVariable(getCursor(), className);
                            if (staticMockedVariable != null) {
                                return reuseMockedStatic(block, (J.MethodInvocation) statement, staticMockedVariable, whenArg, ctx);
                            }
                            restInTry.set(true);
                            return tryWithMockedStatic(block, statements, index, (J.MethodInvocation) statement, className, whenArg, ctx);
                        }
                    }
                    return statement;
                });
            }

            private J.@Nullable MethodInvocation getWhenArg(Statement statement) {
                if (statement instanceof J.MethodInvocation && MOCKITO_WHEN.matches(((J.MethodInvocation) statement).getSelect())) {
                    J.MethodInvocation when = (J.MethodInvocation) ((J.MethodInvocation) statement).getSelect();
                    if (when != null && when.getArguments().get(0) instanceof J.MethodInvocation) {
                        J.MethodInvocation whenArg = (J.MethodInvocation) when.getArguments().get(0);
                        if (whenArg.getMethodType() != null && whenArg.getMethodType().hasFlags(Static)) {
                            return whenArg;
                        }
                    }
                }
                return null;
            }

            private @Nullable String getClassNameFromInvocation(J.MethodInvocation whenArg) {
                J.Identifier clazz = null;
                // Having a fieldType implies that something is a field rather than a class itself
                if (whenArg.getSelect() instanceof J.Identifier && ((J.Identifier) whenArg.getSelect()).getFieldType() == null) {
                    clazz = (J.Identifier) whenArg.getSelect();
                } else if (whenArg.getSelect() instanceof J.FieldAccess && ((J.FieldAccess) whenArg.getSelect()).getTarget() instanceof J.Identifier) {
                    clazz = (J.Identifier) ((J.FieldAccess) whenArg.getSelect()).getTarget();
                }
                return clazz != null && clazz.getType() != null ? clazz.getSimpleName() : null;
            }

            private J.Try tryWithMockedStatic(J.Block block, List<Statement> statements, Integer index,
                                              J.MethodInvocation statement, String className, J.MethodInvocation whenArg, ExecutionContext ctx) {
                String variableName = generateVariableName(""mock"" + className + ++varCounter, updateCursor(block), INCREMENT_NUMBER);
                Expression thenReturnArg = statement.getArguments().get(0);

                J.Try try_ = (J.Try) javaTemplateMockStatic(String.format(
                        ""try(MockedStatic<%1$s> %2$s = mockStatic(%1$s.class)) {\n"" +
                                ""    %2$s.when(() -> #{any()}).thenReturn(#{any()});\n"" +
                                ""}"", className, variableName), ctx)
                        .<J.Block>apply(getCursor(), block.getCoordinates().firstStatement(), whenArg, thenReturnArg)
                        .getStatements().get(0);

                List<Statement> precedingStatements = statements.subList(0, index);
                List<Statement> handledStatements = ListUtils.concat(precedingStatements, try_);
                List<Statement> remainingStatements = statements.subList(index + 1, statements.size());

                List<Statement> newStatements = ListUtils.concatAll(
                        try_.getBody().getStatements(),
                        maybeWrapStatementsInTryWithResourcesMockedStatic(block.withStatements(handledStatements), remainingStatements, ctx));

                return try_.withBody(try_.getBody().withStatements(newStatements))
                        .withPrefix(statement.getPrefix());
            }

            private Statement reuseMockedStatic(J.Block block, J.MethodInvocation statement, Object variable, J.MethodInvocation whenArg, ExecutionContext ctx) {
                String mockedStaticVariableTemplate = variable instanceof J ? ""#{any()}"" : ""#{}"";
                return javaTemplateMockStatic(mockedStaticVariableTemplate + "".when(() -> #{any()}).thenReturn(#{any()});"", ctx)
                        .<J.Block>apply(getCursor(), block.getCoordinates().firstStatement(), variable, whenArg, statement.getArguments().get(0))
                        .getStatements().get(0);
            }

            private List<Statement> mockedStatic(J.Block block, J.MethodInvocation statement, String className, J.MethodInvocation whenArg, ExecutionContext ctx) {
                J.MethodDeclaration containingMethod = getCursor().firstEnclosing(J.MethodDeclaration.class);
                boolean staticSetup = isMethodDeclarationWithAnnotation(containingMethod, BEFORE_CLASS, BEFORE_ALL, BEFORE_PARAM_CLASS_INV);
                String variableName = generateVariableName(""mock"" + className + ++varCounter, updateCursor(block), INCREMENT_NUMBER);
                // We know it will have a matching `@Before*` annotation based on callers
                String matchedAnnotation = requireNonNull(tryGetMatchedAnnotationOnMethodDeclaration(containingMethod, BEFORE));
                String correspondingAfterFqn = matchedAnnotation.replace("".Before"", "".After"");
                Expression thenReturnArg = statement.getArguments().get(0);

                List<Statement> statements = javaTemplateMockStatic(String.format(
                        ""%2$s = mockStatic(%1$s.class);\n"" +
                                ""%2$s.when(() -> #{any()}).thenReturn(#{any()});"", className, variableName), ctx)
                        .<J.Block>apply(getCursor(), block.getCoordinates().firstStatement(), whenArg, thenReturnArg)
                        .getStatements().subList(0, 2);

                doAfterVisit(new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        J.ClassDeclaration after = JavaTemplate
                                .builder(String.format(""private%s MockedStatic<%s> %s;"", staticSetup ? "" static"" : """", className, variableName))
                                .contextSensitive()
                                .build()
                                .apply(updateCursor(classDecl), classDecl.getBody().getCoordinates().firstStatement());

                        List<Statement> afterStatements = after.getBody().getStatements();
                        AnnotationMatcher specificBeforeMatcher = new AnnotationMatcher(matchedAnnotation);
                        if (classDecl.getBody().getStatements().stream().noneMatch(it -> isMethodDeclarationWithAnnotation(it, new AnnotationMatcher(correspondingAfterFqn)))) {
                            String safeAfterMethodName = getSafeAfterMethodName(DEFAULT_AFTER_METHOD, afterStatements);
                            Optional<Statement> beforeMethodJunit4 = afterStatements.stream()
                                    .filter(it -> isMethodDeclarationWithAllAnnotations(it, JUNIT_4_ANNOTATION, specificBeforeMatcher))
                                    .findFirst();
                            Optional<Statement> beforeMethodJunit5 = afterStatements.stream()
                                    .filter(it -> isMethodDeclarationWithAllAnnotations(it, JUNIT_5_ANNOTATION, specificBeforeMatcher))
                                    .findFirst();
                            Optional<Statement> beforeMethodTestng = afterStatements.stream()
                                    .filter(it -> isMethodDeclarationWithAllAnnotations(it, TESTNG_ANNOTATION, specificBeforeMatcher))
                                    .findFirst();
                            String afterAnnotationName = correspondingAfterFqn.substring(correspondingAfterFqn.lastIndexOf('.') + 1);
                            String template = String.format(""@%1$s public%2$s void %3$s() {}"", afterAnnotationName, staticSetup ? "" static"" : """", safeAfterMethodName);
                            if (beforeMethodJunit4.isPresent()) {
                                after = writeAfterMethod(after, beforeMethodJunit4.get(), ctx, template, correspondingAfterFqn, ""junit-4"");
                            } else if (beforeMethodJunit5.isPresent()) {
                                after = writeAfterMethod(after, beforeMethodJunit5.get(), ctx, template, correspondingAfterFqn, ""junit-jupiter-api-5"");
                            } else if (beforeMethodTestng.isPresent()) {
                                after = writeAfterMethod(after, beforeMethodTestng.get(), ctx, template, correspondingAfterFqn, ""testng"");
                            }
                        }

                        J.ClassDeclaration cd = super.visitClassDeclaration(after, ctx);
                        return maybeAutoFormat(classDecl, cd, ctx);
                    }

                    private J.ClassDeclaration writeAfterMethod(J.ClassDeclaration after, Statement beforeMethod, ExecutionContext ctx, String template, String importClass, String... classpaths) {
                        maybeAddImport(importClass);
                        return JavaTemplate.builder(template)
                                .imports(importClass)
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, classpaths))
                                .build()
                                .apply(updateCursor(after), beforeMethod.getCoordinates().after());
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
                        J.MethodDeclaration md = super.visitMethodDeclaration(methodDecl, ctx);
                        if (isMethodDeclarationWithAnnotation(md, new AnnotationMatcher(correspondingAfterFqn))) {
                            return JavaTemplate.builder(variableName + "".close();"")
                                    .contextSensitive()
                                    .build()
                                    .apply(getCursor(), md.getBody().getCoordinates().lastStatement());
                        }
                        return md;
                    }
                });

                return statements;
            }

            private JavaTemplate javaTemplateMockStatic(String code, ExecutionContext ctx) {
                maybeAddImport(""org.mockito.MockedStatic"", false);
                maybeAddImport(""org.mockito.Mockito"", ""mockStatic"");
                return JavaTemplate.builder(code)
                        .contextSensitive()
                        .imports(""org.mockito.MockedStatic"")
                        .staticImports(""org.mockito.Mockito.mockStatic"")
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-5""))
                        .build();
            }
        });
    }

    private static List<J.Try.Resource> getMatchingFilteredResources(@Nullable List<J.Try.Resource> resources, String className) {
        if (resources != null) {
            return resources.stream().filter(res -> {
                J.VariableDeclarations vds = (J.VariableDeclarations) res.getVariableDeclarations();
                return TypeUtils.isAssignableTo(""org.mockito.MockedStatic<"" + className + "">"", vds.getTypeAsFullyQualified());
            }).collect(toList());
        }
        return emptyList();
    }

    private static Optional<String> tryGetMatchedWrappingResourceName(Cursor cursor, String className) {
        try {
            Cursor foundParentCursor = cursor.dropParentUntil(val -> {
                if (val instanceof J.Try) {
                    List<J.Try.Resource> filteredResources = getMatchingFilteredResources(((J.Try) val).getResources(), className);
                    return !filteredResources.isEmpty();
                }
                return false;
            });
            return getMatchingFilteredResources(((J.Try) foundParentCursor.getValue()).getResources(), className)
                    .stream()
                    .findFirst()
                    .map(res -> ((J.VariableDeclarations) res.getVariableDeclarations()).getVariables().get(0).getSimpleName());
        } catch (IllegalStateException e) {
            return Optional.empty();
        }
    }

    private static boolean isMethodDeclarationWithAnnotation(@Nullable Statement statement, AnnotationMatcher... matchers) {
        if (statement instanceof J.MethodDeclaration) {
            return ((J.MethodDeclaration) statement).getLeadingAnnotations().stream()
                    .anyMatch(it -> Arrays.stream(matchers).anyMatch(m -> m.matches(it)));
        }
        return false;
    }

    private static boolean isMethodDeclarationWithAllAnnotations(@Nullable Statement statement, AnnotationMatcher... matchers) {
        if (statement instanceof J.MethodDeclaration) {
            return ((J.MethodDeclaration) statement).getLeadingAnnotations().stream()
                    .anyMatch(it -> Arrays.stream(matchers).allMatch(m -> m.matches(it)));
        }
        return false;
    }

    private static @Nullable String tryGetMatchedAnnotationOnMethodDeclaration(J.@Nullable MethodDeclaration methodDecl, AnnotationMatcher... matchers) {
        if (methodDecl != null) {
            return methodDecl.getLeadingAnnotations().stream()
                    .filter(it -> Arrays.stream(matchers).anyMatch(m -> m.matches(it)))
                    .findFirst()
                    .map(J.Annotation::getType)
                    .map(Object::toString)
                    .orElse(null);
        }
        return null;
    }

    private static String getSafeAfterMethodName(String baseName, List<Statement> existingStatements) {
        return existingStatements.stream()
                .filter(it -> it instanceof J.MethodDeclaration)
                .map(it -> ((J.MethodDeclaration) it).getSimpleName())
                .filter(s -> s.matches(""^"" + baseName + ""(\\d+)?$""))
                .max(Comparator.comparingInt(s -> s.equals(baseName) ? 0 : Integer.parseInt(s.substring(baseName.length()))))
                .map(last -> {
                    int suffix = last.equals(baseName) ? 0 : Integer.parseInt(last.substring(baseName.length()));
                    return baseName + (suffix + 1);
                })
                .orElse(baseName);
    }

    private static J.@Nullable Identifier findMockedStaticVariable(Cursor scope, String className) {
        JavaSourceFile compilationUnit = scope.firstEnclosing(JavaSourceFile.class);
        if (compilationUnit == null) {
            return null;
        }

        return new JavaIsoVisitor<AtomicReference<J.Identifier>>() {
            @Override
            public J.Block visitBlock(J.Block block, AtomicReference<J.Identifier> mockedStaticVar) {
                if (scope.isScopeInPath(block)) {
                    return super.visitBlock(block, mockedStaticVar);
                }
                return block;
            }

            @Override
            public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, AtomicReference<J.Identifier> mockedStaticVar) {
                J.Identifier identifier = variable.getName();
                if (MOCKED_STATIC.matches(identifier) && identifier.getType() instanceof JavaType.Parameterized) {
                    JavaType.Parameterized parameterizedType = (JavaType.Parameterized) identifier.getType();
                    if (parameterizedType.getTypeParameters().size() == 1 && TypeUtils.isAssignableTo(className, parameterizedType.getTypeParameters().get(0))) {
                        mockedStaticVar.set(identifier);
                    }
                }

                return super.visitVariable(variable, mockedStaticVar);
            }
        }.reduce(compilationUnit, new AtomicReference<>()).get();
    }
}
",{}
Remove `Mockito.times(0)` and `Mockito.times(1)`,Remove `Mockito.times(0)` and `Mockito.times(1)` from `Mockito.verify()` calls.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

public class RemoveTimesZeroAndOne extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove `Mockito.times(0)` and `Mockito.times(1)`"";
    }

    @Override
    public String getDescription() {
        return ""Remove `Mockito.times(0)` and `Mockito.times(1)` from `Mockito.verify()` calls."";
    }

    private static final MethodMatcher verifyMatcher = new MethodMatcher(""org.mockito.Mockito verify(..)"", false);
    private static final MethodMatcher timesMatcher = new MethodMatcher(""org.mockito.Mockito times(int)"", false);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new UsesMethod<>(verifyMatcher),
                        new UsesMethod<>(timesMatcher)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if (timesMatcher.matches(mi) && J.Literal.isLiteralValue(mi.getArguments().get(0), 0)) {
                            maybeAddImport(""org.mockito.Mockito"", ""never"");
                            maybeRemoveImport(""org.mockito.Mockito.times"");
                            return JavaTemplate.builder(""never()"")
                                    .staticImports(""org.mockito.Mockito.never"")
                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core""))
                                    .build()
                                    .apply(getCursor(), mi.getCoordinates().replace());
                        }
                        if (verifyMatcher.matches(mi) && mi.getArguments().size() == 2) {
                            J.MethodInvocation times = (J.MethodInvocation) mi.getArguments().get(1);
                            if (timesMatcher.matches(times) && J.Literal.isLiteralValue(times.getArguments().get(0), 1)) {
                                maybeRemoveImport(""org.mockito.Mockito.times"");
                                JavaType.Method methodType = mi.getMethodType()
                                        .withParameterNames(mi.getMethodType().getParameterNames().subList(0, 1))
                                        .withParameterTypes(mi.getMethodType().getParameterTypes().subList(0, 1));
                                return mi
                                        .withArguments(mi.getArguments().subList(0, 1))
                                        .withMethodType(methodType)
                                        .withName(mi.getName().withType(methodType));
                            }
                        }
                        return mi;
                    }
                }
        );
    }
}
",{}
Replace JUnit 4 MockitoJUnitRunner with junit-jupiter MockitoExtension,Replace JUnit 4 MockitoJUnitRunner annotations with JUnit 5 `@ExtendWith(MockitoExtension.class)` ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.testing.junit5.RemoveObsoleteRunners;
import org.openrewrite.java.testing.junit5.RunnerToExtension;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public class MockitoJUnitRunnerToExtension extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Replace JUnit 4 MockitoJUnitRunner with junit-jupiter MockitoExtension"";
    }


    @Override
    public String getDescription() {
        return ""Replace JUnit 4 MockitoJUnitRunner annotations with JUnit 5 `@ExtendWith(MockitoExtension.class)` "" +
                ""using the appropriate strictness levels (LENIENT, WARN, STRICT_STUBS)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.mockito.junit.MockitoJUnitRunner*"", false), new JavaIsoVisitor<ExecutionContext>() {

            final String runWith = ""@org.junit.runner.RunWith"";
            final String extendWithMockito = ""@org.junit.jupiter.api.extension.ExtendWith(org.mockito.junit.jupiter.MockitoExtension.class)"";
            final String mockitoSettings = ""@org.mockito.junit.jupiter.MockitoSettings"";
            final String mockitoStrictness = ""org.mockito.quality.Strictness"";

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                Strictness runnerStrictness = getStrictness(cd, runWith);
                Strictness extensionStrictness = getStrictness(cd, mockitoSettings);

                if (runnerStrictness == null) { // class doesn't have MockitoJunitRunner
                    return cd;
                }
                registerAfterVisit(cd);
                if (extensionStrictness == null || extensionStrictness.isGreaterThan(runnerStrictness)) {
                    List<J.Annotation> annotations = ListUtils.map(cd.getLeadingAnnotations(),
                            a -> a == null || new AnnotationMatcher(mockitoSettings).matches(a) ? null : a);
                    J.ClassDeclaration _cd = cd.withLeadingAnnotations(annotations);
                    return getTemplate(runnerStrictness, ctx)
                            .map(t -> maybeAutoFormat(_cd,
                                    t.apply(updateCursor(_cd), _cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))),
                                    ctx)).orElse(_cd);
                }
                return cd;
            }

            private @Nullable Strictness getStrictness(J.ClassDeclaration cd, String signature) {
                return new Annotated.Matcher(signature).<AtomicReference<@Nullable Strictness>>asVisitor(
                    (a, s) -> a.getTree().acceptJava(new JavaIsoVisitor<AtomicReference<Strictness>>() {
                        @Override
                        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, AtomicReference<Strictness> strictness) {
                            for (Strictness strict : Strictness.values()) {
                                if (TypeUtils.isOfClassType(fieldAccess.getTarget().getType(), strict.runner)) {
                                    strictness.set(strict);
                                    break;
                                }
                                if (TypeUtils.isOfClassType(fieldAccess.getType(), mockitoStrictness)  && fieldAccess.getName().getSimpleName().equals(strict.name())) {
                                    strictness.set(strict);
                                    break;
                                }
                            }
                            return fieldAccess;
                        }
                }, s)).reduce(cd, new AtomicReference<>()).get();
            }

            private void registerAfterVisit(J.ClassDeclaration cd) {
                boolean hasMockitoExtensions = new Annotated.Matcher(extendWithMockito).<AtomicBoolean>asVisitor(
                        (a, flag) -> {
                            flag.set(true);
                            return a.getTree();
                        }).reduce(cd, new AtomicBoolean(false)).get();
                List<String> obsoleteRunners = Arrays.asList(
                        ""org.mockito.junit.MockitoJUnitRunner.Silent"",
                        ""org.mockito.junit.MockitoJUnitRunner.Strict"",
                        ""org.mockito.junit.MockitoJUnitRunner"");
                if (hasMockitoExtensions) {
                    doAfterVisit(new RemoveObsoleteRunners(obsoleteRunners).getVisitor());
                } else {
                    doAfterVisit(new RunnerToExtension(obsoleteRunners, ""org.mockito.junit.jupiter.MockitoExtension"").getVisitor());
                }
                for (Strictness strictness : Strictness.values()) {
                    maybeRemoveImport(strictness.runner);
                }
                maybeAddImport(""org.mockito.quality.Strictness"");
                maybeAddImport(""org.mockito.junit.jupiter.MockitoSettings"");
            }

            private Optional<JavaTemplate> getTemplate(Strictness strictness, ExecutionContext ctx) {
                // MockitoExtension defaults to STRICT_STUBS, no need of explicit setting.
                if (strictness == Strictness.STRICT_STUBS) {
                    return Optional.empty();
                }
                return Optional.of(JavaTemplate.builder(""@MockitoSettings(strictness = Strictness."" + strictness + "")"")
                        .imports(""org.mockito.quality.Strictness"", ""org.mockito.junit.jupiter.MockitoSettings"")
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""mockito-junit-jupiter-3.12"", ""mockito-core-3.12""))
                        .build());
            }
        });
    }

    private enum Strictness {
        LENIENT(""org.mockito.junit.MockitoJUnitRunner.Silent""),
        WARN(""org.mockito.junit.MockitoJUnitRunner""),
        STRICT_STUBS(""org.mockito.junit.MockitoJUnitRunner.Strict"");

        final String runner;

        Strictness(String runner) {
            this.runner = runner;
        }

        // Return true, if current strictness is greater than given strictness.
        boolean isGreaterThan(Strictness strictness) {
            return this.ordinal() > strictness.ordinal();
        }
    }
}
",{}
Replace `PowerMock.mockStatic()` with `Mockito.mockStatic()`,Replaces `PowerMockito.mockStatic()` by `Mockito.mockStatic()`. Removes ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.*;

import static java.util.Collections.replaceAll;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.java.testing.mockito.MockitoUtils.maybeAddMethodWithAnnotation;

public class PowerMockitoMockStaticToMockito extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Replace `PowerMock.mockStatic()` with `Mockito.mockStatic()`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `PowerMockito.mockStatic()` by `Mockito.mockStatic()`. Removes "" +
               ""the `@PrepareForTest` annotation."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(""org.powermock..*"", false),
                        new UsesType<>(""org.mockito..*"", false)
                ),
                new PowerMockitoToMockitoVisitor()
        );
    }

    private static class PowerMockitoToMockitoVisitor extends JavaVisitor<ExecutionContext> {
        private static final String MOCKED_STATIC = ""org.mockito.MockedStatic"";
        private static final String POWER_MOCK_RUNNER = ""org.powermock.modules.junit4.PowerMockRunner"";
        private static final String POWER_MOCK_CONFIG = ""org.powermock.configuration.PowerMockConfiguration"";
        private static final String POWER_MOCK_TEST_CASE = ""org.powermock.modules.testng.PowerMockTestCase"";
        private static final MethodMatcher MOCKED_STATIC_MATCHER = new MethodMatcher(""org.mockito.Mockito mockStatic(..)"");
        private static final MethodMatcher MOCKED_STATIC_CLOSE_MATCHER = new MethodMatcher(""org.mockito.ScopedMock close(..)"", true);
        private static final MethodMatcher MOCKITO_VERIFY_MATCHER = new MethodMatcher(""org.mockito.Mockito verify(..)"");
        private static final MethodMatcher MOCKITO_WHEN_MATCHER = new MethodMatcher(""org.mockito.Mockito when(..)"");
        private static final MethodMatcher MOCKITO_STATIC_METHOD_MATCHER = new MethodMatcher(""org.mockito..* *(..)"");
        private static final AnnotationMatcher PREPARE_FOR_TEST_MATCHER =
                new AnnotationMatcher(""@org.powermock.core.classloader.annotations.PrepareForTest"");
        private static final AnnotationMatcher RUN_WITH_POWER_MOCK_RUNNER_MATCHER =
                new AnnotationMatcher(""@org.junit.runner.RunWith("" + POWER_MOCK_RUNNER + "".class)"");
        private static final String MOCKED_TYPES_FIELDS = ""mockedTypesFields"";
        private static final String MOCK_STATIC_INVOCATIONS = ""mockStaticInvocationsByClassName"";
        private static final MethodMatcher DYNAMIC_WHEN_METHOD_MATCHER = new MethodMatcher(""org.mockito.Mockito when(java.lang.Class, String, ..)"");
        private static final String MOCK_PREFIX = ""mocked"";
        private static final String TEST_GROUP = ""testGroup"";

        private String setUpMethodAnnotationSignature;
        private String setUpMethodAnnotation;
        private String tearDownMethodAnnotationSignature;
        private String tearDownMethodAnnotation;
        private String additionalClasspathResource;
        private String setUpImportToAdd;
        private String tearDownImportToAdd;
        private String tearDownMethodAnnotationParameters = """";

        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                boolean useTestNg = !FindAnnotations.find((J) tree, ""@org.testng.annotations.Test"").isEmpty();
                initTestFrameworkInfo(useTestNg);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            getCursor().putMessage(MOCK_STATIC_INVOCATIONS, new HashMap<>());

            // Add the classes of the arguments in the annotation @PrepareForTest as fields
            // e.g. `@PrepareForTest(Calendar.class)`
            // becomes
            // `private MockStatic mockedCalendar;`
            List<Expression> mockedStaticClasses = new ArrayList<>();
            for (J.Annotation j : classDecl.getAllAnnotations()) {
                if (PREPARE_FOR_TEST_MATCHER.matches(j)) {
                    List<Expression> arguments = j.getArguments();
                    if (arguments != null && !arguments.isEmpty()) {
                        mockedStaticClasses.addAll(ListUtils.flatMap(arguments, a -> {
                            if (a instanceof J.NewArray && ((J.NewArray) a).getInitializer() != null) {
                                // case `@PrepareForTest( {Object1.class, Object2.class ...} )`
                                return ((J.NewArray) a).getInitializer();
                            }
                            if (a instanceof J.Assignment && ((J.NewArray) ((J.Assignment) a).getAssignment()).getInitializer() != null) {
                                // case `@PrepareForTest( value = {Object1.class, Object2.class ...} }`
                                return ((J.NewArray) ((J.Assignment) a).getAssignment()).getInitializer();
                            }
                            if (a instanceof J.FieldAccess) {
                                // case `@PrepareForTest(Object1.class)`
                                return a;
                            }
                            return null;
                        }));
                        doAfterVisit(new RemoveAnnotationVisitor(PREPARE_FOR_TEST_MATCHER));
                    }
                }
            }

            // Remove `@RunWithPowerMockRunner`
            for (J.Annotation annotation : classDecl.getAllAnnotations()) {
                if (RUN_WITH_POWER_MOCK_RUNNER_MATCHER.matches(annotation)) {
                    doAfterVisit(new RemoveAnnotationVisitor(RUN_WITH_POWER_MOCK_RUNNER_MATCHER));
                    maybeRemoveImport(POWER_MOCK_RUNNER);
                }
            }

            J.ClassDeclaration cd = (J.ClassDeclaration) super.visitClassDeclaration(classDecl, ctx);

            // Remove the extension of class PowerMockConfiguration
            cd = removeExtension(cd, POWER_MOCK_CONFIG);
            // Remove the extension of class PowerMockTestCase
            cd = removeExtension(cd, POWER_MOCK_TEST_CASE);

            if (!mockedStaticClasses.isEmpty()) {
                // If there are mocked types, add empty setUp() and tearDown() methods if not yet present
                cd = maybeAddSetUpMethodBody(cd, ctx);
                cd = maybeAddTearDownMethodBody(cd, ctx);
                cd = addFieldDeclarationForMockedTypes(cd, ctx, mockedStaticClasses);

                // Invoke the visitors of the child tree a 2nd time to fill the new methods
                return super.visitClassDeclaration(cd, ctx);
            }
            return cd;
        }

        @Override
        public J visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = (J.MethodDeclaration) super.visitMethodDeclaration(method, ctx);

            // Add close static mocks on demand to tear down method
            AnnotationMatcher tearDownAnnotationMatcher = new AnnotationMatcher(tearDownMethodAnnotationSignature);
            if (m.getAllAnnotations().stream().anyMatch(tearDownAnnotationMatcher::matches)) {
                // Add close statements to the static mocks in the tear down method
                return addCloseStaticMocksOnDemandStatement(m, ctx);
            }

            // Initialize the static mocks in the setup method
            AnnotationMatcher setUpAnnotationMatcher = new AnnotationMatcher(
                    setUpMethodAnnotationSignature);
            if (m.getAllAnnotations().stream().anyMatch(setUpAnnotationMatcher::matches)) {
                // Move the mockStatic method to the setUp method
                m = moveMockStaticMethodToSetUp(m, ctx);
            }
            return m;
        }

        @Override
        public @Nullable J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);

            Map<String, J.MethodInvocation> mockStaticInvocationsByClassName = getCursor().getNearestMessage(MOCK_STATIC_INVOCATIONS);
            if (mockStaticInvocationsByClassName != null && MOCKED_STATIC_MATCHER.matches(mi)) {
                Optional<Expression> firstArgument = mi.getArguments().stream().findFirst();
                firstArgument.ifPresent(expression -> {
                    mockStaticInvocationsByClassName.put(expression.toString(), mi);
                    getCursor().putMessageOnFirstEnclosing(J.MethodDeclaration.class, MOCK_STATIC_INVOCATIONS, mockStaticInvocationsByClassName);
                });
            }

            if (DYNAMIC_WHEN_METHOD_MATCHER.matches(mi)) {
                return modifyDynamicWhenMethodInvocation(mi);
            }

            if (MOCKITO_WHEN_MATCHER.matches(mi) || MOCKITO_VERIFY_MATCHER.matches(mi)) {
                return modifyWhenMethodInvocation(mi);
            }

            if (MOCKED_STATIC_MATCHER.matches(mi)) {
                determineTestGroups();
                if (!getCursor().getPath(o -> o instanceof J.VariableDeclarations ||
                                              o instanceof J.Assignment ||
                                              o instanceof J.Try.Resource).hasNext()) {
                    //noinspection DataFlowIssue
                    return null;
                }
            }
            return mi;
        }

        private static boolean isFieldAlreadyDefined(J.Block classBody, String fieldName) {
            for (Statement statement : classBody.getStatements()) {
                if (statement instanceof J.VariableDeclarations) {
                    for (J.VariableDeclarations.NamedVariable namedVariable : ((J.VariableDeclarations) statement).getVariables()) {
                        if (namedVariable.getSimpleName().equals(fieldName)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        private static boolean isStaticMockAlreadyClosed(J.Identifier staticMock, J.Block methodBody) {
            for (Statement statement : methodBody.getStatements()) {
                if (statement instanceof J.MethodInvocation) {
                    J.MethodInvocation methodInvocation = (J.MethodInvocation) statement;
                    if (MOCKED_STATIC_CLOSE_MATCHER.matches(methodInvocation)) {
                        if (methodInvocation.getSelect() instanceof J.Identifier) {
                            if (((J.Identifier) methodInvocation.getSelect()).getSimpleName()
                                    .equals(staticMock.getSimpleName())) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        private static boolean isStaticMockAlreadyOpened(J.Identifier staticMock, J.Block methodBody) {
            for (Statement statement : methodBody.getStatements()) {
                if (statement instanceof J.MethodInvocation) {
                    J.MethodInvocation methodInvocation = (J.MethodInvocation) statement;
                    if (MOCKED_STATIC_MATCHER.matches(methodInvocation)) {
                        if (methodInvocation.getSelect() instanceof J.Identifier) {
                            if (((J.Identifier) methodInvocation.getSelect()).getSimpleName()
                                    .equals(staticMock.getSimpleName())) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        private J.MethodDeclaration moveMockStaticMethodToSetUp(J.MethodDeclaration m, ExecutionContext ctx) {
            Map<String, J.MethodInvocation> mockStaticInvocations = getCursor().getNearestMessage(MOCK_STATIC_INVOCATIONS);

            if (mockStaticInvocations != null) {
                for (Map.Entry<J.Identifier, Expression> mockedTypesFieldEntry : getMockedTypesFields().entrySet()) {
                    // Only add close method invocation if not already exists
                    J.Block methodBody = m.getBody();
                    if (methodBody == null || isStaticMockAlreadyOpened(mockedTypesFieldEntry.getKey(), methodBody)) {
                        continue;
                    }

                    String className = mockedTypesFieldEntry.getValue().toString();
                    J.MethodInvocation methodInvocation = mockStaticInvocations.get(className);
                    if (methodInvocation != null) {
                        m = JavaTemplate.builder(""mocked#{any(org.mockito.MockedStatic)} = #{any(org.mockito.Mockito)};"")
                                .contextSensitive()
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-3.12""))
                                .build()
                                .apply(
                                        new Cursor(getCursor().getParentOrThrow(), m),
                                        methodBody.getCoordinates().firstStatement(),
                                        mockedTypesFieldEntry.getKey(),
                                        methodInvocation
                                );
                    }
                }
            }
            return m;
        }

        private J.MethodDeclaration addCloseStaticMocksOnDemandStatement(J.MethodDeclaration m, ExecutionContext ctx) {
            for (Map.Entry<J.Identifier, Expression> mockedTypesField : getMockedTypesFields().entrySet()) {
                // Only add close method invocation if not already exists
                J.Block methodBody = m.getBody();
                if (methodBody == null || isStaticMockAlreadyClosed(mockedTypesField.getKey(), methodBody)) {
                    continue;
                }
                m = JavaTemplate.builder(""#{any(org.mockito.MockedStatic)}.closeOnDemand();"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-3.12""))
                        .build()
                        .apply(
                                new Cursor(getCursor().getParentOrThrow(), m),
                                methodBody.getCoordinates().lastStatement(),
                                mockedTypesField.getKey()
                        );
            }
            return m;
        }

        private void determineTestGroups() {
            if (getCursor().getNearestMessage(TEST_GROUP) == null) {
                J.MethodDeclaration methodDeclarationCursor = getCursor().firstEnclosing(J.MethodDeclaration.class);
                if (methodDeclarationCursor != null) {
                    Optional<J.Annotation> testAnnotation = methodDeclarationCursor
                            .getLeadingAnnotations().stream()
                            .filter(annotation -> ""Test"".equals(annotation.getSimpleName())).findFirst();
                    testAnnotation.ifPresent(
                            ta -> {
                                if (ta.getArguments() != null) {
                                    getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, TEST_GROUP, ta.getArguments());
                                }
                            });
                }
            }
        }

        private J.MethodInvocation modifyDynamicWhenMethodInvocation(J.MethodInvocation method) {
            // Example
            // `Mockito.when(Calendar.class, ""getInstance"")`
            // is modified to
            // `mockedCalendar.when(() -> Calendar.getInstance())`
            List<Expression> arguments = method.getArguments();
            String declaringClassName = ((J.FieldAccess) arguments.get(0)).getTarget().toString();
            J.Identifier mockedField = getFieldIdentifier(MOCK_PREFIX + declaringClassName);
            if (mockedField != null) {
                arguments.remove(0);
                J.Literal calledMethod = (J.Literal) arguments.get(0);
                arguments.remove(0);
                String stringOfArguments = arguments.stream().map(Object::toString).collect(joining("",""));
                method = JavaTemplate.builder(""() -> #{}.#{}(#{})"")
                        .contextSensitive()
                        .build()
                        .apply(
                                new Cursor(getCursor().getParentOrThrow(), method),
                                method.getCoordinates().replaceArguments(),
                                declaringClassName,
                                Objects.requireNonNull(calledMethod.getValue()).toString(),
                                stringOfArguments
                        );
                method = method.withSelect(mockedField);
            }
            return method;
        }

        private J.ClassDeclaration removeExtension(J.ClassDeclaration classDecl, String extensionFQN) {
            TypeTree extension = classDecl.getExtends();
            if (extension != null && TypeUtils.isAssignableTo(extensionFQN, extension.getType())) {
                classDecl = classDecl.withExtends(null);
                maybeRemoveImport(extensionFQN);
            }
            return classDecl;
        }

        private void initTestFrameworkInfo(boolean useTestNg) {
            String setUpMethodAnnotationName;
            String tearDownMethodAnnotationName;
            String annotationPackage;

            if (!useTestNg) {
                setUpMethodAnnotationName = ""BeforeEach"";
                tearDownMethodAnnotationName = ""AfterEach"";
                annotationPackage = ""org.junit.jupiter.api"";
                additionalClasspathResource = ""junit-jupiter-api-5"";
            } else {
                setUpMethodAnnotationName = ""BeforeMethod"";
                tearDownMethodAnnotationName = ""AfterMethod"";
                annotationPackage = ""org.testng.annotations"";
                additionalClasspathResource = ""testng-7"";
                tearDownMethodAnnotationParameters = ""(alwaysRun = true)"";
            }

            this.setUpMethodAnnotation = ""@"" + setUpMethodAnnotationName;
            this.tearDownMethodAnnotation = ""@"" + tearDownMethodAnnotationName;

            this.setUpMethodAnnotationSignature = ""@"" + annotationPackage + ""."" + setUpMethodAnnotationName;
            this.tearDownMethodAnnotationSignature = ""@"" + annotationPackage + ""."" + tearDownMethodAnnotationName;

            this.setUpImportToAdd = annotationPackage + ""."" + setUpMethodAnnotationName;
            this.tearDownImportToAdd = annotationPackage + ""."" + tearDownMethodAnnotationName;
        }

        private Map<J.Identifier, Expression> getMockedTypesFields() {
            return getCursor().getNearestMessage(MOCKED_TYPES_FIELDS, new LinkedHashMap<>());
        }

        private J.ClassDeclaration addFieldDeclarationForMockedTypes(J.ClassDeclaration classDecl, ExecutionContext ctx, List<Expression> mockedStaticClasses) {
            // Get the actually invoked staticMethod by class
            Map<String, J.MethodInvocation> invocationByClassName = getCursor().getNearestMessage(MOCK_STATIC_INVOCATIONS);
            if (invocationByClassName == null || invocationByClassName.isEmpty()) {
                // If there are no invocations, nothing needs to be done here
                return classDecl;
            }
            // Add field declarations of mocked types
            Map<J.Identifier, Expression> mockedTypesIdentifiers = new LinkedHashMap<>();
            for (Expression mockedStaticClass : mockedStaticClasses) {
                JavaType.Parameterized classType = TypeUtils.asParameterized(mockedStaticClass.getType());
                if (classType == null) {
                    continue;
                }
                JavaType.FullyQualified fullyQualifiedMockedType = TypeUtils.asFullyQualified(classType.getTypeParameters().get(0));
                if (fullyQualifiedMockedType == null) {
                    continue;
                }
                String classlessTypeName = fullyQualifiedMockedType.getClassName();
                if (invocationByClassName.get(classlessTypeName + "".class"") == null) {
                    // Only add fields for classes that are actually invoked by mockStatic()
                    // The not mocked class can be removed from import
                    maybeRemoveImport(fullyQualifiedMockedType.getFullyQualifiedName());
                    continue;
                }
                String mockedTypedFieldName = MOCK_PREFIX + classlessTypeName;
                if (isFieldAlreadyDefined(classDecl.getBody(), mockedTypedFieldName)) {
                    continue;
                }
                classDecl = JavaTemplate.builder(""private MockedStatic<#{}> "" + MOCK_PREFIX + ""#{};"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-3.12""))
                        .staticImports(""org.mockito.Mockito.mockStatic"")
                        .imports(MOCKED_STATIC)
                        .build()
                        .apply(
                                new Cursor(getCursor().getParentOrThrow(), classDecl),
                                classDecl.getBody().getCoordinates().firstStatement(),
                                classlessTypeName,
                                classlessTypeName.replace(""."", ""_"")
                        );

                J.VariableDeclarations mockField = (J.VariableDeclarations) classDecl.getBody().getStatements().get(0);
                mockedTypesIdentifiers.put(mockField.getVariables().get(0).getName(), mockedStaticClass);
            }
            getCursor().putMessage(MOCKED_TYPES_FIELDS, mockedTypesIdentifiers);

            maybeAutoFormat(classDecl, classDecl.withPrefix(classDecl.getPrefix().
                    withWhitespace("""")), classDecl.getName(), ctx, getCursor());
            maybeAddImport(MOCKED_STATIC);
            maybeAddImport(""org.mockito.Mockito"", ""mockStatic"");
            return classDecl;
        }

        private J.ClassDeclaration maybeAddSetUpMethodBody(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            String testGroupsAsString = getTestGroupsAsString();
            return maybeAddMethodWithAnnotation(this, classDecl, ctx, false, ""setUpStaticMocks"",
                    setUpMethodAnnotationSignature, setUpMethodAnnotation,
                    additionalClasspathResource, setUpImportToAdd, testGroupsAsString);
        }

        private String getTestGroupsAsString() {
            List<Expression> testGroups = getCursor().getNearestMessage(TEST_GROUP);
            String testGroupsAsString = """";
            if (testGroups != null) {
                testGroupsAsString = ""("" +
                                     testGroups.stream().map(Object::toString).collect(joining("","")) +
                                     "")"";
            }
            return testGroupsAsString;
        }

        private J.ClassDeclaration maybeAddTearDownMethodBody(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            String testGroupsAsString = (getTestGroupsAsString().isEmpty()) ? tearDownMethodAnnotationParameters : getTestGroupsAsString();
            return maybeAddMethodWithAnnotation(this, classDecl, ctx, false, ""tearDownStaticMocks"",
                    tearDownMethodAnnotationSignature,
                    tearDownMethodAnnotation,
                    additionalClasspathResource, tearDownImportToAdd, testGroupsAsString);
        }


        private J.MethodInvocation modifyWhenMethodInvocation(J.MethodInvocation whenMethod) {
            List<Expression> methodArguments = whenMethod.getArguments();
            List<J.MethodInvocation> staticMethodInvocationsInArguments = methodArguments.stream()
                    .filter(J.MethodInvocation.class::isInstance).map(J.MethodInvocation.class::cast)
                    .filter(methodInvocation -> !MOCKITO_STATIC_METHOD_MATCHER.matches(methodInvocation))
                    .filter(methodInvocation -> methodInvocation.getMethodType() != null)
                    .filter(methodInvocation -> methodInvocation.getMethodType().hasFlags(Flag.Static))
                    .collect(toList());
            if (staticMethodInvocationsInArguments.size() == 1) {
                J.MethodInvocation staticMI = staticMethodInvocationsInArguments.get(0);
                Expression lambdaInvocation;
                String declaringClassName = getDeclaringClassName(staticMI);
                J.Identifier mockedStaticClassField = getFieldIdentifier(MOCK_PREFIX + declaringClassName);
                if (mockedStaticClassField == null) {
                    // The field definition of the static mocked class is still missing.
                    // Return and wait for the second invocation
                    return whenMethod;
                }
                if (staticMI.getArguments().stream().map(Expression::getType)
                        .noneMatch(Objects::nonNull)) {
                    // If the method invocation has no arguments
                    lambdaInvocation = JavaTemplate.builder(declaringClassName + ""::"" + staticMI.getSimpleName())
                            .contextSensitive()
                            .build()
                            .apply(new Cursor(getCursor(), staticMI), staticMI.getCoordinates().replace());
                } else {
                    JavaType.Method methodType = staticMI.getMethodType();
                    if (methodType != null) {
                        lambdaInvocation = JavaTemplate.builder(""() -> #{any()}"")
                                .contextSensitive()
                                .build()
                                .apply(new Cursor(getCursor(), staticMI), staticMI.getCoordinates().replace(), staticMI);
                    } else {
                        // do nothing
                        lambdaInvocation = staticMI;
                    }
                }
                if (replaceAll(methodArguments, staticMI, lambdaInvocation)) {
                    whenMethod = whenMethod.withSelect(mockedStaticClassField);
                    whenMethod = whenMethod.withArguments(methodArguments);
                }
            }
            return whenMethod;
        }

        private @Nullable String getDeclaringClassName(J.MethodInvocation mi) {
            JavaType.Method methodType = mi.getMethodType();
            if (methodType != null) {
                JavaType.FullyQualified declaringType = methodType.getDeclaringType();
                return declaringType.getClassName();
            }
            return null;
        }

        private J.@Nullable Identifier getFieldIdentifier(String fieldName) {
            return getMockedTypesFields().keySet().stream()
                    .filter(identifier -> identifier.getSimpleName().equals(fieldName)).findFirst()
                    .orElseGet(() -> {
                        J.ClassDeclaration cd = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance).getValue();
                        return cd.getBody().getStatements().stream()
                                .filter(J.VariableDeclarations.class::isInstance)
                                .map(variableDeclarations -> ((J.VariableDeclarations) variableDeclarations).getVariables())
                                .flatMap(Collection::stream)
                                .filter(namedVariable -> namedVariable.getSimpleName().equals(fieldName))
                                .map(J.VariableDeclarations.NamedVariable::getName)
                                .findFirst()
                                .orElse(null);
                    });
        }
    }
}
",{}
Replace `PowerMockito.whenNew` with Mockito counterpart,Replaces `PowerMockito.whenNew` calls with respective `Mockito.whenConstructed` calls.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toSet;
import static org.openrewrite.java.VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER;
import static org.openrewrite.java.VariableNameUtils.generateVariableName;

public class PowerMockitoWhenNewToMockito extends Recipe {

    private static final MethodMatcher PM_WHEN_NEW = new MethodMatcher(""org.powermock.api.mockito.PowerMockito whenNew(..)"");
    private static final MethodMatcher WITH_NO_ARGUMENTS = new MethodMatcher(""*..* withNoArguments()"");
    private static final MethodMatcher WITH_ARGUMENTS = new MethodMatcher(""*..* withArguments(..)"");
    private static final MethodMatcher WITH_ANY_ARGUMENTS = new MethodMatcher(""*..* withAnyArguments()"");
    private static final MethodMatcher THEN_RETURN = new MethodMatcher(""org.mockito.stubbing.OngoingStubbing thenReturn(..)"");
    private static final MethodMatcher MOCKITO_MOCK = new MethodMatcher(""org.mockito.Mockito mock(..)"");
    private static final MethodMatcher PM_MOCK = new MethodMatcher(""org.powermock.api.mockito.PowerMockito mock(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace `PowerMockito.whenNew` with Mockito counterpart"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `PowerMockito.whenNew` calls with respective `Mockito.whenConstructed` calls."";
    }

    private static String extractClassName(J.FieldAccess fieldAccess) {
        Expression target = fieldAccess.getTarget();
        if (target instanceof J.FieldAccess) {
            return ((J.FieldAccess) target).getSimpleName();
        }
        if (target instanceof J.Identifier) {
            return ((J.Identifier) target).getSimpleName();
        }
        return fieldAccess.getSimpleName();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(PM_WHEN_NEW), new JavaVisitor<ExecutionContext>() {
            @Override
            public @Nullable J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (THEN_RETURN.matches(method) && method.getSelect() instanceof J.MethodInvocation) {
                    J.MethodInvocation select1 = (J.MethodInvocation) method.getSelect();
                    boolean withArgumentsMethodMatch = WITH_ANY_ARGUMENTS.matches(select1) || WITH_ARGUMENTS.matches(select1) || WITH_NO_ARGUMENTS.matches(select1);
                    if (withArgumentsMethodMatch && select1.getSelect() instanceof J.MethodInvocation) {
                        J.MethodInvocation select2 = (J.MethodInvocation) select1.getSelect();
                        if (PM_WHEN_NEW.matches(select2) && select2.getArguments().size() == 1) {
                            maybeRemoveImport(""org.powermock.api.mockito.PowerMockito"");

                            Cursor containingMethod = getCursor().dropParentUntil(x -> x instanceof J.MethodDeclaration);
                            Expression argument = select2.getArguments().get(0);
                            if (argument instanceof J.FieldAccess) {
                                ArrayList<J.FieldAccess> listOfMocks = containingMethod.getMessage(""POWERMOCKITO_WHEN_NEW_REPLACED"", new ArrayList<J.FieldAccess>());
                                listOfMocks.add((J.FieldAccess) argument);
                                containingMethod.putMessage(""POWERMOCKITO_WHEN_NEW_REPLACED"", listOfMocks);
                                return null;
                            }
                        }
                    }
                }
                return super.visitMethodInvocation(method, ctx);
            }

            @Override
            public J visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J ret = super.visitMethodDeclaration(method, ctx);
                List<J.FieldAccess> mockArguments = getCursor().getMessage(""POWERMOCKITO_WHEN_NEW_REPLACED"");
                if (mockArguments != null && ret instanceof J.MethodDeclaration) {
                    doAfterVisit(removeMockUsagesVisitor(mockArguments, method));

                    J.MethodDeclaration retM = (J.MethodDeclaration) ret;

                    // onlyIfReferenced=false as `maybeAddImport` doesn't seem to find the type referred to in a try statement
                    // see https://github.com/openrewrite/rewrite/issues/5187
                    maybeAddImport(""org.mockito.MockedConstruction"", false);
                    maybeAddImport(""org.mockito.Mockito"", false);

                    for (J.FieldAccess mockArgument: mockArguments) {
                        String mockedClassName = extractClassName(mockArgument);
                        String variableNameForMock = generateVariableName(""mock"" + mockedClassName, updateCursor(ret), INCREMENT_NUMBER);
                        J.MethodDeclaration appliedTemplate = JavaTemplate.builder(String.format(""try (MockedConstruction<%s> %s = Mockito.mockConstruction(%s.class)) { } "", mockedClassName, variableNameForMock, mockedClassName))
                                .contextSensitive()
                                .imports(""org.mockito.MockedConstruction"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core""))
                                .build()
                                .apply(getCursor(), method.getCoordinates().replaceBody());
                        J.Try try_ = (J.Try) appliedTemplate.getBody().getStatements().get(0);
                        retM = appliedTemplate.withBody(appliedTemplate.getBody().withStatements(singletonList(try_.withBody(retM.getBody()))));
                    }
                    return autoFormat(retM, ctx);
                }
                return ret;
            }

            private JavaIsoVisitor<ExecutionContext> removeMockUsagesVisitor(List<J.FieldAccess> mockArguments, J.MethodDeclaration inMethod) {
                Set<String> mockedClassNames = mockArguments.stream().map(PowerMockitoWhenNewToMockito::extractClassName).collect(toSet());
                return new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                        J.VariableDeclarations ret = super.visitVariableDeclarations(multiVariable, ctx);
                        if (!inMethod.equals(getCursor().firstEnclosing(J.MethodDeclaration.class))) {
                            return ret;
                        }
                        List<J.VariableDeclarations.NamedVariable> variables = ListUtils.filter(ret.getVariables(), varr -> {
                            // The original code likely contains PowerMockito.mock(), but that gets converted to Mockito.mock() by other subrecipes of
                            // org.openrewrite.java.testing.mockito.ReplacePowerMockito, so we need to check both.
                            if (varr.getInitializer() instanceof J.MethodInvocation && (MOCKITO_MOCK.matches(varr.getInitializer()) || PM_MOCK.matches(varr.getInitializer()))) {
                                J.MethodInvocation initializer = (J.MethodInvocation) varr.getInitializer();
                                if (initializer.getArguments().size() == 1 && initializer.getArguments().get(0) instanceof J.FieldAccess) {
                                    J.FieldAccess classReference = (J.FieldAccess) initializer.getArguments().get(0);
                                    if (mockedClassNames.contains(extractClassName(classReference))) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                        return variables.isEmpty() ? null : ret.withVariables(variables);
                    }
                };
            }
        });
    }
}
",{}
Close unclosed static mocks,Ensures that all `mockStatic` calls are properly closed. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toSet;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER;
import static org.openrewrite.java.VariableNameUtils.generateVariableName;

/**
 * Ensures that all mockStatic calls are properly closed.
 * If mockStatic is in lifecycle methods like @BeforeEach or @BeforeAll,
 * creates a class variable and closes it in @AfterEach or @AfterAll.
 * If mockStatic is inside a test method, wraps it in a try-with-resources block.
 */
public class CloseUnclosedStaticMocks extends Recipe {

    private static final MethodMatcher MOCKED_STATIC_CLOSE_MATCHER = new MethodMatcher(""org.mockito.ScopedMock close*(..)"");
    private static final MethodMatcher MOCK_STATIC_MATCHER = new MethodMatcher(""org.mockito.Mockito mockStatic(..)"");
    private static final AnnotationMatcher AFTER_EACH_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.AfterEach"");
    private static final AnnotationMatcher AFTER_ALL_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.AfterAll"");

    @Override
    public String getDisplayName() {
        return ""Close unclosed static mocks"";
    }

    @Override
    public String getDescription() {
        return ""Ensures that all `mockStatic` calls are properly closed. "" +
               ""If `mockStatic` is in lifecycle methods like `@BeforeEach` or `@BeforeAll`, "" +
               ""creates a class variable and closes it in `@AfterEach` or `@AfterAll`. "" +
               ""If `mockStatic` is inside a test method, wraps it in a try-with-resources block."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(MOCK_STATIC_MATCHER), new CloseUnclosedStaticMocksVisitor());
    }

    private static class CloseUnclosedStaticMocksVisitor extends JavaVisitor<ExecutionContext> {

        @Override
        public J visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            J j = super.visitCompilationUnit(cu, ctx);
            if (j != cu) {
                maybeAddImport(""org.mockito.MockedStatic"");
                maybeAddImport(""org.junit.jupiter.api.AfterEach"");
                maybeAddImport(""org.junit.jupiter.api.AfterAll"");
            }
            return j;
        }

        @Override
        public J visitTryResource(J.Try.Resource tryResource, ExecutionContext ctx) {
            if (tryResource.getVariableDeclarations() instanceof J.VariableDeclarations) {
                J.VariableDeclarations vd = (J.VariableDeclarations) tryResource.getVariableDeclarations();
                Set<String> tryWithResourceVars =
                        vd.getVariables().stream()
                                .map(J.VariableDeclarations.NamedVariable::getSimpleName)
                                .collect(toSet());
                getCursor()
                        .dropParentUntil(J.MethodDeclaration.class::isInstance)
                        .computeMessageIfAbsent(""tryWithResourceVars"", k -> new HashSet<>())
                        .addAll(tryWithResourceVars);
            }
            return tryResource;
        }

        @Override
        public J visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            Cursor cursor = getCursor();
            new Annotated.Matcher(""@org.junit.jupiter.api.*"").asVisitor(a -> {
                String annotationName = a.getTree().getSimpleName();
                if (annotationName.startsWith(""Before"")) {
                    cursor.putMessage(MethodType.class.getSimpleName(), MethodType.LIFECYCLE);
                } else if (annotationName.endsWith(""Test"")) {
                    cursor.putMessage(MethodType.class.getSimpleName(), MethodType.TESTABLE);
                }
                return a.getTree();
            }).visit(method, ctx);

            // neither lifecycle nor test method.
            if (cursor.getMessage(MethodType.class.getSimpleName()) == null) {
                return method;
            }
            cursor.putMessage(""staticMethod"", method.hasModifier(J.Modifier.Type.Static));
            return super.visitMethodDeclaration(method, ctx);
        }

        @Override
        public @Nullable J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
            if (isRedundantCloseOfTryWithResource(mi)) {
                return null;
            }
            if (!MOCK_STATIC_MATCHER.matches(mi) || !insideLifecycleMethod()) {
                return mi;
            }
            if (getCursor().getParentTreeCursor().getValue() instanceof J.Block) {
                String mockedClassName = getMockedClassName(mi);
                if (mockedClassName != null) {
                    Cursor classCursor = getCursor().dropParentUntil(J.ClassDeclaration.class::isInstance);
                    String varName = generateMockedVarName(mockedClassName);
                    J.Assignment assignment = JavaTemplate.builder(varName + "" = #{any()}"")
                            .build()
                            .apply(updateCursor(mi), mi.getCoordinates().replace(), mi);
                    boolean isStatic = Boolean.TRUE.equals(getCursor().getNearestMessage(""staticMethod""));
                    doAfterVisit(new DeclareMockVarAndClose(getScopedClassName(), varName, mockedClassName, isStatic));
                    return assignment;
                }
            }
            return mi;
        }

        @Override
        public J visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            if (MOCK_STATIC_MATCHER.matches(assignment.getAssignment())) {
                if (assignment.getVariable() instanceof J.Identifier) {
                    JavaType.Variable varType = ((J.Identifier) assignment.getVariable()).getFieldType();
                    if (varType != null && varType.getOwner() instanceof JavaType.Class) {
                        doAfterVisit(new DeclareMockVarAndClose(getScopedClassName(), varType.getName(), null, varType.getFlags().contains(Flag.Static)));
                    }
                }
            }
            return super.visitAssignment(assignment, ctx);
        }

        @Override
        public J visitVariableDeclarations(J.VariableDeclarations variableDeclarations, ExecutionContext ctx) {
            J.VariableDeclarations vd = (J.VariableDeclarations) super.visitVariableDeclarations(variableDeclarations, ctx);
            J.VariableDeclarations.NamedVariable namedVariable = vd.getVariables().get(0);
            if (!MOCK_STATIC_MATCHER.matches(namedVariable.getInitializer()) || !insideLifecycleMethod()) {
                return vd;
            }
            if (namedVariable.getInitializer() == null) {
                return vd;
            }
            String varName = namedVariable.getSimpleName();
            String mockedClassName = getMockedClassName((J.MethodInvocation) namedVariable.getInitializer());
            if (mockedClassName != null) {
                boolean isStatic = vd.hasModifier(J.Modifier.Type.Static) ||
                                Boolean.TRUE.equals(getCursor().getNearestMessage(""staticMethod""));
                doAfterVisit(new DeclareMockVarAndClose(getScopedClassName(), varName, mockedClassName, isStatic));
                return JavaTemplate.builder(varName + "" = #{any()}"").contextSensitive().build()
                        .apply(updateCursor(vd), vd.getCoordinates().replace(), namedVariable.getInitializer());
            }
            return vd;
        }

        @Override
        public J visitBlock(J.Block block, ExecutionContext ctx) {
            J.Block b = (J.Block) super.visitBlock(block, ctx);
            if (insideLifecycleMethod()) {
                return b;
            }
            AtomicBoolean removeStatement = new AtomicBoolean(false);
            J.Block b1 = block.withStatements(ListUtils.map(b.getStatements(), statement -> {
                if (!removeStatement.get() && shouldUseTryWithResources(statement)) {
                    J.Try tryWithResource = toTryWithResource(b, statement, ctx);
                    if (tryWithResource != null) {
                        removeStatement.set(true);
                        return (J.Try) super.visitTry(tryWithResource, ctx);
                    }
                }
                return removeStatement.get() ? null : statement;
            }));
            return maybeAutoFormat(b, b1, ctx);
        }

        private J.@Nullable Try toTryWithResource(J.Block block, Statement statement, ExecutionContext ctx) {
            String code = null;
            if (statement instanceof J.MethodInvocation) {
                String mockedClassName = getMockedClassName((J.MethodInvocation) statement);
                if (mockedClassName != null) {
                    String varName = generateMockedVarName(mockedClassName);
                    code = String.format(""try(MockedStatic<%s> %s = #{any()}) {}"", mockedClassName, varName);
                }
            } else if (statement instanceof J.VariableDeclarations || statement instanceof J.Assignment) {
                code = ""try(#{any()}) {}"";
            }
            if (code == null) {
                return null;
            }
            J.Try tryWithResources = JavaTemplate.builder(code)
                    .contextSensitive()
                    .imports(""org.mockito.MockedStatic"")
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-5""))
                    .build().apply(new Cursor(getCursor(), statement), statement.getCoordinates().replace(), statement);
            return maybeAutoFormat(tryWithResources, tryWithResources.withBody(findSuccessorStatements(statement, block)), ctx);
        }

        private @Nullable String getMockedClassName(J.MethodInvocation methodInvocation) {
            JavaType.Parameterized type = TypeUtils.asParameterized(methodInvocation.getType());
            if (type != null && type.getTypeParameters().size() == 1) {
                JavaType.FullyQualified mockedClass = TypeUtils.asFullyQualified(type.getTypeParameters().get(0));
                if (mockedClass != null) {
                    return mockedClass.getClassName();
                }
            }
            return null;
        }

        private boolean shouldUseTryWithResources(@Nullable Statement statement) {
            if (statement instanceof J.VariableDeclarations) {
                J.VariableDeclarations varDecl = (J.VariableDeclarations) statement;
                return MOCK_STATIC_MATCHER.matches(varDecl.getVariables().get(0).getInitializer());
            }
            if (statement instanceof J.MethodInvocation) {
                return MOCK_STATIC_MATCHER.matches((J.MethodInvocation) statement);
            }
            return false;
        }

        private J.Block findSuccessorStatements(Statement statement, J.Block block) {
            List<Statement> successors = new ArrayList<>();
            boolean found = false;
            for (Statement successor : block.getStatements()) {
                if (found) {
                    successors.add(successor);
                }
                found = found || successor == statement;
            }
            return new J.Block(randomId(), Space.EMPTY, Markers.EMPTY,
                    new JRightPadded<>(false, Space.EMPTY, Markers.EMPTY), emptyList(),
                    Space.format("" "")).withStatements(successors);
        }

        private String generateMockedVarName(String mockedClassName) {
            return generateVariableName(""mockedStatic"" + mockedClassName.replace(""."", ""_""), getCursor(), INCREMENT_NUMBER);
        }

        private boolean insideLifecycleMethod() {
            return getCursor().getNearestMessage(MethodType.class.getSimpleName()) == MethodType.LIFECYCLE;
        }

        private @Nullable String getScopedClassName() {
            J.ClassDeclaration enclosingClass = getCursor().firstEnclosing(J.ClassDeclaration.class);
            return enclosingClass != null ? enclosingClass.getSimpleName() : null;
        }

        private boolean isRedundantCloseOfTryWithResource(J.MethodInvocation mi) {
            if (!MOCKED_STATIC_CLOSE_MATCHER.matches(mi)) {
                return false;
            }
            if (mi.getSelect() instanceof J.Identifier) {
                J.Identifier ident = (J.Identifier) mi.getSelect();
                Set<String> tryWithResourceVars = getCursor().getNearestMessage(""tryWithResourceVars"");
                return tryWithResourceVars != null && tryWithResourceVars.contains(ident.getSimpleName());
            }
            return false;
        }
    }

    @RequiredArgsConstructor
    private static class DeclareMockVarAndClose extends JavaIsoVisitor<ExecutionContext> {

        @Nullable
        private final String scopedClassName;

        private final String varName;

        @Nullable
        private final String mockedClassName;

        private final boolean isStatic;

        private boolean closed = false;

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            if (!classDecl.getSimpleName().equals(scopedClassName)) {
                return classDecl;
            }
            J.ClassDeclaration cd = classDecl;
            if (!isVarDeclared(cd, varName)) {
                String modifier = isStatic ? ""static "" : """";
                String varTemplate = ""private "" + modifier + ""MockedStatic<"" + mockedClassName + ""> "" + varName + "";"";
                cd = JavaTemplate.builder(varTemplate)
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-5""))
                        .imports(""org.mockito.MockedStatic"")
                        .build().apply(getCursor(), classDecl.getBody().getCoordinates().firstStatement());
            }
            cd = super.visitClassDeclaration(cd, ctx);
            if (closed) {
                return cd;
            }
            String methodName = tearDownMethodName(cd);
            String methodTemplate = String.format(""%s void %s() { %s.closeOnDemand(); }"",
                    isStatic ? ""@AfterAll public static"" : ""@AfterEach public"", methodName, varName);
            return JavaTemplate.builder(methodTemplate)
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                    .imports(""org.junit.jupiter.api.AfterEach"", ""org.junit.jupiter.api.AfterAll"")
                    .build().apply(updateCursor(cd), classDecl.getBody().getCoordinates().lastStatement());
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(methodDecl, ctx);
            if (closed) {
                return md;
            }
            AnnotationMatcher annotationMatcher = isStatic ? AFTER_ALL_MATCHER : AFTER_EACH_MATCHER;
            boolean matched = new Annotated.Matcher(annotationMatcher).<AtomicBoolean>asVisitor((a, found) -> {
                found.set(true);
                return a.getTree();
            }).reduce(md, new AtomicBoolean()).get();
            if (!matched) {
                return md;
            }
            closed = true;
            return JavaTemplate.builder(varName + "".closeOnDemand()"").contextSensitive().build()
                    .apply(updateCursor(md), md.getBody().getCoordinates().lastStatement());
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
            if (methodInvocation.getSelect() instanceof J.Identifier) {
                String selector = ((J.Identifier) methodInvocation.getSelect()).getSimpleName();
                if (selector.equals(varName) && methodInvocation.getSimpleName().startsWith(""close"")) {
                    closed = true;
                }
            }
            return super.visitMethodInvocation(methodInvocation, ctx);
        }

        private String tearDownMethodName(J.ClassDeclaration cd) {
            String methodName = ""tearDown"";
            int suffix = 0;
            String updatedMethodName = methodName;
            for (Statement st : cd.getBody().getStatements()) {
                if (st instanceof J.MethodDeclaration && ((J.MethodDeclaration) st).getSimpleName().equals(updatedMethodName)) {
                    updatedMethodName = methodName + suffix++;
                }
            }
            return updatedMethodName;
        }

        private boolean isVarDeclared(J.ClassDeclaration cd, String varName) {
            return cd.getBody().getStatements().stream()
                    .filter(s -> s instanceof J.VariableDeclarations)
                    .map(J.VariableDeclarations.class::cast)
                    .flatMap(vd -> vd.getVariables().stream())
                    .anyMatch(var -> var.getSimpleName().equals(varName));
        }
    }

    private enum MethodType {
        LIFECYCLE,
        TESTABLE
    }
}
",{}
Use static form of Mockito `MockUtil`,Best-effort attempt to remove Mockito `MockUtil` instances.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.*;
import org.openrewrite.java.ChangeMethodTargetToStatic;
import org.openrewrite.java.DeleteStatement;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

/**
 * In Mockito 1 you use a code snippet like:
 * <p>
 * new MockUtil().isMock(foo);
 * <p>
 * In Mockito 2+ this class now has a private constructor and only exposes static methods:
 * <p>
 * MockUtil.isMock(foo);
 * <p>
 * This recipe makes a best-effort attempt to remove MockUtil instances, but if someone did something unexpected like
 * subclassing MockUtils that will not be handled and will have to be hand-remediated.
 */
public class MockUtilsToStatic extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use static form of Mockito `MockUtil`"";
    }

    @Override
    public String getDescription() {
        return ""Best-effort attempt to remove Mockito `MockUtil` instances."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.mockito.internal.util.MockUtil"", false), new MockUtilsToStaticVisitor());
    }

    public static class MockUtilsToStaticVisitor extends JavaVisitor<ExecutionContext> {
        private static final MethodMatcher METHOD_MATCHER = new MethodMatcher(""org.mockito.internal.util.MockUtil <constructor>()"");
        private final ChangeMethodTargetToStatic changeMethodTargetToStatic = new ChangeMethodTargetToStatic(""org.mockito.internal.util.MockUtil *(..)"", ""org.mockito.internal.util.MockUtil"", null, null, false);

        @Override
        public J visitCompilationUnit(J.CompilationUnit compilationUnit, ExecutionContext ctx) {
            J.CompilationUnit cu = (J.CompilationUnit) super.visitCompilationUnit(compilationUnit, ctx);
            return (J.CompilationUnit) changeMethodTargetToStatic.getVisitor().visitNonNull(cu, ctx);
        }

        @Override
        public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            if (METHOD_MATCHER.matches(newClass)) {
                // Check to see if the new MockUtil() is being assigned to a variable or field, like
                // MockUtil util = new MockUtil();
                // If it is, then we'll get rid of it

                Cursor parent = getCursor().dropParentUntil(J.class::isInstance);
                if (parent.getValue() instanceof J.VariableDeclarations.NamedVariable) {
                    Object namedVar = parent.dropParentUntil(J.class::isInstance).getValue();
                    if (namedVar instanceof J.VariableDeclarations) {
                        doAfterVisit(new DeleteStatement<>((J.VariableDeclarations) namedVar));
                    }
                }
            }
            return super.visitNewClass(newClass, ctx);
        }
    }
}
",{}
Remove `MockitoAnnotations.initMocks(this)` if specified JUnit runners,Remove `MockitoAnnotations.initMocks(this)` if specified class-level JUnit runners `@RunWith(MockitoJUnitRunner.class)` or `@ExtendWith(MockitoExtension.class)`.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;

public class RemoveInitMocksIfRunnersSpecified extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove `MockitoAnnotations.initMocks(this)` if specified JUnit runners"";
    }

    @Override
    public String getDescription() {
        return ""Remove `MockitoAnnotations.initMocks(this)` if specified class-level JUnit runners `@RunWith(MockitoJUnitRunner.class)` or `@ExtendWith(MockitoExtension.class)`."";
    }

    private static final String MOCKITO_EXTENSION = ""org.mockito.junit.jupiter.MockitoExtension"";
    private static final String MOCKITO_JUNIT_RUNNER = ""org.mockito.junit.MockitoJUnitRunner"";
    private static final AnnotationMatcher MOCKITO_EXTENSION_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.extension.ExtendWith("" + MOCKITO_EXTENSION + "".class)"");
    private static final AnnotationMatcher MOCKITO_JUNIT_MATCHER = new AnnotationMatcher(""@org.junit.runner.RunWith("" + MOCKITO_JUNIT_RUNNER + "".class)"");
    private static final MethodMatcher INIT_MOCKS_MATCHER = new MethodMatcher(""org.mockito.MockitoAnnotations initMocks(..)"", false);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new UsesMethod<>(INIT_MOCKS_MATCHER),
                        Preconditions.or(
                                new UsesType<>(MOCKITO_EXTENSION, false),
                                new UsesType<>(MOCKITO_JUNIT_RUNNER, false)
                        )
                ),
                new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if (INIT_MOCKS_MATCHER.matches(mi)) {
                            maybeRemoveImport(""org.mockito.MockitoAnnotations"");
                            return null;
                        }
                        return mi;
                    }

                    @Override
                    public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                        if (md != method && md.getBody() != null && md.getBody().getStatements().isEmpty()) {
                            maybeRemoveImport(""org.junit.jupiter.api.BeforeEach"");
                            maybeRemoveImport(""org.junit.Before"");
                            return null;
                        }
                        return md;
                    }

                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration cd, ExecutionContext ctx) {
                        if (service(AnnotationService.class).matches(updateCursor(cd), MOCKITO_EXTENSION_MATCHER) ||
                                service(AnnotationService.class).matches(updateCursor(cd), MOCKITO_JUNIT_MATCHER)) {
                            return super.visitClassDeclaration(cd, ctx);
                        }
                        return cd;
                    }
                }
        );
    }
}
",{}
Call to Mockito method \,Fixes Sonar issue `java:S6068`: Call to Mockito method \,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.MethodCall;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;

public class SimplifyMockitoVerifyWhenGiven extends Recipe {

    private static final MethodMatcher WHEN_MATCHER = new MethodMatcher(""org.mockito.Mockito when(..)"");
    private static final MethodMatcher GIVEN_MATCHER = new MethodMatcher(""org.mockito.BDDMockito given(..)"");
    private static final MethodMatcher VERIFY_MATCHER = new MethodMatcher(""org.mockito.Mockito verify(..)"");
    private static final MethodMatcher STUBBER_MATCHER = new MethodMatcher(""org.mockito.stubbing.Stubber when(..)"");
    private static final MethodMatcher EQ_MATCHER = new MethodMatcher(""org.mockito.ArgumentMatchers eq(..)"");
    private static final MethodMatcher MOCKITO_EQ_MATCHER = new MethodMatcher(""org.mockito.Mockito eq(..)"");

    @Override
    public String getDisplayName() {
        return ""Call to Mockito method \""verify\"", \""when\"" or \""given\"" should be simplified"";
    }

    @Override
    public String getDescription() {
        return ""Fixes Sonar issue `java:S6068`: Call to Mockito method \""verify\"", \""when\"" or \""given\"" should be simplified."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-6068"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(new UsesMethod<>(EQ_MATCHER), new UsesMethod<>(MOCKITO_EQ_MATCHER)),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(methodInvocation, ctx);

                        if ((WHEN_MATCHER.matches(mi) || GIVEN_MATCHER.matches(mi)) && mi.getArguments().get(0) instanceof J.MethodInvocation) {
                            List<Expression> updatedArguments = new ArrayList<>(mi.getArguments());
                            updatedArguments.set(0, checkAndUpdateEq((J.MethodInvocation) mi.getArguments().get(0)));
                            mi = mi.withArguments(updatedArguments);
                        } else if (VERIFY_MATCHER.matches(mi.getSelect()) ||
                                   STUBBER_MATCHER.matches(mi.getSelect())) {
                            mi = checkAndUpdateEq(mi);
                        }

                        maybeRemoveImport(""org.mockito.ArgumentMatchers.eq"");
                        maybeRemoveImport(""org.mockito.Mockito.eq"");
                        return mi;
                    }

                    private J.MethodInvocation checkAndUpdateEq(J.MethodInvocation methodInvocation) {
                        if (methodInvocation.getArguments().stream().allMatch(arg -> EQ_MATCHER.matches(arg) ||
                                                                                     MOCKITO_EQ_MATCHER.matches(arg))) {
                            return methodInvocation.withArguments(ListUtils.map(methodInvocation.getArguments(), invocation ->
                                    ((MethodCall) invocation).getArguments().get(0).withPrefix(invocation.getPrefix())));
                        }
                        return methodInvocation;
                    }
                });
    }

}
",{}
Replace Mockito 1.x `anyString()` with `nullable(String.class)`,Since Mockito 2.10 `anyString()` no longer matches null values. Use `nullable(Class)` instead.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

import java.time.Duration;

/**
 * Replace Mockito 1.x `anyString()` with `nullable(String.class)`
 */
public class AnyStringToNullable extends Recipe {
    private static final MethodMatcher ANY_STRING = new MethodMatcher(""org.mockito.Mockito anyString()"");

    @Override
    public String getDisplayName() {
        return ""Replace Mockito 1.x `anyString()` with `nullable(String.class)`"";
    }

    @Override
    public String getDescription() {
        return ""Since Mockito 2.10 `anyString()` no longer matches null values. Use `nullable(Class)` instead."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ANY_STRING), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (ANY_STRING.matches(mi)) {
                    maybeAddImport(""org.mockito.ArgumentMatchers"", ""nullable"", false);
                    maybeRemoveImport(""org.mockito.Mockito.anyString"");
                    return JavaTemplate.builder(""nullable(String.class)"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core-3.12""))
                            .staticImports(""org.mockito.ArgumentMatchers.nullable"")
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace());
                }
                return mi;
            }
        });
    }
}
",{}
Replace Mockito 1.x `anyString()`/`any()` with `nullable(Class)`,Since Mockito 2.10 `anyString()` and `any()` no longer matches null values. Use `nullable(Class)` instead.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.ChangeMethodName;
import org.openrewrite.java.ChangeMethodTargetToStatic;
import org.openrewrite.java.dependencies.FindDependency;
import org.openrewrite.java.tree.JavaSourceFile;

import java.util.concurrent.atomic.AtomicBoolean;

public class AnyToNullable extends ScanningRecipe<AtomicBoolean> {
    @Override
    public String getDisplayName() {
        return ""Replace Mockito 1.x `anyString()`/`any()` with `nullable(Class)`"";
    }

    @Override
    public String getDescription() {
        return ""Since Mockito 2.10 `anyString()` and `any()` no longer matches null values. Use `nullable(Class)` instead."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        FindDependency findDependency = new FindDependency(""org.mockito"", ""mockito-all"", null, null, null);
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!acc.get() && tree != findDependency.getVisitor().visit(tree, ctx)) {
                    acc.set(true);
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        return Preconditions.check(acc.get(), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree preVisit(Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    stopAfterPreVisit();
                    doAfterVisit(new ChangeMethodName(
                            ""org.mockito.Mockito any(java.lang.Class)"", ""nullable"", null, null).getVisitor());
                    doAfterVisit(new ChangeMethodTargetToStatic(""org.mockito.Mockito nullable(java.lang.Class)"", ""org.mockito.ArgumentMatchers"", null, null, false).getVisitor());
                    doAfterVisit(new AnyStringToNullable().getVisitor());
                }
                return super.preVisit(tree, ctx);
            }
        });
    }
}
",{}
Replace `MockitoAnnotations.initMocks(this)` to `MockitoAnnotations.openMocks(this)`,Replace `MockitoAnnotations.initMocks(this)` to `MockitoAnnotations.openMocks(this)` and generate `AutoCloseable` mocks.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import static java.util.Collections.emptyList;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.VariableNameUtils.GenerationStrategy.INCREMENT_NUMBER;
import static org.openrewrite.java.VariableNameUtils.generateVariableName;

public class ReplaceInitMockToOpenMock extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Replace `MockitoAnnotations.initMocks(this)` to `MockitoAnnotations.openMocks(this)`"";
    }

    @Override
    public String getDescription() {
        return ""Replace `MockitoAnnotations.initMocks(this)` to `MockitoAnnotations.openMocks(this)` and generate `AutoCloseable` mocks."";
    }

    private static final String MOCKITO_EXTENSION = ""org.mockito.junit.jupiter.MockitoExtension"";
    private static final String MOCKITO_JUNIT_RUNNER = ""org.mockito.junit.MockitoJUnitRunner"";
    private static final String JUPITER_BEFORE_EACH = ""org.junit.jupiter.api.BeforeEach"";
    private static final AnnotationMatcher BEFORE_EACH_MATCHER = new AnnotationMatcher(""@"" + JUPITER_BEFORE_EACH);
    private static final AnnotationMatcher AFTER_EACH_MATCHER = new AnnotationMatcher(""@org.junit.jupiter.api.AfterEach"");
    private static final MethodMatcher INIT_MOCKS_MATCHER = new MethodMatcher(""org.mockito.MockitoAnnotations initMocks(..)"", false);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> preconditions = Preconditions.and(
                new UsesMethod<>(INIT_MOCKS_MATCHER),
                new UsesType<>(JUPITER_BEFORE_EACH, false),
                Preconditions.not(new UsesType<>(MOCKITO_EXTENSION, false)),
                Preconditions.not(new UsesType<>(MOCKITO_JUNIT_RUNNER, false))
        );
        return Preconditions.check(preconditions, new JavaIsoVisitor<ExecutionContext>() {
                    private String variableName = ""mocks"";

                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                        if (getCursor().getMessage(""initMocksFound"", false)) {
                            variableName = generateVariableName(""mocks"", getCursor(), INCREMENT_NUMBER);
                            J.ClassDeclaration after = JavaTemplate.apply(""private AutoCloseable "" + variableName + "";"",
                                    getCursor(), cd.getBody().getCoordinates().firstStatement());
                            return maybeAutoFormat(cd, after, ctx);
                        }
                        return cd;
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        if (service(AnnotationService.class).matches(getCursor(), BEFORE_EACH_MATCHER)) {
                            return super.visitMethodDeclaration(method, ctx);
                        }
                        return method;
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        if (INIT_MOCKS_MATCHER.matches(mi)) {
                            getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, ""initMocksFound"", true);
                            doAfterVisit(updateJUnitLifecycleMethods);
                        }
                        return mi;
                    }

                    final TreeVisitor<J, ExecutionContext> updateJUnitLifecycleMethods = new JavaIsoVisitor<ExecutionContext>() {

                        private final String EXCEPTION_CLASS_NAME = ""java.lang.Exception"";

                        private boolean isAnnotatedMethodPresent(J.ClassDeclaration cd, AnnotationMatcher beforeEachMatcher) {
                            return cd.getBody().getStatements().stream().anyMatch(
                                    st -> st instanceof J.MethodDeclaration &&
                                            ((J.MethodDeclaration) st).getLeadingAnnotations().stream().anyMatch(beforeEachMatcher::matches)
                            );
                        }

                        @Override
                        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration cd, ExecutionContext ctx) {
                            if (!isAnnotatedMethodPresent(cd, AFTER_EACH_MATCHER) && isAnnotatedMethodPresent(cd, BEFORE_EACH_MATCHER)) {
                                maybeAddImport(""org.junit.jupiter.api.AfterEach"");
                                cd = JavaTemplate.builder(""@AfterEach\nvoid "" + tearDownMethodName(cd) + ""() throws Exception {\n}"")
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                        .imports(""org.junit.jupiter.api.AfterEach"")
                                        .build()
                                        .apply(getCursor(), cd.getBody().getCoordinates().lastStatement());
                            }

                            cd = super.visitClassDeclaration(cd, ctx);
                            return autoFormat(cd, ctx);
                        }

                        @Override
                        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);

                            if (service(AnnotationService.class).matches(getCursor(), BEFORE_EACH_MATCHER) && md.getBody() != null) {
                                maybeRemoveImport(""org.mockito.MockitoAnnotations.initMocks"");
                                maybeAddImport(""org.mockito.MockitoAnnotations"");
                                return (J.MethodDeclaration) new JavaVisitor<ExecutionContext>() {
                                    @Override
                                    public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                        J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                                        if (INIT_MOCKS_MATCHER.matches(mi)) {
                                            return JavaTemplate.builder(variableName + "" = MockitoAnnotations.openMocks(this);"")
                                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""mockito-core""))
                                                    .imports(""org.mockito.MockitoAnnotations"")
                                                    .contextSensitive()
                                                    .build()
                                                    .apply(getCursor(), mi.getCoordinates().replace());
                                        }
                                        return mi;
                                    }
                                }.visitNonNull(md, ctx, getCursor().getParentOrThrow());
                            }
                            if (service(AnnotationService.class).matches(getCursor(), AFTER_EACH_MATCHER) && md.getBody() != null) {
                                for (Statement st : md.getBody().getStatements()) {
                                    if (st instanceof J.MethodInvocation &&
                                            ((J.MethodInvocation) st).getSelect() instanceof J.Identifier &&
                                            ((J.Identifier) ((J.MethodInvocation) st).getSelect()).getSimpleName().equals(variableName)) {
                                        return md;
                                    }
                                }

                                md = JavaTemplate.builder(variableName + "".close();"")
                                        .contextSensitive()
                                        .build()
                                        .apply(getCursor(), md.getBody().getCoordinates().lastStatement());
                                md = addThrowsIfAbsent(md);

                                return maybeAutoFormat(method, md, ctx);
                            }

                            return md;
                        }

                        private J.MethodDeclaration addThrowsIfAbsent(J.MethodDeclaration md) {
                            if (md.getThrows() != null && md.getThrows().stream().anyMatch(j -> TypeUtils.isOfClassType(j.getType(), EXCEPTION_CLASS_NAME))) {
                                return md;
                            }
                            JavaType.Class exceptionType = JavaType.ShallowClass.build(EXCEPTION_CLASS_NAME);
                            return md.withThrows(ListUtils.concat(md.getThrows(), new J.Identifier(randomId(), Space.SINGLE_SPACE, Markers.EMPTY, emptyList(), exceptionType.getClassName(), exceptionType, null)));
                        }

                        private String tearDownMethodName(J.ClassDeclaration cd) {
                            String methodName = ""tearDown"";
                            int suffix = 0;
                            String updatedMethodName = methodName;
                            for (Statement st : cd.getBody().getStatements()) {
                                if (st instanceof J.MethodDeclaration && ((J.MethodDeclaration) st).getSimpleName().equals(updatedMethodName)) {
                                    updatedMethodName = methodName + suffix++;
                                }
                            }
                            return updatedMethodName;
                        }
                    };
                }
        );
    }
}
",{}
JUnit 4 MockitoJUnitRunner.Silent to JUnit Jupiter MockitoExtension with LENIENT settings,Replace `@RunWith(MockitoJUnitRunner.Silent.class)` with `@ExtendWith(MockitoExtension.class)` and `@MockitoSettings(strictness = Strictness.LENIENT)`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.testing.junit5.RunnerToExtension;
import org.openrewrite.java.tree.J;

import java.util.Comparator;

import static java.util.Collections.singletonList;

/**
 * @deprecated Use MockitoJUnitRunnerToExtension instead.
 */
@Deprecated
public class MockitoJUnitRunnerSilentToExtension extends Recipe {

    @Override
    public String getDisplayName() {
        return ""JUnit 4 MockitoJUnitRunner.Silent to JUnit Jupiter MockitoExtension with LENIENT settings"";
    }

    @Override
    public String getDescription() {
        return ""Replace `@RunWith(MockitoJUnitRunner.Silent.class)` with `@ExtendWith(MockitoExtension.class)` and `@MockitoSettings(strictness = Strictness.LENIENT)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.mockito.junit.MockitoJUnitRunner$Silent"", false), new JavaIsoVisitor<ExecutionContext>() {

            final AnnotationMatcher silentRunnerMatcher = new AnnotationMatcher(""@org.junit.runner.RunWith(org.mockito.junit.MockitoJUnitRunner.Silent.class)"");

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (cd.getLeadingAnnotations().stream().anyMatch(silentRunnerMatcher::matches)) {
                    JavaTemplate template = JavaTemplate.builder(""@MockitoSettings(strictness = Strictness.LENIENT)"")
                            .imports(""org.mockito.quality.Strictness"", ""org.mockito.junit.jupiter.MockitoSettings"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""mockito-junit-jupiter-3.12"", ""mockito-core-3.12""))
                            .build();
                    cd = maybeAutoFormat(cd, template.apply(updateCursor(cd), cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))), ctx);
                    doAfterVisit(new RunnerToExtension(singletonList(""org.mockito.junit.MockitoJUnitRunner$Silent""),
                            ""org.mockito.junit.jupiter.MockitoExtension"").getVisitor());
                    maybeRemoveImport(""org.mockito.junit.MockitoJUnitRunner"");
                    maybeAddImport(""org.mockito.quality.Strictness"");
                    maybeAddImport(""org.mockito.junit.jupiter.MockitoSettings"");
                }
                return cd;
            }
        });
    }
}
",{}
Cleanup Mockito imports,"Removes unused `org.mockito` import symbols, unless its possible they are associated with method invocations having null or unknown type information.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.staticanalysis.kotlin.KotlinFileChecker;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CleanupMockitoImports extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Cleanup Mockito imports"";
    }

    @Override
    public String getDescription() {
        return ""Removes unused `org.mockito` import symbols, unless its possible they are associated with method invocations having null or unknown type information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                    new UsesType<>(""org.mockito.*"", false),
                    Preconditions.not(new KotlinFileChecker<>())
                ),
                new CleanupMockitoImportsVisitor());
    }

    private static class CleanupMockitoImportsVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final List<String> MOCKITO_METHOD_NAMES = Arrays.asList(
                ""after"",
                ""atLeast"",
                ""atLeastOnce"",
                ""atMost"",
                ""calls"",
                ""clearInvocations"",
                ""doAnswer"",
                ""doCallRealMethod"",
                ""doNothing"",
                ""doReturn"",
                ""doThrow"",
                ""given"",
                ""ignoreStubs"",
                ""inOrder"",
                ""mock"",
                ""mockingDetails"",
                ""never"",
                ""only"",
                ""reset"",
                ""spy"",
                ""stub"",
                ""stubVoid"",
                ""then"",
                ""timeout"",
                ""times"",
                ""verify"",
                ""verifyNoInteractions"",
                ""verifyNoMoreInteractions"",
                ""verifyZeroInteractions"",
                ""when"",
                ""will"",
                ""willAnswer"",
                ""willCallRealMethod"",
                ""willDoNothing"",
                ""willReturn"",
                ""willThrow"");

        @Override
        public @Nullable J preVisit(J tree, ExecutionContext ctx) {
            stopAfterPreVisit();
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile sf = (JavaSourceFile) tree;

                // Determine Mockito methods that are present with valid type information
                List<String> mockitoMethodsUsed = new MockitoMethodTypeVisitor().reduce(sf, new ArrayList<>());

                // Prevent removing mockito imports when an associated mockito method type is not well formed
                List<String> unknownTypeMethodInvocationNames = new WellFormedMockitoMethodTypeVisitor().reduce(sf, new ArrayList<>());
                List<String> qualifiedMethodInvocationNames = new QualifiedMockitoMethodTypeVisitor().reduce(sf, new ArrayList<>());

                for (J.Import _import : sf.getImports()) {
                    if (_import.getPackageName().startsWith(""org.mockito"")) {
                        if (_import.isStatic()) {
                            String staticName = _import.getQualid().getSimpleName();
                            if (mockitoMethodsUsed.contains(staticName)) {
                                continue;
                            }
                            if (""*"".equals(staticName)) {
                                maybeRemoveImport(_import.getPackageName() + ""."" + _import.getClassName());
                            } else if (!unknownTypeMethodInvocationNames.contains(staticName)) {
                                String fullyQualifiedName = _import.getPackageName() + ""."" + _import.getClassName() + ""."" + staticName;
                                maybeRemoveImport(fullyQualifiedName);
                            }
                        } else if (qualifiedMethodInvocationNames.isEmpty()) {
                            maybeRemoveImport(_import.getPackageName() + ""."" + _import.getClassName());
                        }
                    }
                }
            }
            return tree;
        }

        private static class MockitoMethodTypeVisitor extends JavaIsoVisitor<List<String>> {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, List<String> methods) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, methods);
                if (MOCKITO_METHOD_NAMES.contains(mi.getSimpleName()) &&
                        mi.getSelect() == null &&
                        TypeUtils.isWellFormedType(mi.getType())) {
                    methods.add(mi.getSimpleName());
                }
                return mi;
            }
        }

        private static class WellFormedMockitoMethodTypeVisitor extends JavaIsoVisitor<List<String>> {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, List<String> missingMethods) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, missingMethods);
                if (MOCKITO_METHOD_NAMES.contains(mi.getSimpleName()) && !TypeUtils.isWellFormedType(mi.getType())) {
                    missingMethods.add(mi.getSimpleName());
                }
                return mi;
            }
        }

        private static class QualifiedMockitoMethodTypeVisitor extends JavaIsoVisitor<List<String>> {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, List<String> qualifiedMethods) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, qualifiedMethods);
                if (MOCKITO_METHOD_NAMES.contains(mi.getSimpleName()) &&
                    mi.getSelect() != null &&
                    TypeUtils.isAssignableTo(""org.mockito.Mockito"", mi.getSelect().getType())) {
                    qualifiedMethods.add(mi.getSimpleName());
                }
                return mi;
            }
        }
    }
}
",{}
Replace `verifyZeroInteractions()` with `verifyNoMoreInteractions()`,Replaces `verifyZeroInteractions()` with `verifyNoMoreInteractions()` in Mockito tests when migration when using a Mockito version < 3.x.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.mockito;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.ChangeMethodName;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.dependencies.DependencyInsight;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

import java.util.concurrent.atomic.AtomicBoolean;

public class VerifyZeroToNoMoreInteractions extends ScanningRecipe<AtomicBoolean> {

    private static final String VERIFY_ZERO_INTERACTIONS = ""org.mockito.Mockito verifyZeroInteractions(..)"";
    private static final MethodMatcher ASSERT_INSTANCE_OF_MATCHER = new MethodMatcher(VERIFY_ZERO_INTERACTIONS, true);

    @Override
    public String getDisplayName() {
        return ""Replace `verifyZeroInteractions()` with `verifyNoMoreInteractions()`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `verifyZeroInteractions()` with `verifyNoMoreInteractions()` in Mockito tests when migration when using a Mockito version < 3.x."";
    }

    @Override
    public AtomicBoolean getInitialValue(final ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean usingOlderMockito) {
        TreeVisitor<?, ExecutionContext> div = new DependencyInsight(""org.mockito"", ""mockito-*"", ""[1.0,3.0)"", null).getVisitor();
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!usingOlderMockito.get() && div.visit(tree, ctx) != tree) {
                    usingOlderMockito.set(true);
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean usingOlderMockito) {
        return Preconditions.check(usingOlderMockito.get(),
                Preconditions.check(new UsesMethod<>(ASSERT_INSTANCE_OF_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation md = super.visitMethodInvocation(method, ctx);

                        if (!ASSERT_INSTANCE_OF_MATCHER.matches(md)) {
                            return md;
                        }

                        maybeAddImport(""org.mockito.Mockito"", ""verifyNoMoreInteractions"");
                        maybeRemoveImport(""org.mockito.Mockito.verifyZeroInteractions"");

                        ChangeMethodName changeMethodName = new ChangeMethodName(VERIFY_ZERO_INTERACTIONS, ""verifyNoMoreInteractions"", false, false);
                        return (J.MethodInvocation) changeMethodName.getVisitor().visitNonNull(md, ctx);
                    }
                })
        );
    }
}
",{}
Migrate the `DBRiderTestExecutionListener` to the `@DBRider` annotation,Migrate the `DBRiderTestExecutionListener` to the `@DBRider` annotation. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.dbrider;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;

import java.util.Comparator;
import java.util.List;

public class ExecutionListenerToDbRiderAnnotation extends Recipe {

    private static final AnnotationMatcher EXECUTION_LISTENER_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.springframework.test.context.TestExecutionListeners"");
    private static final AnnotationMatcher DBRIDER_ANNOTATION_MATCHER = new AnnotationMatcher(""@com.github.database.rider.junit5.api.DBRider"");
    private static final String DBRIDER_TEST_EXECUTION_LISTENER = ""com.github.database.rider.spring.DBRiderTestExecutionListener"";

    @Override
    public String getDisplayName() {
        return ""Migrate the `DBRiderTestExecutionListener` to the `@DBRider` annotation"";
    }

    @Override
    public String getDescription() {
        return ""Migrate the `DBRiderTestExecutionListener` to the `@DBRider` annotation. "" +
               ""This recipe is useful when migrating from JUnit 4 `dbrider-spring` to JUnit 5 `dbrider-junit5`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(DBRIDER_TEST_EXECUTION_LISTENER, true), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDeclaration, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDeclaration, ctx);
                DbRiderExecutionListenerContext context = DbRiderExecutionListenerContext.ofClass(cd);
                if (!context.shouldMigrate()) {
                    return cd;
                }
                if (context.shouldAddDbRiderAnnotation()) {
                    cd = JavaTemplate.builder(""@DBRider"")
                            .imports(""com.github.database.rider.junit5.api.DBRider"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""rider-junit5-1.44""))
                            .build()
                            .apply(getCursor(), cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                    maybeAddImport(""com.github.database.rider.junit5.api.DBRider"");
                }
                Space prefix = cd.getLeadingAnnotations().get(cd.getLeadingAnnotations().size() - 1).getPrefix();
                return cd.withLeadingAnnotations(ListUtils.map(cd.getLeadingAnnotations(), annotation -> {
                    if (annotation != null && EXECUTION_LISTENER_ANNOTATION_MATCHER.matches(annotation)) {
                        J.Annotation executionListenerAnnotation = context.getExecutionListenerAnnotation();
                        maybeRemoveImport(DBRIDER_TEST_EXECUTION_LISTENER);
                        maybeRemoveImport(""org.springframework.test.context.TestExecutionListeners.MergeMode"");
                        maybeRemoveImport(""org.springframework.test.context.TestExecutionListeners"");
                        if (executionListenerAnnotation != null) {
                            return executionListenerAnnotation
                                    .withArguments(firstItemPrefixWorkaround(executionListenerAnnotation.getArguments()))
                                    .withPrefix(prefix);
                        }
                        return null;
                    }
                    return annotation;
                }));
            }
        });
    }

    private static class DbRiderExecutionListenerContext {
        private J.@Nullable Annotation testExecutionListenerAnnotation;
        private boolean dbriderFound = false;
        private J.@Nullable NewArray listeners;
        private J.@Nullable FieldAccess listener;
        private @Nullable Expression inheritListeners;
        private @Nullable Expression mergeMode;

        static DbRiderExecutionListenerContext ofClass(J.ClassDeclaration clazz) {
            DbRiderExecutionListenerContext context = new DbRiderExecutionListenerContext();
            clazz.getLeadingAnnotations().forEach(annotation -> {
                if (EXECUTION_LISTENER_ANNOTATION_MATCHER.matches(annotation)) {
                    context.testExecutionListenersFound(annotation);
                } else if (DBRIDER_ANNOTATION_MATCHER.matches(annotation)) {
                    context.dbriderFound = true;
                }
            });
            return context;
        }

        private void testExecutionListenersFound(final J.Annotation annotation) {
            testExecutionListenerAnnotation = annotation;
            if (annotation.getArguments() != null) {
                annotation.getArguments().forEach(arg -> {
                    if (arg instanceof J.Assignment) {
                        J.Assignment assignment = (J.Assignment) arg;
                        switch (((J.Identifier) assignment.getVariable()).getSimpleName()) {
                            case ""value"":
                            case ""listeners"":
                                if (assignment.getAssignment() instanceof J.NewArray) {
                                    listeners = (J.NewArray) assignment.getAssignment();
                                }
                                break;
                            case ""inheritListeners"":
                                inheritListeners = assignment.getAssignment();
                                break;
                            case ""mergeMode"":
                                mergeMode = assignment.getAssignment();
                                break;
                        }
                    } else if (arg instanceof J.NewArray) {
                        listeners = (J.NewArray) arg;
                    } else if (arg instanceof J.FieldAccess) {
                        listener = (J.FieldAccess) arg;
                    }
                });
            }
        }

        public boolean shouldMigrate() {
            return isTestExecutionListenerForDbRider() && !dbriderFound;
        }

        public boolean shouldAddDbRiderAnnotation() {
            if (dbriderFound) {
                return false;
            }

            return isTestExecutionListenerForDbRider();
        }

        public J.@Nullable Annotation getExecutionListenerAnnotation() {
            if (isTestExecutionListenerForDbRider()) {
                if (canTestExecutionListenerBeRemoved()) {
                    return null;
                }
                if (testExecutionListenerAnnotation != null && testExecutionListenerAnnotation.getArguments() != null) {
                    return testExecutionListenerAnnotation.withArguments(ListUtils.map(testExecutionListenerAnnotation.getArguments(), arg -> {
                        if (arg instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) arg;
                            Expression newValue = assignment.getAssignment();
                            switch (((J.Identifier) assignment.getVariable()).getSimpleName()) {
                                case ""value"":
                                case ""listeners"":
                                    if (assignment.getAssignment() instanceof J.NewArray) {
                                        newValue = getMigratedListeners();
                                    }
                                    break;
                                case ""inheritListeners"":
                                    newValue = getMigratedInheritListeners();
                                    break;
                                case ""mergeMode"":
                                    newValue = getMigratedMergeMode();
                                    break;
                            }
                            if (newValue == null) {
                                return null;
                            }
                            return assignment.withAssignment(newValue);
                        }
                        if (arg instanceof J.NewArray) {
                            return getMigratedListeners();
                        }
                        if (arg instanceof J.FieldAccess && isTypeReference(arg, DBRIDER_TEST_EXECUTION_LISTENER)) {
                            return null;
                        }
                        return arg;
                    }));
                }
            }

            return testExecutionListenerAnnotation;
        }

        // We can only remove an execution listener annotation if:
        // - InheritListeners was null or true
        // - MergeMode was TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS
        // By default, the TestExecutionListeners.MergeMode is REPLACE_DEFAULTS so if we remove the annotation, other defaults would kick in.
        private boolean canTestExecutionListenerBeRemoved() {
            if (listener == null && listeners != null && listeners.getInitializer() != null &&
                listeners.getInitializer().stream().allMatch(listener -> isTypeReference(listener, DBRIDER_TEST_EXECUTION_LISTENER))) {
                return (getMigratedInheritListeners() == null && getMigratedMergeMode() != null);
            }
            return false;
        }

        private @Nullable Expression getMigratedMergeMode() {
            if (mergeMode instanceof J.FieldAccess && ""REPLACE_DEFAULTS"".equals(((J.FieldAccess) mergeMode).getName().getSimpleName())) {
                return null;
            }
            return mergeMode;
        }

        private @Nullable Expression getMigratedInheritListeners() {
            if (inheritListeners != null && (inheritListeners instanceof J.Literal && Boolean.TRUE.equals(((J.Literal) inheritListeners).getValue()))) {
                return null;
            }
            return inheritListeners;
        }

        // Remove the DBRiderTestExecutionListener from the listeners array
        // If the listeners array is empty after removing the DBRiderTestExecutionListener, return null so that the array itself can be removed
        private J.@Nullable NewArray getMigratedListeners() {
            if (listeners != null && listeners.getInitializer() != null) {
                List<Expression> newListeners = ListUtils.map(listeners.getInitializer(), listener -> {
                    if (listener instanceof J.FieldAccess && isTypeReference(listener, DBRIDER_TEST_EXECUTION_LISTENER)) {
                        return null;
                    }
                    return listener;
                });
                if (newListeners.isEmpty()) {
                    return null;
                }
                return listeners.withInitializer(firstItemPrefixWorkaround(newListeners));
            }
            return listeners;
        }

        private boolean isTestExecutionListenerForDbRider() {
            if (listener != null) {
                return isTypeReference(listener, DBRIDER_TEST_EXECUTION_LISTENER);
            }
            if (listeners != null && listeners.getInitializer() != null) {
                return listeners.getInitializer().stream().anyMatch(listener -> isTypeReference(listener, DBRIDER_TEST_EXECUTION_LISTENER));
            }
            return false;
        }

        private static boolean isTypeReference(Expression expression, String type) {
            return expression.getType() instanceof JavaType.Parameterized &&
                   ""java.lang.Class"".equals(((JavaType.Parameterized) expression.getType()).getFullyQualifiedName()) &&
                   ((JavaType.Parameterized) expression.getType()).getTypeParameters().size() == 1 &&
                   ((JavaType.Parameterized) expression.getType()).getTypeParameters().get(0) instanceof JavaType.Class &&
                   ((JavaType.Class) ((JavaType.Parameterized) expression.getType()).getTypeParameters().get(0)).getFullyQualifiedName().equals(type);
        }
    }

    private static <T extends Expression> @Nullable List<T> firstItemPrefixWorkaround(@Nullable List<T> list) {
        if (list == null || list.isEmpty()) {
            return list;
        }
        return ListUtils.mapFirst(list, t -> t.withPrefix(t.getPrefix().withWhitespace(t.getPrefix().getLastWhitespace().replaceAll("" $"", """"))));
    }
}
",{}
Arquillian JUnit 4 `@InSequence` to JUnit Jupiter `@Order`,Transforms the Arquillian JUnit 4 `@InSequence` to the JUnit Jupiter `@Order`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.testing.arquillian;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;

import java.util.Comparator;

public class ReplaceArquillianInSequenceAnnotation extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Arquillian JUnit 4 `@InSequence` to JUnit Jupiter `@Order`"";
    }

    @Override
    public String getDescription() {
        return ""Transforms the Arquillian JUnit 4 `@InSequence` to the JUnit Jupiter `@Order`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.jboss.arquillian.junit.InSequence"", false),
                new JavaIsoVisitor<ExecutionContext>() {
                    private final String IN_SEQUENCE = ""org.jboss.arquillian.junit.InSequence"";
                    private final String TEST_METHOD_ORDER = ""org.junit.jupiter.api.TestMethodOrder"";
                    private final String METHOD_ORDERER = ""org.junit.jupiter.api.MethodOrderer"";
                    private final AnnotationMatcher IN_SEQUENCE_MATCHER = new AnnotationMatcher(""@"" + IN_SEQUENCE);
                    private final AnnotationMatcher TEST_METHOD_ORDER_MATCHER = new AnnotationMatcher(""@"" + TEST_METHOD_ORDER);

                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        doAfterVisit(new ChangeType(IN_SEQUENCE, ""org.junit.jupiter.api.Order"", true).getVisitor());
                        return super.visitClassDeclaration(classDecl, ctx);
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
                        if (service(AnnotationService.class).matches(updateCursor(m), IN_SEQUENCE_MATCHER)) {
                            J.ClassDeclaration classWithInSequenceMethods = getCursor().firstEnclosing(J.ClassDeclaration.class);
                            if (classWithInSequenceMethods != null) {
                                doAfterVisit(new JavaIsoVisitor<ExecutionContext>() {
                                    @Override
                                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                                        J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                                        if (cd.getName().equals(classWithInSequenceMethods.getName()) &&
                                                !service(AnnotationService.class).matches(updateCursor(cd), TEST_METHOD_ORDER_MATCHER)) {
                                            maybeAddImport(METHOD_ORDERER);
                                            maybeAddImport(TEST_METHOD_ORDER);
                                            return JavaTemplate.builder(""@TestMethodOrder(MethodOrderer.OrderAnnotation.class)"")
                                                    .imports(METHOD_ORDERER, TEST_METHOD_ORDER)
                                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api-5""))
                                                    .build()
                                                    .apply(getCursor(), classDecl.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                                        }
                                        return cd;
                                    }
                                });
                            }
                        }
                        return m;
                    }
                }
        );
    }
}
",{}
