{
  "metadata": {
    "extractionDate": "2025-09-16",
    "totalRecipes": 3,
    "sourceFormat": "OpenRewrite Recipe Collection",
    "description": "Comprehensive collection of OpenRewrite recipes for Java code transformation and repair"
  },
  "statistics": {
    "totalRecipes": 3,
    "recipeTypes": {
      "Java": 3
    },
    "repositories": {
      "unknown": 3
    },
    "averageSourceCodeLength": 11781,
    "totalSourceCodeLength": 35343,
    "recipesWithDescriptions": 2,
    "recipesWithOptions": 1,
    "estimatedTotalTokens": 8835
  },
  "recipes": [
    {
      "id": 1,
      "name": "Find call graph",
      "description": "Produces a data table where each row represents a method call.",
      "type": "Java",
      "sourceCode": "/*\n * Copyright 2023 the original author or authors.\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * https://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.openrewrite;\n\nimport lombok.EqualsAndHashCode;\nimport lombok.Value;\nimport org.openrewrite.java.JavaIsoVisitor;\nimport org.openrewrite.java.tree.J;\nimport org.openrewrite.java.tree.JavaType;\nimport org.openrewrite.marker.Markup;\nimport org.openrewrite.marker.SourceSet;\nimport org.openrewrite.table.CallGraph;\n\nimport java.util.HashSet;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static java.util.Objects.requireNonNull;\n\n@EqualsAndHashCode(callSuper = false)\n@Value\npublic class FindCallGraph extends Recipe {\n    transient CallGraph callGraph = new CallGraph(this);\n\n    @Override\n    public String getDisplayName() {\n        return \"Find call graph\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Produces a data table where each row represents a method call.\";\n    }\n\n    @Option(displayName = \"Include standard library\",\n            description = \"When enabled calls to methods in packages beginning with \\\"java\\\", \\\"groovy\\\", and \\\"kotlin\\\" \" +\n                          \"will be included in the report. \" +\n                          \"By default these are omitted.\",\n            required = false)\n    boolean includeStdLib;\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor() {\n        return new JavaIsoVisitor<ExecutionContext>() {\n\n            @Override\n            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n                if (classDecl.getType() == null) {\n                    return Markup.warn(classDecl, new IllegalStateException(\"Class declaration is missing type attribution\"));\n                }\n                return super.visitClassDeclaration(classDecl, ctx);\n            }\n\n            @Override\n            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {\n                return super.visitNewClass(recordCall(newClass, ctx), ctx);\n            }\n\n            @Override\n            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {\n                return super.visitMethodInvocation(recordCall(method, ctx), ctx);\n            }\n\n            @Override\n            public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {\n                return super.visitMemberReference(recordCall(memberRef, ctx), ctx);\n            }\n\n            private <T extends J> T recordCall(T j, ExecutionContext ctx) {\n                JavaType.Method method = null;\n                if (j instanceof J.MethodInvocation) {\n                    method = ((J.MethodInvocation) j).getMethodType();\n                } else if (j instanceof J.NewClass) {\n                    method = ((J.NewClass) j).getMethodType();\n                } else if (j instanceof J.MemberReference) {\n                    method = ((J.MemberReference) j).getMethodType();\n                }\n                if (method == null) {\n                    return Markup.warn(j, new IllegalStateException(\"Method type not found\"));\n                }\n                String fqn = method.getDeclaringType().getFullyQualifiedName();\n                if (!includeStdLib && (fqn.startsWith(\"java.\") || fqn.startsWith(\"groovy.\") || fqn.startsWith(\"kotlin.\"))) {\n                    return j;\n                }\n                Cursor scope = getCursor().dropParentUntil(it -> it instanceof J.MethodDeclaration || it instanceof J.ClassDeclaration || it instanceof SourceFile);\n                String sourceSet = Optional.ofNullable(scope.firstEnclosing(SourceFile.class))\n                        .map(Tree::getMarkers)\n                        .flatMap(m -> m.findFirst(SourceSet.class))\n                        .map(SourceSet::getName)\n                        .orElse(\"unknown\");\n                if (scope.getValue() instanceof J.ClassDeclaration) {\n                    boolean isInStaticInitializer = inStaticInitializer();\n                    if ((isInStaticInitializer && scope.computeMessageIfAbsent(\"METHODS_CALLED_IN_STATIC_INITIALIZATION\", k -> new HashSet<>()).add(method)) ||\n                        (!isInStaticInitializer && scope.computeMessageIfAbsent(\"METHODS_CALLED_IN_INSTANCE_INITIALIZATION\", k -> new HashSet<>()).add(method))) {\n                        callGraph.insertRow(ctx, row(sourceSet, requireNonNull(((J.ClassDeclaration) scope.getValue()).getType()).getFullyQualifiedName(), method));\n                    }\n                } else if (scope.getValue() instanceof J.MethodDeclaration) {\n                    Set<JavaType.Method> methodsCalledInScope = scope.computeMessageIfAbsent(\"METHODS_CALLED_IN_SCOPE\", k -> new HashSet<>());\n                    if (methodsCalledInScope.add(method)) {\n                        callGraph.insertRow(ctx, row(sourceSet,requireNonNull(((J.MethodDeclaration) scope.getValue()).getMethodType()), method));\n                    }\n                } else if (scope.getValue() instanceof SourceFile) {\n                    // In Java there has to be a class declaration, but that isn't the case in Groovy/Kotlin/etc.\n                    // So we'll just use the source file path instead\n                    Set<JavaType.Method> methodsCalledInScope = scope.computeMessageIfAbsent(\"METHODS_CALLED_IN_SCOPE\", k -> new HashSet<>());\n                    if (methodsCalledInScope.add(method)) {\n                        callGraph.insertRow(ctx, row(sourceSet, ((SourceFile) scope.getValue()).getSourcePath().toString(), method));\n                    }\n                }\n                return j;\n            }\n\n            private boolean inStaticInitializer() {\n                AtomicBoolean inStaticInitializer = new AtomicBoolean();\n                getCursor().dropParentUntil(it -> {\n                    if (it instanceof SourceFile) {\n                        return true;\n                    }\n                    if (it instanceof J.Block) {\n                        J.Block b = (J.Block) it;\n                        if (b.isStatic()) {\n                            inStaticInitializer.set(true);\n                            return true;\n                        }\n                    } else if (it instanceof J.VariableDeclarations) {\n                        J.VariableDeclarations vd = (J.VariableDeclarations) it;\n                        if (vd.hasModifier(J.Modifier.Type.Static)) {\n                            inStaticInitializer.set(true);\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return inStaticInitializer.get();\n            }\n\n            private CallGraph.Row row(String sourceSet, String fqn, JavaType.Method to) {\n                return new CallGraph.Row(\n                        sourceSet,\n                        fqn,\n                        inStaticInitializer() ? \"<clinit>\" : \"<init>\",\n                        \"\",\n                        CallGraph.ResourceType.METHOD,\n                        CallGraph.ResourceAction.CALL,\n                        to.getDeclaringType().getFullyQualifiedName(),\n                        to.getName(),\n                        parameters(to),\n                        resourceType(to),\n                        returnType(to)\n                );\n            }\n\n            private CallGraph.Row row(String sourceSet,JavaType.Method from, JavaType.Method to) {\n                return new CallGraph.Row(\n                        sourceSet,\n                        from.getDeclaringType().getFullyQualifiedName(),\n                        from.getName(),\n                        parameters(from),\n                        resourceType(from),\n                        CallGraph.ResourceAction.CALL,\n                        to.getDeclaringType().getFullyQualifiedName(),\n                        to.getName(),\n                        parameters(to),\n                        resourceType(to),\n                        returnType(to)\n                );\n            }\n        };\n\n    }\n\n    private static String parameters(JavaType.Method method) {\n        StringJoiner joiner = new StringJoiner(\",\");\n        for (JavaType javaType : method.getParameterTypes()) {\n            String string = javaType.toString();\n            joiner.add(string);\n        }\n        return joiner.toString();\n    }\n\n    private static CallGraph.ResourceType resourceType(JavaType.Method method) {\n        if (method.isConstructor()) {\n            return CallGraph.ResourceType.CONSTRUCTOR;\n        }\n        return CallGraph.ResourceType.METHOD;\n    }\n\n    private static String returnType(JavaType.Method method) {\n        return method.getReturnType().toString();\n    }\n}\n",
      "options": {
        "includeStdLib": "boolean field"
      },
      "repository": "unknown",
      "metadata": {
        "sourceCodeLength": 9358,
        "hasDescription": true,
        "hasOptions": true,
        "estimatedTokens": 2339
      }
    },
    {
      "id": 2,
      "name": "Find duplicate source files",
      "description": "Record the presence of LSTs with duplicate paths, indicating that the same file was parsed more than once.",
      "type": "Java",
      "sourceCode": "/*\n * Copyright 2021 the original author or authors.\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * https://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.openrewrite;\n\nimport org.jspecify.annotations.Nullable;\nimport org.openrewrite.marker.SearchResult;\nimport org.openrewrite.table.DuplicateSourceFiles;\n\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport static java.util.Collections.emptyList;\n\npublic class FindDuplicateSourceFiles extends ScanningRecipe<Map<Path, List<String>>> {\n    transient DuplicateSourceFiles duplicateSourceFiles = new DuplicateSourceFiles(this);\n\n    @Override\n    public String getDisplayName() {\n        return \"Find duplicate source files\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Record the presence of LSTs with duplicate paths, indicating that the same file was parsed more than once.\";\n    }\n\n    @Override\n    public Map<Path, List<String>> getInitialValue(ExecutionContext ctx) {\n        return new HashMap<>();\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getScanner(Map<Path, List<String>> acc) {\n        return new TreeVisitor<Tree, ExecutionContext>() {\n            @Override\n            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                if (tree instanceof SourceFile) {\n                    acc.computeIfAbsent(((SourceFile) tree).getSourcePath(), k -> new ArrayList<>())\n                            .add(tree.getClass().getSimpleName());\n                }\n                return tree;\n            }\n        };\n    }\n\n    @Override\n    public Collection<? extends SourceFile> generate(Map<Path, List<String>> acc, ExecutionContext ctx) {\n        for (Map.Entry<Path, List<String>> path : acc.entrySet()) {\n            if (path.getValue().size() > 1) {\n                duplicateSourceFiles.insertRow(ctx, new DuplicateSourceFiles.Row(\n                        path.getKey().toString(),\n                        path.getValue().size(),\n                        new HashSet<>(path.getValue())\n                ));\n            }\n        }\n        return emptyList();\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getVisitor(Map<Path, List<String>> acc) {\n        return new TreeVisitor<Tree, ExecutionContext>() {\n            @Override\n            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                assert tree instanceof SourceFile;\n                SourceFile s = (SourceFile) tree;\n                if(acc.containsKey(s.getSourcePath()) && acc.get(s.getSourcePath()).size() > 1) {\n                    s = SearchResult.found(s);\n                }\n                return s;\n            }\n        };\n    }\n}\n",
      "options": {},
      "repository": "unknown",
      "metadata": {
        "sourceCodeLength": 3320,
        "hasDescription": true,
        "hasOptions": false,
        "estimatedTokens": 830
      }
    },
    {
      "id": 3,
      "name": "Language composition report",
      "description": "",
      "type": "Java",
      "sourceCode": "/*\n * Copyright 2021 the original author or authors.\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * https://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.openrewrite;\n\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\nimport lombok.Value;\nimport org.jspecify.annotations.Nullable;\nimport org.openrewrite.binary.Binary;\nimport org.openrewrite.csharp.tree.Cs;\nimport org.openrewrite.groovy.tree.G;\nimport org.openrewrite.hcl.tree.Hcl;\nimport org.openrewrite.java.tree.J;\nimport org.openrewrite.json.tree.Json;\nimport org.openrewrite.kotlin.tree.K;\nimport org.openrewrite.properties.tree.Properties;\nimport org.openrewrite.protobuf.tree.Proto;\nimport org.openrewrite.python.tree.Py;\nimport org.openrewrite.quark.Quark;\nimport org.openrewrite.remote.Remote;\nimport org.openrewrite.table.LanguageCompositionPerFile;\nimport org.openrewrite.table.LanguageCompositionPerFolder;\nimport org.openrewrite.table.LanguageCompositionPerRepository;\nimport org.openrewrite.text.PlainText;\nimport org.openrewrite.toml.tree.Toml;\nimport org.openrewrite.tree.ParseError;\nimport org.openrewrite.xml.tree.Xml;\nimport org.openrewrite.yaml.tree.Yaml;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.Collections.emptyList;\n\n@EqualsAndHashCode(callSuper = false)\n@Value\npublic class LanguageComposition extends ScanningRecipe<LanguageComposition.Accumulator> {\n\n    transient LanguageCompositionPerRepository perRepositoryReport = new LanguageCompositionPerRepository(this);\n    transient LanguageCompositionPerFolder perFolderReport = new LanguageCompositionPerFolder(this);\n    transient LanguageCompositionPerFile perFileReport = new LanguageCompositionPerFile(this);\n\n    @Override\n    public String getDisplayName() {\n        return \"Language composition report\";\n    }\n\n    @Override\n    public String getDescription() {\n        //language=markdown\n        return \"Counts the number of lines of the various kinds of source code and data formats parsed by OpenRewrite. \" +\n               \"Comments are not included in line counts. \" +\n               \"This recipe emits its results as two data tables, making no changes to any source file. \" +\n               \"One data table is per-file, the other is per-repository.\";\n    }\n\n    @Data\n    public static class Accumulator {\n        Map<String, Map<String, Counts>> folderToLanguageToCounts = new HashMap<>();\n    }\n\n    private static String containingFolderPath(SourceFile s) {\n        String sourcePath = PathUtils.separatorsToUnix(s.getSourcePath().toString());\n        int lastSlash = sourcePath.lastIndexOf('/');\n        if (lastSlash == -1) {\n            return \"\";\n        }\n        return s.getSourcePath().toString().substring(0, lastSlash);\n    }\n\n    @Override\n    public Accumulator getInitialValue(ExecutionContext ctx) {\n        return new Accumulator();\n    }\n\n    @Override\n    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {\n        return new TreeVisitor<Tree, ExecutionContext>() {\n            @Override\n            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {\n                if (!(tree instanceof SourceFile)) {\n                    return tree;\n                }\n\n                SourceFile s = (SourceFile) tree;\n                String folderPath = containingFolderPath(s);\n                // Parse failures *should* only ever appear on PlainText sources, but always checking finds a parser bug\n                boolean hasParseFailure = s.getMarkers().findFirst(ParseExceptionResult.class).isPresent();\n                if (s instanceof Quark || s instanceof Binary || s instanceof Remote) {\n                    Counts quarkCounts = acc.getFolderToLanguageToCounts()\n                            .computeIfAbsent(folderPath, k -> new HashMap<>())\n                            .computeIfAbsent(\"Other/unknown/unparseable\", k -> new Counts());\n                    quarkCounts.fileCount++;\n                    perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                            s.getSourcePath().toString(),\n                            \"Other/unknown/unparseable\",\n                            s.getClass().getName(),\n                            0,\n                            hasParseFailure));\n                } else {\n                    int genericLineCount = LineCounter.count(s);\n                    if (s.getClass().getName().startsWith(\"org.openrewrite.cobol.tree.CobolPreprocessor$Copybook\")) {\n                        Counts copybookCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Copybook\", k -> new Counts());\n                        copybookCounts.fileCount++;\n                        copybookCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Copybook\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s.getClass().getName().startsWith(\"org.openrewrite.cobol.tree.Cobol\")) {\n                        Counts cobolCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Cobol\", k -> new Counts());\n                        cobolCounts.fileCount++;\n                        cobolCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Cobol\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof K) {\n                        Counts kotlinCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Kotlin\", k -> new Counts());\n                        kotlinCounts.fileCount++;\n                        // Don't have a kotlin-specific counter yet and Java count should be very close\n                        kotlinCounts.lineCount += org.openrewrite.java.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Kotlin\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof G) {\n                        Counts groovyCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Groovy\", k -> new Counts());\n                        groovyCounts.fileCount++;\n                        groovyCounts.lineCount += org.openrewrite.groovy.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Groovy\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Py) {\n                        Counts pythonCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Python\", k -> new Counts());\n                        pythonCounts.fileCount++;\n                        pythonCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Python\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Cs.CompilationUnit) {\n                        Counts csharpCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"C#\", k -> new Counts());\n                        csharpCounts.fileCount++;\n                        csharpCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"C#\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof J) {\n                        Counts javaCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Java\", k -> new Counts());\n                        javaCounts.fileCount++;\n                        javaCounts.lineCount += org.openrewrite.java.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Java\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Json) {\n                        Counts jsonCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Json\", k -> new Counts());\n                        jsonCounts.fileCount++;\n                        jsonCounts.lineCount += org.openrewrite.json.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Json\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Hcl) {\n                        Counts hclCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Hcl\", k -> new Counts());\n                        hclCounts.fileCount++;\n                        hclCounts.lineCount += org.openrewrite.hcl.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Hcl\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Properties) {\n                        Counts propertiesCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Properties\", k -> new Counts());\n                        propertiesCounts.fileCount++;\n                        propertiesCounts.lineCount += org.openrewrite.properties.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Properties\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Proto) {\n                        Counts protobufCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Protobuf\", k -> new Counts());\n                        protobufCounts.fileCount++;\n                        protobufCounts.lineCount += org.openrewrite.protobuf.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Protobuf\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Toml) {\n                        Counts tomlCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Toml\", k -> new Counts());\n                        tomlCounts.fileCount++;\n                        tomlCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Toml\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Xml) {\n                        Counts xmlCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Xml\", k -> new Counts());\n                        xmlCounts.fileCount++;\n                        xmlCounts.lineCount += org.openrewrite.xml.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Xml\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof Yaml) {\n                        Counts yamlCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Yaml\", k -> new Counts());\n                        yamlCounts.fileCount++;\n                        yamlCounts.lineCount += org.openrewrite.yaml.CountLinesVisitor.countLines(s);\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Yaml\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else if (s instanceof PlainText) {\n                        if (s.getSourcePath().endsWith(\".js\") || s.getSourcePath().endsWith(\".jsx\") || s.getSourcePath().endsWith(\".mjs\")) {\n                            Counts javascriptCounts = acc.getFolderToLanguageToCounts()\n                                    .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                    .computeIfAbsent(\"Javascript\", k -> new Counts());\n                            javascriptCounts.fileCount++;\n                            javascriptCounts.lineCount += genericLineCount;\n                            perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                    s.getSourcePath().toString(),\n                                    \"JavaScript\",\n                                    s.getClass().getName(),\n                                    genericLineCount,\n                                    hasParseFailure));\n                        } else if (s.getSourcePath().endsWith(\".ts\") || s.getSourcePath().endsWith(\".tsx\")) {\n                            Counts typescriptCounts = acc.getFolderToLanguageToCounts()\n                                    .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                    .computeIfAbsent(\"TypeScript\", k -> new Counts());\n                            typescriptCounts.fileCount++;\n                            typescriptCounts.lineCount += genericLineCount;\n                            perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                    s.getSourcePath().toString(),\n                                    \"Typescript\",\n                                    s.getClass().getName(),\n                                    genericLineCount,\n                                    hasParseFailure));\n                        } else {\n                            Counts plainTextCounts = acc.getFolderToLanguageToCounts()\n                                    .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                    .computeIfAbsent(\"Plain text\", k -> new Counts());\n                            plainTextCounts.fileCount++;\n                            plainTextCounts.lineCount += genericLineCount;\n                            perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                    s.getSourcePath().toString(),\n                                    \"Plain text\",\n                                    s.getClass().getName(),\n                                    genericLineCount,\n                                    hasParseFailure));\n                        }\n                    } else if (s instanceof ParseError) {\n                        Counts parseErrorCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Parse error\", k -> new Counts());\n                        parseErrorCounts.fileCount++;\n                        parseErrorCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Parse error\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    } else {\n                        Counts unknownCounts = acc.getFolderToLanguageToCounts()\n                                .computeIfAbsent(folderPath, k -> new HashMap<>())\n                                .computeIfAbsent(\"Unknown\", k -> new Counts());\n                        unknownCounts.fileCount++;\n                        unknownCounts.lineCount += genericLineCount;\n                        perFileReport.insertRow(ctx, new LanguageCompositionPerFile.Row(\n                                s.getSourcePath().toString(),\n                                \"Unknown\",\n                                s.getClass().getName(),\n                                genericLineCount,\n                                hasParseFailure));\n                    }\n                }\n                return tree;\n            }\n        };\n    }\n\n    @Override\n    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {\n        Map<String, Counts> languageToCount = new HashMap<>();\n        for (Map.Entry<String, Map<String, Counts>> entry : acc.getFolderToLanguageToCounts().entrySet()) {\n            for (Map.Entry<String, Counts> languageEntry : entry.getValue().entrySet()) {\n                perFolderReport.insertRow(ctx, new LanguageCompositionPerFolder.Row(entry.getKey(),\n                        languageEntry.getKey(), languageEntry.getValue().fileCount, languageEntry.getValue().lineCount));\n\n                Counts counts = languageToCount.computeIfAbsent(languageEntry.getKey(), k -> new Counts());\n                counts.fileCount += languageEntry.getValue().fileCount;\n                counts.lineCount += languageEntry.getValue().lineCount;\n            }\n        }\n        for (Map.Entry<String, Counts> entry : languageToCount.entrySet()) {\n            perRepositoryReport.insertRow(ctx, new LanguageCompositionPerRepository.Row(entry.getKey(), entry.getValue().fileCount, entry.getValue().lineCount));\n        }\n\n        return emptyList();\n    }\n\n    private static class Counts {\n        int lineCount;\n        int fileCount;\n    }\n\n    private static class LineCounter extends PrintOutputCapture<Integer> {\n        private int count;\n        private boolean startedLine;\n\n        public LineCounter() {\n            super(0);\n        }\n\n        static int count(SourceFile s) {\n            LineCounter counter = new LineCounter();\n            s.printAll(counter);\n            return counter.getLineCount();\n        }\n\n        @Override\n        public PrintOutputCapture<Integer> append(char c) {\n            if (c == '\\n') {\n                count++;\n                startedLine = false;\n            } else {\n                startedLine = true;\n            }\n            return this;\n        }\n\n        @Override\n        public PrintOutputCapture<Integer> append(@Nullable String text) {\n            if (text == null) {\n                return this;\n            }\n            for (int i = 0; i < text.length(); i++) {\n                append(text.charAt(i));\n            }\n            return this;\n        }\n\n        int getLineCount() {\n            return count + (startedLine ? 1 : 0);\n        }\n    }\n\n}\n",
      "options": {},
      "repository": "unknown",
      "metadata": {
        "sourceCodeLength": 22665,
        "hasDescription": false,
        "hasOptions": false,
        "estimatedTokens": 5666
      }
    }
  ]
}