Recipe name,Recipe description,Recipe type,Recipe source code,Recipe options
The name of the recipe.,The description of the recipe.,"Differentiate between Java and YAML recipes, as they may be two independent data sets used in LLM fine-tuning.",The full source code of the recipe.,JSON format of recipe options.
Upgrade Spring dependencies,Upgrades dependencies according to the specified version of spring boot. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.spring;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.java.dependencies.UpgradeDependencyVersion;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.XRange;
import org.openrewrite.xml.tree.Xml;

import java.util.*;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;

@EqualsAndHashCode(callSuper = false)
@Value
public class UpgradeExplicitSpringBootDependencies extends ScanningRecipe<UpgradeExplicitSpringBootDependencies.Accumulator> {

    private static final String SPRINGBOOT_GROUP = ""org.springframework.boot"";
    private static final String SPRING_BOOT_DEPENDENCIES = ""spring-boot-dependencies"";

    @Option(displayName = ""From Spring version"",
            description = ""XRage pattern for spring version used to limit which projects should be updated"",
            example = "" 2.7.+"")
    String fromVersion;

    @Option(displayName = ""To Spring version"",
            description = ""Upgrade version of `org.springframework.boot`"",
            example = ""3.0.0-M3"")
    String toVersion;

    @Override
    public String getDisplayName() {
        return ""Upgrade Spring dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Upgrades dependencies according to the specified version of spring boot. "" +
               ""Spring boot has many direct and transitive dependencies. When a module has an explicit dependency on "" +
               ""one of these it may also need to be upgraded to match the version used by spring boot."";
    }

    @Data
    public static class Accumulator {
        UpgradeDependencyVersion.Accumulator udvAcc = new UpgradeDependencyVersion.Accumulator(
                new org.openrewrite.maven.UpgradeDependencyVersion.Accumulator(),
                new org.openrewrite.gradle.UpgradeDependencyVersion.DependencyVersionState()
        );
        List<MavenRepository> repositories = new ArrayList<>();
        Map<String, String> springBootDependenciesMap = new HashMap<>();

        @Nullable
        MavenDownloadingException mavenDownloadingException = null;
    }

    private TreeVisitor<?, ExecutionContext> precondition() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag resultTag = super.visitTag(tag, ctx);
                if (isManagedDependencyTag()) {
                    ResolvedManagedDependency managedDependency = findManagedDependency(resultTag);
                    if (managedDependency != null && SPRINGBOOT_GROUP.equals(managedDependency.getGroupId()) &&
                        satisfiesOldVersionPattern(managedDependency.getVersion())) {
                        return SearchResult.found(resultTag);
                    }
                }

                if (isDependencyTag()) {
                    ResolvedDependency dependency = findDependency(resultTag);
                    if ((dependency != null) && SPRINGBOOT_GROUP.equals(dependency.getGroupId()) &&
                        satisfiesOldVersionPattern(dependency.getVersion())) {
                        return SearchResult.found(resultTag);
                    }
                }
                return resultTag;
            }

            private boolean satisfiesOldVersionPattern(@Nullable String version) {
                return version != null && XRange.build(fromVersion, version).isValid();
            }
        };
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        //noinspection NullableProblems
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(Tree tree, ExecutionContext ctx) {
                TreeVisitor<?, ExecutionContext> udvScanner = new UpgradeDependencyVersion("""", """", """", null, null, null)
                        .getScanner(acc.getUdvAcc());
                if (udvScanner.isAcceptable((SourceFile) tree, ctx)) {
                    udvScanner.visit(tree, ctx);
                }

                Optional<GradleProject> maybeGp = tree.getMarkers()
                        .findFirst(GradleProject.class);
                if (maybeGp.isPresent()) {
                    GradleProject gp = maybeGp.get();
                    acc.repositories.addAll(gp.getMavenRepositories());
                }
                Optional<MavenResolutionResult> maybeMrr = tree.getMarkers()
                        .findFirst(MavenResolutionResult.class);
                if (maybeMrr.isPresent()) {
                    MavenResolutionResult mrr = maybeMrr.get();
                    acc.repositories.addAll(mrr.getPom().getRepositories());
                }

                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, Collection<SourceFile> generatedInThisCycle, ExecutionContext ctx) {
        List<MavenRepository> repositories = acc.getRepositories();
        repositories.add(MavenRepository.builder()
                .id(""repository.spring.milestone"")
                .uri(""https://repo.spring.io/milestone"")
                .releases(true)
                .snapshots(true)
                .build());
        repositories.add(MavenRepository.builder()
                .id(""spring-snapshot"")
                .uri(""https://repo.spring.io/snapshot"")
                .releases(false)
                .snapshots(true)
                .build());
        repositories.add(MavenRepository.builder()
                .id(""spring-release"")
                .uri(""https://repo.spring.io/release"")
                .releases(true)
                .snapshots(false)
                .build());

        MavenPomDownloader downloader = new MavenPomDownloader(emptyMap(), ctx);
        GroupArtifactVersion gav = new GroupArtifactVersion(SPRINGBOOT_GROUP, SPRING_BOOT_DEPENDENCIES, toVersion);
        String relativePath = """";

        try {
            Pom pom = downloader.download(gav, relativePath, null, repositories);
            ResolvedPom resolvedPom = pom.resolve(emptyList(), downloader, repositories, ctx);
            List<ResolvedManagedDependency> dependencyManagement = resolvedPom.getDependencyManagement();
            dependencyManagement
                    .stream()
                    .filter(d -> d.getVersion() != null)
                    .forEach(d -> acc.getSpringBootDependenciesMap().put(d.getGroupId() + "":"" + d.getArtifactId().toLowerCase(), d.getVersion()));
        } catch (MavenDownloadingException e) {
            acc.mavenDownloadingException = e;
        }
        return emptyList();
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        return super.generate(acc, ctx);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return Preconditions.check(precondition(), new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                if(acc.mavenDownloadingException != null) {
                    return acc.mavenDownloadingException.warn(document);
                }
                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag resultTag = super.visitTag(tag, ctx);
                if (isManagedDependencyTag()) {
                    ResolvedManagedDependency managedDependency = findManagedDependency(resultTag);
                    if (managedDependency != null) {
                        mayBeUpdateVersion(acc, managedDependency.getGroupId(), managedDependency.getArtifactId(), resultTag);
                    }
                }
                if (isDependencyTag()) {
                    ResolvedDependency dependency = findDependency(resultTag);
                    if (dependency != null) {
                        mayBeUpdateVersion(acc, dependency.getGroupId(), dependency.getArtifactId(), resultTag);
                    }
                }
                return resultTag;
            }

            private void mayBeUpdateVersion(Accumulator acc, String groupId, String artifactId, Xml.Tag tag) {
                String dependencyVersion = acc.springBootDependenciesMap.get(groupId + "":"" + artifactId);
                if (dependencyVersion != null) {
                    Optional<Xml.Tag> version = tag.getChild(""version"");
                    if (!version.isPresent() || !version.get().getValue().isPresent()) {
                        return;
                    }
                    doAfterVisit(new org.openrewrite.java.dependencies.UpgradeDependencyVersion(groupId, artifactId, dependencyVersion, null, true, null)
                            .getVisitor(acc.getUdvAcc()));
                }
            }
        });
    }
}
","{
  ""fromVersion"": ""String field"",
  ""toVersion"": ""String field""
}"
Change parameter type for a method declaration,"Change parameter type for a method declaration, identified by a method pattern.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.service.ImportService;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

/**
 * A recipe to change parameter type for a method declaration.
 * <p>
 * NOTE: This recipe is usually used for initial modification of parameter changes.
 * After modifying method parameters using this recipe, you may also need to modify
 * the method definition as needed to avoid compilation errors.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeMethodParameter extends Recipe {

    /**
     * A method pattern that is used to find matching method declarations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = ""A method pattern that is used to find the method declarations to modify."",
            example = ""com.yourorg.A foo(int, int)"")
    String methodPattern;

    @Option(displayName = ""Parameter type"",
            description = ""The new type of the parameter that gets updated."",
            example = ""java.lang.String"")
    String parameterType;

    @Option(displayName = ""Parameter index"",
            description = ""A zero-based index that indicates the position at which the parameter will be added."",
            example = ""0"")
    Integer parameterIndex;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` in methods `%s`"", parameterType, methodPattern);
    }

    @Override
    public String getDisplayName() {
        return ""Change parameter type for a method declaration"";
    }

    @Override
    public String getDescription() {
        return ""Change parameter type for a method declaration, identified by a method pattern."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = new MethodMatcher(methodPattern, true);
        return Preconditions.check(new DeclaresMethod<>(methodMatcher), new ChangeMethodArgumentVisitor(methodMatcher));
    }

    @RequiredArgsConstructor
    private class ChangeMethodArgumentVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDeclaration, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(methodDeclaration, ctx);

            if (methodMatcher.matches(md.getMethodType())) {
                if (md.getParameters().isEmpty() ||
                    md.getParameters().get(0) instanceof J.Empty ||
                    md.getParameters().size() <= parameterIndex) {
                    return md;
                }
                if (md.getParameters().get(parameterIndex) instanceof J.VariableDeclarations) {
                    J.VariableDeclarations parameter = (J.VariableDeclarations) md.getParameters().get(parameterIndex);

                    TypeTree typeTree = createTypeTree(parameterType);
                    if (TypeUtils.isOfType(parameter.getType(), typeTree.getType())) {
                        return md;
                    }

                    String parameterName = parameter.getVariables().get(0).getSimpleName();
                    parameter = parameter.withTypeExpression(typeTree).withVariables(singletonList(
                            new J.VariableDeclarations.NamedVariable(
                                    randomId(),
                                    Space.EMPTY,
                                    Markers.EMPTY,
                                    new J.Identifier(
                                            randomId(),
                                            Space.EMPTY,
                                            Markers.EMPTY,
                                            emptyList(),
                                            parameterName,
                                            typeTree.getType(),
                                            new JavaType.Variable(
                                                    null,
                                                    0,
                                                    parameterName,
                                                    md.getMethodType(),
                                                    typeTree.getType(),
                                                    null
                                            )
                                    ),
                                    emptyList(),
                                    null,
                                    null
                            )
                    ));

                    md = autoFormat(changeParameter(md, parameter), parameter, ctx, getCursor().getParentTreeCursor());
                }

            }
            return md;
        }

        private J.MethodDeclaration changeParameter(J.MethodDeclaration method, J.VariableDeclarations parameter) {
            List<Statement> originalParameters = method.getParameters();
            List<Statement> newParameters = new ArrayList<>();
            for (int i = 0; i < originalParameters.size(); i++) {
                if (i == parameterIndex) {
                    newParameters.add(parameter);
                } else {
                    newParameters.add(originalParameters.get(i));
                }
            }

            method = method.withParameters(newParameters);

            if (parameter.getTypeExpression() != null && !(parameter.getTypeExpression() instanceof J.Identifier || parameter.getTypeExpression() instanceof J.Primitive)) {
                doAfterVisit(service(ImportService.class).shortenFullyQualifiedTypeReferencesIn(parameter.getTypeExpression()));
            }
            return method;
        }

        private TypeTree createTypeTree(String typeName) {
            int arrayIndex = typeName.lastIndexOf('[');
            if (arrayIndex != -1) {
                TypeTree elementType = createTypeTree(typeName.substring(0, arrayIndex));
                return new J.ArrayType(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        elementType,
                        null,
                        JLeftPadded.build(Space.EMPTY),
                        new JavaType.Array(null, elementType.getType(), null)
                );
            }
            int genericsIndex = typeName.indexOf('<');
            if (genericsIndex != -1) {
                TypeTree rawType = createTypeTree(typeName.substring(0, genericsIndex));
                List<JRightPadded<Expression>> typeParameters = new ArrayList<>();
                for (String typeParam : typeName.substring(genericsIndex + 1, typeName.lastIndexOf('>')).split("","")) {
                    typeParameters.add(JRightPadded.build((Expression) createTypeTree(typeParam.trim())));
                }
                return new J.ParameterizedType(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        rawType,
                        JContainer.build(Space.EMPTY, typeParameters, Markers.EMPTY),
                        new JavaType.Parameterized(null, (JavaType.FullyQualified) rawType.getType(), null)
                );
            }
            JavaType.Primitive type = JavaType.Primitive.fromKeyword(typeName);
            if (type != null) {
                return new J.Primitive(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        type
                );
            }
            if (""?"".equals(typeName)) {
                return new J.Wildcard(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        null,
                        null
                );
            }
            if (typeName.startsWith(""?"") && typeName.contains(""extends"")) {
                return new J.Wildcard(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        new JLeftPadded<>(Space.SINGLE_SPACE, J.Wildcard.Bound.Extends, Markers.EMPTY),
                        createTypeTree(typeName.substring(typeName.indexOf(""extends"") + ""extends"".length() + 1).trim()).withPrefix(Space.SINGLE_SPACE)
                );
            }
            if (typeName.indexOf('.') == -1) {
                String javaLangType = TypeUtils.findQualifiedJavaLangTypeName(typeName);
                if (javaLangType != null) {
                    return new J.Identifier(
                            randomId(),
                            Space.EMPTY,
                            Markers.EMPTY,
                            emptyList(),
                            typeName,
                            JavaType.buildType(javaLangType),
                            null
                    );
                }
            }
            TypeTree typeTree = TypeTree.build(typeName);
            // somehow the type attribution is incomplete, but `ChangeType` relies on this
            if (typeTree instanceof J.FieldAccess) {
                typeTree = ((J.FieldAccess) typeTree).withName(((J.FieldAccess) typeTree).getName().withType(typeTree.getType()));
            } else if (typeTree.getType() == null) {
                typeTree = ((J.Identifier) typeTree).withType(JavaType.ShallowClass.build(typeName));
            }
            return typeTree;
        }
    }
}
","{
  ""parameterType"": ""String field"",
  ""parameterIndex"": ""Integer field""
}"
Add a spring configuration property,Add a spring configuration property to a configuration file if it does not already exist in that file.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.properties.AddProperty;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.MergeYaml;
import org.openrewrite.yaml.tree.Yaml;

import java.nio.file.Path;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A recipe to uniformly add a property to Spring configuration file. This recipe supports adding properties to
 * "".properties"" and YAML files. This recipe will only add the property if it does not already exist within the
 * configuration file.
 * <P>
 * NOTE: Because an application may have a large collection of yaml files (some of which may not even be related to
 *       Spring configuration), this recipe will only make changes to files that match one of the pathExpressions. If
 *       the recipe is configured without pathExpressions, it will query the execution context for reasonable defaults.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class AddSpringProperty extends Recipe {

    @Option(displayName = ""Property key"",
            description = ""The property key to add."",
            example = ""management.metrics.enable.process.files"")
    String property;

    @Option(displayName = ""Property value"",
            description = ""The value of the new property key."",
            example = ""true"")
    String value;

    @Option(displayName = ""Optional comment to be prepended to the property"",
            description = ""A comment that will be added to the new property."",
            required = false,
            example = ""This is a comment"")
    @Nullable
    String comment;

    @Option(displayName = ""Optional list of file path matcher"",
            description = ""Each value in this list represents a glob expression that is used to match which files will "" +
                          ""be modified. If this value is not present, this recipe will query the execution context for "" +
                          ""reasonable defaults. (\""**/application.yml\"", \""**/application.yml\"", and \""**/application.properties\""."",
            required = false,
            example = ""[\""**/application.yml\""]"")
    @Nullable
    List<String> pathExpressions;

    @Override
    public String getDisplayName() {
        return ""Add a spring configuration property"";
    }

    @Override
    public String getDescription() {
        return ""Add a spring configuration property to a configuration file if it does not already exist in that file."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof Yaml.Documents || sourceFile instanceof Properties.File;
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree t, ExecutionContext ctx) {
                if (t instanceof Yaml.Documents && sourcePathMatches(((SourceFile) t).getSourcePath(), ctx)) {
                    t = createMergeYamlVisitor().getVisitor().visit(t, ctx);
                } else if (t instanceof Properties.File && sourcePathMatches(((SourceFile) t).getSourcePath(), ctx)) {
                    t = new AddProperty(property, value, comment, null).getVisitor().visit(t, ctx);
                }
                return t;
            }
        };
    }

    private boolean sourcePathMatches(Path sourcePath, ExecutionContext ctx) {
        List<String> expressions = pathExpressions;
        if (expressions == null || pathExpressions.isEmpty()) {
            //If not defined, get reasonable defaults from the execution context.
            expressions = SpringExecutionContextView.view(ctx).getDefaultApplicationConfigurationPaths();
        }
        if (expressions.isEmpty()) {
            return true;
        }
        for (String filePattern : expressions) {
            if (PathUtils.matchesGlob(sourcePath, filePattern)) {
                return true;
            }
        }

        return false;
    }

    private MergeYaml createMergeYamlVisitor() {
        String[] propertyParts = property.split(""\\."");

        StringBuilder yaml = new StringBuilder();

        String indent = """";
        for (String part : propertyParts) {
            if (yaml.length() > 0) {
                yaml.append(""\n"");
            }
            if (!StringUtils.isBlank(comment)) {
                //noinspection StringEquality
                if (part == propertyParts[propertyParts.length - 1]) {
                    yaml.append(indent).append(""# "").append(comment).append(""\n"");
                }
            }
            yaml.append(indent).append(part).append("":"");
            indent = indent + ""  "";
        }
        if (quoteValue(value)) {
            yaml.append("" \"""").append(value).append('""');
        } else {
            yaml.append("" "").append(value);
        }
        return new MergeYaml(""$"", yaml.toString(), true, null, null, null, null, null);
    }

    private static final Pattern scalarNeedsAQuote = Pattern.compile(""[^a-zA-Z\\d\\s]*"");
    private boolean quoteValue(String value) {
        return scalarNeedsAQuote.matcher(value).matches();
    }
}
","{
  ""property"": ""String field"",
  ""value"": ""String field""
}"
Comment out Spring properties,"Add comment to specified Spring properties, and comment out the property.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.tree.Yaml;

@EqualsAndHashCode(callSuper = false)
@Value
public class CommentOutSpringPropertyKey extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Comment out Spring properties"";
    }

    @Override
    public String getDescription() {
        return ""Add comment to specified Spring properties, and comment out the property."";
    }

    @Option(displayName = ""Property key"",
            description = ""The name of the property key to comment out."",
            example = ""management.metrics.binders.files.enabled"")
    String propertyKey;

    @Option(displayName = ""Comment"",
            description = ""Comment to replace the property key."",
            example = ""This property is deprecated and no longer applicable starting from Spring Boot 3.0.x"")
    String comment;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Recipe changeProperties = new org.openrewrite.properties.AddPropertyComment(propertyKey, comment, true);
        Recipe changeYaml = new org.openrewrite.yaml.CommentOutProperty(propertyKey, comment, true);
        return Preconditions.check(new IsPossibleSpringConfigFile(), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree preVisit(@NonNull Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof Properties.File) {
                    return changeProperties.getVisitor().visit(tree, ctx);
                }
                if (tree instanceof Yaml.Documents) {
                    return changeYaml.getVisitor().visit(tree, ctx);
                }
                return tree;
            }
        });
    }
}
","{
  ""propertyKey"": ""String field"",
  ""comment"": ""String field""
}"
Remove implicit web annotation names,Removes implicit web annotation names.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toSet;
import static org.openrewrite.java.tree.TypeUtils.isOfClassType;

public class ImplicitWebAnnotationNames extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove implicit web annotation names"";
    }

    @Override
    public String getDescription() {
        return ""Removes implicit web annotation names."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(""org.springframework.web.bind.annotation.PathVariable"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.RequestParam"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.RequestHeader"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.RequestAttribute"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.CookieValue"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.ModelAttribute"", false),
                new UsesType<>(""org.springframework.web.bind.annotation.SessionAttribute"", false)
        ), new ImplicitWebAnnotationNamesVisitor());
    }

    private static class ImplicitWebAnnotationNamesVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final Set<String> PARAM_ANNOTATIONS = Stream.of(
                ""PathVariable"",
                ""RequestParam"",
                ""RequestHeader"",
                ""RequestAttribute"",
                ""CookieValue"",
                ""ModelAttribute"",
                ""SessionAttribute""
        ).map(className -> ""org.springframework.web.bind.annotation."" + className).collect(toSet());


        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations varDecls = super.visitVariableDeclarations(multiVariable, ctx);
            // Fix when the annotation looses all it's arguments, and there is no prefix between the annotation and the type expression
            // i.e: @Annotation(argument)Type is valid but @AnnotationType it's not
            if (!varDecls.getLeadingAnnotations().isEmpty()) {
                if (varDecls.getTypeExpression() != null && varDecls.getTypeExpression().getPrefix().getWhitespace().isEmpty()) {
                    List<J.Annotation> annotations = varDecls.getLeadingAnnotations();
                    J.Annotation lastAnnotation = annotations.get(annotations.size() - 1);
                    if (lastAnnotation.getArguments() == null || lastAnnotation.getArguments().isEmpty()) {
                        varDecls = varDecls.withTypeExpression(
                                varDecls.getTypeExpression().withPrefix(
                                        varDecls.getTypeExpression().getPrefix().withWhitespace("" "")));
                    }
                }
            }
            return varDecls;
        }

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = super.visitAnnotation(annotation, ctx);

            if (PARAM_ANNOTATIONS.stream().anyMatch(annotationClass -> isOfClassType(annotation.getType(), annotationClass)) &&
                    annotation.getArguments() != null && getCursor().getParentOrThrow().getValue() instanceof J.VariableDeclarations) {

                // Copying the first argument whitespace to use it later on in case we remove the original first argument.
                String firstWhitespace = a.getArguments() != null && !a.getArguments().isEmpty() ?
                        a.getArguments().get(0).getPrefix().getWhitespace() :
                        null;

                a = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                    Cursor varDecsCursor = getCursor().getParentOrThrow();
                    J.VariableDeclarations.NamedVariable namedVariable = varDecsCursor.<J.VariableDeclarations>getValue().getVariables().get(0);
                    if (arg instanceof J.Assignment) {
                        J.Assignment assignment = (J.Assignment) arg;
                        if (assignment.getVariable() instanceof J.Identifier && assignment.getAssignment() instanceof J.Literal) {
                            J.Identifier assignName = (J.Identifier) assignment.getVariable();
                            if (""value"".equals(assignName.getSimpleName()) || ""name"".equals(assignName.getSimpleName())) {
                                if (maybeRemoveArg(namedVariable, (J.Literal) assignment.getAssignment())) {
                                    return null;
                                }
                            }
                        }
                    } else if (arg instanceof J.Literal) {
                        if (maybeRemoveArg(namedVariable, (J.Literal) arg)) {
                            return null;
                        }
                    }

                    return arg;
                }));
                // Copying the original first argument whitespace to the new first argument in case the original first argument was removed.
                // No need to check if the first argument has been removed. Worst case scenario we are overriding the same whitespace.
                if (firstWhitespace != null) {
                    a = a.withArguments(ListUtils.mapFirst(a.getArguments(), arg -> arg.withPrefix(arg.getPrefix().withWhitespace(firstWhitespace))));
                }
            }

            return a;
        }

        private boolean maybeRemoveArg(J.VariableDeclarations.NamedVariable namedVariable, J.Literal assignValue) {
            Object value = assignValue.getValue();
            assert value != null;
            return namedVariable.getSimpleName().equals(value);
        }
    }
}
",{}
Normalize Spring `application*.properties` properties to kebab-case,Normalize Spring `application*.properties` properties to kebab-case.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.properties.PropertiesIsoVisitor;
import org.openrewrite.properties.tree.Properties;

@EqualsAndHashCode(callSuper = false)
class PropertiesToKebabCaseProperties extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Normalize Spring `application*.properties` properties to kebab-case"";
    }

    @Override
    public String getDescription() {
        return ""Normalize Spring `application*.properties` properties to kebab-case."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles(""**/application*.properties""), new PropertiesIsoVisitor<ExecutionContext>() {
            @Override
            public Properties.Entry visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                Properties.Entry e = super.visitEntry(entry, ctx);
                String key = e.getKey();
                String asKebabCase = NameCaseConvention.LOWER_HYPHEN.format(key);
                if (!key.equals(asKebabCase)) {
                    return e.withKey(asKebabCase);
                }
                return e;
            }
        });
    }
}
",{}
Separate application YAML by profile,The Spring team's recommendation is to separate profile properties into their own YAML files now.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.yaml.DeleteProperty;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.nio.file.Path;
import java.util.*;

import static java.util.Collections.singletonList;

public class SeparateApplicationYamlByProfile extends ScanningRecipe<SeparateApplicationYamlByProfile.ApplicationProfiles> {

    @Override
    public String getDisplayName() {
        return ""Separate application YAML by profile"";
    }

    @Override
    public String getDescription() {
        return ""The Spring team's recommendation is to separate profile properties into their own YAML files now."";
    }

    @Override
    public ApplicationProfiles getInitialValue(ExecutionContext ctx) {
        return new ApplicationProfiles();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(ApplicationProfiles acc) {
        return new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Documents visitDocuments(Yaml.Documents yaml, ExecutionContext ctx) {
                if (PathUtils.matchesGlob(yaml.getSourcePath(), ""**/application.yml"")) {
                    Set<Yaml.Documents> profiles = new HashSet<>(yaml.getDocuments().size());

                    //noinspection unchecked
                    Yaml.Documents mainYaml = yaml.withDocuments(ListUtils.map(
                            (List<Yaml.Document>) yaml.getDocuments(),
                            doc -> {
                                String profileName = FindProperty.find(doc, ""spring.config.activate.on-profile"", true).stream()
                                        .findAny()
                                        .map(profile -> ((Yaml.Scalar) profile).getValue())
                                        .orElse(null);

                                if (profileName != null && profileName.matches(""[A-z0-9-]+"")) {
                                    Yaml.Document profileDoc = (Yaml.Document) new DeleteProperty(""spring.config.activate.on-profile"", true, true, null)
                                            .getVisitor().visit(doc, ctx, new Cursor(null, yaml));
                                    assert profileDoc != null;
                                    profiles.add(yaml
                                            .withId(Tree.randomId())
                                            .withDocuments(singletonList(profileDoc.withExplicit(false)))
                                            .withSourcePath(yaml.getSourcePath().resolveSibling(""application-"" + profileName + "".yml"")));
                                    return null;
                                }

                                return doc;
                            }));

                    if (!profiles.isEmpty()) {
                        acc.getModifiedMainProfileFiles().put(yaml.getSourcePath(), mainYaml);
                        acc.getNewProfileFiles().addAll(profiles);
                    }
                }
                return yaml;
            }
        };
    }

    @Override
    public Collection<SourceFile> generate(ApplicationProfiles acc, ExecutionContext ctx) {
        return acc.getNewProfileFiles();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(ApplicationProfiles acc) {
        return new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Documents visitDocuments(Yaml.Documents yaml, ExecutionContext ctx) {
                return acc.getModifiedMainProfileFiles().getOrDefault(yaml.getSourcePath(), yaml);
            }
        };
    }

    @Value
    public static class ApplicationProfiles {
        Map<Path, Yaml.Documents> modifiedMainProfileFiles = new HashMap<>();
        Set<SourceFile> newProfileFiles = new HashSet<>();
    }
}
",{}
Update the API manifest,Keep a consolidated manifest of the API endpoints that this application exposes up-to-date.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.Data;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.*;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextParser;
import org.openrewrite.text.PlainTextVisitor;

import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

@Incubating(since = ""4.12.0"")
public class UpdateApiManifest extends ScanningRecipe<UpdateApiManifest.ApiManifest> {
    private static final List<AnnotationMatcher> REST_ENDPOINTS = Stream.of(""Request"", ""Get"", ""Post"", ""Put"", ""Delete"", ""Patch"")
            .map(method -> new AnnotationMatcher(""@org.springframework.web.bind.annotation."" + method + ""Mapping""))
            .collect(toList());

    @Override
    public String getDisplayName() {
        return ""Update the API manifest"";
    }

    @Override
    public String getDescription() {
        return ""Keep a consolidated manifest of the API endpoints that this application exposes up-to-date."";
    }

    @Override
    public ApiManifest getInitialValue(ExecutionContext ctx) {
        return new ApiManifest();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(ApiManifest acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    new SpringHttpEndpointCollector().visit(tree, acc.getApis());
                } else if (tree instanceof PlainText && ((PlainText) tree).getSourcePath().equals(Paths.get(""META-INF/api-manifest.txt""))) {
                    acc.setGenerate(false);
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<SourceFile> generate(ApiManifest acc, ExecutionContext ctx) {
        return acc.isGenerate() ? singletonList(generateManifest(acc.getApis())) : emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(ApiManifest acc) {
        return Preconditions.check(!acc.isGenerate(), new PlainTextVisitor<ExecutionContext>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                if (text.getSourcePath().equals(Paths.get(""META-INF/api-manifest.txt""))) {
                    return text.withText(generateManifest(acc.getApis()).getText());
                }
                return text;
            }
        });
    }

    private PlainText generateManifest(List<String> apis) {
        //noinspection OptionalGetWithoutIsPresent
        return new PlainTextParser()
                .parse(String.join(""\n"", apis))
                .findFirst()
                .get()
                .withSourcePath(Paths.get(""META-INF/api-manifest.txt""));
    }

    private String getArg(J.Annotation annotation, String key, String defaultValue) {
        if (annotation.getArguments() != null) {
            for (Expression argument : annotation.getArguments()) {
                if (argument instanceof J.Literal) {
                    //noinspection ConstantConditions
                    return (String) ((J.Literal) argument).getValue();
                }
                if (argument instanceof J.Assignment) {
                    J.Assignment arg = (J.Assignment) argument;
                    if (((J.Identifier) arg.getVariable()).getSimpleName().equals(key)) {
                        if (arg.getAssignment() instanceof J.FieldAccess) {
                            return ((J.FieldAccess) arg.getAssignment()).getSimpleName();
                        }
                        if (arg.getAssignment() instanceof J.Identifier) {
                            return ((J.Identifier) arg.getAssignment()).getSimpleName();
                        }
                        if (arg.getAssignment() instanceof J.Literal) {
                            //noinspection ConstantConditions
                            return (String) ((J.Literal) arg.getAssignment()).getValue();
                        }
                    }
                }
            }
        }
        return defaultValue;
    }

    @Data
    static class ApiManifest {
        boolean generate = true;
        List<String> apis = new ArrayList<>();
    }

    private class SpringHttpEndpointCollector extends JavaIsoVisitor<List<String>> {
        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, List<String> apis) {
            method.getAllAnnotations().stream()
                    .filter(this::hasRequestMapping)
                    .findAny()
                    .ifPresent(mapping -> {
                        String path =
                                getCursor().getPathAsStream()
                                        .filter(J.ClassDeclaration.class::isInstance)
                                        .map(classDecl -> ((J.ClassDeclaration) classDecl).getAllAnnotations().stream()
                                                .filter(this::hasRequestMapping)
                                                .findAny()
                                                .map(classMapping -> getArg(classMapping, ""value"", """"))
                                                .orElse(null))
                                        .filter(Objects::nonNull)
                                        .collect(joining(""/"")) +
                                        getArg(mapping, ""value"", """");
                        path = path.replace(""//"", ""/"");

                        JavaType.FullyQualified type = TypeUtils.asFullyQualified(mapping.getType());
                        assert type != null;
                        String httpMethod = type.getClassName().startsWith(""Request"") ?
                                getArg(mapping, ""method"", ""GET"") :
                                type.getClassName().replace(""Mapping"", """").toUpperCase();
                        apis.add(httpMethod + "" "" + path);
                    });
            return method;
        }

        private boolean hasRequestMapping(J.Annotation ann) {
            for (AnnotationMatcher restEndpoint : REST_ENDPOINTS) {
                if (restEndpoint.matches(ann)) {
                    return true;
                }
            }
            return false;
        }
    }
}
",{}
Remove the `@Autowired` annotation on inferred constructor,Spring can infer an autowired constructor when there is a single constructor on the bean. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;

public class NoAutowiredOnConstructor extends Recipe {
    private static final AnnotationMatcher AUTOWIRED_ANNOTATION_MATCHER =
            new AnnotationMatcher(""@org.springframework.beans.factory.annotation.Autowired(true)"");

    @Override
    public String getDisplayName() {
        return ""Remove the `@Autowired` annotation on inferred constructor"";
    }

    @Override
    public String getDescription() {
        return ""Spring can infer an autowired constructor when there is a single constructor on the bean. "" +
                ""This recipe removes unneeded `@Autowired` annotations on constructors."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.beans.factory.annotation.Autowired"", false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

                int constructorCount = 0;
                for (Statement s : cd.getBody().getStatements()) {
                    if (isConstructor(s)) {
                        constructorCount++;
                        if (constructorCount > 1) {
                            return cd;
                        }
                    }
                }

                // Lombok can also provide a constructor, so keep `@Autowired` on constructors if found
                if (!FindAnnotations.find(cd, ""@lombok.*Constructor"").isEmpty()) {
                    return cd;
                }

                // `@ConfigurationProperties` classes usually use field injection, so keep `@Autowired` on constructors
                if (!FindAnnotations.find(cd, ""@org.springframework.boot.context.properties.ConfigurationProperties"").isEmpty()) {
                    return cd;
                }

                return cd.withBody(cd.getBody().withStatements(
                        ListUtils.map(cd.getBody().getStatements(), s -> {
                            if (!isConstructor(s)) {
                                return s;
                            }
                            maybeRemoveImport(""org.springframework.beans.factory.annotation.Autowired"");
                            return (Statement) new RemoveAnnotationVisitor(AUTOWIRED_ANNOTATION_MATCHER).visit(s, ctx, getCursor());
                        })
                ));
            }
        });
    }

    private static boolean isConstructor(Statement s) {
        return s instanceof J.MethodDeclaration && ((J.MethodDeclaration) s).isConstructor();
    }
}
",{}
"Normalize Spring `application*.{yml,yaml}` properties to kebab-case","Normalize Spring `application*.{yml,yaml}` properties to kebab-case.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.tree.Yaml;

@EqualsAndHashCode(callSuper = false)
class PropertiesToKebabCaseYaml extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Normalize Spring `application*.{yml,yaml}` properties to kebab-case"";
    }

    @Override
    public String getDescription() {
        return ""Normalize Spring `application*.{yml,yaml}` properties to kebab-case."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new FindSourceFiles(""**/application*.{yml,yaml}"").getVisitor(),
                new YamlIsoVisitor<ExecutionContext>() {
                    @Override
                    public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                        Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);
                        if (e.getKey() instanceof Yaml.Scalar) {
                            String key = e.getKey().getValue();
                            String asKebabCase = NameCaseConvention.LOWER_HYPHEN.format(key);
                            if (!key.equals(asKebabCase)) {
                                return e.withKey(((Yaml.Scalar) e.getKey()).withValue(asKebabCase));
                            }
                        }
                        return e;
                    }
                });
    }
}
",{}
Change the key of a Spring application property,"Change Spring application property keys existing in either Properties or YAML files, and in `@Value` annotations.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.ChangePropertyKey;
import org.openrewrite.yaml.tree.Yaml;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.regex.Pattern.quote;

/**
 * This composite recipe will change a spring application property key across YAML and properties files.
 * It also changes property keys in @Value annotations.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeSpringPropertyKey extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Change the key of a Spring application property"";
    }

    @Override
    public String getDescription() {
        return ""Change Spring application property keys existing in either Properties or YAML files, and in `@Value` annotations."";
    }

    @Option(displayName = ""Old property key"",
            description = ""The property key to rename."",
            example = ""management.metrics.binders.*.enabled"")
    String oldPropertyKey;

    @Option(displayName = ""New property key"",
            description = ""The new name for the property key."",
            example = ""management.metrics.enable.process.files"")
    String newPropertyKey;

    @Option(displayName = ""Except"",
            description = ""Regex. If any of these property keys exist as direct children of `oldPropertyKey`, then they will not be moved to `newPropertyKey`."",
            required = false,
            example = ""jvm"")
    @Nullable
    List<String> except;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        ChangePropertyKey yamlChangePropertyKey =
                new ChangePropertyKey(oldPropertyKey, newPropertyKey, true, except, null);
        org.openrewrite.properties.ChangePropertyKey propertiesChangePropertyKey =
                new org.openrewrite.properties.ChangePropertyKey(oldPropertyKey, newPropertyKey, true, false);
        org.openrewrite.properties.ChangePropertyKey subpropertiesChangePropertyKey =
                new org.openrewrite.properties.ChangePropertyKey(quote(oldPropertyKey) + exceptRegex() + ""(.+)"", newPropertyKey + ""$1"", true, true);

        return Preconditions.check(Preconditions.or(
                new IsPossibleSpringConfigFile(),
                new UsesType<>(""org.springframework.beans.factory.annotation.Value"", false),
                new UsesType<>(""org.springframework.boot.autoconfigure.condition.ConditionalOnProperty"", false)
        ), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof Yaml.Documents) {
                    tree = yamlChangePropertyKey.getVisitor().visit(tree, ctx);
                } else if (tree instanceof Properties.File) {
                    if (FindProperties.find((Properties.File) tree, newPropertyKey, true).isEmpty()) {
                        Tree newTree = propertiesChangePropertyKey.getVisitor().visit(tree, ctx);
                        // for compatibility with yaml syntax, a spring property key will never have both a (scalar) value and also subproperties
                        if (newTree == tree) {
                            newTree = subpropertiesChangePropertyKey.getVisitor().visit(tree, ctx);
                        }
                        tree = newTree;
                    }
                } else if (tree instanceof JavaSourceFile) {
                    tree = new JavaPropertyKeyVisitor().visit(tree, ctx);
                }
                return tree;
            }
        });
    }

    private String exceptRegex() {
        return except == null || except.isEmpty() ?
                """" :
                ""(?!\\.(?:"" + String.join(""|"", except) + "")\\b)"";
    }

    private class JavaPropertyKeyVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final AnnotationMatcher VALUE_MATCHER =
                new AnnotationMatcher(""@org.springframework.beans.factory.annotation.Value"");
        private final AnnotationMatcher CONDITIONAL_ON_PROPERTY_MATCHER =
                new AnnotationMatcher(""@org.springframework.boot.autoconfigure.condition.ConditionalOnProperty"");

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = annotation;

            if (VALUE_MATCHER.matches(annotation)) {
                if (a.getArguments() != null) {
                    a = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                        if (arg instanceof J.Literal) {
                            J.Literal literal = (J.Literal) arg;
                            if (literal.getValue() instanceof String) {
                                String value = (String) literal.getValue();
                                if (value.contains(oldPropertyKey)) {
                                    Pattern pattern = Pattern.compile(""\\$\\{("" + quote(oldPropertyKey) + exceptRegex() + ""(?:\\.[^.}:]+)*)(((?:\\\\.|[^}])*)\\})"");
                                    Matcher matcher = pattern.matcher(value);
                                    int idx = 0;
                                    if (matcher.find()) {
                                        StringBuilder sb = new StringBuilder();
                                        do {
                                            sb.append(value, idx, matcher.start());
                                            idx = matcher.end();
                                            sb.append(""${"")
                                                    .append(matcher.group(1).replaceFirst(quote(oldPropertyKey), newPropertyKey))
                                                    .append(matcher.group(2));
                                        } while (matcher.find());
                                        sb.append(value, idx, value.length());

                                        String newValue = sb.toString();

                                        if (!value.equals(newValue)) {
                                            if (except != null) {
                                                for (String e : except) {
                                                    if (newValue.contains(""${"" + newPropertyKey + '.' + e)) {
                                                        return arg;
                                                    }
                                                }
                                            }
                                            arg = literal.withValue(newValue)
                                                    .withValueSource(""\"""" + newValue.replace(""\\"", ""\\\\"") + ""\"""");
                                        }
                                    }
                                }
                            }
                        }
                        return arg;
                    }));
                }
            } else if (CONDITIONAL_ON_PROPERTY_MATCHER.matches(annotation)) {
                if (a.getArguments() != null) {
                    a = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                        if (arg instanceof J.Assignment &&
                            ""name"".equals(((J.Identifier) ((J.Assignment) arg).getVariable()).getSimpleName()) &&
                            ((J.Assignment) arg).getAssignment() instanceof J.Literal) {
                            J.Assignment assignment = (J.Assignment) arg;
                            J.Literal literal = (J.Literal) assignment.getAssignment();
                            String value = literal.getValue().toString();

                            Pattern pattern = Pattern.compile(""^"" + quote(oldPropertyKey) + exceptRegex());
                            Matcher matcher = pattern.matcher(value);
                            if (matcher.find()) {
                                arg = assignment.withAssignment(
                                        literal.withValueSource(
                                                        literal.getValueSource().replaceFirst(quote(oldPropertyKey), newPropertyKey))
                                                .withValue(value.replaceFirst(quote(oldPropertyKey), newPropertyKey))
                                );
                            }
                        }
                        return arg;
                    }));
                }
            }

            return a;
        }
    }
}
","{
  ""oldPropertyKey"": ""String field"",
  ""newPropertyKey"": ""String field""
}"
Remove unnecessary `@Repository` annotation from Spring Data `Repository` sub-interface,Removes superfluous `@Repository` annotation from Spring Data `Repository` sub-interfaces.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

public class NoRepoAnnotationOnRepoInterface extends Recipe {

    private static final String INTERFACE_REPOSITORY = ""org.springframework.data.repository.Repository"";
    private static final String ANNOTATION_REPOSITORY = ""org.springframework.stereotype.Repository"";

    @Override
    public String getDisplayName() {
        return ""Remove unnecessary `@Repository` annotation from Spring Data `Repository` sub-interface"";
    }

    @Override
    public String getDescription() {
        return ""Removes superfluous `@Repository` annotation from Spring Data `Repository` sub-interfaces."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(ANNOTATION_REPOSITORY, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);
                if (c.getKind() == J.ClassDeclaration.Kind.Type.Interface) {
                    boolean hasRepoAnnotation = c.getLeadingAnnotations().stream().anyMatch(annotation -> {
                        if (annotation.getArguments() == null || annotation.getArguments().isEmpty() ||
                                annotation.getArguments().get(0) instanceof J.Empty) {
                            JavaType.FullyQualified type = TypeUtils.asFullyQualified(annotation.getType());
                            return type != null && ANNOTATION_REPOSITORY.equals(type.getFullyQualifiedName());
                        }
                        return false;
                    });
                    if (hasRepoAnnotation && TypeUtils.isAssignableTo(INTERFACE_REPOSITORY, c.getType())) {
                        maybeRemoveImport(ANNOTATION_REPOSITORY);
                        return (J.ClassDeclaration) new RemoveAnnotationVisitor(new AnnotationMatcher(""@"" + ANNOTATION_REPOSITORY))
                                .visit(c, ctx, getCursor().getParentOrThrow());
                    }
                }
                return c;
            }
        });
    }
}
",{}
Rename bean,"Renames a Spring bean, both declaration and references.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.ChangeMethodName;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.DeclaresType;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.*;

import static java.util.Collections.singleton;
import static org.openrewrite.java.MethodMatcher.methodPattern;

@EqualsAndHashCode(callSuper = false)
@Value
public class RenameBean extends ScanningRecipe<List<TreeVisitor<?, ExecutionContext>>> {

    @Option(required = false, example = ""foo.MyType"")
    @Nullable
    String type;

    @Option(example = ""fooBean"")
    String oldName;

    @Option(example = ""barBean"")
    String newName;

    private static final String FQN_QUALIFIER = ""org.springframework.beans.factory.annotation.Qualifier"";

    private static final String FQN_BEAN = ""org.springframework.context.annotation.Bean"";

    private static final String FQN_COMPONENT = ""org.springframework.stereotype.Component"";

    private static final Set<String> JUST_QUALIFIER = singleton(FQN_QUALIFIER);
    private static final Set<String> BEAN_METHOD_ANNOTATIONS = new HashSet<String>() {{
        add(FQN_QUALIFIER);
        add(FQN_BEAN);
    }};

    private static final Set<String> BEAN_TYPE_ANNOTATIONS = new HashSet<String>() {{
        add(FQN_QUALIFIER);
        add(FQN_COMPONENT);
    }};

    @Override
    public String getDisplayName() {
        return ""Rename bean"";
    }

    @Override
    public String getDescription() {
        return ""Renames a Spring bean, both declaration and references."";
    }

    @Override
    public List<TreeVisitor<?, ExecutionContext>> getInitialValue(ExecutionContext ctx) {
        return new ArrayList<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(List<TreeVisitor<?, ExecutionContext>> acc) {

        return Preconditions.check(precondition(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                // handle beans named via methods
                List<J.Annotation> allAnnotations = service(AnnotationService.class).getAllAnnotations(getCursor());
                Expression beanNameExpression = getBeanNameExpression(allAnnotations, BEAN_METHOD_ANNOTATIONS);
                if (beanNameExpression == null && isRelevantType(m.getMethodType().getReturnType()) && m.getSimpleName().equals(oldName)) {
                    acc.add(new ChangeMethodName(methodPattern(m), newName, true, false).getVisitor());
                }

                // handle annotation renames
                acc.add(renameBeanAnnotations(BEAN_METHOD_ANNOTATIONS));
                return m;
            }

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

                List<J.Annotation> allAnnotations = service(AnnotationService.class).getAllAnnotations(getCursor());
                Expression beanNameExpression = getBeanNameExpression(allAnnotations, BEAN_TYPE_ANNOTATIONS);

                // handle bean named via class name
                if (beanNameExpression == null && isRelevantType(cd.getType()) && StringUtils.uncapitalize(cd.getSimpleName()).equals(oldName)) {
                    String newFullyQualifiedTypeName = cd.getType().getFullyQualifiedName()
                            .replaceAll(""^((.+\\.)*)[^.]+$"", ""$1"" + StringUtils.capitalize(newName));
                    acc.add(new ChangeType(cd.getType().getFullyQualifiedName(), newFullyQualifiedTypeName, false).getVisitor());
                    acc.add(new ChangeType(cd.getType().getFullyQualifiedName() + ""Test"", newFullyQualifiedTypeName + ""Test"", false).getVisitor());
                }

                // handle annotation renames
                acc.add(renameBeanAnnotations(BEAN_TYPE_ANNOTATIONS));

                return cd;
            }
        });
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(List<TreeVisitor<?, ExecutionContext>> acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                J.CompilationUnit newCu = super.visitCompilationUnit(cu, ctx);
                for (TreeVisitor<?, ExecutionContext> visitor : acc) {
                    newCu = (J.CompilationUnit) visitor.visit(newCu, ctx);
                }
                return newCu;
            }
        };
    }

    /**
     * @param methodDeclaration, which may or may not declare a bean
     * @param newName,           for the potential bean
     * @return a recipe for this methodDeclaration if it declares a bean, or null if it does not declare a bean
     */
    public static @Nullable RenameBean fromDeclaration(J.MethodDeclaration methodDeclaration, String newName) {
        return methodDeclaration.getMethodType() == null ? null :
                fromDeclaration(methodDeclaration, newName, methodDeclaration.getMethodType().getReturnType().toString());
    }

    /**
     * @param methodDeclaration, which may or may not declare a bean
     * @param newName,           for the potential bean
     * @param type,              to override the type field on the returned RenameBean instance
     * @return a recipe for this methodDeclaration if it declares a bean, or null if it does not declare a bean
     */
    public static @Nullable RenameBean fromDeclaration(J.MethodDeclaration methodDeclaration, String newName, @Nullable String type) {
        BeanSearchResult beanSearchResult = isBean(methodDeclaration.getAllAnnotations(), BEAN_METHOD_ANNOTATIONS);
        if (!beanSearchResult.isBean || methodDeclaration.getMethodType() == null) {
            return null;
        }
        String beanName =
                beanSearchResult.beanName != null ? beanSearchResult.beanName : methodDeclaration.getSimpleName();
        return beanName.equals(newName) ? null : new RenameBean(type, beanName, newName);
    }

    /**
     * @param classDeclaration, which may or may not declare a bean
     * @param newName,          for the potential bean
     * @return a recipe for this classDeclaration if it declares a bean, or null if it does not declare a bean
     */
    public static @Nullable RenameBean fromDeclaration(J.ClassDeclaration classDeclaration, String newName) {
        return classDeclaration.getType() == null ? null :
                fromDeclaration(classDeclaration, newName, classDeclaration.getType().toString());
    }

    /**
     * @param classDeclaration, which may or may not declare a bean
     * @param newName,          for the potential bean
     * @param type,             to override the type field on the returned RenameBean instance
     * @return a recipe for this classDeclaration if it declares a bean, or null if it does not declare a bean
     */
    public static @Nullable RenameBean fromDeclaration(J.ClassDeclaration classDeclaration, String newName, @Nullable String type) {
        BeanSearchResult beanSearchResult = isBean(classDeclaration.getAllAnnotations(), BEAN_TYPE_ANNOTATIONS);
        if (!beanSearchResult.isBean || classDeclaration.getType() == null) {
            return null;
        }
        String beanName =
                beanSearchResult.beanName != null ? beanSearchResult.beanName : StringUtils.uncapitalize(classDeclaration.getSimpleName());
        return beanName.equals(newName) ? null : new RenameBean(type, beanName, newName);
    }

    private static BeanSearchResult isBean(Collection<J.Annotation> annotations, Set<String> types) {
        for (J.Annotation annotation : annotations) {
            if (anyAnnotationMatches(annotation, types)) {
                if (annotation.getArguments() != null && !annotation.getArguments().isEmpty()) {
                    for (Expression expr : annotation.getArguments()) {
                        if (expr instanceof J.Literal) {
                            return new BeanSearchResult(true, (String) ((J.Literal) expr).getValue());
                        }
                        J.Assignment beanNameAssignment = asBeanNameAssignment(expr);
                        if (beanNameAssignment != null) {
                            Expression assignmentExpr = beanNameAssignment.getAssignment();
                            if (assignmentExpr instanceof J.Literal) {
                                return new BeanSearchResult(true, (String) ((J.Literal) assignmentExpr).getValue());
                            }
                            if (assignmentExpr instanceof J.NewArray) {
                                List<Expression> initializers = ((J.NewArray) assignmentExpr).getInitializer();
                                if (initializers != null) {
                                    for (Expression initExpr : initializers) {
                                        // if multiple aliases, just take the first one
                                        if (initExpr instanceof J.Literal) {
                                            return new BeanSearchResult(true,
                                                    (String) ((J.Literal) initExpr).getValue());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return new BeanSearchResult(true, null);
            }
        }
        return new BeanSearchResult(false, null);
    }

    private static boolean anyAnnotationMatches(J.Annotation type, Set<String> types) {
        for (String it : types) {
            if (!FindAnnotations.find(type, '@' + it, true).isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private static class BeanSearchResult {
        public boolean isBean;

        @Nullable
        public String beanName;

        public BeanSearchResult(boolean isBean, @Nullable String beanName) {
            this.isBean = isBean;
            this.beanName = beanName;
        }
    }

    private TreeVisitor<?, ExecutionContext> precondition() {
        return type == null ?
                Preconditions.or(
                        new FindAnnotations(""@"" + FQN_QUALIFIER, false).getVisitor(),
                        new FindAnnotations(""@"" + FQN_BEAN, false).getVisitor(),
                        new FindAnnotations(""@"" + FQN_COMPONENT, true).getVisitor()) :
                Preconditions.or(new UsesType<>(type, false), new DeclaresType<>(type));
    }

    private @Nullable Expression getBeanNameExpression(Collection<J.Annotation> annotations, Set<String> types) {
        for (J.Annotation annotation : annotations) {
            if (anyAnnotationMatches(annotation, types)) {
                if (annotation.getArguments() != null && !annotation.getArguments().isEmpty()) {
                    for (Expression expr : annotation.getArguments()) {
                        if (expr instanceof J.Literal) {
                            return expr;
                        }
                        J.Assignment beanNameAssignment = asBeanNameAssignment(expr);
                        if (beanNameAssignment != null) {
                            return beanNameAssignment;
                        }
                    }
                }
            }
        }
        return null;
    }

    private TreeVisitor<J, ExecutionContext> renameBeanAnnotations(Set<String> types) {
        return new JavaIsoVisitor<ExecutionContext>() {
            private boolean annotationParentMatchesBeanType() {
                if (getCursor().getParent() != null) {
                    Object annotationParent = getCursor().getParent().getValue();

                    if (annotationParent instanceof J.MethodDeclaration) {
                        return isRelevantType(((J.MethodDeclaration) annotationParent).getMethodType().getReturnType());
                    }
                    if (annotationParent instanceof J.ClassDeclaration) {
                        return isRelevantType(((J.ClassDeclaration) annotationParent).getType());
                    }
                    if (annotationParent instanceof J.VariableDeclarations) {
                        return isRelevantType(((J.VariableDeclarations) annotationParent).getType());
                    }
                }
                return false;
            }

            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                Expression beanNameExpression = getBeanNameExpression(singleton(annotation), types);

                if (beanNameExpression != null && annotationParentMatchesBeanType()) {
                    if (beanNameExpression instanceof J.Literal) {
                        if (oldName.equals(((J.Literal) beanNameExpression).getValue())) {
                            doAfterVisit(renameBeanAnnotationValue(annotation));
                        }
                    } else if (beanNameExpression instanceof J.Assignment) {
                        J.Assignment beanNameAssignment = (J.Assignment) beanNameExpression;
                        if (contains(beanNameAssignment.getAssignment(), oldName)) {
                            doAfterVisit(renameBeanAnnotationValue(annotation, beanNameAssignment));
                        }
                    }
                }
                return super.visitAnnotation(annotation, ctx);
            }
        };
    }

    private static J.@Nullable Assignment asBeanNameAssignment(Expression argumentExpression) {
        if (argumentExpression instanceof J.Assignment) {
            Expression variable = ((J.Assignment) argumentExpression).getVariable();
            if (variable instanceof J.Identifier) {
                String variableName = ((J.Identifier) variable).getSimpleName();
                if (""name"".equals(variableName) || ""value"".equals(variableName)) {
                    return (J.Assignment) argumentExpression;
                }
            }
        }
        return null;
    }

    private TreeVisitor<J, ExecutionContext> renameBeanAnnotationValue(
            J.Annotation beanAnnotation, J.Assignment beanNameAssignment) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                J.Annotation a = super.visitAnnotation(annotation, ctx);
                if (a == beanAnnotation) {
                    a = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                        if (arg == beanNameAssignment) {
                            return beanNameAssignment.withAssignment(
                                    replace(beanNameAssignment.getAssignment(), oldName, newName));
                        }
                        return arg;
                    }));
                }
                return a;
            }
        };
    }

    private TreeVisitor<J, ExecutionContext> renameBeanAnnotationValue(J.Annotation beanAnnotation) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                J.Annotation a = super.visitAnnotation(annotation, ctx);
                if (a == beanAnnotation) {
                    a = a.withArguments(ListUtils.map(a.getArguments(), arg -> replace(arg, oldName, newName)));
                }
                return a;
            }
        };
    }

    private Expression replace(Expression assignment, String oldName, String newName) {
        if (assignment instanceof J.Literal) {
            J.Literal literalAssignment = (J.Literal) assignment;
            if (oldName.equals(literalAssignment.getValue())) {
                return literalAssignment.withValue(newName).withValueSource(""\"""" + newName + ""\"""");
            }
        } else if (assignment instanceof J.NewArray) {
            J.NewArray newArrayAssignment = (J.NewArray) assignment;
            return newArrayAssignment.withInitializer(
                    ListUtils.map(newArrayAssignment.getInitializer(), expr -> replace(expr, oldName, newName)));
        }
        return assignment;
    }

    private static boolean contains(Expression assignment, String oldName) {
        if (assignment instanceof J.Literal) {
            return oldName.equals(((J.Literal) assignment).getValue());
        }
        if (assignment instanceof J.NewArray) {
            J.NewArray newArrayAssignment = (J.NewArray) assignment;
            if (newArrayAssignment.getInitializer() == null) {
                return false;
            }
            for (Expression it : newArrayAssignment.getInitializer()) {
                if (contains(it, oldName)) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

    private boolean isRelevantType(@Nullable JavaType javaType) {
        return this.type == null || TypeUtils.isOfClassType(javaType, this.type);
    }
}
","{
  ""oldName"": ""String field"",
  ""newName"": ""String field""
}"
Delete a spring configuration property,Delete a spring configuration property from any configuration file that contains a matching key.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.properties.DeleteProperty;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.tree.Yaml;

/**
 * A recipe to remove a property (or matching property group) from Spring configuration files. This recipe supports deleting properties from
 * "".properties"" and YAML files.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class DeleteSpringProperty extends Recipe {

    @Option(displayName = ""Property key"",
        description = ""The property key to delete. Supports glob expressions"",
        example = ""management.endpoint.configprops.*"")
    String propertyKey;

    @Override
    public String getDisplayName() {
        return ""Delete a spring configuration property"";
    }

    @Override
    public String getDescription() {
        return ""Delete a spring configuration property from any configuration file that contains a matching key."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof Yaml.Documents || sourceFile instanceof Properties.File;
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree t, ExecutionContext ctx) {
                if (t instanceof Yaml.Documents) {
                    t = new org.openrewrite.yaml.DeleteProperty(propertyKey, false, true, null)
                        .getVisitor().visitNonNull(t, ctx);
                } else if (t instanceof Properties.File) {
                    t = new DeleteProperty(propertyKey, true)
                        .getVisitor().visitNonNull(t, ctx);
                }
                return t;
            }
        };
    }
}
","{
  ""propertyKey"": ""String field""
}"
Remove `@RequestMapping` annotations,"Replace method declaration `@RequestMapping` annotations with `@GetMapping`, `@PostMapping`, etc. when possible.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;

import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import static java.util.Collections.singleton;

/**
 * Replace method declaration @RequestMapping annotations with the associated variant
 * as defined by the request method type (GET, POST, PUT, PATCH, DELETE)
 * <p>
 * (HEAD, OPTIONS, TRACE) methods do not have associated RequestMapping variant and are not converted
 * <ul>
 * <li> @RequestMapping() changes to @GetMapping
 * <li> @RequestMapping(method = POST) changes to @PostMapping
 * <li> @RequestMapping(method = { HEAD, GET }) No change
 * </ul>
 */
public class NoRequestMappingAnnotation extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove `@RequestMapping` annotations"";
    }

    @Override
    public String getDescription() {
        return ""Replace method declaration `@RequestMapping` annotations with `@GetMapping`, `@PostMapping`, etc. when possible."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S4488"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.web.bind.annotation.RequestMapping"", false),
                new NoRequestMappingAnnotationVisitor());
    }

    private static class NoRequestMappingAnnotationVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final AnnotationMatcher REQUEST_MAPPING_ANNOTATION_MATCHER = new AnnotationMatcher(""@org.springframework.web.bind.annotation.RequestMapping"");

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = super.visitAnnotation(annotation, ctx);
            if (REQUEST_MAPPING_ANNOTATION_MATCHER.matches(a) && getCursor().getParentOrThrow().getValue() instanceof J.MethodDeclaration) {
                Optional<J.Assignment> requestMethodArg = requestMethodArgument(a);
                Optional<String> requestType = requestMethodArg.map(this::requestMethodType);
                String resolvedRequestMappingAnnotationClassName = requestType.map(this::associatedRequestMapping).orElse(null);
                if (resolvedRequestMappingAnnotationClassName == null) {
                    // Without a method argument @RequestMapping matches all request methods, so we can't safely convert
                    return a;
                }

                maybeRemoveImport(""org.springframework.web.bind.annotation.RequestMapping"");
                maybeRemoveImport(""org.springframework.web.bind.annotation.RequestMethod"");
                requestType.ifPresent(requestMethod -> maybeRemoveImport(""org.springframework.web.bind.annotation.RequestMethod."" + requestMethod));

                // Remove the argument
                if (methodArgumentHasSingleType(requestMethodArg.get())) {
                    if (a.getArguments() != null) {
                        a = a.withArguments(ListUtils.map(a.getArguments(), arg -> requestMethodArg.get().equals(arg) ? null : arg));
                    }
                }

                // Change the Annotation Type
                maybeAddImport(""org.springframework.web.bind.annotation."" + resolvedRequestMappingAnnotationClassName);
                a = (J.Annotation) new ChangeType(""org.springframework.web.bind.annotation.RequestMapping"",
                        ""org.springframework.web.bind.annotation."" + resolvedRequestMappingAnnotationClassName, false)
                        .getVisitor().visit(a, ctx, getCursor().getParentOrThrow());

                // if there is only one remaining argument now, and it is ""path"" or ""value"", then we can drop the key name
                if (a != null && a.getArguments() != null && a.getArguments().size() == 1) {
                    a = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                        if (arg instanceof J.Assignment && ((J.Assignment) arg).getVariable() instanceof J.Identifier) {
                            J.Identifier ident = (J.Identifier) ((J.Assignment) arg).getVariable();
                            if (""path"".equals(ident.getSimpleName()) || ""value"".equals(ident.getSimpleName())) {
                                return ((J.Assignment) arg).getAssignment().withPrefix(Space.EMPTY);
                            }
                        }
                        return arg;
                    }));
                }
            }
            return a != null ? a : annotation;
        }

        private Optional<J.Assignment> requestMethodArgument(J.Annotation annotation) {
            if (annotation.getArguments() == null) {
                return Optional.empty();
            }
            return annotation.getArguments().stream()
                    .filter(arg -> arg instanceof J.Assignment &&
                            ((J.Assignment) arg).getVariable() instanceof J.Identifier &&
                            ""method"".equals(((J.Identifier) ((J.Assignment) arg).getVariable()).getSimpleName()))
                    .map(J.Assignment.class::cast)
                    .findFirst();
        }

        private boolean methodArgumentHasSingleType(J.Assignment assignment) {
            if (!(assignment.getAssignment() instanceof J.NewArray)) {
                return true;
            }
            J.NewArray newArray = (J.NewArray) assignment.getAssignment();
            return newArray.getInitializer() != null && newArray.getInitializer().size() == 1;
        }

        private @Nullable String requestMethodType(J.@Nullable Assignment assignment) {
            if (assignment == null) {
                return null;
            }
            if (assignment.getAssignment() instanceof J.Identifier) {
                return ((J.Identifier) assignment.getAssignment()).getSimpleName();
            }
            if (assignment.getAssignment() instanceof J.FieldAccess) {
                return ((J.FieldAccess) assignment.getAssignment()).getSimpleName();
            }
            if (methodArgumentHasSingleType(assignment)) {
                if (assignment.getAssignment() instanceof J.NewArray) {
                    J.NewArray newArray = (J.NewArray) assignment.getAssignment();
                    List<Expression> initializer = newArray.getInitializer();
                    if (initializer == null || initializer.size() != 1) {
                        return null;
                    }
                    Expression methodName = initializer.get(0);
                    if (methodName instanceof J.Identifier) {
                        return ((J.Identifier) methodName).getSimpleName();
                    }
                    if (methodName instanceof J.FieldAccess) {
                        return ((J.FieldAccess) methodName).getSimpleName();
                    }
                } else if (assignment.getAssignment() instanceof J.Identifier) {
                    return ((J.Identifier) assignment.getAssignment()).getSimpleName();
                }
            }
            return null;
        }

        private @Nullable String associatedRequestMapping(String method) {
            switch (method) {
                case ""POST"":
                case ""PUT"":
                case ""DELETE"":
                case ""PATCH"":
                case ""GET"":
                    return method.charAt(0) + method.toLowerCase().substring(1) + ""Mapping"";
            }
            // HEAD, OPTIONS, TRACE do not have associated RequestMapping variant
            return null;
        }
    }
}
",{}
Expand Spring YAML properties,Expand YAML properties to not use the dot syntax shortcut.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.tree.Yaml;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

@EqualsAndHashCode(callSuper = false)
@Value
public class ExpandProperties extends Recipe {

    @Option(displayName = ""Source file mask"",
            description = ""An optional source file path mask use to restrict which YAML files will be expanded by this recipe."",
            example = ""**/application*.yml"",
            required = false)
    @Nullable
    private String sourceFileMask;

    @Override
    public String getDisplayName() {
        return ""Expand Spring YAML properties"";
    }

    @Override
    public String getDescription() {
        return ""Expand YAML properties to not use the dot syntax shortcut."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        YamlVisitor<ExecutionContext> visitor = new YamlVisitor<ExecutionContext>() {
            @Override
            public Yaml.Documents visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                Yaml.Documents docs = (Yaml.Documents) super.visitDocuments(documents, ctx);
                Yaml.Documents docsExpanded = (Yaml.Documents) new ExpandEntriesVisitor().visitNonNull(docs, ctx);
                if (docsExpanded != docs) {
                    docs = (Yaml.Documents) new CoalesceEntriesVisitor().visitNonNull(docsExpanded, ctx);
                    docs = removeEmptyFirstLine(docs, ctx);
                }
                return docs;
            }

            // If the old first entry was coalesced under a subsequent entry then it will look like a newline was added
            private Yaml.Documents removeEmptyFirstLine(Yaml.Documents docs, ExecutionContext ctx) {
                return (Yaml.Documents) new YamlIsoVisitor<ExecutionContext>() {
                    boolean doneTrimming;
                    @Override
                    public Yaml.Scalar visitScalar(Yaml.Scalar scalar, ExecutionContext ctx) {
                        doneTrimming = true;
                        return scalar.withPrefix(trimNewlineBeforeComment(scalar.getPrefix()));
                    }

                    @Override
                    public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                        doneTrimming = true;
                        return entry.withPrefix(trimNewlineBeforeComment(entry.getPrefix()));
                    }

                    @Override
                    public Yaml.Sequence.Entry visitSequenceEntry(Yaml.Sequence.Entry entry, ExecutionContext ctx) {
                        doneTrimming = true;
                        return entry.withPrefix(trimNewlineBeforeComment(entry.getPrefix()));
                    }

                    @Override
                    public @Nullable Yaml visit(@Nullable Tree tree, ExecutionContext ctx) {
                        if (doneTrimming) {
                            return (Yaml) tree;
                        }
                        return super.visit(tree, ctx);
                    }

                    private String trimNewlineBeforeComment(String prefix) {
                        int hashIndex = prefix.indexOf('#');
                        if(hashIndex >= 0) {
                            return prefix.substring(0, hashIndex).trim() + prefix.substring(hashIndex);
                        }
                        return prefix.trim();
                    }
                }.visitNonNull(docs, ctx);
            }
        };
        return sourceFileMask != null ?
                Preconditions.check(new FindSourceFiles(sourceFileMask), visitor) :
                visitor;
    }

    private static class ExpandEntriesVisitor extends YamlVisitor<ExecutionContext> {
        @Override
        public Yaml visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
            Yaml.Mapping.Entry e = entry;
            String key = e.getKey().getValue();
            if (key.contains(""."") && e.getKey() instanceof Yaml.Scalar) {
                e = e.withKey(((Yaml.Scalar) e.getKey()).withValue(key.substring(0, key.indexOf('.'))));
                e = e.withValue(new Yaml.Mapping(
                        randomId(),
                        Markers.EMPTY,
                        null,
                        singletonList(
                                new Yaml.Mapping.Entry(
                                        randomId(),
                                        """",
                                        Markers.EMPTY,
                                        new Yaml.Scalar(
                                                randomId(),
                                                """",
                                                Markers.EMPTY,
                                                Yaml.Scalar.Style.PLAIN,
                                                null,
                                                null,
                                                key.substring(key.indexOf('.') + 1)),
                                        """",
                                        e.getValue()
                                )
                        ),
                        null,
                        null,
                        null
                ));
                e = autoFormat(e, ctx, getCursor().getParentOrThrow());
            }
            return super.visitMappingEntry(e, ctx);
        }
    }

    private static class CoalesceEntriesVisitor extends YamlVisitor<ExecutionContext> {
        @Override
        public Yaml visitMapping(Yaml.Mapping mapping, ExecutionContext ctx) {
            Map<String, List<Yaml.Mapping>> mappingsByKey = new HashMap<>();
            for (Yaml.Mapping.Entry entry : mapping.getEntries()) {
                if (entry.getValue() instanceof Yaml.Mapping) {
                    mappingsByKey.computeIfAbsent(entry.getKey().getValue(), v -> new ArrayList<>()).add((Yaml.Mapping) entry.getValue());
                }
            }

            for (Map.Entry<String, List<Yaml.Mapping>> keyMappings : mappingsByKey.entrySet()) {
                if (keyMappings.getValue().size() > 1) {
                    Yaml.Mapping newMapping = new Yaml.Mapping(
                            randomId(),
                            Markers.EMPTY,
                            null,
                            keyMappings.getValue().stream().flatMap(duplicateMapping -> duplicateMapping.getEntries().stream())
                                    .collect(toList()),
                            null,
                            null,
                            null
                    );
                    Yaml.Mapping.Entry newEntry = autoFormat(
                            new Yaml.Mapping.Entry(randomId(),
                                    """",
                                    Markers.EMPTY,
                                    new Yaml.Scalar(randomId(), """", Markers.EMPTY, Yaml.Scalar.Style.PLAIN, null, null, keyMappings.getKey()),
                                    """", newMapping),
                            ctx, getCursor());

                    AtomicInteger insertIndex = new AtomicInteger(-1);
                    mapping = mapping.withEntries(ListUtils.map(mapping.getEntries(), (i, ent) -> {
                        if (ent.getKey().getValue().equals(keyMappings.getKey())) {
                            if (insertIndex.get() < 0) {
                                insertIndex.set(i);
                            }
                            return null;
                        }
                        return ent;
                    }));
                    //noinspection ConstantConditions
                    mapping = mapping.withEntries(ListUtils.insertAll(mapping.getEntries(), insertIndex.get(), singletonList(newEntry)));
                }
            }
            return super.visitMapping(mapping, ctx);
        }
    }
}
",{}
Change the value of a spring application property,Change spring application property values existing in either Properties or Yaml files.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.tree.Yaml;

import java.util.regex.Pattern;

@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeSpringPropertyValue extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Change the value of a spring application property"";
    }

    @Override
    public String getDescription() {
        return ""Change spring application property values existing in either Properties or Yaml files."";
    }

    @Option(displayName = ""Property key"",
            description = ""The name of the property key whose value is to be changed."",
            example = ""management.metrics.binders.files.enabled"")
    String propertyKey;

    @Option(displayName = ""New value"",
            description = ""The new value to be used for key specified by `propertyKey`."",
            example = ""management.metrics.enable.process.files"")
    String newValue;

    @Option(displayName = ""Old value"",
            required = false,
            description = ""Only change the property value if it matches the configured `oldValue`."",
            example = ""false"")
    @Nullable
    String oldValue;

    @Option(displayName = ""Regex"",
            description = ""Default false. If enabled, `oldValue` will be interpreted as a Regular Expression, and capture group contents will be available in `newValue`"",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                          ""rules. Default is `true`. Set to `false` to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Override
    public Validated<Object> validate() {
        return super.validate().and(
                Validated.test(""oldValue"", ""is required if `regex` is enabled"", oldValue,
                        value -> !(Boolean.TRUE.equals(regex) && StringUtils.isNullOrEmpty(value))));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Recipe changeProperties = new org.openrewrite.properties.ChangePropertyValue(propertyKey, newValue, oldValue, regex, relaxedBinding);
        String yamlValue = quoteValue(newValue) ? ""\"""" + newValue + ""\"""" : newValue;
        Recipe changeYaml = new org.openrewrite.yaml.ChangePropertyValue(propertyKey, yamlValue, oldValue, regex, relaxedBinding, null);
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof Properties.File) {
                    tree = changeProperties.getVisitor().visit(tree, ctx);
                } else if (tree instanceof Yaml.Documents) {
                    tree = changeYaml.getVisitor().visit(tree, ctx);
                }
                return tree;
            }
        };
    }

    private static final Pattern scalarNeedsAQuote = Pattern.compile(""[^a-zA-Z\\d\\s]*"");
    private boolean quoteValue(String value) {
        return scalarNeedsAQuote.matcher(value).matches();
    }
}
","{
  ""propertyKey"": ""String field"",
  ""newValue"": ""String field""
}"
Replace `SpringClassRule` and `SpringMethodRule` with JUnit 5 `SpringExtension`,Replace JUnit 4's `SpringClassRule` and `SpringMethodRule` with JUnit 5's `SpringExtension` or rely on an existing `@SpringBootTest`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.test;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import static java.util.Comparator.comparing;

public class SpringRulesToJUnitExtension extends Recipe {

    private static final String SPRING_CLASS_RULE = ""org.springframework.test.context.junit4.rules.SpringClassRule"";
    private static final String SPRING_METHOD_RULE = ""org.springframework.test.context.junit4.rules.SpringMethodRule"";
    private static final String EXTEND_WITH = ""org.junit.jupiter.api.extension.ExtendWith"";
    private static final String SPRING_EXTENSION = ""org.springframework.test.context.junit.jupiter.SpringExtension"";
    private static final AnnotationMatcher ANNOTATION_MATCHER = new AnnotationMatcher(String.format(""@%s(%s.class)"", EXTEND_WITH, SPRING_EXTENSION), true);


    @Override
    public String getDisplayName() {
        return ""Replace `SpringClassRule` and `SpringMethodRule` with JUnit 5 `SpringExtension`"";
    }

    @Override
    public String getDescription() {
        return ""Replace JUnit 4's `SpringClassRule` and `SpringMethodRule` with JUnit 5's `SpringExtension` or rely on an existing `@SpringBootTest`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(SPRING_CLASS_RULE, true),
                        new UsesType<>(SPRING_METHOD_RULE, true)
                ),
                new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public J.@Nullable VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                        J.VariableDeclarations vd = super.visitVariableDeclarations(multiVariable, ctx);
                        if (TypeUtils.isOfClassType(vd.getTypeAsFullyQualified(), SPRING_CLASS_RULE) ||
                            TypeUtils.isOfClassType(vd.getTypeAsFullyQualified(), SPRING_METHOD_RULE)) {
                            maybeRemoveImport(SPRING_CLASS_RULE);
                            maybeRemoveImport(SPRING_METHOD_RULE);
                            maybeRemoveImport(""org.junit.ClassRule"");
                            maybeRemoveImport(""org.junit.Rule"");

                            doAfterVisit(new JavaIsoVisitor<ExecutionContext>() {
                                @Override
                                public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                                    J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                                    if (cd.getLeadingAnnotations().stream().noneMatch(ANNOTATION_MATCHER::matches)) {
                                        maybeAddImport(EXTEND_WITH);
                                        maybeAddImport(SPRING_EXTENSION);
                                        return JavaTemplate.builder(""@ExtendWith(SpringExtension.class)"")
                                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""junit-jupiter-api"", ""spring-test""))
                                                .imports(EXTEND_WITH, SPRING_EXTENSION)
                                                .build()
                                                .apply(getCursor(), cd.getCoordinates().addAnnotation(comparing(J.Annotation::getSimpleName)));

                                    }
                                    return cd;
                                }
                            });

                            //noinspection DataFlowIssue
                            return null;
                        }
                        return vd;
                    }
                });
    }
}
",{}
Use varargs equivalents for deprecated JdbcTemplate signatures,"`JdbcTemplate` signatures with `Object[]` arguments are deprecated, in favor of their existing varargs equivalents.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;
import java.util.List;

public class JdbcTemplateObjectArrayArgToVarArgs extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use varargs equivalents for deprecated JdbcTemplate signatures"";
    }

    @Override
    public String getDescription() {
        return ""`JdbcTemplate` signatures with `Object[]` arguments are deprecated, in favor of their existing varargs equivalents."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.jdbc.core.JdbcTemplate"", true), new JdbcTemplateArgsVisitor());
    }

    private static class JdbcTemplateArgsVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final MethodMatcher queryMapper = new MethodMatcher(""org.springframework.jdbc.core.JdbcTemplate query(..)"");
        private static final MethodMatcher queryForObjectMapper = new MethodMatcher(""org.springframework.jdbc.core.JdbcTemplate queryForObject(..)"");
        private static final MethodMatcher queryForListMapper = new MethodMatcher(""org.springframework.jdbc.core.JdbcTemplate queryForList(..)"");

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (queryMapper.matches(mi) || queryForObjectMapper.matches(mi) || queryForListMapper.matches(mi)) {
                List<Expression> args = mi.getArguments();
                if (args.size() == 3 && shouldSwapArgs(args.get(1).getType(), args.get(2).getType())) {
                    List<Expression> reOrderedArgs = new ArrayList<>(3);
                    reOrderedArgs.add(args.get(0));
                    reOrderedArgs.add(args.get(2).withPrefix(args.get(1).getPrefix()));
                    reOrderedArgs.add(args.get(1).withPrefix(args.get(2).getPrefix()));
                    mi = mi.withArguments(reOrderedArgs);
                }
            }
            return mi;
        }

        private boolean shouldSwapArgs(@Nullable JavaType arg1, @Nullable JavaType arg2) {
            return arg1 instanceof JavaType.Array && (
                    (arg2 instanceof JavaType.Parameterized && ((JavaType.Parameterized) arg2).getTypeParameters().get(0) instanceof JavaType.Class) ||
                            TypeUtils.isOfClassType(arg2, ""org.springframework.jdbc.core.RowMapper"") ||
                            TypeUtils.isOfClassType(arg2, ""org.springframework.jdbc.core.ResultSetExtractor"") ||
                            TypeUtils.isOfClassType(arg2, ""org.springframework.jdbc.core.RowCallbackHandler"")

            );
        }
    }
}
",{}
`@Bean` methods may not return `void`,Make `@Bean` methods return `Object` instead of `void`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.*;

import java.util.List;

public class BeanMethodReturnNull extends Recipe {
    private static final String BEAN_ANNOTATION_FQN = ""org.springframework.context.annotation.Bean"";
    private static final AnnotationMatcher BEAN_ANNOTATION_MATCHER = new AnnotationMatcher(""@"" + BEAN_ANNOTATION_FQN);
    private static final String MSG_RETURN_VOID = ""RETURN_VOID"";

    @Override
    public String getDisplayName() {
        return ""`@Bean` methods may not return `void`"";
    }

    @Override
    public String getDescription() {
        return ""Make `@Bean` methods return `Object` instead of `void`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(BEAN_ANNOTATION_FQN, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
                // When the method is annotated with @Bean and it is not an override method
                if (service(AnnotationService.class).matches(getCursor(), BEAN_ANNOTATION_MATCHER) &&
                    !TypeUtils.isOverride(md.getMethodType()) && md.getBody() != null &&
                    md.getReturnTypeExpression() != null && md.getReturnTypeExpression().getType() == JavaType.Primitive.Void) {

                    // Add `return null;` if the method does not have a return statement
                    List<Statement> statements = md.getBody().getStatements();
                    if (statements.isEmpty() || !(statements.get(statements.size() - 1) instanceof J.Return)) {
                        md = JavaTemplate.apply(""return null;"", updateCursor(md), md.getBody().getCoordinates().lastStatement());
                    }

                    // Change the return type to `Object`
                    md = md.withReturnTypeExpression(TypeTree.build(""Object"")
                            .withType(JavaType.buildType(""java.lang.Object""))
                            .withPrefix(md.getReturnTypeExpression().getPrefix()));

                    getCursor().putMessage(MSG_RETURN_VOID, true);
                }

                return super.visitMethodDeclaration(md, ctx);
            }

            // Change `return;` to `return null;`
            @Override
            public J.Return visitReturn(J.Return _return, ExecutionContext ctx) {
                if (_return.getExpression() == null && getCursor().getNearestMessage(MSG_RETURN_VOID, false)) {
                    return JavaTemplate.apply(""return null;"", getCursor(), _return.getCoordinates().replace());
                }
                return super.visitReturn(_return, ctx);
            }

            // Do not traverse down into lambda and new class to avoid adding `return null;` there
            @Override
            public J.Lambda visitLambda(J.Lambda lambda, ExecutionContext ctx) {
                return lambda;
            }

            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                return newClass;
            }
        });
    }
}
",{}
Remove `public` from `@Bean` methods,Remove public modifier from `@Bean` methods. They no longer have to be public visibility to be usable by Spring.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.ChangeMethodAccessLevelVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

public class BeanMethodsNotPublic extends Recipe {
    private static final String BEAN = ""org.springframework.context.annotation.Bean"";
    private static final AnnotationMatcher BEAN_ANNOTATION_MATCHER = new AnnotationMatcher(""@"" + BEAN);

    @Override
    public String getDisplayName() {
        return ""Remove `public` from `@Bean` methods"";
    }

    @Override
    public String getDescription() {
        return ""Remove public modifier from `@Bean` methods. They no longer have to be public visibility to be usable by Spring."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(BEAN, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                if (service(AnnotationService.class).matches(getCursor(), BEAN_ANNOTATION_MATCHER) &&
                    !TypeUtils.isOverride(method.getMethodType())) {
                    // remove public modifier and copy any associated comments to the method
                    doAfterVisit(new ChangeMethodAccessLevelVisitor<>(new MethodMatcher(method), null));
                }
                return super.visitMethodDeclaration(method, ctx);
            }
        });
    }
}
",{}
Migrate `org.springframework.web.reactive.HandlerResult.setExceptionHandler` method,"`org.springframework.web.reactive.HandlerResult.setExceptionHandler(Function<Throwable, Mono<HandlerResult>>)` was deprecated, in favor of `setExceptionHandler(DispatchExceptionHandler)`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

public class MigrateHandlerResultSetExceptionHandlerMethod extends Recipe {

    private static final String HandlerResult = ""org.springframework.web.reactive.HandlerResult"";

    private static final MethodMatcher METHOD_MATCHER = new MethodMatcher(HandlerResult + "" setExceptionHandler(java.util.function.Function)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `org.springframework.web.reactive.HandlerResult.setExceptionHandler` method"";
    }

    @Override
    public String getDescription() {
        return ""`org.springframework.web.reactive.HandlerResult.setExceptionHandler(Function<Throwable, Mono<HandlerResult>>)` was deprecated, in favor of `setExceptionHandler(DispatchExceptionHandler)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(HandlerResult, false), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (METHOD_MATCHER.matches(m)) {
                    if (m.getArguments().get(0) instanceof J.Identifier) {
                        return JavaTemplate.builder(""(exchange, ex) ->  #{any()}.apply(ex)"")
                                .build()
                                .apply(getCursor(), m.getCoordinates().replaceArguments(), m.getArguments().get(0));
                    }
                    if (m.getArguments().get(0) instanceof J.Lambda) {
                        return JavaTemplate.builder(""(exchange, ex) ->  #{any()}"")
                                .build()
                                .apply(getCursor(), m.getCoordinates().replaceArguments(), ((J.Lambda) m.getArguments().get(0)).getBody());
                    }
                }
                return m;
            }
        });
    }

}
",{}
Replace `WebMvcConfigurerAdapter` with `WebMvcConfigurer`,As of 5.0 `WebMvcConfigurer` has default methods (made possible by a Java 8 baseline) and can be ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

public class MigrateWebMvcConfigurerAdapter extends Recipe {
    private static final String WEB_MVC_CONFIGURER_ADAPTER = ""org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter"";
    private static final String WEB_MVC_CONFIGURER = ""org.springframework.web.servlet.config.annotation.WebMvcConfigurer"";

    @Override
    public String getDisplayName() {
        return ""Replace `WebMvcConfigurerAdapter` with `WebMvcConfigurer`"";
    }

    @Override
    public String getDescription() {
        return ""As of 5.0 `WebMvcConfigurer` has default methods (made possible by a Java 8 baseline) and can be "" +
               ""implemented directly without the need for this adapter."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(WEB_MVC_CONFIGURER_ADAPTER, false), new JavaIsoVisitor<ExecutionContext>() {
            private final JavaType WEB_MVC_CONFIGURER_TYPE = JavaType.buildType(WEB_MVC_CONFIGURER);

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (cd.getExtends() != null && TypeUtils.isOfClassType(cd.getExtends().getType(), WEB_MVC_CONFIGURER_ADAPTER)) {
                    cd = cd.withExtends(null);
                    updateCursor(cd);
                    // This is an interesting one... WebMvcConfigurerAdapter implements WebMvcConfigurer
                    // remove the super type from the class type to prevent a stack-overflow exception when the JavaTemplate visits class type.
                    JavaType.Class type = (JavaType.Class) cd.getType();
                    if (type != null) {
                        cd = cd.withType(type.withSupertype(null));
                        updateCursor(cd);
                    }
                    cd = JavaTemplate.builder(""WebMvcConfigurer"")
                            .contextSensitive()
                            .imports(WEB_MVC_CONFIGURER)
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-webmvc-5""))
                            .build().apply(getCursor(), cd.getCoordinates().addImplementsClause());
                    updateCursor(cd);
                    cd = (J.ClassDeclaration) new RemoveSuperStatementVisitor().visitNonNull(cd, ctx, getCursor().getParentOrThrow());
                    maybeRemoveImport(WEB_MVC_CONFIGURER_ADAPTER);
                    maybeAddImport(WEB_MVC_CONFIGURER);
                }
                return cd;
            }

            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                if (newClass.getClazz() != null && TypeUtils.isOfClassType(newClass.getClazz().getType(), WEB_MVC_CONFIGURER_ADAPTER)) {
                    if (newClass.getClazz() instanceof J.Identifier) {
                        J.Identifier identifier = (J.Identifier) newClass.getClazz();
                        newClass = newClass.withClazz(identifier
                                .withType(WEB_MVC_CONFIGURER_TYPE)
                                .withSimpleName(((JavaType.ShallowClass) WEB_MVC_CONFIGURER_TYPE).getClassName())
                        );
                    }
                    maybeRemoveImport(WEB_MVC_CONFIGURER_ADAPTER);
                    maybeAddImport(WEB_MVC_CONFIGURER);
                }
                return super.visitNewClass(newClass, ctx);
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
                if (md.getMethodType() != null && TypeUtils.isOfClassType(md.getType(), WEB_MVC_CONFIGURER_ADAPTER)) {
                    if (md.getReturnTypeExpression() instanceof J.Identifier) {
                        J.Identifier identifier = (J.Identifier) md.getReturnTypeExpression();
                        md = md.withReturnTypeExpression(identifier
                                .withType(WEB_MVC_CONFIGURER_TYPE)
                                .withSimpleName(((JavaType.ShallowClass) WEB_MVC_CONFIGURER_TYPE).getClassName())
                        );
                    }

                    maybeRemoveImport(WEB_MVC_CONFIGURER_ADAPTER);
                    maybeAddImport(WEB_MVC_CONFIGURER);
                }
                return super.visitMethodDeclaration(md, ctx);
            }

            class RemoveSuperStatementVisitor extends JavaIsoVisitor<ExecutionContext> {
                final MethodMatcher wm = new MethodMatcher(""org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter *(..)"");

                @Override
                public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                    J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                    if (wm.matches(method.getMethodType())) {
                        return null;
                    }
                    return mi;
                }
            }
        });
    }
}
",{}
Migrate deprecated Spring Web UTF8 `MediaType` enums,Spring Web `MediaType#APPLICATION_JSON_UTF8` and `MediaType#APPLICATION_PROBLEM_JSON_UTF8` were deprecated in 5.2.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

public class MigrateUtf8MediaTypes extends Recipe {
    private final JavaType.FullyQualified mediaTypeFqn =
            JavaType.ShallowClass.build(""org.springframework.http.MediaType"");

    @Override
    public String getDisplayName() {
        return ""Migrate deprecated Spring Web UTF8 `MediaType` enums"";
    }

    @Override
    public String getDescription() {
        return ""Spring Web `MediaType#APPLICATION_JSON_UTF8` and `MediaType#APPLICATION_PROBLEM_JSON_UTF8` were deprecated in 5.2."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.http.MediaType"", false), new JavaIsoVisitor<ExecutionContext>() {
            private final Map<String, String> updateDeprecatedFields = new HashMap<String, String>() {{
                put(""APPLICATION_JSON_UTF8"", ""APPLICATION_JSON"");
                put(""APPLICATION_JSON_UTF8_VALUE"", ""APPLICATION_JSON_VALUE"");
                put(""APPLICATION_PROBLEM_JSON_UTF8"", ""APPLICATION_PROBLEM_JSON"");
                put(""APPLICATION_PROBLEM_JSON_UTF8_VALUE"", ""APPLICATION_PROBLEM_JSON_VALUE"");
            }};

            @Override
            public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);
                if (TypeUtils.isOfType(mediaTypeFqn, fa.getTarget().getType()) &&
                        updateDeprecatedFields.containsKey(fa.getName().getSimpleName())) {

                    if (fa.getTarget() instanceof J.FieldAccess) {
                        fa = TypeTree.build(mediaTypeFqn.getFullyQualifiedName() + ""."" + updateDeprecatedFields.get(fieldAccess.getName().getSimpleName()))
                                .withPrefix(fa.getPrefix());
                    } else {
                        fa = fa.withName(fa.getName().withSimpleName(updateDeprecatedFields.get(fa.getName().getSimpleName())));
                        fa = fa.withTarget(new J.Identifier(
                                Tree.randomId(),
                                fa.getTarget().getPrefix(),
                                fa.getTarget().getMarkers(),
                                emptyList(),
                                mediaTypeFqn.getClassName(),
                                mediaTypeFqn,
                                null));
                    }
                }
                return fa;
            }

            @Override
            public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
                J.Identifier id = super.visitIdentifier(identifier, ctx);
                if (isTargetFieldType(id) && updateDeprecatedFields.containsKey(id.getSimpleName())) {
                    JavaType.Variable fieldType = id.getFieldType();
                    id = new J.Identifier(
                            Tree.randomId(),
                            id.getPrefix(),
                            id.getMarkers(),
                            emptyList(),
                            updateDeprecatedFields.get(id.getSimpleName()),
                            id.getType(),
                            new JavaType.Variable(
                                    null,
                                    fieldType == null ? 0 : Flag.flagsToBitMap(fieldType.getFlags()),
                                    updateDeprecatedFields.get(id.getSimpleName()),
                                    mediaTypeFqn,
                                    null,
                                    emptyList()));
                }
                return id;
            }

            private boolean isTargetFieldType(J.Identifier identifier) {
                if (identifier.getFieldType() != null) {
                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified((identifier.getFieldType()).getOwner());
                    return fqn != null && mediaTypeFqn.getFullyQualifiedName().equals(fqn.getFullyQualifiedName());
                }
                return false;
            }
        });
    }
}
",{}
Migrate `ResponseEntityExceptionHandler` from HttpStatus to HttpStatusCode,With Spring 6 `HttpStatus` was replaced by `HttpStatusCode` in most method signatures in the `ResponseEntityExceptionHandler`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

public class MigrateResponseEntityExceptionHandlerHttpStatusToHttpStatusCode extends Recipe {

    private static final String HTTP_STATUS_FQ = ""org.springframework.http.HttpStatus"";
    private static final String HTTP_STATUS_CODE_FQ = ""org.springframework.http.HttpStatusCode"";
    private static final String RESPONSE_ENTITY_EXCEPTION_HANDLER_FQ = ""org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler"";
    private static final MethodMatcher HANDLER_METHOD = new MethodMatcher(
            ""org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler *(..)"", true);

    @Override
    public String getDisplayName() {
        return ""Migrate `ResponseEntityExceptionHandler` from HttpStatus to HttpStatusCode"";
    }

    @Override
    public String getDescription() {
        return ""With Spring 6 `HttpStatus` was replaced by `HttpStatusCode` in most method signatures in the `ResponseEntityExceptionHandler`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(RESPONSE_ENTITY_EXCEPTION_HANDLER_FQ, true),
                new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration m = method;
                        if (HANDLER_METHOD.matches(m.getMethodType())) {
                            JavaType javaTypeHttpStatusCode = JavaType.buildType(HTTP_STATUS_CODE_FQ);
                            //noinspection DataFlowIssue
                            JavaType.Method met = m.getMethodType().withParameterTypes(ListUtils.map(m.getMethodType().getParameterTypes(),
                                    type -> TypeUtils.isAssignableTo(HTTP_STATUS_FQ, type) ? javaTypeHttpStatusCode : type));
                            if (met == m.getMethodType()) {
                                // There was no parameter to change
                                return m;
                            }

                            m = m.withMethodType(met);
                            m = m.withParameters(ListUtils.map(m.getParameters(), var -> {
                                if (var instanceof J.VariableDeclarations) {
                                    J.VariableDeclarations v = (J.VariableDeclarations) var;
                                    J.VariableDeclarations.NamedVariable declaredVar = v.getVariables().get(0);
                                    if (declaredVar.getVariableType() != null && TypeUtils.isAssignableTo(HTTP_STATUS_FQ, v.getType())) {
                                        J.Identifier newName = declaredVar.getName().withType(javaTypeHttpStatusCode);
                                        if (newName.getFieldType() != null) {
                                            newName = newName.withFieldType(newName.getFieldType().withType(javaTypeHttpStatusCode));
                                        }
                                        declaredVar = declaredVar
                                                .withName(newName)
                                                .withVariableType(declaredVar.getVariableType().withOwner(met));
                                        return v.withVariables(singletonList(declaredVar.withType(javaTypeHttpStatusCode)))
                                                .withTypeExpression(TypeTree.build(""HttpStatusCode"")
                                                        .withType(javaTypeHttpStatusCode)
                                                        .withPrefix(requireNonNull(v.getTypeExpression()).getPrefix()));
                                    }
                                }
                                return var;
                            }));
                        }
                        updateCursor(m);
                        maybeAddImport(HTTP_STATUS_CODE_FQ);
                        maybeRemoveImport(HTTP_STATUS_FQ);
                        return super.visitMethodDeclaration(m, ctx);
                    }

                    @Override
                    public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
                        J.Identifier ident = super.visitIdentifier(identifier, ctx);
                        J.MethodDeclaration methodScope = getCursor().firstEnclosing(J.MethodDeclaration.class);
                        if (methodScope != null) {
                            for (Statement stmt : methodScope.getParameters()) {
                                if (stmt instanceof J.VariableDeclarations) {
                                    J.VariableDeclarations vd = (J.VariableDeclarations) stmt;
                                    for (J.VariableDeclarations.NamedVariable var : vd.getVariables()) {
                                        if (var.getName().getSimpleName().equals(ident.getSimpleName())) {
                                            if (!TypeUtils.isOfType(var.getName().getType(), ident.getType())) {
                                                ident = ident.withType(var.getName().getType());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return super.visitIdentifier(ident, ctx);
                    }
                }
        );
    }
}
",{}
Migrate `ResourceHttpMessageWriter.addHeaders`,"`org.springframework.http.codec.ResourceHttpMessageWriter.addHeaders` was deprecated, in favor of `addDefaultHeaders` method.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class MigrateResourceHttpMessageWriterAddHeadersMethod extends Recipe {

    private static final MethodMatcher ADD_HEADERS_MATCHER = new MethodMatcher(""org.springframework.http.codec.ResourceHttpMessageWriter addHeaders(..)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `ResourceHttpMessageWriter.addHeaders`"";
    }

    @Override
    public String getDescription() {
        return ""`org.springframework.http.codec.ResourceHttpMessageWriter.addHeaders` was deprecated, in favor of `addDefaultHeaders` method."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ADD_HEADERS_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (ADD_HEADERS_MATCHER.matches(m)) {
                    return JavaTemplate.builder(""#{any(org.springframework.http.codec.ResourceHttpMessageWriter)}"" +
                                    "".addDefaultHeaders(#{any(org.springframework.http.ReactiveHttpOutputMessage)},"" +
                                    "" #{any(org.springframework.core.io.Resource)},"" +
                                    "" #{any(org.springframework.http.MediaType)},"" +
                                    "" #{any(java.util.Map)})"" +
                                    "".block()"")
                            .build()
                            .apply(getCursor(), m.getCoordinates().replace(), m.getSelect(),
                                    m.getArguments().get(0),
                                    m.getArguments().get(1),
                                    m.getArguments().get(2),
                                    m.getArguments().get(3));
                }
                return m;
            }
        });
    }
}
",{}
Migrate `org.springframework.util.Base64Utils` to `java.io.Base64`,Replaces usages of deprecated `org.springframework.util.Base64Utils` with `java.util.Base64`.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

import java.util.HashMap;
import java.util.Map;

public class MigrateBase64Utils extends Recipe {

    private static final String SPRING_BASE_64_UTILS = ""org.springframework.util.Base64Utils"";
    private static final MethodMatcher ANY_BASE64UTILS = new MethodMatcher(SPRING_BASE_64_UTILS + "" *(..)"");

    private static final MethodMatcher ENCODE = new MethodMatcher(SPRING_BASE_64_UTILS + "" encode(byte[])"");
    private static final MethodMatcher DECODE = new MethodMatcher(SPRING_BASE_64_UTILS + "" decode(byte[])"");
    private static final MethodMatcher ENCODE_TO_STRING = new MethodMatcher(SPRING_BASE_64_UTILS + "" encodeToString(byte[])"");
    private static final MethodMatcher DECODE_FROM_STRING = new MethodMatcher(SPRING_BASE_64_UTILS + "" decodeFromString(String)"");

    private static final MethodMatcher ENCODE_URL_SAFE = new MethodMatcher(SPRING_BASE_64_UTILS + "" encodeUrlSafe(byte[])"");
    private static final MethodMatcher DECODE_URL_SAFE = new MethodMatcher(SPRING_BASE_64_UTILS + "" decodeUrlSafe(byte[])"");
    private static final MethodMatcher ENCODE_TO_URL_SAFE_STRING = new MethodMatcher(SPRING_BASE_64_UTILS + "" encodeToUrlSafeString(byte[])"");
    private static final MethodMatcher DECODE_FROM_URL_SAFE_STRING = new MethodMatcher(SPRING_BASE_64_UTILS + "" decodeFromUrlSafeString(String)"");

    private static final Map<MethodMatcher, String> MAPPINGS = new HashMap<>();
    static {
        MAPPINGS.put(ENCODE, ""Base64.getEncoder().encode(#{anyArray(byte)})"");
        MAPPINGS.put(DECODE, ""Base64.getDecoder().decode(#{anyArray(byte)})"");
        MAPPINGS.put(ENCODE_TO_STRING, ""Base64.getEncoder().encodeToString(#{anyArray(byte)})"");
        MAPPINGS.put(DECODE_FROM_STRING, ""Base64.getDecoder().decode(#{any(String)})"");
        MAPPINGS.put(ENCODE_URL_SAFE, ""Base64.getUrlEncoder().encode(#{anyArray(byte)})"");
        MAPPINGS.put(DECODE_URL_SAFE, ""Base64.getUrlDecoder().decode(#{anyArray(byte)})"");
        MAPPINGS.put(ENCODE_TO_URL_SAFE_STRING, ""Base64.getUrlEncoder().encodeToString(#{anyArray(byte)})"");
        MAPPINGS.put(DECODE_FROM_URL_SAFE_STRING, ""Base64.getUrlDecoder().decode(#{any(String)})"");
    }

    @Override
    public String getDisplayName() {
        return ""Migrate `org.springframework.util.Base64Utils` to `java.io.Base64`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces usages of deprecated `org.springframework.util.Base64Utils` with `java.util.Base64`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(ANY_BASE64UTILS), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (ANY_BASE64UTILS.matches(m)) {
                    for (Map.Entry<MethodMatcher, String> entry : MAPPINGS.entrySet()) {
                        if (entry.getKey().matches(m)) {
                            maybeAddImport(""java.util.Base64"");
                            maybeRemoveImport(SPRING_BASE_64_UTILS);
                            return JavaTemplate.builder(entry.getValue())
                                    .imports(""java.util.Base64"")
                                    .build()
                                    .apply(updateCursor(m), m.getCoordinates().replace(), method.getArguments().get(0));
                        }
                    }
                }
                return m;
            }
        });
    }
}
",{}
Replaces deprecated `ClientHttpResponse#getRawStatusCode()`,"`ClientHttpResponse#getRawStatusCode()` was deprecated, so we replace it with `getStatusCode()`, ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class MigrateClientHttpResponseGetRawStatusCodeMethod extends Recipe {
    private static final MethodMatcher MATCHER = new MethodMatcher(""org.springframework.http.client.ClientHttpResponse getRawStatusCode()"");

    @Override
    public String getDisplayName() {
        return ""Replaces deprecated `ClientHttpResponse#getRawStatusCode()`"";
    }

    @Override
    public String getDescription() {
        return ""`ClientHttpResponse#getRawStatusCode()` was deprecated, so we replace it with `getStatusCode()`, "" +
                ""though the return type has changed from `int` to `HttpStatusCode`, so we must account for that as well."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(MATCHER), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (MATCHER.matches(m)) {
                    return JavaTemplate.builder(""#{any(org.springframework.http.client.ClientHttpResponse)}.getStatusCode().value()"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-web-6""))
                            .build()
                            .apply(updateCursor(m), m.getCoordinates().replace(), m.getSelect());
                }
                return m;
            }
        });
    }
}
",{}
Migrate `WebExchangeBindException.resolveErrorMessages`,"`org.springframework.web.bind.support.WebExchangeBindException.resolveErrorMessages` was deprecated, in favor of `BindErrorUtils`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class MigrateWebExchangeBindExceptionResolveErrorMethod extends Recipe {

    private static final MethodMatcher RESOLVE_ERROR_MESSAGES = new MethodMatcher(
            ""org.springframework.web.bind.support.WebExchangeBindException"" +
                    "" resolveErrorMessages(org.springframework.context.MessageSource, java.util.Locale)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `WebExchangeBindException.resolveErrorMessages`"";
    }

    @Override
    public String getDescription() {
        return ""`org.springframework.web.bind.support.WebExchangeBindException.resolveErrorMessages` was deprecated, in favor of `BindErrorUtils`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(RESOLVE_ERROR_MESSAGES), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (RESOLVE_ERROR_MESSAGES.matches(m)) {
                    maybeAddImport(""org.springframework.web.util.BindErrorUtils"");
                    return JavaTemplate.builder(""BindErrorUtils.resolve(#{any()}.getAllErrors(), #{any()}, #{any()})"")
                            .imports(""org.springframework.web.util.BindErrorUtils"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx,
                                            ""spring-context-6.+"",
                                            ""spring-core-6.+"",
                                            ""spring-web-6.+""))
                            .build()
                            .apply(getCursor(), m.getCoordinates().replace(), m.getSelect(), m.getArguments().get(0), m.getArguments().get(1));
                }
                return m;
            }
        });
    }
}
",{}
Migrate `HandlerInterceptorAdapter` to `HandlerInterceptor`,Deprecated as of 5.3 in favor of implementing `HandlerInterceptor` and/or `AsyncHandlerInterceptor`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;

import static java.util.Collections.singletonList;

public class MigrateHandlerInterceptor extends Recipe {

    private static final String HANDLER_INTERCEPTOR_ADAPTER = ""org.springframework.web.servlet.handler.HandlerInterceptorAdapter"";
    private static final String HANDLER_INTERCEPTOR_INTERFACE = ""org.springframework.web.servlet.HandlerInterceptor"";

    private static final MethodMatcher PRE_HANDLE = new MethodMatcher(""org.springframework.web.servlet.HandlerInterceptor preHandle(..)"");
    private static final MethodMatcher POST_HANDLE = new MethodMatcher(""org.springframework.web.servlet.HandlerInterceptor postHandle(..)"");
    private static final MethodMatcher AFTER_COMPLETION = new MethodMatcher(""org.springframework.web.servlet.HandlerInterceptor afterCompletion(..)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `HandlerInterceptorAdapter` to `HandlerInterceptor`"";
    }

    @Override
    public String getDescription() {
        return ""Deprecated as of 5.3 in favor of implementing `HandlerInterceptor` and/or `AsyncHandlerInterceptor`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(HANDLER_INTERCEPTOR_ADAPTER, false), new JavaVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = (J.ClassDeclaration) super.visitClassDeclaration(classDecl, ctx);
                if (cd.getExtends() == null || !TypeUtils.isOfClassType(cd.getExtends().getType(), HANDLER_INTERCEPTOR_ADAPTER)) {
                    return cd;
                }

                maybeAddImport(HANDLER_INTERCEPTOR_INTERFACE);
                maybeRemoveImport(HANDLER_INTERCEPTOR_ADAPTER);

                TypeTree implments = TypeTree.build(""HandlerInterceptor"")
                        .withType(JavaType.buildType(HANDLER_INTERCEPTOR_INTERFACE));
                cd = cd.withExtends(null).withImplements(singletonList(implments));
                return autoFormat(cd, implments, ctx, getCursor().getParentOrThrow());
            }

            @Override
            public @Nullable J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (mi.getMethodType() != null &&
                    TypeUtils.isOfClassType(mi.getMethodType().getDeclaringType(), HANDLER_INTERCEPTOR_INTERFACE) &&
                    mi.getSelect() instanceof J.Identifier && ""super"".equals(((J.Identifier) mi.getSelect()).getSimpleName())) {
                    if (PRE_HANDLE.matches(mi)) {
                        // No need to call super for the hardcoded `true` return value there
                        return JavaTemplate.apply(""true"", getCursor(), mi.getCoordinates().replace());
                    }
                    if (POST_HANDLE.matches(mi) || AFTER_COMPLETION.matches(mi)) {
                        return null; // No need to call super for empty methods there
                    }
                }
                return mi;
            }
        });
    }
}
",{}
Migrate `MethodArgumentNotValidException.errorsToStringList` and `resolveErrorMessages`,"`org.springframework.web.bind.MethodArgumentNotValidException.errorsToStringList` and `resolveErrorMessages` method was deprecated, in favor of `BindErrorUtils`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class MigrateMethodArgumentNotValidExceptionErrorMethod extends Recipe {

    private static final String TARGET_CLASS = ""org.springframework.web.bind.MethodArgumentNotValidException"";

    private static final MethodMatcher ERRORS_TO_STRING_LIST = new MethodMatcher(TARGET_CLASS +
            "" errorsToStringList(java.util.List)"");

    private static final MethodMatcher ERRORS_TO_STRING_LIST_WITH_LOCALE = new MethodMatcher(TARGET_CLASS +
            "" errorsToStringList(java.util.List, org.springframework.context.MessageSource, java.util.Locale)"");

    private static final MethodMatcher RESOLVE_ERROR_MESSAGES = new MethodMatcher(TARGET_CLASS +
            "" resolveErrorMessages(org.springframework.context.MessageSource, java.util.Locale)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `MethodArgumentNotValidException.errorsToStringList` and `resolveErrorMessages`"";
    }

    @Override
    public String getDescription() {
        return ""`org.springframework.web.bind.MethodArgumentNotValidException.errorsToStringList` and `resolveErrorMessages` method was deprecated, in favor of `BindErrorUtils`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(TARGET_CLASS + "" *rrors*(..)"", false), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (ERRORS_TO_STRING_LIST.matches(m)) {
                    maybeAddImport(""org.springframework.web.util.BindErrorUtils"");
                    return JavaTemplate.builder(""BindErrorUtils.resolve(#{any()}).values().stream().toList()"")
                            .imports(""org.springframework.web.util.BindErrorUtils"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context-6.+"", ""spring-web-6.+""))
                            .build()
                            .apply(getCursor(), m.getCoordinates().replace(), m.getArguments().get(0));
                }
                if (ERRORS_TO_STRING_LIST_WITH_LOCALE.matches(m)) {
                    maybeAddImport(""org.springframework.web.util.BindErrorUtils"");
                    Expression messageSourceArg = m.getArguments().get(1);
                    if (messageSourceArg instanceof J.Literal) { // null
                        return JavaTemplate.builder(""BindErrorUtils.resolve(#{any()}).values().stream().toList()"")
                                .imports(""org.springframework.web.util.BindErrorUtils"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context-6.+"", ""spring-web-6.+""))
                                .build()
                                .apply(getCursor(), m.getCoordinates().replace(), m.getArguments().get(0));
                    }
                    return JavaTemplate.builder(""BindErrorUtils.resolve(#{any()}, #{any(org.springframework.context.MessageSource)}, #{any()}).values().stream().toList()"")
                            .imports(""org.springframework.web.util.BindErrorUtils"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context-6.+"", ""spring-web-6.+""))
                            .build()
                            .apply(getCursor(), m.getCoordinates().replace(), m.getArguments().get(0), messageSourceArg, m.getArguments().get(2));
                }
                if (RESOLVE_ERROR_MESSAGES.matches(m)) {
                    maybeAddImport(""org.springframework.web.util.BindErrorUtils"");
                    return JavaTemplate.builder(""BindErrorUtils.resolve(#{any()}.getAllErrors(), #{any()}, #{any()})"")
                            .imports(""org.springframework.web.util.BindErrorUtils"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context-6.+"", ""spring-web-6.+""))
                            .build()
                            .apply(getCursor(), m.getCoordinates().replace(), m.getSelect(), m.getArguments().get(0), m.getArguments().get(1));
                }
                return m;
            }
        });
    }
}
",{}
Migrate `UriComponentsBuilder.fromHttpRequest` and `parseForwardedFor`,"The `fromHttpRequest` and `parseForwardedFor` methods in `org.springframework.web.util.UriComponentsBuilder` were deprecated, in favor of `org.springframework.web.util.ForwardedHeaderUtils`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class MigrateUriComponentsBuilderMethods extends Recipe {

    private static final String TARGET_CLASS = ""org.springframework.web.util.UriComponentsBuilder"";

    private static final MethodMatcher FROM_HTTP_REQUEST = new MethodMatcher(TARGET_CLASS + "" fromHttpRequest(org.springframework.http.HttpRequest)"");

    private static final MethodMatcher PARSE_FORWARDED_FOR = new MethodMatcher(TARGET_CLASS + "" parseForwardedFor(org.springframework.http.HttpRequest, java.net.InetSocketAddress)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `UriComponentsBuilder.fromHttpRequest` and `parseForwardedFor`"";
    }

    @Override
    public String getDescription() {
        return ""The `fromHttpRequest` and `parseForwardedFor` methods in `org.springframework.web.util.UriComponentsBuilder` were deprecated, in favor of `org.springframework.web.util.ForwardedHeaderUtils`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(TARGET_CLASS + "" *(..)"", false), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (FROM_HTTP_REQUEST.matches(mi)) {
                    maybeAddImport(""org.springframework.web.util.ForwardedHeaderUtils"");
                    maybeRemoveImport(""org.springframework.web.util.UriComponentsBuilder"");
                    return JavaTemplate.builder(""ForwardedHeaderUtils.adaptFromForwardedHeaders(#{any()}.getURI(), #{any()}.getHeaders())"")
                        .imports(""org.springframework.web.util.ForwardedHeaderUtils"")
                        .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-web-6.+""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), mi.getArguments().get(0), mi.getArguments().get(0));
                }
                if (PARSE_FORWARDED_FOR.matches(mi)) {
                    maybeAddImport(""org.springframework.web.util.ForwardedHeaderUtils"");
                    maybeRemoveImport(""org.springframework.web.util.UriComponentsBuilder"");
                    return JavaTemplate.builder(""ForwardedHeaderUtils.parseForwardedFor(#{any()}.getURI(), #{any()}.getHeaders(), #{any()})"")
                        .imports(""org.springframework.web.util.ForwardedHeaderUtils"")
                        .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-web-6.+""))
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), mi.getArguments().get(0), mi.getArguments().get(0), mi.getArguments().get(1));
                }
                return mi;
            }
        });
    }
}
",{}
Convert `InstantiationAwareBeanPostProcessorAdapter` to `SmartInstantiationAwareBeanPostProcessor`,As of Spring-Framework 5.3 `InstantiationAwareBeanPostProcessorAdapter` is deprecated in favor of the existing default methods in `SmartInstantiationAwareBeanPostProcessor`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.Markers;

import static java.util.Collections.emptyList;

public class MigrateInstantiationAwareBeanPostProcessorAdapter extends Recipe {
    private final String fromExtendingFqn = ""org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter"";
    private final String toImplementsFqn = ""org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor"";

    @Override
    public String getDisplayName() {
        return ""Convert `InstantiationAwareBeanPostProcessorAdapter` to `SmartInstantiationAwareBeanPostProcessor`"";
    }

    @Override
    public String getDescription() {
        return ""As of Spring-Framework 5.3 `InstantiationAwareBeanPostProcessorAdapter` is deprecated in favor of the existing default methods in `SmartInstantiationAwareBeanPostProcessor`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(fromExtendingFqn, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (cd.getExtends() != null && TypeUtils.isOfClassType(cd.getExtends().getType(), fromExtendingFqn)) {
                    cd = cd.withExtends(null);
                    J.Identifier ident = new J.Identifier(Tree.randomId(), Space.format("" ""), Markers.EMPTY, emptyList(),
                            ""SmartInstantiationAwareBeanPostProcessor"", JavaType.buildType(toImplementsFqn), null);
                    J.Block body = cd.getBody();
                    cd = maybeAutoFormat(cd, cd.withBody(cd.getBody().withStatements(emptyList())).withImplements(ListUtils.concat(cd.getImplements(), ident)), ctx, getCursor().getParentOrThrow());
                    cd = cd.withBody(body);
                }
                return cd;
            }

            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                J.CompilationUnit compilationUnit = super.visitCompilationUnit(cu, ctx);
                doAfterVisit(new ChangeType(fromExtendingFqn, toImplementsFqn, false).getVisitor());
                return compilationUnit;
            }
        });
    }
}
",{}
Migrate `ResponseStatusException#getRawStatusCode()` to `getStatusCode().value()`,Migrate Spring Framework 5.3's `ResponseStatusException` method `getRawStatusCode()` to Spring Framework 6's `getStatusCode().value()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.trait.MethodAccess;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.MethodCall;

public class MigrateResponseStatusExceptionGetRawStatusCodeMethod extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate `ResponseStatusException#getRawStatusCode()` to `getStatusCode().value()`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate Spring Framework 5.3's `ResponseStatusException` method `getRawStatusCode()` to Spring Framework 6's `getStatusCode().value()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MethodAccess.Matcher(""org.springframework.web.server.ResponseStatusException getRawStatusCode()"")
                .asVisitor((mc, ctx) -> {
                    MethodCall tree = mc.getTree();
                    if (tree instanceof J.MethodInvocation) {
                        return JavaTemplate.builder(""#{any()}.getStatusCode().value()"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-core-6"", ""spring-beans-6"", ""spring-web-6""))
                                .build().apply(mc.getCursor(), tree.getCoordinates().replace(), ((J.MethodInvocation) tree).getSelect());
                    }
                    return tree;
                });
    }
}
",{}
Migrate `ResponseStatusException#getStatus()` to `getStatusCode()`,Migrate Spring Framework 5.3's `ResponseStatusException` method `getStatus()` to Spring Framework 6's `getStatusCode()`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;

public class MigrateResponseStatusExceptionGetStatusCodeMethod extends Recipe {
    private static final MethodMatcher GET_STATUS_METHOD_MATCHER = new MethodMatcher(
            ""org.springframework.web.server.ResponseStatusException getStatus()""
    );
    private static final String HTTP_STATUS_CODE_CLASS = ""HttpStatusCode"";
    private static final String FULL_HTTP_STATUS_CLASS = ""org.springframework.http.HttpStatus"";
    private static final String FULL_HTTP_STATUS_CODE_CLASS = ""org.springframework.http.HttpStatusCode"";

    @Override
    public String getDisplayName() {
        return ""Migrate `ResponseStatusException#getStatus()` to `getStatusCode()`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate Spring Framework 5.3's `ResponseStatusException` method `getStatus()` to Spring Framework 6's `getStatusCode()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(GET_STATUS_METHOD_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (GET_STATUS_METHOD_MATCHER.matches(mi)) {
                    return JavaTemplate.builder(""#{any()}.getStatusCode()"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-core-6"", ""spring-beans-6"", ""spring-web-6""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), mi.getSelect());
                }
                return mi;
            }

            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                J.VariableDeclarations vd = super.visitVariableDeclarations(multiVariable, ctx);
                if (vd.getTypeExpression() != null && TypeUtils.isOfClassType(vd.getTypeExpression().getType(), FULL_HTTP_STATUS_CLASS)) {
                    JavaType.ShallowClass httpStatusCodeJavaType = JavaType.ShallowClass.build(FULL_HTTP_STATUS_CODE_CLASS);
                    vd = vd
                            .withTypeExpression(TypeTree.build(HTTP_STATUS_CODE_CLASS).withType(httpStatusCodeJavaType))
                            .withVariables(ListUtils.map(vd.getVariables(), variable -> {
                                        if (variable.getVariableType() != null && TypeUtils.isAssignableTo(FULL_HTTP_STATUS_CLASS, variable.getType())) {
                                            return variable
                                                    .withVariableType(variable.getVariableType().withType(httpStatusCodeJavaType))
                                                    .withName(variable.getName().withType(httpStatusCodeJavaType).withFieldType(variable.getName().getFieldType().withType(httpStatusCodeJavaType)));
                                        }
                                        return variable;
                                    })
                            );
                    maybeAddImport(FULL_HTTP_STATUS_CODE_CLASS);
                    maybeRemoveImport(FULL_HTTP_STATUS_CLASS);
                }
                return vd;
            }
        });
    }
}
",{}
Migrate `setReadTimeout(java.lang.int)` to SocketConfig `setSoTimeout(..)`,`setReadTimeout(..)` was removed in Spring Framework 6.1.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public class HttpComponentsClientHttpRequestFactoryReadTimeout extends Recipe {
    private static final MethodMatcher SET_READ_TIMEOUT_METHOD_MATCHER = new MethodMatcher(""org.springframework.http.client.HttpComponentsClientHttpRequestFactory setReadTimeout(..)"");
    private static final String POOLING_CONNECTION_MANAGER = ""org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager"";

    // Known case we do not handle yet
    private static final MethodMatcher SET_DEFAULT_SOCKET_CONFIG = new MethodMatcher(POOLING_CONNECTION_MANAGER + "" setDefaultSocketConfig(org.apache.hc.core5.http.io.SocketConfig)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `setReadTimeout(java.lang.int)` to SocketConfig `setSoTimeout(..)`"";
    }

    @Override
    public String getDescription() {
        return ""`setReadTimeout(..)` was removed in Spring Framework 6.1."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(SET_READ_TIMEOUT_METHOD_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit compilationUnit, ExecutionContext ctx) {
                // Extract the argument to `setReadTimeout`
                AtomicReference<Expression> readTimeout = new AtomicReference<>();
                AtomicBoolean incompatibilityFound = new AtomicBoolean(false);
                J.CompilationUnit cuWithComment = (J.CompilationUnit) new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        if (SET_READ_TIMEOUT_METHOD_MATCHER.matches(method)) {
                            Expression expression = method.getArguments().get(0);
                            if (expression instanceof J.Literal || expression instanceof J.FieldAccess) {
                                readTimeout.set(expression);
                            }

                            String message = "" Manual migration to `SocketConfig.Builder.setSoTimeout(Timeout)` necessary; see: "" +
                                             ""https://docs.spring.io/spring-framework/docs/6.0.0/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html#setReadTimeout(int)"";
                            if (method.getComments().stream().noneMatch(c -> c.printComment(getCursor()).contains(message))) {
                                return method.withPrefix(method.getPrefix().withComments(ListUtils.concat(method.getComments(),
                                        new TextComment(false, message, ""\n"" + method.getPrefix().getIndent(), Markers.EMPTY)
                                )));
                            }
                        } else if (SET_DEFAULT_SOCKET_CONFIG.matches(method)) {
                            incompatibilityFound.set(true);
                        }
                        return super.visitMethodInvocation(method, ctx);
                    }
                }.visitNonNull(compilationUnit, ctx);

                //noinspection ConstantValue
                if (readTimeout.get() == null || incompatibilityFound.get()) {
                    return cuWithComment;
                }

                // Attempt to use expression in replacement
                J.CompilationUnit cu = (J.CompilationUnit) new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                        for (Statement statement : block.getStatements()) {
                            if (statement instanceof J.VariableDeclarations &&
                                TypeUtils.isAssignableTo(POOLING_CONNECTION_MANAGER,
                                        ((J.VariableDeclarations) statement).getTypeAsFullyQualified())) {
                                J.VariableDeclarations varDecl = (J.VariableDeclarations) statement;
                                maybeAddImport(""org.apache.hc.core5.http.io.SocketConfig"");
                                maybeAddImport(""java.util.concurrent.TimeUnit"");
                                return JavaTemplate.builder(""#{any()}.setDefaultSocketConfig(SocketConfig.custom().setSoTimeout(#{any()}, TimeUnit.MILLISECONDS).build());"")
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""httpcore5"", ""httpclient5""))
                                        .imports(""java.util.concurrent.TimeUnit"", ""org.apache.hc.core5.http.io.SocketConfig"")
                                        .build().apply(getCursor(), varDecl.getCoordinates().after(),
                                                varDecl.getVariables().get(0).getName().withPrefix(Space.EMPTY),
                                                readTimeout.get());
                            }
                        }
                        return super.visitBlock(block, ctx);
                    }
                }.visitNonNull(compilationUnit, ctx);

                if (cu != compilationUnit) {
                    // Clear out the `setReadTimeout` method invocation
                    return super.visitCompilationUnit(cu, ctx);
                }

                // No replacement time out could be set; make no change at all to prevent time out being lost
                return cuWithComment;
            }

            @Override
            public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (SET_READ_TIMEOUT_METHOD_MATCHER.matches(method)) {
                    //noinspection DataFlowIssue
                    return null;
                }
                return super.visitMethodInvocation(method, ctx);
            }
        });
    }
}
",{}
Migrate `HandlerResult.hasExceptionHandler()` to `getExceptionHandler()`,"`org.springframework.web.reactive.HandlerResult.hasExceptionHandler()` was deprecated, in favor of `getExceptionHandler()`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class MigrateHandlerResultHasExceptionHandlerMethod extends Recipe {

    private static final MethodMatcher METHOD_MATCHER = new MethodMatcher(""org.springframework.web.reactive.HandlerResult hasExceptionHandler()"");

    @Override
    public String getDisplayName() {
        return ""Migrate `HandlerResult.hasExceptionHandler()` to `getExceptionHandler()`"";
    }

    @Override
    public String getDescription() {
        return ""`org.springframework.web.reactive.HandlerResult.hasExceptionHandler()` was deprecated, in favor of `getExceptionHandler()`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(METHOD_MATCHER), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (METHOD_MATCHER.matches(mi)) {
                    return JavaTemplate
                            .builder(""#{any(org.springframework.web.reactive.HandlerResult)}.getExceptionHandler() != null"")
                            .build().apply(getCursor(), mi.getCoordinates().replace(), mi.getSelect());
                }
                return mi;
            }
        });
    }
}
",{}
Use `Environment#acceptsProfiles(Profiles)`,`Environment#acceptsProfiles(String...)` was deprecated in Spring Framework 5.1.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.framework;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

import static java.util.stream.Collectors.joining;

public class EnvironmentAcceptsProfiles extends Recipe {
    private static final MethodMatcher MATCHER = new MethodMatcher(""org.springframework.core.env.Environment acceptsProfiles(java.lang.String...)"");

    @Override
    public String getDisplayName() {
        return ""Use `Environment#acceptsProfiles(Profiles)`"";
    }

    @Override
    public String getDescription() {
        return ""`Environment#acceptsProfiles(String...)` was deprecated in Spring Framework 5.1."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(MATCHER), new EnvironmentAcceptsProfilesVisitor());
    }

    private static class EnvironmentAcceptsProfilesVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (MATCHER.matches(method)) {
                maybeAddImport(""org.springframework.core.env.Profiles"");
                String template = ""Profiles.of("" + method.getArguments().stream().map(a -> ""#{any(java.lang.String)}"").collect(joining("","")) + "")"";
                method = JavaTemplate.builder(template)
                    .imports(""org.springframework.core.env.Profiles"", ""org.springframework.core.env.Environment"")
                    .javaParser(JavaParser.fromJavaVersion()
                        .classpathFromResources(ctx, ""spring-core-5.*""))
                    .build()
                    .apply(
                        getCursor(),
                        method.getCoordinates().replaceArguments(),
                        method.getArguments().toArray()
                    );
            }
            return super.visitMethodInvocation(method, ctx);
        }
    }
}
",{}
Use TLS for AMQP connection strings,Use TLS for AMQP connection strings.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.amqp;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.java.spring.AddSpringProperty;
import org.openrewrite.java.spring.ChangeSpringPropertyValue;
import org.openrewrite.java.spring.SpringExecutionContextView;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.properties.PropertiesIsoVisitor;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.JsonPathMatcher;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.util.List;

@EqualsAndHashCode(callSuper = false)
@Value
public class UseTlsAmqpConnectionString extends Recipe {
    private static final String PREFIX_AMQP = ""amqp"";
    private static final String PREFIX_AMQP_SECURE = ""amqps"";

    @Option(displayName = ""Property key"",
            description = ""The Spring property key to perform updates against. "" +
                    ""If this value is specified, the specified property will be used for searching, otherwise a default of `spring.rabbitmq.addresses` "" +
                    ""will be used instead."",
            example = ""spring.rabbitmq.addresses"",
            required = false)
    @Nullable
    String propertyKey;

    @Option(displayName = ""Old Port"",
            description = ""The non-TLS enabled port number to replace with the TLS-enabled port. "" +
                    ""If this value is specified, no changes will be made to amqp connection strings which do not contain this port number. "",
            example = ""1234"")
    @Nullable
    Integer oldPort;

    @Option(displayName = ""TLS Port"",
            description = ""The TLS-enabled port to use."",
            example = ""1234"")
    @Nullable
    Integer port;

    @Option(displayName = ""TLS Property Key"",
            description = ""The Spring property key to enable default TLS mode against. "" +
                    ""If this value is specified, the specified property will be used when updating the default TLS mode, otherwise a default of "" +
                    ""`spring.rabbitmq.ssl.enabled` will be used instead."",
            example = ""spring.rabbitmq.ssl.enabled"",
            required = false)
    @Nullable
    String tlsPropertyKey;

    @Option(displayName = ""Optional list of file path matcher"",
            description = ""Each value in this list represents a glob expression that is used to match which files will "" +
                    ""be modified. If this value is not present, this recipe will query the execution context for "" +
                    ""reasonable defaults. (\""**/application.yml\"", \""**/application.yaml\"", and \""**/application.properties\""."",
            example = ""**/application.yml"",
            required = false)
    @Nullable
    List<String> pathExpressions;

    @Override
    public String getDisplayName() {
        return ""Use TLS for AMQP connection strings"";
    }

    @Override
    public String getDescription() {
        return ""Use TLS for AMQP connection strings."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        String actualPropertyKey = propertyKey == null || propertyKey.isEmpty() ? ""spring.rabbitmq.addresses"" : propertyKey;
        String actualTlsPropertyKey = tlsPropertyKey == null || tlsPropertyKey.isEmpty() ? ""spring.rabbitmq.ssl.enabled"" : tlsPropertyKey;
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof Yaml.Documents || sourceFile instanceof Properties.File;
            }

            @Override
            public Tree visit(@Nullable Tree t, ExecutionContext ctx) {
                if (t instanceof Yaml.Documents && sourcePathMatches(((SourceFile) t).getSourcePath(), ctx)) {
                    t = new UseTlsAmqpConnectionStringYaml(actualPropertyKey, oldPort, port, actualTlsPropertyKey, pathExpressions)
                        .getVisitor().visit(t, ctx);
                } else if (t instanceof Properties.File && sourcePathMatches(((SourceFile) t).getSourcePath(), ctx)) {
                    t = new UseTlsAmqpConnectionStringProperties(actualPropertyKey, oldPort, port, actualTlsPropertyKey, pathExpressions)
                        .getVisitor().visit(t, ctx);
                }
                return t;
            }

            private boolean sourcePathMatches(Path sourcePath, ExecutionContext ctx) {
                List<String> expressions = pathExpressions;
                if (expressions == null || pathExpressions.isEmpty()) {
                    //If not defined, get reasonable defaults from the execution context.
                    expressions = SpringExecutionContextView.view(ctx).getDefaultApplicationConfigurationPaths();
                }
                if (expressions.isEmpty()) {
                    return true;
                }
                for (String filePattern : expressions) {
                    if (PathUtils.matchesGlob(sourcePath, filePattern)) {
                        return true;
                    }
                }

                return false;
            }
        };
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class UseTlsAmqpConnectionStringYaml extends Recipe {
        String propertyKey;

        @Nullable
        Integer oldPort;

        @Nullable
        Integer port;

        String tlsPropertyKey;

        @Nullable
        List<String> pathExpressions;

        @Override
        public String getDisplayName() {
            return ""Use TLS for AMQP connection strings"";
        }

        @Override
        public String getDescription() {
            return ""Use TLS for AMQP connection strings."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Preconditions.check(new YamlVisitor<ExecutionContext>() {
                @Override
                public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                    if (!FindProperty.find(documents, propertyKey, true).isEmpty()) {
                        return SearchResult.found(documents);
                    }
                    return documents;
                }
            }, new YamlIsoVisitor<ExecutionContext>() {
                final JsonPathMatcher amqpUrl = new JsonPathMatcher(""$."" + propertyKey);

                @Override
                public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                    Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);

                    if (amqpUrl.matches(getCursor())) {
                        String[] connectionStrings = ((Yaml.Scalar) e.getValue()).getValue().split("","");
                        try {
                            boolean skip = false;
                            boolean updated = false;
                            for (int i = 0; i < connectionStrings.length; i++) {
                                String connectionString = connectionStrings[i];
                                if (connectionString.startsWith(PREFIX_AMQP + ""://"") || connectionString.startsWith(PREFIX_AMQP_SECURE + ""://"")) {
                                    // amqp(s)://hostname:port(/virtualhost)
                                    URI amqpUrl = URI.create(connectionString);
                                    if (oldPort != null && !amqpUrl.getSchemeSpecificPart().contains("":"" + oldPort)) {
                                        skip = true;
                                        continue;
                                    }
                                    URI updatedAmqpUrl = maybeUpdateAmqpConnectionUri(amqpUrl, port);
                                    if (updatedAmqpUrl != amqpUrl) {
                                        updated = true;
                                        connectionStrings[i] = updatedAmqpUrl.toString();
                                        doAfterVisit(new ChangeSpringPropertyValue(tlsPropertyKey, ""true"", ""false"", null, null)
                                            .getVisitor());
                                    }
                                } else {
                                    // hostname:port(/virtualhost)
                                    String[] parts = connectionString.split("":"");
                                    if (parts.length == 2 && oldPort != null && !parts[1].split(""/"")[0].equals(oldPort.toString())) {
                                        skip = true;
                                        continue;
                                    }
                                    String updatedConnectionString = maybeUpdateAmqpConnectionString(connectionString, port);
                                    if (!updatedConnectionString.equals(connectionString)) {
                                        updated = true;
                                        connectionStrings[i] = updatedConnectionString;
                                        doAfterVisit(new AddSpringProperty(tlsPropertyKey, ""true"", null, pathExpressions)
                                            .getVisitor());
                                        doAfterVisit(new ChangeSpringPropertyValue(tlsPropertyKey, ""true"", null, null, null)
                                            .getVisitor());
                                    }
                                }
                            }

                            if (skip && !updated) {
                                return e;
                            }

                            if (updated) {
                                e = e.withValue(((Yaml.Scalar) e.getValue()).withValue(join(connectionStrings, "","")));
                            }
                        } catch (URISyntaxException | IllegalArgumentException ignored) {
                            // do nothing
                        }
                    }
                    return e;
                }
            });
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class UseTlsAmqpConnectionStringProperties extends Recipe {
        String propertyKey;

        @Nullable
        Integer oldPort;

        @Nullable
        Integer port;

        String tlsPropertyKey;

        @Nullable
        List<String> pathExpressions;

        @Override
        public String getDisplayName() {
            return ""Use TLS for AMQP connection strings"";
        }

        @Override
        public String getDescription() {
            return ""Use TLS for AMQP connection strings."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Preconditions.check(new PropertiesVisitor<ExecutionContext>() {
                @Override
                public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                    if (!FindProperties.find(file, propertyKey, true).isEmpty()) {
                        return SearchResult.found(file);
                    }
                    return file;
                }
            }, new PropertiesIsoVisitor<ExecutionContext>() {
                @Override
                public Properties.Entry visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                    Properties.Entry e = super.visitEntry(entry, ctx);

                    if (NameCaseConvention.equalsRelaxedBinding(entry.getKey(), propertyKey)) {
                        String[] connectionStrings = entry.getValue().getText().split("","");
                        try {
                            boolean skip = false;
                            boolean updated = false;
                            for (int i = 0; i < connectionStrings.length; i++) {
                                String connectionString = connectionStrings[i];
                                if (connectionString.startsWith(PREFIX_AMQP + ""://"") || connectionString.startsWith(PREFIX_AMQP_SECURE + ""://"")) {
                                    // amqp(s)://hostname:port(/virtualhost)
                                    URI amqpUrl = URI.create(connectionStrings[i]);
                                    if (oldPort != null && !amqpUrl.getSchemeSpecificPart().contains("":"" + oldPort)) {
                                        skip = true;
                                        continue;
                                    }
                                    URI updatedAmqpUrl = maybeUpdateAmqpConnectionUri(amqpUrl, port);
                                    if (updatedAmqpUrl != amqpUrl) {
                                        updated = true;
                                        connectionStrings[i] = updatedAmqpUrl.toString();
                                        doAfterVisit(new ChangeSpringPropertyValue(tlsPropertyKey, ""true"", ""false"", null, null)
                                            .getVisitor());
                                    }
                                } else {
                                    // hostname:port(/virtualhost)
                                    String[] parts = connectionString.split("":"");
                                    if (parts.length == 2 && oldPort != null && !parts[1].split(""/"")[0].equals(oldPort.toString())) {
                                        skip = true;
                                        continue;
                                    }
                                    String updatedConnectionString = maybeUpdateAmqpConnectionString(connectionString, port);
                                    if (!updatedConnectionString.equals(connectionString)) {
                                        updated = true;
                                        connectionStrings[i] = updatedConnectionString;
                                        doAfterVisit(new AddSpringProperty(tlsPropertyKey, ""true"", null, pathExpressions)
                                            .getVisitor());
                                        doAfterVisit(new ChangeSpringPropertyValue(tlsPropertyKey, ""true"", null, null, null)
                                            .getVisitor());
                                    }
                                }
                            }

                            if (skip && !updated) {
                                return e;
                            }

                            if (updated) {
                                e = e.withValue(e.getValue().withText(join(connectionStrings, "","")));
                            }
                        } catch (URISyntaxException | IllegalArgumentException ignored) {
                            // do nothing
                        }
                    }
                    return e;
                }
            });
        }
    }

    private static URI maybeUpdateAmqpConnectionUri(URI amqpUrl, @Nullable Integer port) throws URISyntaxException {
        URI updatedAmqpUrl = amqpUrl;
        if (port != null && !amqpUrl.getSchemeSpecificPart().contains("":"" + port)) {
            updatedAmqpUrl = new URI(amqpUrl.getScheme(), amqpUrl.getSchemeSpecificPart()
                    .replaceFirst("":\\d+"", "":"" + port), amqpUrl.getFragment());
        }
        if (PREFIX_AMQP.equals(amqpUrl.getScheme())) {
            updatedAmqpUrl = new URI(PREFIX_AMQP_SECURE, updatedAmqpUrl.getSchemeSpecificPart(), amqpUrl.getFragment());
        }
        return updatedAmqpUrl;
    }

    private static String maybeUpdateAmqpConnectionString(String amqpUrl, @Nullable Integer port) {
        String updatedAmqpUrl = amqpUrl;
        if (port != null && !amqpUrl.contains("":"" + port)) {
            updatedAmqpUrl = updatedAmqpUrl.replaceFirst("":\\d+"", "":"" + port);
        }
        return updatedAmqpUrl;
    }

    private static String join(String[] strings, String separator) {
        if (strings.length == 0) {
            return """";
        }

        StringBuilder builder = new StringBuilder();
        int idx = 0;
        while (idx < strings.length - 1) {
            builder.append(strings[idx++]).append(separator);
        }
        return builder.append(strings[idx]).toString();
    }
}
",{}
Remove calls matching `AuthenticationEntryPointFailureHandler.setRethrowAuthenticationServiceException(true)`,Remove any calls matching `AuthenticationEntryPointFailureHandler.setRethrowAuthenticationServiceException(true)`. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.Objects;

public class PropagateAuthenticationServiceExceptions extends Recipe {

    private static final MethodMatcher MATCHER = new MethodMatcher(""org.springframework.security.web.authentication.AuthenticationEntryPointFailureHandler setRethrowAuthenticationServiceException(boolean)"");

    @Override
    public String getDisplayName() {
        return ""Remove calls matching `AuthenticationEntryPointFailureHandler.setRethrowAuthenticationServiceException(true)`"";
    }

    @Override
    public String getDescription() {
        return ""Remove any calls matching `AuthenticationEntryPointFailureHandler.setRethrowAuthenticationServiceException(true)`. "" +
               ""See the corresponding [Sprint Security 6.0 migration step](https://docs.spring.io/spring-security/reference/6.0.0/migration/servlet/authentication.html#_propagate_authenticationserviceexceptions) for details."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.security.web.authentication.AuthenticationEntryPointFailureHandler"", true), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                method = super.visitMethodInvocation(method, ctx);
                if (method.getSelect() != null && method.getArguments().size() == 1 && MATCHER.matches(method)) {
                    Expression arg0 = method.getArguments().get(0);
                    if (arg0 instanceof J.Literal && Objects.equals(((J.Literal) arg0).getValue(), Boolean.TRUE)) {
                        //noinspection DataFlowIssue
                        return null;
                    }
                }
                return method;
            }
        });
    }
}
",{}
Remove unneeded `oauth2Login` config when upgrading to Spring Security 6,,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.RemoveMethodInvocationsVisitor;
import org.openrewrite.java.search.UsesMethod;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

public class RemoveOauth2LoginConfig extends Recipe {
    private static final MethodMatcher O_AUTH_2_LOGIN_MATCHER = new MethodMatcher(
            ""org.springframework.security.config.annotation.web.builders.HttpSecurity oauth2Login()""
    );

    @Override
    public String getDisplayName() {
        return ""Remove unneeded `oauth2Login` config when upgrading to Spring Security 6"";
    }

    @Override
    public String getDescription() {
        //language=markdown
        return ""`oauth2Login()` is a Spring Security feature that allows users to authenticate with an OAuth2 or OpenID "" +
                ""Connect 1.0 provider. When a user is authenticated using this feature, they are granted a set of "" +
                ""authorities that determines what actions they are allowed to perform within the application.\n"" +
                ""\n"" +
                ""In Spring Security 5, the default authority given to a user authenticated with an OAuth2 or OpenID "" +
                ""Connect 1.0 provider via `oauth2Login()` is `ROLE_USER`. This means that the user is allowed to access "" +
                ""the application's resources as a regular user.\n"" +
                ""\n"" +
                ""However, in Spring Security 6, the default authority given to a user authenticated with an OAuth2 "" +
                ""provider is `OAUTH2_USER`, and the default authority given to a user authenticated with an OpenID "" +
                ""Connect 1.0 provider is `OIDC_USER`. These authorities are more specific and allow for better "" +
                ""customization of the user's permissions within the application.\n"" +
                ""\n"" +
                ""If you are upgrading to Spring Security 6 and you have previously configured a "" +
                ""`GrantedAuthoritiesMapper` to handle the authorities of users authenticated via `oauth2Login()`, you can "" +
                ""remove it completely as the new default authorities should be sufficient."";
    }

    @Override
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(8);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        List<String> methods = new ArrayList<>();
        methods.add(""org.springframework.security.config.annotation.web.builders.HttpSecurity oauth2Login()"");
        methods.add(""org.springframework.security.config.annotation.web.configurers.oauth2.client.OAuth2LoginConfigurer userInfoEndpoint()"");
        methods.add(""org.springframework.security.config.annotation.web.configurers.oauth2.client.OAuth2LoginConfigurer$UserInfoEndpointConfig userAuthoritiesMapper(org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper)"");
        return Preconditions.check(new UsesMethod<>(O_AUTH_2_LOGIN_MATCHER), new RemoveMethodInvocationsVisitor(methods));
    }
}
",{}
Keep the default RequestCache querying behavior in Spring Security 5,"By default, Spring Security 5 queries the saved request on every request, which means that in a ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

import static java.util.Collections.singletonList;

public class UpdateRequestCache extends Recipe {

    private static final MethodMatcher CONTINUE_PARAMETER_MATCHER = new MethodMatcher(
            ""org.springframework.security.web.savedrequest.HttpSessionRequestCache setMatchingRequestParameterName(java.lang.String)""
    );

    private static final MethodMatcher REQUEST_CACHE_MATCHER = new MethodMatcher(
            ""org.springframework.security.config.annotation.web.configurers.RequestCacheConfigurer requestCache(org.springframework.security.web.savedrequest.RequestCache)""
    );

    @Override
    public String getDisplayName() {
        return ""Keep the default RequestCache querying behavior in Spring Security 5"";
    }

    @Override
    public String getDescription() {
        return ""By default, Spring Security 5 queries the saved request on every request, which means that in a "" +
                ""typical setup, the HttpSession is queried on every request to use the RequestCache. In Spring "" +
                ""Security 6, the default behavior has changed, and RequestCache will only be queried for a cached "" +
                ""request if the HTTP parameter \""continue\"" is defined. To maintain the same default behavior as "" +
                ""Spring Security 5, either explicitly add the HTTP parameter \""continue\"" to every request or use "" +
                ""NullRequestCache to override the default behavior."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(REQUEST_CACHE_MATCHER), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                block = super.visitBlock(block, ctx);
                List<Statement> statements = block.getStatements();

                boolean hasContinueParameterStatement = findContinueParameterStatement(statements);
                if (hasContinueParameterStatement) {
                    return block;
                }

                for (int i = 0; i < statements.size(); i++) {
                    Statement statement = statements.get(i);
                    if (isNewHttpSessionRequestCacheStatement(statement)) {
                        statement = JavaTemplate.builder(""#{any()}.setMatchingRequestParameterName(\""continue\"");"")
                            .contextSensitive()
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-security-web-6""))
                            .imports(
                                ""org.springframework.security.web.savedrequest.HttpSessionRequestCache"")
                            .build()
                            .apply(
                                new Cursor(getCursor(), statement),
                                statement.getCoordinates().replace(),
                                getSelect(statement)
                            );
                        statements = ListUtils.insert(statements, statement, i + 1);

                        return block.withStatements(statements);
                    }
                }
                return block;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method,
                                                            ExecutionContext ctx) {
                if (REQUEST_CACHE_MATCHER.matches(method)) {
                    Expression arg = method.getArguments().get(0);
                    if (isNewHttpSessionRequestCacheExpression(arg)) {
                        JavaTemplate template = JavaTemplate.builder(""new NullRequestCache()"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""spring-security-web-6""))
                                .imports(
                                        ""org.springframework.security.web.savedrequest.NullRequestCache"")
                                .build();
                        maybeAddImport(""org.springframework.security.web.savedrequest.NullRequestCache"");
                        maybeRemoveImport(""org.springframework.security.web.savedrequest.HttpSessionRequestCache"");
                        arg = template.apply(
                            new Cursor(getCursor(), arg),
                            arg.getCoordinates().replace());
                        return method.withArguments(singletonList(arg));
                    }

                    return method;
                }

                return super.visitMethodInvocation(method, ctx);
            }
        });
    }

    private static J.Identifier getSelect(Statement statement) {
        return ((J.VariableDeclarations) statement).getVariables().get(0).getName();
    }

    private static boolean isNewHttpSessionRequestCacheStatement(Statement statement) {
        if (statement instanceof J.VariableDeclarations) {
            J.VariableDeclarations mv = (J.VariableDeclarations) statement;
            if (mv.getVariables().size() == 1) {
                J.VariableDeclarations.NamedVariable v = mv.getVariables().get(0);
                return TypeUtils.isOfClassType(v.getType(),
                        ""org.springframework.security.web.savedrequest.HttpSessionRequestCache"") &&
                        v.getInitializer() != null && isNewHttpSessionRequestCacheExpression(v.getInitializer());
            }
        }
        return false;
    }

    private static boolean isContinueParameterStatement(Statement statement) {
        if (statement instanceof J.MethodInvocation) {
            J.MethodInvocation m = (J.MethodInvocation) statement;

            if (CONTINUE_PARAMETER_MATCHER.matches(m)) {
                if (m.getArguments().get(0) instanceof J.Literal) {
                    return ""continue"".equals(((J.Literal) m.getArguments().get(0)).getValue());
                }
            }
        }
        return false;
    }

    private static boolean findContinueParameterStatement(List<Statement> statements) {
        return statements.stream().anyMatch(UpdateRequestCache::isContinueParameterStatement);
    }

    private static boolean isNewHttpSessionRequestCacheExpression(Expression expression) {
        if (!(expression instanceof J.NewClass)) {
            return false;
        }
        J.NewClass newClass = (J.NewClass) expression;

        if (TypeUtils.isOfClassType(newClass.getConstructorType().getReturnType(),
                ""org.springframework.security.web.savedrequest.HttpSessionRequestCache"")) {
            return true;
        }
        return false;
    }
}
",{}
Convert `HttpSecurity::apply` chained calls into `HttpSecurity::with` Lambda DSL,Converts `HttpSecurity::apply` chained call from Spring Security pre 6.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.boot2.ConvertToSecurityDslVisitor;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.singletonList;

public class ApplyToWithLambdaDsl extends Recipe {

    private static final String FQN_ABSTRACT_CONFIGURED_SECURITY_BUILDER =
            ""org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder"";

    private static final Collection<String> APPLICABLE_METHOD_NAMES = singletonList(""apply"");

    private static final Map<String, String> ARG_REPLACEMENTS = new HashMap<String, String>() {{
        put(""apply"", null);
    }};

    private static final Map<String, String> METHOD_RENAMES = new HashMap<String, String>() {{
        put(""apply"", ""with"");
    }};

    @Override
    public String getDisplayName() {
        return ""Convert `HttpSecurity::apply` chained calls into `HttpSecurity::with` Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `HttpSecurity::apply` chained call from Spring Security pre 6.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
          new UsesType<>(FQN_ABSTRACT_CONFIGURED_SECURITY_BUILDER, true),
          new ConvertToSecurityDslVisitor<>(FQN_ABSTRACT_CONFIGURED_SECURITY_BUILDER,
                  APPLICABLE_METHOD_NAMES, ARG_REPLACEMENTS, METHOD_RENAMES)
        );
    }
}
",{}
Remove unnecessary `filterSecurityInterceptorOncePerRequest(false)` when upgrading to Spring Security 6,"In Spring Security 6.0, `<http>` defaults `authorizeRequests#filterSecurityInterceptorOncePerRequest` to false. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.RemoveMethodInvocationsVisitor;
import org.openrewrite.java.tree.Expression;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;

public class RemoveFilterSecurityInterceptorOncePerRequest extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove unnecessary `filterSecurityInterceptorOncePerRequest(false)` when upgrading to Spring Security 6"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 6.0, `<http>` defaults `authorizeRequests#filterSecurityInterceptorOncePerRequest` to false. "" +
               ""So, to complete migration, any defaults values can be removed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Map<MethodMatcher, Predicate<List<Expression>>> matchers = new HashMap<>();
        matchers.put(new MethodMatcher(""org.springframework.security.config.annotation.web.configurers.AbstractInterceptUrlConfigurer.AbstractInterceptUrlRegistry filterSecurityInterceptorOncePerRequest(boolean)""
            ), RemoveMethodInvocationsVisitor.isFalseArgument());
        return new RemoveMethodInvocationsVisitor(matchers);
    }
}
",{}
Remove the `useAuthorizationManager=true` attribute from `@EnableReactiveMethodSecurity`,"In Spring security 6.0, `@EnableReactiveMethodSecurity` defaults `useAuthorizationManager` to true. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.time.Duration;
import java.util.List;

public class UpdateEnableReactiveMethodSecurity extends Recipe {

    private static final AnnotationMatcher ENABLE_REACTIVE_METHOD_SECURITY_MATCHER =
            new AnnotationMatcher(""@org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity"");

    @Override
    public String getDisplayName() {
        return ""Remove the `useAuthorizationManager=true` attribute from `@EnableReactiveMethodSecurity`"";
    }

    @Override
    public String getDescription() {
        return ""In Spring security 6.0, `@EnableReactiveMethodSecurity` defaults `useAuthorizationManager` to true. "" +
                ""So, to complete migration, `@EnableReactiveMethodSecurity` remove the `useAuthorizationManager` attribute."";
    }

    @Override
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity"", false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        annotation = super.visitAnnotation(annotation, ctx);
                        if (ENABLE_REACTIVE_METHOD_SECURITY_MATCHER.matches(annotation) &&
                                annotation.getArguments() != null &&
                                !annotation.getArguments().isEmpty()) {
                            List<Expression> args = annotation.getArguments();
                            args = ListUtils.map(args, arg -> isUseAuthorizationManagerArgSetToTrue(arg) ? null : arg);
                            return autoFormat(annotation.withArguments(args), ctx);
                        }
                        return annotation;
                    }
                });
    }

    private static boolean isUseAuthorizationManagerArgSetToTrue(Expression arg) {
        if (arg instanceof J.Assignment) {
            J.Assignment assignment = (J.Assignment) arg;
            return ""useAuthorizationManager"".equals(assignment.getVariable().toString()) &&
                    RequireExplicitSavingOfSecurityContextRepository.isTrue(assignment.getAssignment());
        }
        return false;
    }
}
",{}
Remove explicit `SecurityContextConfigurer.requireExplicitSave(true)` opt-in,Remove explicit `SecurityContextConfigurer.requireExplicitSave(true)` opt-in as that is the new default in Spring Security 6. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import lombok.Value;
import lombok.With;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Marker;

import java.util.List;
import java.util.UUID;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

public class RequireExplicitSavingOfSecurityContextRepository extends Recipe {

    private static final MethodMatcher REQUIRE_EXPLICIT_SAVE_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configurers.SecurityContextConfigurer#requireExplicitSave(boolean)"");
    private static final String HTTP_SECURITY_TYPE = ""org.springframework.security.config.annotation.web.builders.HttpSecurity"";

    @Override
    public String getDisplayName() {
        return ""Remove explicit `SecurityContextConfigurer.requireExplicitSave(true)` opt-in"";
    }

    @Override
    public String getDescription() {
        return ""Remove explicit `SecurityContextConfigurer.requireExplicitSave(true)` opt-in as that is the new default in Spring Security 6. "" +
                ""See the corresponding [Sprint Security 6.0 migration step](https://docs.spring.io/spring-security/reference/6.0.0/migration/servlet/session-management.html#_require_explicit_saving_of_securitycontextrepository) for details."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.security.config.annotation.web.configurers.SecurityContextConfigurer"", true), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                method = super.visitMethodInvocation(method, ctx);
                if (method.getSelect() != null && method.getArguments().size() == 1 &&
                        REQUIRE_EXPLICIT_SAVE_MATCHER.matches(method) &&
                        isTrue(method.getArguments().get(0))) {
                    return ToBeRemoved.withMarker(method);
                }
                if (method.getSelect() instanceof J.MethodInvocation && ToBeRemoved.hasMarker(method.getSelect())) {
                    return method.withSelect(((J.MethodInvocation) method.getSelect()).getSelect());
                }
                if (method.getArguments().stream().anyMatch(ToBeRemoved::hasMarker) &&
                        method.getSelect() != null && TypeUtils.isAssignableTo(HTTP_SECURITY_TYPE, method.getSelect().getType())) {
                    if (method.getArguments().stream().allMatch(ToBeRemoved::hasMarker)) {
                        return ToBeRemoved.withMarker(method);
                    }
                    return method.withArguments(method.getArguments().stream().filter(a -> !ToBeRemoved.hasMarker(a)).collect(toList()));
                }
                return method;
            }

            @Override
            public J.Lambda visitLambda(J.Lambda lambda, ExecutionContext ctx) {
                lambda = super.visitLambda(lambda, ctx);
                J body = lambda.getBody();
                if (body instanceof J.MethodInvocation && ToBeRemoved.hasMarker(body)) {
                    Expression select = ((J.MethodInvocation) body).getSelect();
                    List<J> parameters = lambda.getParameters().getParameters();
                    if (select instanceof J.Identifier && !parameters.isEmpty() && parameters.get(0) instanceof J.VariableDeclarations) {
                        J.VariableDeclarations declarations = (J.VariableDeclarations) parameters.get(0);
                        if (((J.Identifier) select).getSimpleName().equals(declarations.getVariables().get(0).getSimpleName())) {
                            return ToBeRemoved.withMarker(lambda.withBody(J.Block.createEmptyBlock().withPrefix(body.getPrefix())));
                        }
                    } else if (select instanceof J.MethodInvocation) {
                        return lambda.withBody(select.withPrefix(body.getPrefix()));
                    }
                } else if (body instanceof J.Block && ToBeRemoved.hasMarker(body)) {
                    return ToBeRemoved.withMarker(lambda.withBody(J.Block.createEmptyBlock().withPrefix(body.getPrefix())));
                }
                return lambda;
            }

            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                block = super.visitBlock(block, ctx);
                List<Statement> statements = block.getStatements();
                if (!statements.isEmpty() && statements.stream().allMatch(ToBeRemoved::hasMarker)) {
                    return ToBeRemoved.withMarker(block.withStatements(emptyList()));
                }
                if (statements.stream().anyMatch(ToBeRemoved::hasMarker)) {
                    //noinspection DataFlowIssue
                    return block.withStatements(statements.stream()
                            .filter(s -> !ToBeRemoved.hasMarker(s) || s instanceof J.MethodInvocation && ((J.MethodInvocation) s).getSelect() instanceof J.MethodInvocation)
                            .map(s -> s instanceof J.MethodInvocation && ToBeRemoved.hasMarker(s) ? ((J.MethodInvocation) s).getSelect().withPrefix(s.getPrefix()) : s)
                            .collect(toList()));
                }
                return block;
            }
        });
    }

    @Value
    @With
    static class ToBeRemoved implements Marker {
        UUID id;

        static <J2 extends J> J2 withMarker(J2 j) {
            return j.withMarkers(j.getMarkers().addIfAbsent(new ToBeRemoved(randomId())));
        }

        static <J2 extends J> J2 removeMarker(J2 j) {
            return j.withMarkers(j.getMarkers().removeByType(ToBeRemoved.class));
        }

        static boolean hasMarker(J j) {
            return j.getMarkers().findFirst(ToBeRemoved.class).isPresent();
        }
    }

    public static boolean isTrue(Expression expression) {
        if (expression instanceof J.Literal) {
            return expression.getType() == JavaType.Primitive.Boolean && Boolean.TRUE.equals(((J.Literal) expression).getValue());
        }
        return false;
    }
}
",{}
Remove explicit configuration of SHA-256 as encoding and matching algorithm for `TokenBasedRememberMeServices`,As of Spring Security 6.0 the SHA-256 algorithm is the default for the encoding and matching algorithm used by `TokenBasedRememberMeServices` and does thus no longer need to be explicitly configured. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.internal.LocalVariableUtils;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.ArrayList;

public class UseSha256InRememberMe extends Recipe {

    private static final JavaType.Class REMEMBER_ME_TOKEN_ALGORITHM_TYPE = (JavaType.Class) JavaType.buildType(""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices$RememberMeTokenAlgorithm"");
    private static final MethodMatcher REMEMBER_ME_SERVICES_CONSTRUCTOR_MATCHER =
            new MethodMatcher(""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices <constructor>(String, org.springframework.security.core.userdetails.UserDetailsService, "" +
                              REMEMBER_ME_TOKEN_ALGORITHM_TYPE.getFullyQualifiedName() + "")"");
    private static final MethodMatcher REMEMBER_ME_SERVICES_SET_MATCHING_ALGORITHM_MATCHER =
            new MethodMatcher(""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices setMatchingAlgorithm("" +
                              REMEMBER_ME_TOKEN_ALGORITHM_TYPE.getFullyQualifiedName() + "")"");

    @Override
    public String getDisplayName() {
        return ""Remove explicit configuration of SHA-256 as encoding and matching algorithm for `TokenBasedRememberMeServices`"";
    }

    @Override
    public String getDescription() {
        return ""As of Spring Security 6.0 the SHA-256 algorithm is the default for the encoding and matching algorithm used by `TokenBasedRememberMeServices` and does thus no longer need to be explicitly configured. "" +
               ""See the corresponding [Sprint Security 6.0 migration step](https://docs.spring.io/spring-security/reference/6.0.0/migration/servlet/authentication.html#servlet-opt-in-sha256-rememberme) for details."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"", true), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                newClass = super.visitNewClass(newClass, ctx);
                if (newClass.getArguments().size() == 3 && REMEMBER_ME_SERVICES_CONSTRUCTOR_MATCHER.matches(newClass)) {
                    if (isSha256Algorithm(newClass.getArguments().get(2), getCursor())) {
                        return newClass.withArguments(new ArrayList<>(newClass.getArguments().subList(0, 2)));
                    }
                }
                return newClass;
            }

            @Override
            @SuppressWarnings(""DataFlowIssue"")
            public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                method = super.visitMethodInvocation(method, ctx);
                if (method.getSelect() != null && method.getArguments().size() == 1 &&
                    REMEMBER_ME_SERVICES_SET_MATCHING_ALGORITHM_MATCHER.matches(method)) {
                    if (isSha256Algorithm(method.getArguments().get(0), getCursor())) {
                        return null;
                    }
                }
                return method;
            }
        });
    }

    private boolean isSha256Algorithm(Expression expression, Cursor cursor) {
        Expression resolvedExpression = LocalVariableUtils.resolveExpression(expression, cursor);
        JavaType.Variable fieldType = null;
        if (resolvedExpression instanceof J.Identifier) {
            fieldType = ((J.Identifier) resolvedExpression).getFieldType();
        } else if (resolvedExpression instanceof J.FieldAccess) {
            fieldType = ((J.FieldAccess) resolvedExpression).getName().getFieldType();
        }

        return fieldType != null && ""SHA256"".equals(fieldType.getName()) && TypeUtils.isOfType(fieldType.getType(), REMEMBER_ME_TOKEN_ALGORITHM_TYPE);
    }

}
",{}
Convert `OAuth2ResourceServerConfigurer` chained calls into Lambda DSL,Converts `OAuth2ResourceServerConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6.oauth2.server.resource;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.boot2.ConvertToSecurityDslVisitor;

import java.util.Arrays;
import java.util.Collection;

@EqualsAndHashCode(callSuper = false)
@Value
public class OAuth2ResourceServerLambdaDsl extends Recipe {
    private static final String FQN_OAUTH2_CLIENT_CONFIGURER = ""org.springframework.security.config.annotation.web.configurers.oauth2.server.resource.OAuth2ResourceServerConfigurer"";

    private static final Collection<String> APPLICABLE_METHODS = Arrays.asList(""jwt"", ""opaqueToken"");

    @Override
    public String getDisplayName() {
        return ""Convert `OAuth2ResourceServerConfigurer` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `OAuth2ResourceServerConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_OAUTH2_CLIENT_CONFIGURER, true),
                new ConvertToSecurityDslVisitor<>(FQN_OAUTH2_CLIENT_CONFIGURER, APPLICABLE_METHODS)
        );
    }
}
",{}
Convert `OAuth2ClientConfigurer` chained calls into Lambda DSL,Converts `OAuth2ClientConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6.oauth2.client;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.boot2.ConvertToSecurityDslVisitor;

import java.util.Collection;

import static java.util.Collections.singletonList;

@EqualsAndHashCode(callSuper = false)
@Value
public class OAuth2ClientLambdaDsl extends Recipe {
    private static final String FQN_OAUTH2_CLIENT_CONFIGURER = ""org.springframework.security.config.annotation.web.configurers.oauth2.client.OAuth2ClientConfigurer"";

    private static final Collection<String> APPLICABLE_METHODS = singletonList(""authorizationCodeGrant"");

    @Override
    public String getDisplayName() {
        return ""Convert `OAuth2ClientConfigurer` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `OAuth2ClientConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_OAUTH2_CLIENT_CONFIGURER, true),
                new ConvertToSecurityDslVisitor<>(FQN_OAUTH2_CLIENT_CONFIGURER, APPLICABLE_METHODS)
        );
    }
}
",{}
Convert `OAuth2LoginConfigurer` chained calls into Lambda DSL,Converts `OAuth2LoginConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security6.oauth2.client;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.boot2.ConvertToSecurityDslVisitor;

import java.util.Arrays;
import java.util.Collection;

@EqualsAndHashCode(callSuper = false)
@Value
public class OAuth2LoginLambdaDsl extends Recipe {
    private static final String FQN_OAUTH2_LOGIN_CONFIGURER = ""org.springframework.security.config.annotation.web.configurers.oauth2.client.OAuth2LoginConfigurer"";

    private static final Collection<String> APPLICABLE_METHOD_NAMES = Arrays.asList(""authorizationEndpoint"", ""redirectionEndpoint"",
            ""tokenEndpoint"", ""userInfoEndpoint"");
    @Override
    public String getDisplayName() {
        return ""Convert `OAuth2LoginConfigurer` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `OAuth2LoginConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_OAUTH2_LOGIN_CONFIGURER, true),
                new ConvertToSecurityDslVisitor<>(FQN_OAUTH2_LOGIN_CONFIGURER, APPLICABLE_METHOD_NAMES)
        );
    }
}
",{}
Find Spring components,"Find Spring components, including controllers, services, repositories, ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.search;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.SourceFile;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.spring.table.SpringComponentRelationships;
import org.openrewrite.java.spring.table.SpringComponents;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import static java.util.Objects.requireNonNull;

public class FindSpringComponents extends Recipe {
    transient SpringComponents springComponents = new SpringComponents(this);
    transient SpringComponentRelationships componentRelationships = new SpringComponentRelationships(this);

    @Override
    public String getDisplayName() {
        return ""Find Spring components"";
    }

    @Override
    public String getDescription() {
        return ""Find Spring components, including controllers, services, repositories, "" +
               ""return types of `@Bean` annotated methods, etc."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);
                for (J.Annotation annotation : classDecl.getLeadingAnnotations()) {
                    if (TypeUtils.isAssignableTo(""org.springframework.stereotype.Component"", annotation.getType())) {
                        c = SearchResult.found(c, ""component"");
                        springComponents.insertRow(ctx, new SpringComponents.Row(
                                getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().toString(),
                                requireNonNull(classDecl.getType()).getFullyQualifiedName()
                        ));
                        recordConstructorInjections(c, ctx);
                        break;
                    }
                }
                return c;
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
                if (!FindAnnotations.find(m, ""@org.springframework.context.annotation.Bean"").isEmpty() &&
                    m.getReturnTypeExpression() != null) {

                    m = SearchResult.found(m, ""bean"");
                    recordDependencies(TypeUtils.asFullyQualified(requireNonNull(m.getReturnTypeExpression()).getType()), m, ctx);
                }
                return m;
            }

            private void recordConstructorInjections(J.ClassDeclaration c, ExecutionContext ctx) {
                int ctorCount = 0;
                J.MethodDeclaration ctor = null;
                for (Statement statement : c.getBody().getStatements()) {
                    if (statement instanceof J.MethodDeclaration) {
                        J.MethodDeclaration m = (J.MethodDeclaration) statement;
                        if (m.isConstructor()) {
                            boolean autowired = !FindAnnotations.find(m, ""@org.springframework.beans.factory.annotation.Autowired"").isEmpty();
                            if (autowired || m.hasModifier(J.Modifier.Type.Public)) {
                                ctor = m;
                                ctorCount++;
                            }
                            if (autowired) {
                                ctorCount = 1;
                                break;
                            }
                        }
                    }
                }

                // single constructors are implicitly autowired
                if (ctor != null && ctorCount == 1) {
                    recordDependencies(c.getType(), ctor, ctx);
                }
            }

            private void recordDependencies(JavaType.@Nullable FullyQualified dependentType, J.MethodDeclaration m, ExecutionContext ctx) {
                if (dependentType == null) {
                    return;
                }
                for (Statement dependency : m.getParameters()) {
                    if (dependency instanceof J.VariableDeclarations) {
                        JavaType.FullyQualified depType = ((J.VariableDeclarations) dependency).getTypeAsFullyQualified();
                        if (depType != null) {
                            componentRelationships.insertRow(ctx, new SpringComponentRelationships.Row(
                                    getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().toString(),
                                    dependentType.getFullyQualifiedName(),
                                    depType.getFullyQualifiedName()
                            ));
                        }
                    }
                }
            }
        };
    }
}
",{}
Find Spring API endpoints,,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.spring.table.ApiEndpoints;
import org.openrewrite.java.spring.trait.SpringRequestMapping;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.marker.SearchResult;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindApiEndpoints extends Recipe {

    transient ApiEndpoints apis = new ApiEndpoints(this);

    @Override
    public String getDisplayName() {
        return ""Find Spring API endpoints"";
    }

    @Override
    public String getDescription() {
        //language=markdown
        return ""Find all HTTP API endpoints exposed by Spring applications. "" +
               ""More specifically, this marks method declarations annotated with `@RequestMapping`, `@GetMapping`, "" +
               ""`@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` as search results."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                SpringRequestMapping.Matcher matcher = new SpringRequestMapping.Matcher();
                for (J.Annotation annotation : service(AnnotationService.class).getAllAnnotations(getCursor())) {
                    m = matcher.get(annotation, getCursor()).map(requestMapping -> {
                        String path = requestMapping.getPath();
                        String methodSignature = requestMapping.getMethodSignature();
                        String httpMethod = requestMapping.getHttpMethod();
                        String leadingAnnotations = requestMapping.getLeadingAnnotations();

                        apis.insertRow(ctx, new ApiEndpoints.Row(
                                getCursor().firstEnclosingOrThrow(JavaSourceFile.class).getSourcePath().toString(),
                                methodSignature,
                                method.getSimpleName(),
                                httpMethod,
                                path,
                                leadingAnnotations
                        ));

                        return SearchResult.found(method, httpMethod + "" "" + path);
                    }).orElse(m);
                }
                return m;
            }
        };
    }
}
",{}
Find HTTP API calls via `RestTemplate`,,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.SourceFile;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.spring.table.ApiCalls;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindApiCalls extends Recipe {
    transient ApiCalls calls = new ApiCalls(this);

    @Override
    public String getDisplayName() {
        return ""Find HTTP API calls via `RestTemplate`"";
    }

    @Override
    public String getDescription() {
        //language=markdown
        return ""Find outbound HTTP API calls made via Spring's `RestTemplate` class."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            final MethodMatcher restTemplateCall = new MethodMatcher(""org.springframework.web.client.RestTemplate *For*(..)"");
            final MethodMatcher restTemplateExchange = new MethodMatcher(""org.springframework.web.client.RestTemplate exchange(String, ..)"");
            final MethodMatcher webClientUri = new MethodMatcher(""org.springframework.web.reactive.function.client.WebClient.UriSpec(String, ..)"");

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (restTemplateCall.matches(method)) {
                    String httpMethod = method.getSimpleName().substring(0, method.getSimpleName().indexOf(""For"")).toUpperCase();
                    Expression uri = method.getArguments().get(0);
                    String uriValue = uri instanceof J.Literal ?
                            String.valueOf(((J.Literal) uri).getValue()) :
                            uri.printTrimmed(getCursor());
                    m = SearchResult.found(m, httpMethod + "" "" + uriValue);
                    calls.insertRow(ctx, new ApiCalls.Row(
                            getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().toString(),
                            httpMethod,
                            uriValue
                    ));
                } else if (restTemplateExchange.matches(method)) {

                }
                return m;
            }
        };
    }
}
",{}
Simplify unnecessary `MediaType.parseMediaType()` and `MediaType.valueOf()` calls,Replaces `MediaType.parseMediaType(\,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.http;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Optional;

public class SimplifyMediaTypeParseCalls extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Simplify unnecessary `MediaType.parseMediaType()` and `MediaType.valueOf()` calls"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `MediaType.parseMediaType(\""application/json\"")` and `MediaType.valueOf(\""application/json\"")` with `MediaType.APPLICATION_JSON`."";
    }

    static final String MEDIA_TYPE = ""org.springframework.http.MediaType"";
    static final String PARSE_MEDIA_TYPE = MEDIA_TYPE + "" parseMediaType(String)"";
    static final String VALUE_OF = MEDIA_TYPE + "" valueOf(String)"";

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(new UsesMethod<>(PARSE_MEDIA_TYPE), new UsesMethod<>(VALUE_OF)),
                new SimplifyParseCallsVisitor());
    }

    private static final class SimplifyParseCallsVisitor extends JavaVisitor<ExecutionContext> {
        @Override
        public J visitMethodInvocation(J.MethodInvocation methodInvocation, ExecutionContext ctx) {
            J j = super.visitMethodInvocation(methodInvocation, ctx);
            J.MethodInvocation mi = (J.MethodInvocation) j;
            if (new MethodMatcher(PARSE_MEDIA_TYPE).matches(mi) || new MethodMatcher(VALUE_OF).matches(mi)) {
                Expression methodArg = mi.getArguments().get(0);
                if (methodArg instanceof J.FieldAccess &&
                        TypeUtils.isOfClassType(((J.FieldAccess) methodArg).getTarget().getType(), MEDIA_TYPE)) {
                    maybeRemoveImport(MEDIA_TYPE + "".parseMediaType"");
                    maybeRemoveImport(MEDIA_TYPE + "".valueOf"");
                    J.FieldAccess fieldAccess = (J.FieldAccess) methodArg;
                    String replacementConstant = fieldAccess.getSimpleName().replace(""_VALUE"", """");
                    Optional<JavaType.Variable> first = fieldAccess.getName().getFieldType() != null ?
                            ((JavaType.Class) fieldAccess.getName().getFieldType().getOwner()).getMembers().stream().filter(v -> v.getName().equals(replacementConstant)).findFirst() :
                            Optional.empty();
                    return fieldAccess
                            .withType(JavaType.Primitive.String)
                            .withName(fieldAccess.getName()
                                    .withSimpleName(replacementConstant)
                                    .withFieldType(first.orElse(null))
                            )
                            .withPrefix(mi.getPrefix())
                            .withMarkers(mi.getMarkers())
                            .withComments(mi.getComments());
                }
            }
            return j;
        }
    }
}
",{}
Replace String literals with `HttpHeaders` constants,Replace String literals with `org.springframework.http.HttpHeaders` constants.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.http;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.ReplaceStringLiteralWithConstant;
import org.openrewrite.java.tree.J;
import org.openrewrite.maven.search.DependencyInsight;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class ReplaceStringLiteralsWithHttpHeadersConstants extends ScanningRecipe<AtomicBoolean> {

    private static final List<String> HEADERS = Arrays.asList(
            ""ACCEPT"",
            ""ACCEPT_CHARSET"",
            ""ACCEPT_ENCODING"",
            ""ACCEPT_LANGUAGE"",
            ""ACCEPT_PATCH"",
            ""ACCEPT_RANGES"",
            ""ACCESS_CONTROL_ALLOW_CREDENTIALS"",
            ""ACCESS_CONTROL_ALLOW_HEADERS"",
            ""ACCESS_CONTROL_ALLOW_METHODS"",
            ""ACCESS_CONTROL_ALLOW_ORIGIN"",
            ""ACCESS_CONTROL_EXPOSE_HEADERS"",
            ""ACCESS_CONTROL_MAX_AGE"",
            ""ACCESS_CONTROL_REQUEST_HEADERS"",
            ""ACCESS_CONTROL_REQUEST_METHOD"",
            ""AGE"",
            ""ALLOW"",
            ""AUTHORIZATION"",
            ""CACHE_CONTROL"",
            ""CONNECTION"",
            ""CONTENT_ENCODING"",
            ""CONTENT_DISPOSITION"",
            ""CONTENT_LANGUAGE"",
            ""CONTENT_LENGTH"",
            ""CONTENT_LOCATION"",
            ""CONTENT_RANGE"",
            ""CONTENT_TYPE"",
            ""COOKIE"",
            ""DATE"",
            ""ETAG"",
            ""EXPECT"",
            ""EXPIRES"",
            ""FROM"",
            ""HOST"",
            ""IF_MATCH"",
            ""IF_MODIFIED_SINCE"",
            ""IF_NONE_MATCH"",
            ""IF_RANGE"",
            ""IF_UNMODIFIED_SINCE"",
            ""LAST_MODIFIED"",
            ""LINK"",
            ""LOCATION"",
            ""MAX_FORWARDS"",
            ""ORIGIN"",
            ""PRAGMA"",
            ""PROXY_AUTHENTICATE"",
            ""PROXY_AUTHORIZATION"",
            ""RANGE"",
            ""REFERER"",
            ""RETRY_AFTER"",
            ""SERVER"",
            ""SET_COOKIE"",
            ""SET_COOKIE2"",
            ""TE"",
            ""TRAILER"",
            ""TRANSFER_ENCODING"",
            ""UPGRADE"",
            ""USER_AGENT"",
            ""VARY"",
            ""VIA"",
            ""WARNING"",
            ""WWW_AUTHENTICATE"");

    @Override
    public String getDisplayName() {
        return ""Replace String literals with `HttpHeaders` constants"";
    }

    @Override
    public String getDescription() {
        return ""Replace String literals with `org.springframework.http.HttpHeaders` constants."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!acc.get() && tree instanceof SourceFile) {
                    acc.set(declaresSpringWebDependency((SourceFile) tree, ctx));
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        return Preconditions.check(acc.get(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J preVisit(J tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                for (String header : HEADERS) {
                    doAfterVisit(new ReplaceStringLiteralWithConstant(null, ""org.springframework.http.HttpHeaders."" + header).getVisitor());
                }
                return tree;
            }
        });
    }

    static boolean declaresSpringWebDependency(SourceFile sourceFile, ExecutionContext ctx) {
        TreeVisitor<?, ExecutionContext> visitor = new DependencyInsight(""org.springframework"", ""spring-web"", ""compile"", null, null).getVisitor();
        if (visitor.isAcceptable(sourceFile, ctx) && visitor.visit(sourceFile, ctx) != sourceFile) {
            return true;
        }
        visitor = new org.openrewrite.gradle.search.DependencyInsight(""org.springframework"", ""spring-web"", ""compileClasspath"", null).getVisitor();
        return visitor.isAcceptable(sourceFile, ctx) && visitor.visit(sourceFile, ctx) != sourceFile;
    }
}
",{}
Replace String literals with `MediaType` constants,Replace String literals with `org.springframework.http.MediaType` constants.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.http;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.ReplaceStringLiteralWithConstant;
import org.openrewrite.java.tree.J;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.openrewrite.java.spring.http.ReplaceStringLiteralsWithHttpHeadersConstants.declaresSpringWebDependency;

public class ReplaceStringLiteralsWithMediaTypeConstants extends ScanningRecipe<AtomicBoolean> {

    private static final List<String> MEDIA_TYPES = Arrays.asList(
            ""ALL_VALUE"",
            ""APPLICATION_ATOM_XML_VALUE"",
            ""APPLICATION_CBOR_VALUE"",
            ""APPLICATION_FORM_URLENCODED_VALUE"",
            ""APPLICATION_GRAPHQL_VALUE"",
            ""APPLICATION_GRAPHQL_RESPONSE_VALUE"",
            ""APPLICATION_JSON_VALUE"",
            ""APPLICATION_JSON_UTF8_VALUE"",
            ""APPLICATION_OCTET_STREAM_VALUE"",
            ""APPLICATION_PDF_VALUE"",
            ""APPLICATION_PROBLEM_JSON_VALUE"",
            ""APPLICATION_PROBLEM_JSON_UTF8_VALUE"",
            ""APPLICATION_PROBLEM_XML_VALUE"",
            ""APPLICATION_PROTOBUF_VALUE"",
            ""APPLICATION_RSS_XML_VALUE"",
            ""APPLICATION_NDJSON_VALUE"",
            ""APPLICATION_STREAM_JSON_VALUE"",
            ""APPLICATION_XHTML_XML_VALUE"",
            ""APPLICATION_XML_VALUE"",
            ""IMAGE_GIF_VALUE"",
            ""IMAGE_JPEG_VALUE"",
            ""IMAGE_PNG_VALUE"",
            ""MULTIPART_FORM_DATA_VALUE"",
            ""MULTIPART_MIXED_VALUE"",
            ""MULTIPART_RELATED_VALUE"",
            ""TEXT_EVENT_STREAM_VALUE"",
            ""TEXT_HTML_VALUE"",
            ""TEXT_MARKDOWN_VALUE"",
            ""TEXT_PLAIN_VALUE"",
            ""TEXT_XML_VALUE"");

    @Override
    public String getDisplayName() {
        return ""Replace String literals with `MediaType` constants"";
    }

    @Override
    public String getDescription() {
        return ""Replace String literals with `org.springframework.http.MediaType` constants."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!acc.get() && tree instanceof SourceFile) {
                    acc.set(declaresSpringWebDependency((SourceFile) tree, ctx));
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        return Preconditions.check(acc.get(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J preVisit(J tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                for (String mediaType : MEDIA_TYPES) {
                    try {
                        doAfterVisit(new ReplaceStringLiteralWithConstant(null, ""org.springframework.http.MediaType."" + mediaType).getVisitor());
                    } catch (IllegalArgumentException ignore) {
                        // this is typically a NoSuchFieldException when an older version of Spring is used
                    }
                }
                return tree;
            }
        });
    }
}
",{}
Simplify WebTestClient expressions,Simplifies various types of WebTestClient expressions to improve code readability.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.http;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.List;

import static java.util.Collections.emptyList;

public class SimplifyWebTestClientCalls extends Recipe {

    private static final MethodMatcher IS_EQUAL_TO_MATCHER = new MethodMatcher(""org.springframework.test.web.reactive.server.StatusAssertions isEqualTo(..)"");

    @Override
    public String getDisplayName() {
        return ""Simplify WebTestClient expressions"";
    }

    @Override
    public String getDescription() {
        return ""Simplifies various types of WebTestClient expressions to improve code readability."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(IS_EQUAL_TO_MATCHER), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (IS_EQUAL_TO_MATCHER.matches(m.getMethodType())) {
                    final int statusCode = extractStatusCode(m.getArguments().get(0));
                    switch (statusCode) {
                        case 200:
                            return replaceMethod(m, ""isOk()"");
                        case 201:
                            return replaceMethod(m, ""isCreated()"");
                        case 202:
                            return replaceMethod(m, ""isAccepted()"");
                        case 204:
                            return replaceMethod(m, ""isNoContent()"");
                        case 302:
                            return replaceMethod(m, ""isFound()"");
                        case 303:
                            return replaceMethod(m, ""isSeeOther()"");
                        case 304:
                            return replaceMethod(m, ""isNotModified()"");
                        case 307:
                            return replaceMethod(m, ""isTemporaryRedirect()"");
                        case 308:
                            return replaceMethod(m, ""isPermanentRedirect()"");
                        case 400:
                            return replaceMethod(m, ""isBadRequest()"");
                        case 401:
                            return replaceMethod(m, ""isUnauthorized()"");
                        case 403:
                            return replaceMethod(m, ""isForbidden()"");
                        case 404:
                            return replaceMethod(m, ""isNotFound()"");
                    }
                }
                return m;
            }

            private int extractStatusCode(Expression expression) {
                if (expression instanceof J.FieldAccess) {
                    //isEqualTo(HttpStatus.OK)
                    J.FieldAccess fa = (J.FieldAccess) expression;
                    if (fa.getTarget() instanceof J.Identifier) {
                        if (""HttpStatus"".equals(((J.Identifier) fa.getTarget()).getSimpleName())) {
                            switch (fa.getSimpleName()) {
                                case ""OK"":
                                    return 200;
                                case ""CREATED"":
                                    return 201;
                                case ""ACCEPTED"":
                                    return 202;
                                case ""NO_CONTENT"":
                                    return 204;
                                case ""FOUND"":
                                    return 302;
                                case ""SEE_OTHER"":
                                    return 303;
                                case ""NOT_MODIFIED"":
                                    return 304;
                                case ""TEMPORARY_REDIRECT"":
                                    return 307;
                                case ""PERMANENT_REDIRECT"":
                                    return 308;
                                case ""BAD_REQUEST"":
                                    return 400;
                                case ""UNAUTHORIZED"":
                                    return 401;
                                case ""FORBIDDEN"":
                                    return 403;
                                case ""NOT_FOUND"":
                                    return 404;
                            }
                        }
                    }
                } else if (expression instanceof J.Literal) {
                    //isEqualTo(200)
                    Object raw = ((J.Literal) expression).getValue();
                    if (raw instanceof Integer) {
                        return (int) raw;
                    }
                } else if (expression instanceof J.MethodInvocation) {
                    //isEqualTo(HttpStatus.valueOf(200))
                    //isEqualTo(HttpStatusCode.valueOf(200))
                    J.MethodInvocation methodInvocation = (J.MethodInvocation) expression;
                    List<Expression> arguments = methodInvocation.getArguments();
                    if (arguments.size() == 1 && arguments.get(0) instanceof J.Literal) {
                        Object raw = ((J.Literal) arguments.get(0)).getValue();
                        if (raw instanceof Integer) {
                            return (int) raw;
                        }
                    }
                }
                return -1;
            }

            private J.MethodInvocation replaceMethod(J.MethodInvocation method, String methodName) {
                maybeRemoveImport(""org.springframework.http.HttpStatus"");
                maybeRemoveImport(""org.springframework.http.HttpStatusCode"");
                J.MethodInvocation methodInvocation = JavaTemplate.apply(methodName, getCursor(), method.getCoordinates().replaceMethod());
                JavaType.Method type = methodInvocation
                        .getMethodType()
                        .withParameterNames(emptyList())
                        .withParameterTypes(emptyList());
                return methodInvocation
                        .withArguments(emptyList())
                        .withMethodType(type)
                        .withName(methodInvocation.getName().withType(type));
            }
        });
    }
}
",{}
Use `Duration` in `KafkaTestUtils`,Replace `KafkaTestUtils` methods that take a `long` argument with methods that take a `Duration`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.kafka;

import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.ArrayList;
import java.util.List;

public class KafkaTestUtilsDuration extends Recipe {

    private static final String JAVA_TIME_DURATION = ""java.time.Duration"";
    private static final MethodMatcher LAST_ARGUMENT_MATCHER = new MethodMatcher(""org.springframework.kafka.test.utils.KafkaTestUtils get*Record*(.., long)"");
    private static final MethodMatcher SECOND_ARGUMENT_MATCHER = new MethodMatcher(""org.springframework.kafka.test.utils.KafkaTestUtils getRecords(.., long, int)"");

    @Override
    public String getDisplayName() {
        return ""Use `Duration` in `KafkaTestUtils`"";
    }

    @Override
    public String getDescription() {
        return ""Replace `KafkaTestUtils` methods that take a `long` argument with methods that take a `Duration`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesMethod<>(LAST_ARGUMENT_MATCHER),
                        new UsesMethod<>(SECOND_ARGUMENT_MATCHER)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);

                        List<Expression> originalArguments = mi.getArguments();
                        final Expression millis;
                        if (LAST_ARGUMENT_MATCHER.matches(mi)) {
                            millis = originalArguments.get(originalArguments.size() - 1);
                        } else if (SECOND_ARGUMENT_MATCHER.matches(mi)) {
                            millis = originalArguments.get(1);
                        } else {
                            return mi;
                        }

                        JavaType durationType = JavaType.buildType(JAVA_TIME_DURATION);
                        List<JavaType> newParameterTypes = new ArrayList<>(mi.getMethodType().getParameterTypes());
                        List<Expression> newArguments = ListUtils.map(originalArguments, (index, arg) -> {
                            if (arg == millis) {
                                newParameterTypes.set(index, durationType);
                                maybeAddImport(JAVA_TIME_DURATION);
                                return JavaTemplate.builder(""Duration.ofMillis(#{any()})"")
                                        .imports(JAVA_TIME_DURATION)
                                        .build()
                                        .apply(new Cursor(getCursor(), arg), arg.getCoordinates().replace(), millis);
                            }
                            return arg;
                        });

                        return mi.withArguments(newArguments)
                                .withMethodType(mi.getMethodType().withParameterTypes(newParameterTypes));
                    }
                }
        );
    }
}
",{}
Remove `KafkaOperations.usingCompletableFuture()`,Remove the `KafkaOperations.usingCompletableFuture()` bridge during Spring Kafka 2.9 to 3.0 migration.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.kafka;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.RemoveMethodInvocationsVisitor;

import static java.util.Collections.singletonList;

public class RemoveUsingCompletableFuture extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove `KafkaOperations.usingCompletableFuture()`"";
    }

    @Override
    public String getDescription() {
        return ""Remove the `KafkaOperations.usingCompletableFuture()` bridge during Spring Kafka 2.9 to 3.0 migration."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveMethodInvocationsVisitor(singletonList(""org.springframework.kafka.core.KafkaOperations usingCompletableFuture()""));
    }
}
",{}
Change `KafkaOperations.send*` return type to `CompletableFuture`,Send operations used to return a `ListenableFuture` but as of 3.0 return a `CompletableFuture`. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.kafka;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.util.concurrent.ListenableToCompletableFuture;

public class KafkaOperationsSendReturnType extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Change `KafkaOperations.send*` return type to `CompletableFuture`"";
    }

    @Override
    public String getDescription() {
        return ""Send operations used to return a `ListenableFuture` but as of 3.0 return a `CompletableFuture`. "" +
               ""Adjust the usage to use `CompletableFuture` instead."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.springframework.kafka.support.SendResult"", true),
                new ListenableToCompletableFuture());
    }
}
",{}
Transform classes that extend a given Class to implement the given Interface instead,As of spring-batch 5.x Listeners has default methods (made possible by a Java 8 baseline) and can be ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

@EqualsAndHashCode(callSuper = false)
@Value
public class ReplaceSupportClassWithItsInterface extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Transform classes that extend a given Class to implement the given Interface instead"";
    }

    @Override
    public String getDescription() {
        return ""As of spring-batch 5.x Listeners has default methods (made possible by a Java 8 baseline) and can be "" +
               ""implemented directly without the need for this adapter."";
    }

    @Option(displayName = ""Fully qualified class name"",
            description = ""A fully-qualified class name to be replaced."",
            example = ""org.springframework.batch.core.listener.JobExecutionListenerSupport"")
    String fullyQualifiedClassName;

    @Option(displayName = ""Fully qualified interface name"",
            description = ""A fully-qualified Interface name to replace by."",
            example = ""org.springframework.batch.core.JobExecutionListener"")
    String fullyQualifiedInterfaceName;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return Preconditions.check(new UsesType<>(fullyQualifiedClassName, false), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl,
                                                            ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (cd.getExtends() != null &&
                    TypeUtils.isOfClassType(cd.getExtends().getType(), fullyQualifiedClassName)) {
                    cd = cd.withExtends(null);
                    updateCursor(cd);
                    // This is an interesting one... JobExecutionListenerSupport implements
                    // JobExecutionListener
                    // remove the super type from the class type to prevent a stack-overflow
                    // exception when the JavaTemplate visits class type.
                    JavaType.Class type = (JavaType.Class) cd.getType();
                    if (type != null) {
                        cd = cd.withType(type.withSupertype(null));
                        updateCursor(cd);
                    }

                    cd = JavaTemplate
                            .builder(JavaType.ShallowClass.build(fullyQualifiedInterfaceName).getClassName())
                            .imports(fullyQualifiedInterfaceName)
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-batch-core-5"", ""spring-batch-infrastructure-5""))
                            .build()
                            .apply(
                                    getCursor(),
                                    cd.getCoordinates().addImplementsClause()
                            );
                    cd = (J.ClassDeclaration) new RemoveSuperStatementVisitor().visitNonNull(cd, ctx, getCursor().getParentOrThrow());
                    maybeRemoveImport(fullyQualifiedClassName);
                    maybeAddImport(fullyQualifiedInterfaceName);
                }
                return cd;
            }
        });
    }

    class RemoveSuperStatementVisitor extends JavaIsoVisitor<ExecutionContext> {
        final MethodMatcher wm = new MethodMatcher(fullyQualifiedClassName + "" *(..)"");

        @Override
        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method,
                                                                  ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (wm.matches(method.getMethodType())) {
                //noinspection DataFlowIssue
                return null;
            }
            return mi;
        }
    }
}
","{
  ""fullyQualifiedClassName"": ""String field"",
  ""fullyQualifiedInterfaceName"": ""String field""
}"
Migrate `ItemWriter`,`JobBuilderFactory` was deprecated in spring-batch 5.x: replaced by `JobBuilder`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.List;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.joining;

public class MigrateItemWriterWrite extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate `ItemWriter`"";
    }

    @Override
    public String getDescription() {
        return ""`JobBuilderFactory` was deprecated in spring-batch 5.x: replaced by `JobBuilder`."";
    }

    private static final MethodMatcher ITEM_WRITER_MATCHER = new MethodMatcher(""org.springframework.batch.item.ItemWriter write(java.util.List)"", true);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new DeclaresMethod<>(ITEM_WRITER_MATCHER), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                if (!ITEM_WRITER_MATCHER.matches(method.getMethodType())) {
                    return m;
                }

                J.VariableDeclarations parameter = (J.VariableDeclarations) m.getParameters().get(0);
                if (!(parameter.getTypeExpression() instanceof J.ParameterizedType) ||
                    ((J.ParameterizedType) parameter.getTypeExpression()).getTypeParameters() == null) {
                    return m;
                }
                String chunkTypeParameter = ((J.ParameterizedType) parameter.getTypeExpression()).getTypeParameters().get(0).toString();
                String paramName = parameter.getVariables().get(0).getSimpleName();

                // @Override may or may not already be present

                String annotationsWithOverride = Stream.concat(
                                service(AnnotationService.class)
                                        .getAllAnnotations(getCursor()).stream()
                                        .map(it -> it.print(getCursor())),
                                Stream.of(""@Override""))
                        .distinct()
                        .collect(joining(""\n""));

                m = new UpdateListMethodInvocations(paramName).visitMethodDeclaration(m, ctx);
                updateCursor(m);

                // Should be able to replace just the parameters and have usages of those parameters get their types
                // updated automatically. Since parameters usages do not have their type updated, must replace the whole
                // method to ensure that type info is accurate / List import can potentially be removed
                // See: https://github.com/openrewrite/rewrite/issues/2819

                m = JavaTemplate.builder(""#{}\n #{} void write(#{} Chunk<#{}> #{}) throws Exception #{}"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-batch-core-5.1.+"", ""spring-batch-infrastructure-5.1.+""))
                        .imports(""org.springframework.batch.item.Chunk"")
                        .build()
                        .apply(
                                getCursor(),
                                m.getCoordinates().replace(),
                                annotationsWithOverride,
                                m.getModifiers().stream()
                                        .map(J.Modifier::toString)
                                        .collect(joining("" "")),
                                parameter.getModifiers().stream()
                                        .map(J.Modifier::toString)
                                        .collect(joining("" "")),
                                chunkTypeParameter,
                                paramName,
                                m.getBody() == null ? "";"" : m.getBody().print(getCursor()));

                maybeAddImport(""org.springframework.batch.item.Chunk"");
                maybeRemoveImport(""java.util.List"");

                return m;
            }
        });
    }

    private static class UpdateListMethodInvocations extends JavaIsoVisitor<ExecutionContext> {
        private static final String ITERABLE_FQN = ""java.lang.Iterable"";
        private static final String GET_ITEMS_METHOD = ""getItems"";
        private final String parameterName;

        public UpdateListMethodInvocations(String parameterName) {
            this.parameterName = parameterName;
        }

        private static final MethodMatcher COLLECTION_MATCHER = new MethodMatcher(""java.util.Collection *(..)"", true);
        private static final MethodMatcher LIST_MATCHER = new MethodMatcher(""java.util.List *(..)"", true);

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if ((COLLECTION_MATCHER.matches(mi) || LIST_MATCHER.matches(mi)) && isParameter(mi.getSelect())) {
                assert mi.getPadding().getSelect() != null;
                // No need to take care of typing here, since it's going to be printed and parsed on the JavaTemplate later on.
                mi = mi.withSelect(newGetItemsMethodInvocation(mi.getPadding().getSelect()));

            }
            if (!ITEM_WRITER_MATCHER.matches(mi) && mi.getMethodType() != null) {
                List<JavaType> parameterTypes = mi.getMethodType().getParameterTypes();
                mi = mi.withArguments(ListUtils.map(mi.getArguments(), (i, e) -> {
                    if (isParameter(e)) {
                        JavaType type = parameterTypes.size() > i ?
                                parameterTypes.get(i) :
                                parameterTypes.get(parameterTypes.size() - 1);

                        if (notAssignableFromChunk(type)) {
                            return newGetItemsMethodInvocation(
                                    new JRightPadded<>(e, Space.EMPTY, Markers.EMPTY)
                            );
                        }
                    }
                    return e;
                }));
            }
            return mi;
        }

        @Override
        public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext ctx) {
            J.VariableDeclarations.NamedVariable var = super.visitVariable(variable, ctx);

            if (notAssignableFromChunk(var) && isParameter(var.getInitializer())) {
                var = var.withInitializer(newGetItemsMethodInvocation(
                        new JRightPadded<>(var.getInitializer(), Space.EMPTY, Markers.EMPTY)
                ));
            }
            return var;
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            J.Assignment a = super.visitAssignment(assignment, ctx);
            if (notAssignableFromChunk(a.getVariable().getType()) && isParameter(a.getAssignment())) {
                a = a.withAssignment(newGetItemsMethodInvocation(
                        new JRightPadded<>(a.getAssignment(), Space.EMPTY, Markers.EMPTY)
                ));
            }
            return a;
        }

        private boolean notAssignableFromChunk(J.VariableDeclarations.NamedVariable var) {
            return var.getVariableType() != null && notAssignableFromChunk(var.getVariableType().getType());
        }

        private boolean notAssignableFromChunk(@Nullable JavaType type) {
            // Iterable is the only common type between List and Chunk
            return !TypeUtils.isOfClassType(type, ITERABLE_FQN);
        }

        private boolean isParameter(@Nullable Expression maybeParameter) {
            return maybeParameter instanceof J.Identifier &&
                   ((J.Identifier) maybeParameter).getFieldType() != null &&
                   ((J.Identifier) maybeParameter).getFieldType().getName().equals(parameterName);
        }

        private static J.MethodInvocation newGetItemsMethodInvocation(JRightPadded<Expression> select) {
            return new J.MethodInvocation(
                    Tree.randomId(), Space.EMPTY, Markers.EMPTY,
                    select, null,
                    newGetItemsIdentifier(),
                    JContainer.empty(),
                    null
            );
        }

        private static J.Identifier newGetItemsIdentifier() {
            return new J.Identifier(
                    Tree.randomId(),
                    Space.EMPTY, Markers.EMPTY, emptyList(),
                    GET_ITEMS_METHOD,
                    null, null);
        }
    }
}
",{}
Migrate `JobBuilderFactory` to `JobBuilder`,`JobBuilderFactory` was deprecated in spring-batch 5.x. It is replaced by `JobBuilder`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

public class MigrateJobBuilderFactory extends Recipe {
    private static final MethodMatcher JOB_BUILDER_FACTORY = new MethodMatcher(
            ""org.springframework.batch.core.configuration.annotation.JobBuilderFactory get(java.lang.String)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `JobBuilderFactory` to `JobBuilder`"";
    }

    @Override
    public String getDescription() {
        return ""`JobBuilderFactory` was deprecated in spring-batch 5.x. It is replaced by `JobBuilder`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(JOB_BUILDER_FACTORY), new JavaVisitor<ExecutionContext>() {

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (JOB_BUILDER_FACTORY.matches(method)) {
                    J.ClassDeclaration clazz = getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class);
                    J.MethodDeclaration enclosingMethod = getCursor().firstEnclosingOrThrow(J.MethodDeclaration.class);

                    maybeAddImport(""org.springframework.batch.core.job.builder.JobBuilder"", false);
                    maybeRemoveImport(""org.springframework.batch.core.configuration.annotation.JobBuilderFactory"");
                    maybeAddImport(""org.springframework.batch.core.repository.JobRepository"");

                    doAfterVisit(new MigrateJobBuilderFactory.RemoveJobBuilderFactoryVisitor(clazz, enclosingMethod));

                    return JavaTemplate
                            .builder(""new JobBuilder(#{any(java.lang.String)}, jobRepository)"")
                            .contextSensitive()
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-batch-core-5.1.+""))
                            .imports(""org.springframework.batch.core.repository.JobRepository"",
                                    ""org.springframework.batch.core.job.builder.JobBuilder"")
                            .build().apply(
                                    getCursor(),
                                    method.getCoordinates().replace(),
                                    method.getArguments().get(0)
                            );
                }
                return super.visitMethodInvocation(method, ctx);
            }
        });
    }

    private static class RemoveJobBuilderFactoryVisitor extends JavaIsoVisitor<ExecutionContext> {

        private final J.ClassDeclaration scope;

        private final J.MethodDeclaration enclosingMethod;

        public RemoveJobBuilderFactoryVisitor(J.ClassDeclaration scope, J.MethodDeclaration enclosingMethod) {
            this.scope = scope;
            this.enclosingMethod = enclosingMethod;
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

            if (!cd.equals(scope)) {
                return cd;
            }
            cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                if (statement instanceof J.VariableDeclarations && ((J.VariableDeclarations) statement).getTypeExpression() != null) {
                    if (TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getTypeExpression().getType(),
                            ""org.springframework.batch.core.configuration.annotation.JobBuilderFactory"")) {
                        return null;
                    }
                }
                return statement;
            })));
            maybeRemoveImport(""org.springframework.batch.core.configuration.annotation.JobBuilderFactory"");
            return cd;
        }

        @Override
        public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration methodDecl, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(methodDecl, ctx);

            if (!enclosingMethod.equals(md) && !md.isConstructor()) {
                return md;
            }

            List<Object> params = md.getParameters().stream()
                    .filter(j -> !(j instanceof J.Empty) && !isJobBuilderFactoryParameter(j))
                    .collect(toList());

            if (params.isEmpty() && md.isConstructor()) {
                //noinspection DataFlowIssue
                return null;
            }

            if (md.getParameters().stream().noneMatch(this::isJobRepositoryParameter) && !md.isConstructor()) {
                params.add(""JobRepository jobRepository"");
            }

            JavaTemplate paramsTemplate = JavaTemplate
                    .builder(params.stream().map(p -> ""#{}"").collect(joining("", "")))
                    .contextSensitive()
                    .imports(""org.springframework.batch.core.repository.JobRepository"",
                            ""org.springframework.batch.core.job.builder.JobBuilder"",
                            ""org.springframework.batch.core.Step"")
                    .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-batch-core-5.1.+""))
                    .build();

            md = paramsTemplate.apply(getCursor(), md.getCoordinates().replaceParameters(), params.toArray());

            maybeRemoveImport(""org.springframework.batch.core.configuration.annotation.JobBuilderFactory"");
            maybeAddImport(""org.springframework.batch.core.repository.JobRepository"");
            maybeRemoveImport(""org.springframework.beans.factory.annotation.Autowired"");
            return md;
        }

        private boolean isJobRepositoryParameter(Statement statement) {
            return statement instanceof J.VariableDeclarations &&
                   TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getType(),
                           ""org.springframework.batch.core.repository.JobRepository"");
        }

        private boolean isJobBuilderFactoryParameter(Statement statement) {
            return statement instanceof J.VariableDeclarations &&
                   TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getType(),
                           ""org.springframework.batch.core.configuration.annotation.JobBuilderFactory"");
        }
    }
}
",{}
Migrate `StepBuilderFactory` to `StepBuilder`,`StepBuilderFactory` was deprecated in spring-batch 5.x. It is replaced by `StepBuilder`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindMethods;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class MigrateStepBuilderFactory extends Recipe {

    private static final String STEP_BUILDER_FACTORY_GET = ""org.springframework.batch.core.configuration.annotation.StepBuilderFactory get(java.lang.String)"";

    @Override
    public String getDisplayName() {
        return ""Migrate `StepBuilderFactory` to `StepBuilder`"";
    }

    @Override
    public String getDescription() {
        return ""`StepBuilderFactory` was deprecated in spring-batch 5.x. It is replaced by `StepBuilder`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(STEP_BUILDER_FACTORY_GET),
                new JavaVisitor<ExecutionContext>() {
                    @Override
                    public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                        tree = new AddJobRepositoryVisitor().visit(tree, ctx);
                        return new NewStepBuilderVisitor().visit(tree, ctx);
                    }
                }
        );
    }

    private static class AddJobRepositoryVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDeclaration, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDeclaration, ctx);

            // Remove StepBuilderFactory field if StepBuilderFactory.get(..) is used further down
            if (!FindMethods.find(classDeclaration, STEP_BUILDER_FACTORY_GET).isEmpty()) {
                cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), statement -> {
                    if (statement instanceof J.VariableDeclarations &&
                            ((J.VariableDeclarations) statement).getTypeExpression() != null) {
                        if (TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getTypeExpression().getType(),
                                ""org.springframework.batch.core.configuration.annotation.StepBuilderFactory"")) {
                            return null;
                        }
                    }
                    return statement;
                })));
            }

            return cd;
        }

        @Override
        public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
            // Add JobRepository parameter to method if StepBuilderFactory.get(..) is used further down
            if (!FindMethods.find(md, STEP_BUILDER_FACTORY_GET).isEmpty()) {
                List<Statement> params = ListUtils.filter(md.getParameters(), j -> !isStepBuilderFactoryParameter(j));
                if (params.isEmpty() && md.isConstructor()) {
                    return null;
                }
                params = ListUtils.mapFirst(params, p -> p.withPrefix(md.getParameters().get(0).getPrefix().withComments(emptyList())));

                if (md.getParameters().stream().noneMatch(this::isJobRepositoryParameter) && !md.isConstructor()) {
                    maybeAddImport(""org.springframework.batch.core.repository.JobRepository"");
                    boolean parametersEmpty = params.isEmpty() || params.get(0) instanceof J.Empty;
                    J.VariableDeclarations vdd = JavaTemplate.builder(""JobRepository jobRepository"")
                            .contextSensitive()
                            .imports(""org.springframework.batch.core.repository.JobRepository"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-batch-core-5.1.+""))
                            .build()
                            .<J.MethodDeclaration>apply(getCursor(), md.getCoordinates().replaceParameters())
                            .getParameters().get(0).withPrefix(parametersEmpty ? Space.EMPTY : Space.SINGLE_SPACE);
                    if (parametersEmpty) {
                        return md.withParameters(singletonList(vdd))
                                .withMethodType(md.getMethodType()
                                        .withParameterTypes(singletonList(vdd.getType())));
                    }
                    return md.withParameters(ListUtils.concat(params, vdd))
                            .withMethodType(md.getMethodType()
                                    .withParameterTypes(ListUtils.concat(md.getMethodType().getParameterTypes(), vdd.getType())));
                }
            }

            return super.visitMethodDeclaration(md, ctx);
        }

        private boolean isJobRepositoryParameter(Statement statement) {
            return statement instanceof J.VariableDeclarations &&
                    TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getType(),
                            ""org.springframework.batch.core.repository.JobRepository"");
        }

        private boolean isStepBuilderFactoryParameter(Statement statement) {
            return statement instanceof J.VariableDeclarations &&
                    TypeUtils.isOfClassType(((J.VariableDeclarations) statement).getType(),
                            ""org.springframework.batch.core.configuration.annotation.StepBuilderFactory"");
        }
    }

    private static class NewStepBuilderVisitor extends JavaVisitor<ExecutionContext> {
        final MethodMatcher STEP_BUILDER_FACTORY_MATCHER = new MethodMatcher(STEP_BUILDER_FACTORY_GET);

        @Override
        public J visitMethodInvocation(J.MethodInvocation mi, ExecutionContext ctx) {
            if (STEP_BUILDER_FACTORY_MATCHER.matches(mi)) {
                maybeAddImport(""org.springframework.batch.core.step.builder.StepBuilder"", false);
                maybeRemoveImport(""org.springframework.beans.factory.annotation.Autowired"");
                maybeRemoveImport(""org.springframework.batch.core.configuration.annotation.StepBuilderFactory"");
                return JavaTemplate.builder(""new StepBuilder(#{any(java.lang.String)}, jobRepository)"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-batch-core-5.1.+"", ""spring-batch-infrastructure-5.1.+""))
                        .imports(""org.springframework.batch.core.step.builder.StepBuilder"")
                        .build()
                        .apply(getCursor(), mi.getCoordinates().replace(), mi.getArguments().get(0));
            }
            return super.visitMethodInvocation(mi, ctx);
        }
    }
}
",{}
Remove `DefaultBatchConfigurer`,Remove `extends DefaultBatchConfigurer` and `@Override` from associated methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.Markup;

import java.util.List;
import java.util.Optional;

public class RemoveDefaultBatchConfigurer extends Recipe {

    private static final String BATCH_CONFIGURER = ""org.springframework.batch.core.configuration.annotation.BatchConfigurer"";
    private static final String DEFAULT_BATCH_CONFIGURER = ""org.springframework.batch.core.configuration.annotation.DefaultBatchConfigurer"";

    @Override
    public String getDisplayName() {
        return ""Remove `DefaultBatchConfigurer`"";
    }

    @Override
    public String getDescription() {
        return ""Remove `extends DefaultBatchConfigurer` and `@Override` from associated methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(DEFAULT_BATCH_CONFIGURER, true), new RemoveDefaultBatchConfigurerVisitor());
    }

    static final class RemoveDefaultBatchConfigurerVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            if (TypeUtils.isAssignableTo(DEFAULT_BATCH_CONFIGURER, cd.getType())) {
                // Strip extends DefaultBatchConfigurer
                maybeRemoveImport(DEFAULT_BATCH_CONFIGURER);
                return cd.withExtends(null);
            }
            return cd;
        }

        @Override
        public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (overridesDefaultBatchConfigurerMethod(md) || callsDefaultBatchConfigurerSuperConstructor(md)) {
                // Strip @Override
                md = md.withLeadingAnnotations(ListUtils.map(md.getLeadingAnnotations(),
                        a -> (TypeUtils.isAssignableTo(""java.lang.Override"", a.getType())) ? null : a));
                md = Markup.info(md, ""TODO Used to override a DefaultBatchConfigurer method; reconsider if still needed"");

                // Strip calls to super()
                md = md.withBody(md.getBody().withStatements(ListUtils.map(md.getBody().getStatements(),
                        s -> (s instanceof J.MethodInvocation && ""super"".equals(((J.MethodInvocation) s).getSimpleName())) ? null : s)));

                // Strip calls to super.*()
                md = md.withBody(md.getBody().withStatements(ListUtils.map(md.getBody().getStatements(),
                        s -> (s instanceof J.MethodInvocation && ((J.MethodInvocation) s).getSelect() instanceof J.Identifier &&
                              ""super"".equals(((J.Identifier) ((J.MethodInvocation) s).getSelect()).getSimpleName())) ? null : s)));

                // Strip (now) empty methods
                if (md.getBody().getStatements().isEmpty()) {
                    return null;
                }
            }

            // Strip calls to new DefaultBatchConfigurer()
            List<Statement> statements = md.getBody().getStatements();
            if (statements.size() == 1 &&
                statements.get(0) instanceof J.Return &&
                new MethodMatcher(DEFAULT_BATCH_CONFIGURER + "" <constructor>(..)"")
                        .matches(((J.Return) statements.get(0)).getExpression())) {
                maybeRemoveImport(BATCH_CONFIGURER);
                maybeRemoveImport(DEFAULT_BATCH_CONFIGURER);
                return null;
            }

            return md;
        }

        private static boolean overridesDefaultBatchConfigurerMethod(J.MethodDeclaration md) {
            return Optional.ofNullable(md.getMethodType())
                    .map(JavaType.Method::getDeclaringType)
                    .map(JavaType.FullyQualified::getSupertype)
                    .filter(type -> type.isAssignableTo(DEFAULT_BATCH_CONFIGURER))
                    .flatMap(type -> TypeUtils.findDeclaredMethod(type, md.getSimpleName(), md.getMethodType().getParameterTypes()))
                    .isPresent();
        }

        private static boolean callsDefaultBatchConfigurerSuperConstructor(J.MethodDeclaration md) {
            return md.isConstructor() && Optional.ofNullable(md.getMethodType())
                    .map(JavaType.Method::getDeclaringType)
                    .filter(type -> type.isAssignableTo(DEFAULT_BATCH_CONFIGURER))
                    .isPresent();
        }
    }
}
",{}
Migration invocation of JobParameter.toString to JobParameter.getValue.toString,"JobParameter.toString() logic is quite different in spring batch 5, need take JobParameter.getValue.toString replace the JobParameter.toString.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class JobParameterToString extends Recipe {

    private static final MethodMatcher JOB_PARAMETER_TO_STRING_MATCHER = new MethodMatcher(""org.springframework.batch.core.JobParameter toString()"");

    @Override
    public String getDisplayName() {
        return ""Migration invocation of JobParameter.toString to JobParameter.getValue.toString"";
    }

    @Override
    public String getDescription() {
        return ""JobParameter.toString() logic is quite different in spring batch 5, need take JobParameter.getValue.toString replace the JobParameter.toString."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesMethod<>(JOB_PARAMETER_TO_STRING_MATCHER),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        method = super.visitMethodInvocation(method, ctx);
                        if (JOB_PARAMETER_TO_STRING_MATCHER.matches(method)) {
                            return JavaTemplate.builder(""#{any()}.getValue().toString()"")
                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-batch-core-4.3.+""))
                                    .build().apply(getCursor(), method.getCoordinates().replace(), method.getSelect());
                        }
                        return method;
                    }
                });
    }
}
",{}
Add class argument to `JobParameters`,"Migration Job Parameter, parameterized type is essential in Spring Batch 5.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import org.jetbrains.annotations.Contract;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AddImport;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeTree;

import java.util.regex.Pattern;

public class MigrateJobParameter extends Recipe {

    private static final String JOBPARAMETER = ""org.springframework.batch.core.JobParameter"";

    @Override
    public String getDisplayName() {
        return ""Add class argument to `JobParameters`"";
    }

    @Override
    public String getDescription() {
        return ""Migration Job Parameter, parameterized type is essential in Spring Batch 5."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.or(
                        new UsesType<>(JOBPARAMETER, true),
                        new UsesType<>(""org.springframework.batch.core.JobParameters"", true)
                ),
                new JavaIsoVisitor<ExecutionContext>() {

                    private boolean defineMapTypeWithJobParameter(@Nullable JavaType type) {
                        if (type != null && type.isAssignableFrom(Pattern.compile(""java.util.Map"")) &&
                                type instanceof JavaType.Parameterized) {
                            return ((JavaType.Parameterized) type).getTypeParameters().get(1).isAssignableFrom(Pattern.compile(JOBPARAMETER)) &&
                                    !(((JavaType.Parameterized) type).getTypeParameters().get(1) instanceof JavaType.Parameterized);
                        }
                        return false;
                    }

                    private boolean defineMapEntryTypeWithJobParameter(@Nullable JavaType type) {
                        if (type != null && type.isAssignableFrom(Pattern.compile(""java.util.Map.Entry"")) &&
                                type instanceof JavaType.Parameterized) {
                            return ((JavaType.Parameterized) type).getTypeParameters().get(1).isAssignableFrom(Pattern.compile(JOBPARAMETER)) &&
                                    !(((JavaType.Parameterized) type).getTypeParameters().get(1) instanceof JavaType.Parameterized);
                        }
                        return false;
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        method = super.visitMethodInvocation(method, ctx);
                        if (method.getType() != null &&
                                method.getType().isAssignableFrom(Pattern.compile(""java.util.Map"")) &&
                                ""of"".equals(method.getName().getSimpleName()) && method.getArguments().size() % 2 == 0) {
                            return method.withTypeParameters(null);
                        }
                        return method;
                    }

                    @Override
                    public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                        multiVariable = super.visitVariableDeclarations(multiVariable, ctx);
                        if (defineMapTypeWithJobParameter(multiVariable.getType())) {
                            multiVariable = new JNewClassOfMap().visitVariableDeclarations(multiVariable, ctx);
                            maybeAddImport(""java.util.Map"");
                            return multiVariable.withTypeExpression(TypeTree.build(""Map<String, JobParameter<?>>"")
                                    .withPrefix(multiVariable.getTypeExpression().getPrefix()))
                                    .withType(JavaType.buildType(""java.util.Map""));
                        }
                        if (defineMapEntryTypeWithJobParameter(multiVariable.getType())) {
                            maybeAddImport(""java.util.Map"");
                            return multiVariable.withTypeExpression(TypeTree.build(""Map.Entry<String, JobParameter<?>>"")
                                    .withPrefix(multiVariable.getTypeExpression().getPrefix()))
                                    .withType(JavaType.buildType(""java.util.Map.Entry""));
                        }
                        return multiVariable;
                    }


                    @Override
                    public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
                        J.Assignment ass = super.visitAssignment(assignment, ctx);
                        return new JNewClassOfMap().visitAssignment(ass, ctx);
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        method = super.visitMethodDeclaration(method, ctx);

                        if (method.getReturnTypeExpression() != null && defineMapTypeWithJobParameter(method.getReturnTypeExpression().getType())) {
                            method = method.withReturnTypeExpression(TypeTree.build(""Map<String, JobParameter<?>>"")
                                    .withPrefix(method.getReturnTypeExpression().getPrefix()));
                            doAfterVisit(new AddImport<>(""java.util.Map"", null, false));
                        } else if (method.getReturnTypeExpression() != null && defineMapEntryTypeWithJobParameter(method.getReturnTypeExpression().getType())) {
                            method = method.withReturnTypeExpression(TypeTree.build(""Map.Entry<String, JobParameter<?>>"")
                                    .withPrefix(method.getReturnTypeExpression().getPrefix()));
                            doAfterVisit(new AddImport<>(""java.util.Map"", null, false));
                        }
                        return method;
                    }

                    @Contract(""null -> null"")
                    private @Nullable String typeString(@Nullable JavaType javaType) {
                        if (javaType instanceof JavaType.Primitive) {
                            return ((JavaType.Primitive) javaType).name();
                        }
                        if (javaType instanceof JavaType.Class) {
                            return ((JavaType.Class) javaType).getClassName();
                        }
                        if (javaType instanceof JavaType.Array) {
                            return javaType.toString();
                        }
                        return null;
                    }

                    @Override
                    public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                        J.NewClass nc = super.visitNewClass(newClass, ctx);
                        if (nc.getClazz() != null &&
                                nc.getClazz().getType() != null &&
                                nc.getClazz().getType().isAssignableFrom(Pattern.compile(""org.springframework.batch.core.JobParameter""))) {
                            if(newClass.getArguments().stream().filter(expression -> expression.getType()!=null).anyMatch(expression -> expression.getType().isAssignableFrom(Pattern.compile(""java.lang.Class"")))) {
                                return newClass;
                            }
                            JavaType javaType = nc.getArguments().get(0).getType();
                            String typeString = typeString(javaType);
                            if (typeString == null) {
                                return nc;
                            }

                            if (nc.getArguments().size() > 1) {
                                return JavaTemplate.builder(""new JobParameter<>(#{any()}, #{}.class, #{any()})"")
                                        .imports(""org.springframework.batch.core.JobParameter"")
                                        .javaParser(JavaParser.fromJavaVersion()
                                                .classpathFromResources(ctx, ""spring-batch-core-5.1.+"", ""spring-batch-infrastructure-5.1.+""))
                                        .build()
                                        .apply(getCursor(), nc.getCoordinates().replace(),
                                                nc.getArguments().get(0),
                                                typeString,
                                                nc.getArguments().get(1));
                            }
                            return JavaTemplate.builder(""new JobParameter<>(#{any()}, #{}.class)"")
                                    .imports(""org.springframework.batch.core.JobParameter"")
                                    .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-batch-core-5.1.+"", ""spring-batch-infrastructure-5.1.+""))
                                    .build()
                                    .apply(getCursor(), nc.getCoordinates().replace(),
                                            nc.getArguments().get(0),
                                            typeString);
                        }
                        return nc;
                    }
                }
        );
    }

    private static class JNewClassOfMap extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass nc = super.visitNewClass(newClass, ctx);
            if (nc.getType() != null &&
                    nc.getType().isAssignableFrom(Pattern.compile(""java.util.Map"")) &&
                    nc.getClazz() instanceof J.ParameterizedType) {
                return nc.withClazz(TypeTree.build(((J.ParameterizedType) nc.getClazz()).getClazz() + ""<>"").withPrefix(Space.SINGLE_SPACE));
            }
            return nc;
        }
    }

}
",{}
Migrate method when it annotated by Spring Batch API,Migrate method when it annotated by Spring Batch API.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import lombok.RequiredArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeTree;

import java.util.*;
import java.util.regex.Pattern;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.joining;

public class MigrateMethodAnnotatedByBatchAPI extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate method when it annotated by Spring Batch API"";
    }

    @Override
    public String getDescription() {
        return ""Migrate method when it annotated by Spring Batch API."";

    }

    private static final Set<String> annotatedMethods = new HashSet<String>() {
        {
            add(""org.springframework.batch.core.annotation.OnWriteError"");
            add(""org.springframework.batch.core.annotation.BeforeWrite"");
            add(""org.springframework.batch.core.annotation.AfterWrite"");
        }
    };

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaIsoVisitor<ExecutionContext> visitor = new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                Optional<J.Annotation> methodAnnotation = method.getLeadingAnnotations().stream()
                        .filter(annotation -> Objects.nonNull(annotation.getType()))
                        .filter(annotation -> annotatedMethods.contains(annotation.getType().toString()))
                        .findFirst();

                if (methodAnnotation.isPresent()) {
                    method = super.visitMethodDeclaration(method, ctx);
                    doAfterVisit(new RefineMethod(method));
                    return method;
                }
                return super.visitMethodDeclaration(method, ctx);

            }
        };
        return Preconditions.check(new UsesType<>(""org.springframework.batch.core.annotation.*"", true), visitor);
    }

    @RequiredArgsConstructor
    private static class RefineMethod extends JavaIsoVisitor<ExecutionContext> {

        final J.MethodDeclaration method;

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (method != this.method) {
                return super.visitMethodDeclaration(method, ctx);
            }
            Optional<J.VariableDeclarations> parameterOptional = method.getParameters().stream()
                    .filter(parameter -> parameter instanceof J.VariableDeclarations)
                    .map(parameter -> ((J.VariableDeclarations) parameter))
                    .filter(parameter -> parameter.getType().isAssignableFrom(Pattern.compile(""java.util.List"")))
                    .findFirst();
            if (!parameterOptional.isPresent()) {
                return super.visitMethodDeclaration(method, ctx);
            }
            J.VariableDeclarations parameter = parameterOptional.get();
            String chunkTypeParameter = null;
            if ((parameter.getTypeExpression() instanceof J.ParameterizedType)) {
                if (((J.ParameterizedType) parameter.getTypeExpression()).getTypeParameters() != null) {
                    chunkTypeParameter = ((J.ParameterizedType) parameter.getTypeExpression()).getTypeParameters().get(0).toString();
                } else {
                    chunkTypeParameter = ""?"";
                }
            }
            String chunkType = chunkTypeParameter == null ? """" : ""<"" + chunkTypeParameter + "">"";
            String paramName = parameter.getVariables().get(0).getSimpleName();


            J.VariableDeclarations vdd = JavaTemplate.builder(""Chunk"" + chunkType + "" _chunk"")
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-batch-core-5.1.+""))
                    .imports(""org.springframework.batch.item.Chunk"")
                    .build()
                    .<J.MethodDeclaration>apply(getCursor(), method.getCoordinates().replaceParameters())
                    .getParameters().get(0).withPrefix(Space.EMPTY);
            vdd = vdd.withTypeExpression(TypeTree.build(""org.springframework.batch.item.Chunk"")).withType(JavaType.buildType(""org.springframework.batch.item.Chunk""));

            J.MethodDeclaration methodDeclaration = JavaTemplate.builder(""List"" + chunkType + "" #{} = _chunk.getItems();"")
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-batch-core-5.1.+""))
                    .imports(""org.springframework.batch.item.Chunk"")
                    .build()
                    .apply(getCursor(), method.getBody().getCoordinates().firstStatement(), paramName);


            methodDeclaration = methodDeclaration.withParameters(singletonList(vdd))
                    .withMethodType(method.getMethodType()
                            .withParameterTypes(singletonList(vdd.getType())));


            maybeAddImport(""org.springframework.batch.item.Chunk"");
            String annotations = method.getLeadingAnnotations().stream().map(a -> a.print(getCursor())).reduce((a1, a2) -> a1 + ""\n"" + a2).orElse("""");
            String methodModifiers = method.getModifiers().stream()
                    .map(J.Modifier::toString)
                    .collect(joining("" ""));
            String parameterModifiers = parameter.getModifiers().stream()
                    .map(J.Modifier::toString)
                    .collect(joining("" ""));
            String throwz = Optional.ofNullable(method.getThrows()).flatMap(throwsList -> throwsList.stream().map(Object::toString).reduce((a, b) -> a + "", "" + b).map(e -> "" throws "" + e)).orElse("""");
            String body = method.getBody() == null ? """" : methodDeclaration.getBody().print(getCursor());
            return JavaTemplate.builder(String.format(""%s\n %s void write(%s Chunk"" + chunkType + "" %s)%s %s"", annotations, methodModifiers, parameterModifiers, ""_chunk"", throwz, body))
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-batch-core-5.1.+"", ""spring-batch-infrastructure-5.1.+""))
                    .imports(""org.springframework.batch.item.Chunk"")
                    .build()
                    .apply(getCursor(), method.getCoordinates().replace());
        }
    }
}
",{}
Convert receive type in some invocation of StepExecution.xx(),Convert receive type in some invocation of StepExecution.xx().,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.batch;

import lombok.RequiredArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Javadoc;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class ConvertReceiveTypeWhenCallStepExecutionMethod extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Convert receive type in some invocation of StepExecution.xx()"";
    }

    @Override
    public String getDescription() {
        return ""Convert receive type in some invocation of StepExecution.xx()."";
    }


    private static final MethodMatcher CommitCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getCommitCount()"");
    private static final MethodMatcher ReadCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getReadCount()"");
    private static final MethodMatcher WriteCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getWriteCount()"");
    private static final MethodMatcher RollbackCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getRollbackCount()"");
    private static final MethodMatcher FilterCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getFilterCount()"");
    private static final MethodMatcher SkipCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getSkipCount()"");
    private static final MethodMatcher ReadSkipCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getReadSkipCount()"");
    private static final MethodMatcher WriteSkipCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getWriteSkipCount()"");
    private static final MethodMatcher ProcessSkipCount = new MethodMatcher(""org.springframework.batch.core.StepExecution getProcessSkipCount()"");

    private static final MethodMatcher WHEN_MATCHER = new MethodMatcher(""org.mockito.Mockito when(..)"");
    private static final MethodMatcher THEN_RETURN_MATCHER = new MethodMatcher(""org.mockito.stubbing.OngoingStubbing thenReturn(..)"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesMethod<>(""org.springframework.batch.core.StepExecution get*Count()""),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
                        memberRef = super.visitMemberReference(memberRef, ctx);
                        final J.MemberReference mr = memberRef;
                        if (Stream.of(CommitCount, ReadCount, WriteCount, RollbackCount, FilterCount, SkipCount, ReadSkipCount, WriteSkipCount, ProcessSkipCount)
                                .anyMatch(methodMatcher -> methodMatcher.matches(mr))) {
                            doAfterVisit(new MemberReferenceToMethodInvocation(memberRef));
                        }
                        return memberRef;
                    }


                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        method = super.visitMethodInvocation(method, ctx);
                        final J.MethodInvocation md = method;
                        if (Stream.of(CommitCount, ReadCount, WriteCount, RollbackCount, FilterCount, SkipCount, ReadSkipCount, WriteSkipCount, ProcessSkipCount)
                                .anyMatch(methodMatcher -> methodMatcher.matches(md))) {
                            doAfterVisit(new AddCastToMethodInvocation(method));
                        }
                        return method;
                    }
                });
    }

    @RequiredArgsConstructor
    private static class AddCastToMethodInvocation extends JavaVisitor<ExecutionContext> {

        private final J.MethodInvocation selfMethodInvocation;

        @Override
        public J visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J j = super.visitVariableDeclarations(multiVariable, ctx);
            VisitMethodInvocation visitMethodInvocation = new VisitMethodInvocation(selfMethodInvocation);
            visitMethodInvocation.visitVariableDeclarations(multiVariable, ctx);
            if (visitMethodInvocation.isFound) {
                doAfterVisit(new AddCast());
            }
            return j;
        }

        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J j = super.visitMethodInvocation(method, ctx);
            if (method != selfMethodInvocation) {
                if (THEN_RETURN_MATCHER.matches(method)) {
                    if (method.getArguments().get(0).getType() != null &&
                            (""int"".equals(method.getArguments().get(0).getType().toString()) ||
                                    method.getArguments().get(0).getType().isAssignableFrom(Pattern.compile(""java.lang.Integer"")))) {

                        final AtomicBoolean findWhen = new AtomicBoolean(false);
                        new JavaIsoVisitor<ExecutionContext>() {
                            @Override
                            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                if (WHEN_MATCHER.matches(method)) {
                                    findWhen.set(true);
                                }
                                return super.visitMethodInvocation(method, ctx);
                            }
                        }.visit(method, ctx);
                        if (findWhen.get()) {
                            j = JavaTemplate.builder(""#{any(org.mockito.stubbing.OngoingStubbing)}.thenReturn((long) #{})"")
                                    .contextSensitive()
                                    .build().apply(getCursor(), method.getCoordinates().replace(), method.getSelect(), method.getArguments().get(0))
                                    .withPrefix(method.getPrefix());
                        }
                    }
                    return j;

                }
                if (WHEN_MATCHER.matches(method)) {
                    return j;
                }
                VisitMethodInvocation visitMethodInvocation = new VisitMethodInvocation(selfMethodInvocation);
                visitMethodInvocation.visitMethodInvocation(method, ctx);
                if (visitMethodInvocation.isFound) {
                    doAfterVisit(new AddCast());
                }

            }
            return j;

        }

        @Override
        public J visitReturn(J.Return return_, ExecutionContext ctx) {
            J j = super.visitReturn(return_, ctx);
            VisitMethodInvocation visitMethodInvocation = new VisitMethodInvocation(selfMethodInvocation);
            visitMethodInvocation.visitReturn(return_, ctx);
            if (visitMethodInvocation.isFound) {
                doAfterVisit(new AddCast());
            }
            return j;
        }

        private class AddCast extends JavaVisitor<ExecutionContext> {
            @Override
            protected JavadocVisitor<ExecutionContext> getJavadocVisitor() {
                return new JavadocVisitor<ExecutionContext>(this) {
                    @Override
                    public Javadoc visitReference(Javadoc.Reference reference, ExecutionContext ctx) {
                        return reference;
                    }
                };
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J parent = getCursor().getParentTreeCursor().getValue();
                if (selfMethodInvocation == method &&
                        !(parent instanceof J.TypeCast) &&
                        !(parent instanceof Expression && WHEN_MATCHER.matches((Expression) parent))) {
                    return JavaTemplate.builder(""(int) #{any(int)}"")
                            .contextSensitive()
                            .build().apply(getCursor(), method.getCoordinates().replace(), method)
                            .withPrefix(method.getPrefix());
                }
                return super.visitMethodInvocation(method, ctx);
            }
        }

    }

    @RequiredArgsConstructor
    private static class VisitMethodInvocation extends JavaIsoVisitor<ExecutionContext> {

        private final J.MethodInvocation selfMethodInvocation;

        private boolean isFound = false;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            method = super.visitMethodInvocation(method, ctx);
            if (method == selfMethodInvocation) {
                isFound = true;
            }
            return method;
        }
    }

    @RequiredArgsConstructor
    private static class MemberReferenceToMethodInvocation extends JavaVisitor<ExecutionContext> {

        private final J.MemberReference selfMemberRef;

        @Override
        public J visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
            if (selfMemberRef == memberRef) {
                J.MemberReference mr = (J.MemberReference) super.visitMemberReference(memberRef, ctx);
                if (mr.getMethodType() == null) {
                    return mr;
                }

                String templateCode = String.format(""_stepExecution -> (int)_stepExecution.%s()"",
                        mr.getReference().getSimpleName());
                return JavaTemplate.builder(templateCode)
                        .contextSensitive()
                        .build().apply(getCursor(), mr.getCoordinates().replace())
                        .withPrefix(mr.getPrefix());
            }
            return super.visitMemberReference(memberRef, ctx);
        }
    }
}
",{}
Convert `HttpSecurity` chained calls into Lambda DSL,Converts `HttpSecurity` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;

import java.util.Arrays;
import java.util.Collection;

public final class HttpSecurityLambdaDsl extends Recipe {

    private static final String FQN_HTTP_SECURITY = ""org.springframework.security.config.annotation.web.builders.HttpSecurity"";

    private static final Collection<String> APPLICABLE_METHOD_NAMES = Arrays.asList(
            ""anonymous"", ""authorizeHttpRequests"", ""authorizeRequests"", ""cors"", ""csrf"", ""exceptionHandling"", ""formLogin"",
            ""headers"", ""httpBasic"", ""jee"", ""logout"", ""oauth2Client"", ""oauth2Login"", ""oauth2ResourceServer"",
            ""openidLogin"", ""portMapper"", ""rememberMe"", ""requestCache"", ""requestMatchers"", ""requiresChannel"",
            ""saml2Login"", ""securityContext"", ""servletApi"", ""sessionManagement"", ""x509"");

    @Override
    public String getDisplayName() {
        return ""Convert `HttpSecurity` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `HttpSecurity` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_HTTP_SECURITY, true),
                new ConvertToSecurityDslVisitor<>(FQN_HTTP_SECURITY, APPLICABLE_METHOD_NAMES)
        );
    }

}
",{}
Migrate multi-condition `@ConditionalOnBean` annotations,Migrate multi-condition `@ConditionalOnBean` annotations to `AnyNestedCondition`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Statement;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import static java.util.stream.Collectors.joining;

public class ConditionalOnBeanAnyNestedCondition extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate multi-condition `@ConditionalOnBean` annotations"";
    }

    @Override
    public String getDescription() {
        return ""Migrate multi-condition `@ConditionalOnBean` annotations to `AnyNestedCondition`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.autoconfigure.condition.ConditionalOnBean"", false), new ConditionalOnBeanAnyNestedConditionVisitor());
    }

    private static class ConditionalOnBeanAnyNestedConditionVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final String ANY_CONDITION_TEMPLATES = ""any_condition_templates"";
        private static final AnnotationMatcher CONDITIONAL_BEAN = new AnnotationMatcher(""@org.springframework.boot.autoconfigure.condition.ConditionalOnBean"");


        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = super.visitAnnotation(annotation, ctx);

            if (CONDITIONAL_BEAN.matches(a) && a.getArguments() != null) {
                // First check for an array of Class arguments
                List<String> conditionalOnBeanCandidates = new ArrayList<>();
                for (Expression p : a.getArguments()) {
                    if (p instanceof J.NewArray) {
                        J.NewArray na = (J.NewArray) p;
                        if (na.getInitializer() != null && na.getInitializer().size() > 1) {
                            for (Expression expression : na.getInitializer()) {
                                J.FieldAccess fieldAccess = (J.FieldAccess) expression;
                                Expression target = fieldAccess.getTarget();
                                if (target instanceof J.Identifier) {
                                    J.Identifier identifier = (J.Identifier) target;
                                    String simpleName = identifier.getSimpleName();
                                    conditionalOnBeanCandidates.add(simpleName);
                                }
                            }
                        }
                    }
                }

                String nestedConditionParameterFormat = ""%s.class"";

                // If class arguments are not found then search for an array of type arguments
                if (conditionalOnBeanCandidates.isEmpty()) {
                    for (Expression arg : a.getArguments()) {
                        if (arg instanceof J.Assignment &&
                                ((J.Assignment) arg).getAssignment() instanceof J.NewArray &&
                                ""type"".equals(((J.Identifier) ((J.Assignment) arg).getVariable()).getSimpleName())) {
                            J.NewArray na = (J.NewArray) ((J.Assignment) arg).getAssignment();
                            if (na.getInitializer() != null) {
                                for (Expression l : na.getInitializer()) {
                                    J.Literal lit = (J.Literal) l;
                                    if (lit.getValue() != null) {
                                        conditionalOnBeanCandidates.add(lit.getValue().toString());
                                    }
                                }
                            }
                        }
                    }

                    nestedConditionParameterFormat = ""type = \""%s\"""";
                }

                if (!conditionalOnBeanCandidates.isEmpty()) {
                    String conditionalClassName = conditionalClassNameFromCandidates(conditionalOnBeanCandidates);

                    // Replacing the annotation will be performed by the JavaTemplate.
                    // The associated conditional class must exist for the JavaTemplate to generate a type attributed AST
                    boolean anyConditionClassExists = false;
                    for (Statement statement : getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class).getBody().getStatements()) {
                        if (statement instanceof J.ClassDeclaration) {
                            J.ClassDeclaration c = (J.ClassDeclaration) statement;
                            if (c.getSimpleName().equals(conditionalClassName)) {
                                anyConditionClassExists = true;
                                break;
                            }
                        }
                    }

                    if (anyConditionClassExists) {
                        a = JavaTemplate.builder(""@Conditional(#{}.class)"")
                            .imports(""org.springframework.context.annotation.Conditional"")
                            .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-context-5.*"", ""spring-boot-autoconfigure-2.*""))
                            .build()
                            .apply(
                                getCursor(),
                                a.getCoordinates().replace(), conditionalClassName
                            );
                        maybeAddImport(""org.springframework.context.annotation.Conditional"");
                    } else {
                        // add the new conditional class template string to the parent ClassDeclaration Cursor
                        Cursor classDeclarationCursor = getCursor().dropParentUntil(it -> it instanceof J.ClassDeclaration || it == Cursor.ROOT_VALUE);
                        Set<String> anyConditionClasses = classDeclarationCursor.getMessage(ANY_CONDITION_TEMPLATES);
                        if (anyConditionClasses == null) {
                            anyConditionClasses = new TreeSet<>();
                            classDeclarationCursor.putMessage(ANY_CONDITION_TEMPLATES, anyConditionClasses);
                        }
                        anyConditionClasses.add(anyConditionClassTemplate(conditionalOnBeanCandidates, nestedConditionParameterFormat));
                    }
                }
            }
            return a;
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);
            Set<String> conditionalTemplates = getCursor().pollMessage(ANY_CONDITION_TEMPLATES);
            if (conditionalTemplates != null && !conditionalTemplates.isEmpty()) {
                for (String s : conditionalTemplates) {
                    JavaTemplate t = JavaTemplate.builder(s)
                            .contextSensitive()
                            .imports(""org.springframework.boot.autoconfigure.condition.AnyNestedCondition"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-context-5.*"", ""spring-boot-autoconfigure-2.*""))
                            .build();

                    c = maybeAutoFormat(
                            c,
                            t.apply(getCursor(), c.getBody().getCoordinates().lastStatement()),
                            ctx);
                    updateCursor(c);
                }

                // Schedule another visit to modify the associated annotations now that the new conditional classes have been added to the AST
                doAfterVisit(new ConditionalOnBeanAnyNestedConditionVisitor());
                maybeAddImport(""org.springframework.boot.autoconfigure.condition.AnyNestedCondition"");
            }
            return c;
        }

        private String conditionalClassNameFromCandidates(List<String> conditionalCandidates) {
            return ""Condition"" + conditionalCandidates.stream().sorted().map(this::getSimpleName).collect(joining(""Or""));
        }

        private String anyConditionClassTemplate(List<String> conditionalIdentifiers, String parameterFormatString) {
            String conditionalClassFormat = ""@ConditionalOnBean("" + parameterFormatString + "")class %sCondition {}"";
            String conditionClassName = conditionalClassNameFromCandidates(conditionalIdentifiers);
            StringBuilder s = new StringBuilder(""private static class "").append(conditionClassName)
                    .append("" extends AnyNestedCondition {"")
                    .append(conditionClassName).append(""(){super(ConfigurationPhase.REGISTER_BEAN);}"");
            conditionalIdentifiers.stream().sorted().forEach(ci -> s.append(String.format(conditionalClassFormat, ci, getSimpleName(ci))));
            s.append(""}"");
            return s.toString();
        }

        private String getSimpleName(String type) {
            String t = type;
            if (t.endsWith("".class"")) {
                t = t.substring(0, t.lastIndexOf("".""));
            }
            if (t.contains(""."")) {
                t = t.substring(t.lastIndexOf(""."") + 1);
            }
            return t;
        }
    }
}
",{}
Use `RestTemplateBuilder#setConnectTimeout(Duration)` and `RestTemplateBuilder#setReadTimeout(Duration)`,`RestTemplateBuilder#setConnectTimeout(int)` and `RestTemplateBuilder#setReadTimeout(int)` were deprecated in Spring Boot 2.1.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

public class MigrateRestTemplateBuilderTimeoutByInt extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use `RestTemplateBuilder#setConnectTimeout(Duration)` and `RestTemplateBuilder#setReadTimeout(Duration)`"";
    }

    @Override
    public String getDescription() {
        return ""`RestTemplateBuilder#setConnectTimeout(int)` and `RestTemplateBuilder#setReadTimeout(int)` were deprecated in Spring Boot 2.1."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.web.client.RestTemplateBuilder"", true),
                new JavaIsoVisitor<ExecutionContext>() {
                    final MethodMatcher connectionTimeout = new MethodMatcher(""org.springframework.boot.web.client.RestTemplateBuilder setConnectTimeout(int)"");
                    final MethodMatcher readTimeout = new MethodMatcher(""org.springframework.boot.web.client.RestTemplateBuilder setReadTimeout(int)"");

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                        updateCursor(m);
                        if (connectionTimeout.matches(m) || readTimeout.matches(m)) {
                            m = JavaTemplate
                                    .builder(""Duration.ofMillis(#{any(int)})"")
                                    .imports(""java.time.Duration"")
                                    .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-boot-2.*""))
                                    .build()
                                    .apply(
                                            getCursor(),
                                            m.getCoordinates().replaceArguments(),
                                            m.getArguments().get(0));
                            maybeAddImport(""java.time.Duration"");
                        }
                        return m;
                    }
                });
    }
}
",{}
Migrate deprecated `ActuatorMediaType` to `ApiVersion#getProducedMimeType`,Spring Boot `ActuatorMediaType` was deprecated in 2.5 in favor of `ApiVersion#getProducedMimeType()`. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

public class MigrateActuatorMediaTypeToApiVersion extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate deprecated `ActuatorMediaType` to `ApiVersion#getProducedMimeType`"";
    }

    @Override
    public String getDescription() {
        return ""Spring Boot `ActuatorMediaType` was deprecated in 2.5 in favor of `ApiVersion#getProducedMimeType()`. "" +
                ""Replace `MediaType.parseMediaType(ActuatorMediaType.Vx_JSON)` with `MediaType.asMediaType(ApiVersion.Vx.getProducedMimeType())`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            private final MethodMatcher mediaTypeMatcher = new MethodMatcher(""org.springframework.http.MediaType parseMediaType(java.lang.String)"");

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (mediaTypeMatcher.matches(mi)) {
                    Expression arg0 = mi.getArguments().get(0);
                    if (arg0 instanceof J.FieldAccess) {
                        J.FieldAccess expFa = (J.FieldAccess) arg0;
                        if (TypeUtils.isOfClassType(expFa.getTarget().getType(), ""org.springframework.boot.actuate.endpoint.http.ActuatorMediaType"")) {
                            String apiVersion = null;
                            if (""V2_JSON"".equals(expFa.getSimpleName())) {
                                apiVersion = ""V2"";
                            } else if (""V3_JSON"".equals(expFa.getSimpleName())) {
                                apiVersion = ""V3"";
                            }
                            if (apiVersion != null) {
                                maybeAddImport(""org.springframework.boot.actuate.endpoint.ApiVersion"");
                                maybeAddImport(""org.springframework.http.MediaType"");
                                maybeRemoveImport(""org.springframework.boot.actuate.endpoint.http.ActuatorMediaType"");
                                mi = JavaTemplate.builder(""MediaType.asMediaType(ApiVersion.#{}.getProducedMimeType())"")
                                    .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""spring-web-5.*"", ""spring-boot-actuator-2.5.*"",
                                            ""spring-core-5.*""))
                                    .imports(""org.springframework.http.MediaType"",
                                        ""org.springframework.boot.actuate.endpoint.ApiVersion"")
                                    .build().apply(
                                        getCursor(),
                                        mi.getCoordinates().replace(),
                                        apiVersion);
                            }
                        }
                    }
                }
                return mi;
            }
        };
    }
}
",{}
Use `EnableConfigurationProperties.VALIDATOR_BEAN_NAME`,Replaces field and static access of `ConfigurationPropertiesBindingPostProcessor.VALIDATOR_BEAN_NAME` with `EnableConfigurationProperties.VALIDATOR_BEAN_NAME`. Deprecated in 2.2.x.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

public class MigrateConfigurationPropertiesBindingPostProcessorValidatorBeanName extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use `EnableConfigurationProperties.VALIDATOR_BEAN_NAME`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces field and static access of `ConfigurationPropertiesBindingPostProcessor.VALIDATOR_BEAN_NAME` with `EnableConfigurationProperties.VALIDATOR_BEAN_NAME`. Deprecated in 2.2.x."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor"",
                false), new MigrateConfigurationPropertiesBindingPostProcessorValidatorBeanNameVisitor());
    }

    private static class MigrateConfigurationPropertiesBindingPostProcessorValidatorBeanNameVisitor extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.FullyQualified ORIGINAL_FQN = JavaType.ShallowClass.build(""org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor"");
        private static final JavaType.FullyQualified NEW_FQN = JavaType.ShallowClass.build(""org.springframework.boot.context.properties.EnableConfigurationProperties"");

        private final Map<String, String> updateDeprecatedFields = new HashMap<>();

        MigrateConfigurationPropertiesBindingPostProcessorValidatorBeanNameVisitor() {
            updateDeprecatedFields.put(""VALIDATOR_BEAN_NAME"", ""VALIDATOR_BEAN_NAME"");
        }

        private static boolean isTargetFieldType(J.Identifier identifier) {
            if (identifier.getFieldType() != null) {
                JavaType.FullyQualified fqn = TypeUtils.asFullyQualified((identifier.getFieldType()).getOwner());
                return fqn != null && ORIGINAL_FQN.getFullyQualifiedName().equals(fqn.getFullyQualifiedName());
            }
            return false;
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);
            if (TypeUtils.isOfType(ORIGINAL_FQN, fa.getTarget().getType()) &&
                    updateDeprecatedFields.containsKey(fa.getName().getSimpleName())) {

                if (fa.getTarget() instanceof J.FieldAccess) {
                    fa = TypeTree.build(NEW_FQN.getFullyQualifiedName() + ""."" + updateDeprecatedFields.get(fieldAccess.getName().getSimpleName())).withPrefix(fa.getPrefix());
                } else {
                    fa = fa.withName(fa.getName().withSimpleName(updateDeprecatedFields.get(fa.getName().getSimpleName())));
                    fa = fa.withTarget(new J.Identifier(
                            Tree.randomId(),
                            fa.getTarget().getPrefix(),
                            fa.getTarget().getMarkers(),
                            emptyList(),
                            NEW_FQN.getClassName(),
                            NEW_FQN,
                            null));
                }
                maybeRemoveImport(ORIGINAL_FQN);
                maybeAddImport(NEW_FQN);
            }
            return fa;
        }

        @Override
        public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
            J.Identifier id = super.visitIdentifier(identifier, ctx);
            if (isTargetFieldType(id) && updateDeprecatedFields.containsKey(id.getSimpleName())) {
                JavaType.Variable fieldType = id.getFieldType();
                id = new J.Identifier(
                        Tree.randomId(),
                        id.getPrefix(),
                        id.getMarkers(),
                        emptyList(),
                        updateDeprecatedFields.get(id.getSimpleName()),
                        id.getType(),
                        new JavaType.Variable(
                                null,
                                fieldType == null ? 0 : Flag.flagsToBitMap(fieldType.getFlags()),
                                updateDeprecatedFields.get(id.getSimpleName()),
                                NEW_FQN,
                                id.getType(),
                                emptyList()));

                maybeRemoveImport(ORIGINAL_FQN);
                maybeAddImport(NEW_FQN);
            }
            return id;
        }
    }
}
",{}
Convert `ServerHttpSecurity` chained calls into Lambda DSL,Converts `ServerHttpSecurity` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;

import java.util.Arrays;
import java.util.Collection;

public final class ServerHttpSecurityLambdaDsl extends Recipe {

    private static final String FQN_SERVER_HTTP_SECURITY = ""org.springframework.security.config.web.server.ServerHttpSecurity"";

    private static final Collection<String> APPLICABLE_METHOD_NAMES = Arrays.asList(
            ""anonymous"", ""authorizeExchange"", ""cors"", ""csrf"", ""exceptionHandling"", ""formLogin"",
            ""headers"", ""httpBasic"", ""logout"", ""oauth2Client"", ""oauth2Login"", ""oauth2ResourceServer"",
            ""redirectToHttps"", ""requestCache"", ""x509"");

    @Override
    public String getDisplayName() {
        return ""Convert `ServerHttpSecurity` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `ServerHttpSecurity` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_SERVER_HTTP_SECURITY, true),
                new ConvertToSecurityDslVisitor<>(FQN_SERVER_HTTP_SECURITY, APPLICABLE_METHOD_NAMES)
        );
    }

}
",{}
Migrate deprecated Spring-Boot `EmbeddedDatabaseConnection.HSQL`,Spring-Boot `EmbeddedDatabaseConnection.HSQL` was deprecated in favor of `EmbeddedDatabaseConnection.HSQLDB` in 2.4.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

public class MigrateHsqlEmbeddedDatabaseConnection extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate deprecated Spring-Boot `EmbeddedDatabaseConnection.HSQL`"";
    }

    @Override
    public String getDescription() {
        return ""Spring-Boot `EmbeddedDatabaseConnection.HSQL` was deprecated in favor of `EmbeddedDatabaseConnection.HSQLDB` in 2.4."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.jdbc.EmbeddedDatabaseConnection"", false),
                new MigrateHsqlEmbeddedDatabaseConnection.UpdateDeprecatedConstantFieldNames());
    }

    private static class UpdateDeprecatedConstantFieldNames extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.FullyQualified EMBEDDED_DATABASE_CONNECTION_FNQ =
                JavaType.ShallowClass.build(""org.springframework.boot.jdbc.EmbeddedDatabaseConnection"");
        private final Map<String, String> updateDeprecatedFields = new HashMap<>();

        UpdateDeprecatedConstantFieldNames() {
            updateDeprecatedFields.put(""HSQL"", ""HSQLDB"");
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);
            if (TypeUtils.isOfType(EMBEDDED_DATABASE_CONNECTION_FNQ, fa.getTarget().getType()) &&
                    updateDeprecatedFields.containsKey(fa.getName().getSimpleName())) {

                if (fa.getTarget() instanceof J.FieldAccess) {
                    fa = TypeTree.build(EMBEDDED_DATABASE_CONNECTION_FNQ.getFullyQualifiedName() + ""."" + updateDeprecatedFields.get(fieldAccess.getName().getSimpleName()))
                            .withPrefix(fa.getPrefix());
                } else {
                    fa = fa.withName(fa.getName().withSimpleName(updateDeprecatedFields.get(fa.getName().getSimpleName())));
                    fa = fa.withTarget(new J.Identifier(
                            Tree.randomId(),
                            fa.getTarget().getPrefix(),
                            fa.getTarget().getMarkers(),
                            emptyList(),
                            EMBEDDED_DATABASE_CONNECTION_FNQ.getClassName(),
                            EMBEDDED_DATABASE_CONNECTION_FNQ,
                            null));
                }
            }
            return fa;
        }

        @Override
        public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
            J.Identifier id = super.visitIdentifier(identifier, ctx);
            if (isTargetFieldType(id) && updateDeprecatedFields.containsKey(id.getSimpleName())) {
                JavaType.Variable fieldType = id.getFieldType();
                id = new J.Identifier(
                        Tree.randomId(),
                        id.getPrefix(),
                        id.getMarkers(),
                        emptyList(),
                        updateDeprecatedFields.get(id.getSimpleName()),
                        id.getType(),
                        new JavaType.Variable(
                                null,
                                fieldType == null ? 0 : Flag.flagsToBitMap(fieldType.getFlags()),
                                updateDeprecatedFields.get(id.getSimpleName()),
                                EMBEDDED_DATABASE_CONNECTION_FNQ,
                                fieldType == null ? null : fieldType.getType(),
                                emptyList()));
            }
            return id;
        }

        private boolean isTargetFieldType(J.Identifier identifier) {
            if (identifier.getFieldType() != null) {
                JavaType.FullyQualified fqn = TypeUtils.asFullyQualified((identifier.getFieldType()).getOwner());
                return fqn != null && EMBEDDED_DATABASE_CONNECTION_FNQ.getFullyQualifiedName().equals(fqn.getFullyQualifiedName());
            }
            return false;
        }
    }
}
",{}
Migrate `RestTemplateBuilder`,Migrate `RestTemplateBuilder#requestFactory` calls to use a `Supplier`. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

public class RestTemplateBuilderRequestFactory extends Recipe {
    private static final MethodMatcher REQUEST_FACTORY = new MethodMatcher(
            ""org.springframework.boot.web.client.RestTemplateBuilder requestFactory(org.springframework.http.client.ClientHttpRequestFactory)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `RestTemplateBuilder`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate `RestTemplateBuilder#requestFactory` calls to use a `Supplier`. "" +
                ""See the [migration guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#resttemplatebuilder) for more."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.web.client.RestTemplateBuilder"", true),
                new RestTemplateBuilderRequestFactoryVisitor());
    }

    private static class RestTemplateBuilderRequestFactoryVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

            // TODO JavaTemplate doesn't replace method type attribution when replacing arguments.
            boolean isArgumentClientHttpRequestFactory = method.getArguments().size() == 1 &&
                    TypeUtils.isAssignableTo(JavaType.ShallowClass.build(""org.springframework.http.client.ClientHttpRequestFactory""),
                            method.getArguments().get(0).getType());

            if (REQUEST_FACTORY.matches(method) && isArgumentClientHttpRequestFactory) {
                JavaTemplate.Builder t = JavaTemplate.builder(""() -> #{any(org.springframework.http.client.ClientHttpRequestFactory)}"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-boot-2.*""));
                m = t.build().apply(getCursor(), m.getCoordinates().replaceArguments(), m.getArguments().get(0));
            }
            return m;
        }
    }
}
",{}
"Use `ErrorAttributes#getErrorAttributes(WebRequest, ErrorAttributeOptions)`","`ErrorAttributes#getErrorAttributes(WebRequest, boolean)` was deprecated in Spring Boot 2.3.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

public class GetErrorAttributes extends Recipe {
    private static final MethodMatcher MATCHER = new MethodMatcher(""org.springframework.boot.web.servlet.error.ErrorAttributes getErrorAttributes(org.springframework.web.context.request.WebRequest, boolean)"");

    @Override
    public String getDisplayName() {
        return ""Use `ErrorAttributes#getErrorAttributes(WebRequest, ErrorAttributeOptions)`"";
    }

    @Override
    public String getDescription() {
        return ""`ErrorAttributes#getErrorAttributes(WebRequest, boolean)` was deprecated in Spring Boot 2.3."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(MATCHER), new GetErrorAttributesVisitor());
    }

    private static class GetErrorAttributesVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final String[] parserImports = new String[]{
                ""org.springframework.boot.web.error.ErrorAttributeOptions"",
                ""org.springframework.boot.web.error.ErrorAttributes"",
                ""org.springframework.web.context.request.WebRequest"",
                ""org.springframework.web.context.request.RequestAttributes""
        };

        private static boolean isLiteralTrue(@Nullable Expression expression) {
            return expression instanceof J.Literal && ((J.Literal) expression).getValue() == Boolean.valueOf(true);
        }

        private static boolean isLiteralFalse(@Nullable Expression expression) {
            return expression instanceof J.Literal && ((J.Literal) expression).getValue() == Boolean.valueOf(false);
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (MATCHER.matches(mi)) {
                assert mi.getArguments().size() == 2;
                Expression includeStackTraceArgument = mi.getArguments().get(1);
                if (isLiteralTrue(includeStackTraceArgument)) {
                    String template = ""#{any(org.springframework.web.context.request.WebRequest)}, ErrorAttributeOptions.defaults().including(ErrorAttributeOptions.Include.STACK_TRACE)"";
                    mi = JavaTemplate.builder(template)
                        .contextSensitive()
                        .imports(parserImports)
                        .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-boot-2.*"", ""spring-boot-autoconfigure-2.*"", ""spring-web-5.*""))
                        .build().apply(
                            getCursor(),
                            mi.getCoordinates().replaceArguments(),
                            mi.getArguments().get(0)
                    );
                } else if (isLiteralFalse(includeStackTraceArgument)) {
                    String template = ""#{any(org.springframework.web.context.request.WebRequest)}, ErrorAttributeOptions.defaults()"";
                    mi = JavaTemplate.builder(template)
                        .contextSensitive()
                        .imports(parserImports)
                        .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-boot-2.*"", ""spring-boot-autoconfigure-2.*"", ""spring-web-5.*""))
                        .build()
                        .apply(
                            getCursor(),
                            mi.getCoordinates().replaceArguments(),
                            mi.getArguments().get(0)
                    );
                } else if (!(mi.getArguments().get(1) instanceof J.Ternary)) {
                    String template = ""#{any(org.springframework.web.context.request.WebRequest)}, #{any(boolean)} ? ErrorAttributeOptions.defaults().including(ErrorAttributeOptions.Include.STACK_TRACE) : ErrorAttributeOptions.defaults()"";
                    mi = JavaTemplate.builder(template)
                        .contextSensitive()
                        .imports(parserImports)
                        .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-boot-2.*"", ""spring-boot-autoconfigure-2.*"", ""spring-web-5.*""))
                        .build()
                        .apply(
                            getCursor(),
                            mi.getCoordinates().replaceArguments(),
                            mi.getArguments().toArray()
                    );
                }
                maybeAddImport(""org.springframework.boot.web.error.ErrorAttributeOptions"");
            }
            return mi;
        }
    }
}
",{}
Replace `EnvironmentTestUtils` with `TestPropertyValues`,Replaces any references to the deprecated `EnvironmentTestUtils` ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.SemanticallyEqual;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.marker.Marker;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public class ReplaceDeprecatedEnvironmentTestUtils extends Recipe {

    private static final MethodMatcher APP_CONTEXT = new MethodMatcher(""org.springframework.boot.test.util.EnvironmentTestUtils addEnvironment(org.springframework.context.ConfigurableApplicationContext, String...)"");
    private static final MethodMatcher ENVIRONMENT = new MethodMatcher(""org.springframework.boot.test.util.EnvironmentTestUtils addEnvironment(org.springframework.core.env.ConfigurableEnvironment, String...)"");
    private static final MethodMatcher NAMED_ENVIRONMENT = new MethodMatcher(""org.springframework.boot.test.util.EnvironmentTestUtils addEnvironment(String, org.springframework.core.env.ConfigurableEnvironment, String...)"");

    @Override
    public String getDisplayName() {
        return ""Replace `EnvironmentTestUtils` with `TestPropertyValues`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces any references to the deprecated `EnvironmentTestUtils` "" +
                ""with `TestPropertyValues` and the appropriate functionality."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.test.util.EnvironmentTestUtils"", false),
                new FindEnvironmentTestUtilsVisitor());
    }

    static final class ReplaceEnvironmentUtilsMarker implements Marker {
        private final String templateString;
        private final List<Expression> parameters;
        private final UUID id;

        ReplaceEnvironmentUtilsMarker(String templateString, List<Expression> parameters, UUID id) {
            this.templateString = templateString;
            this.parameters = parameters;
            this.id = id;
        }

        @Override
        public UUID getId() {
            return id;
        }

        @Override
        @SuppressWarnings(""unchecked"")
        public ReplaceEnvironmentUtilsMarker withId(UUID id) {
            return new ReplaceEnvironmentUtilsMarker(templateString, parameters, id);
        }
    }

    private static class FindEnvironmentTestUtilsVisitor extends JavaIsoVisitor<ExecutionContext> {
        public static final int MINIMUM_ARGUMENT_COUNT = 2;
        private static final int MINIMUM_ARGUMENT_COUNT_WITH_NAME = 3;

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            return super.visitClassDeclaration(classDecl, ctx);
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

            if (m.getBody() == null || m.getBody().getStatements().isEmpty()) {
                return m;
            }

            List<Statement> statements = m.getBody().getStatements();
            List<Statement> newStatements = new ArrayList<>();
            List<J.MethodInvocation> collectedEnvironmentMethods = new ArrayList<>();
            boolean requiresRemoval = false;

            for (Statement statement : statements) {
                if (statement instanceof J.MethodInvocation && isAddEnvironmentMethod((J.MethodInvocation) statement)) {
                    J.MethodInvocation methodInvocation = (J.MethodInvocation) statement;
                    if (collectedEnvironmentMethods.isEmpty() || isCollectedContextOrEnvironment(collectedEnvironmentMethods, methodInvocation)) {
                        collectedEnvironmentMethods.add(methodInvocation);
                        requiresRemoval = true;
                    } else {
                        newStatements.add(coalesceToFluentMethod(collectedEnvironmentMethods));
                        collectedEnvironmentMethods = new ArrayList<>();
                        collectedEnvironmentMethods.add(methodInvocation);
                    }
                } else {
                    if (!collectedEnvironmentMethods.isEmpty()) {
                        newStatements.add(coalesceToFluentMethod(collectedEnvironmentMethods));
                        collectedEnvironmentMethods = new ArrayList<>();
                    }
                    newStatements.add(statement);
                }
            }

            if (!collectedEnvironmentMethods.isEmpty()) {
                newStatements.add(coalesceToFluentMethod(collectedEnvironmentMethods));
            }

            if (requiresRemoval) {
                doAfterVisit(new ReplaceDeprecatedEnvironmentTestUtils.RemoveEnvironmentTestUtilsVisitor());
            }

            return m.withBody(m.getBody().withStatements(newStatements));
        }

        private boolean isCollectedContextOrEnvironment(List<J.MethodInvocation> collectedMethods, J.MethodInvocation methodInvocation) {
            if (methodInvocation.getArguments().isEmpty() ||
                    collectedMethods.isEmpty() ||
                    collectedMethods.get(0).getArguments().isEmpty()) {
                return false;
            }
            J.MethodInvocation collectedMethod = collectedMethods.get(0);
            Expression contextOrEnvironmentToCheck = getContextOrEnvironmentArgument(methodInvocation);
            Expression collectedContextOrEnvironment = getContextOrEnvironmentArgument(collectedMethod);

            Expression environmentNameToCheck = getEnvironmentNameArgument(methodInvocation);
            Expression collectedEnvironmentName = getEnvironmentNameArgument(collectedMethod);

            return !(contextOrEnvironmentToCheck instanceof J.NewClass) &&
                    SemanticallyEqual.areEqual(contextOrEnvironmentToCheck, collectedContextOrEnvironment) &&
                    (environmentNameToCheck == null && collectedEnvironmentName == null) ||
                    (environmentNameToCheck != null && collectedEnvironmentName != null &&
                    SemanticallyEqual.areEqual(environmentNameToCheck, collectedEnvironmentName));
        }

        private @Nullable Expression getEnvironmentNameArgument(J.MethodInvocation methodInvocation) {
            if (methodInvocation.getArguments().size() < MINIMUM_ARGUMENT_COUNT_WITH_NAME) {
                return null;
            }
            Expression firstArgument = methodInvocation.getArguments().get(0);

            if (firstArgument.getType() != null && firstArgument.getType().equals(JavaType.Primitive.String)) {
                return firstArgument;
            }
            return null;
        }

        private List<Expression> getPairArguments(J.MethodInvocation methodInvocation) {
            if (methodInvocation.getArguments().size() < MINIMUM_ARGUMENT_COUNT) {
                throw new IllegalArgumentException(""getPairArguments requires a method with at least "" + MINIMUM_ARGUMENT_COUNT + "" arguments"");
            }
            List<Expression> pairArguments = new ArrayList<>();
            int startingIndex = isNamedEnvironmentMethod(methodInvocation) ? 2 : 1;
            for (int i = startingIndex; i < methodInvocation.getArguments().size(); i++) {
                pairArguments.add(methodInvocation.getArguments().get(i));
            }
            return pairArguments;
        }

        private Expression getContextOrEnvironmentArgument(J.MethodInvocation methodInvocation) {
            if (methodInvocation.getArguments().size() < MINIMUM_ARGUMENT_COUNT) {
                throw new IllegalArgumentException(""getContextOrEnvironmentArgument requires a method with at least "" + MINIMUM_ARGUMENT_COUNT + "" arguments"");
            }
            return methodInvocation.getArguments().get(isNamedEnvironmentMethod(methodInvocation) ? 1 : 0);
        }

        private J.MethodInvocation coalesceToFluentMethod(List<J.MethodInvocation> collectedMethods) {
            if (collectedMethods.isEmpty()) {
                throw new IllegalArgumentException(""collectedMethods must have at least one element"");
            }
            J.MethodInvocation toReplace = collectedMethods.get(0);

            String currentTemplateString = generateTemplateString(collectedMethods);
            List<Expression> parameters = generateParameters(collectedMethods);

            return toReplace.withMarkers(toReplace.getMarkers().addIfAbsent(new ReplaceEnvironmentUtilsMarker(currentTemplateString, parameters, UUID.randomUUID())));
        }

        private List<Expression> generateParameters(List<J.MethodInvocation> collectedMethods) {
            if (collectedMethods.isEmpty()) {
                throw new IllegalArgumentException(""collectedMethods must have at least one element"");
            }
            List<Expression> parameters = new ArrayList<>();
            for (J.MethodInvocation collectedMethod : collectedMethods) {
                parameters.addAll(getPairArguments(collectedMethod));
            }
            parameters.add(getContextOrEnvironmentArgument(collectedMethods.get(0)));

            if (isNamedEnvironmentMethod(collectedMethods.get(0))) {
                parameters.add(collectedMethods.get(0).getArguments().get(0));
            }

            return parameters;
        }

        private String generateTemplateString(List<J.MethodInvocation> collectedMethods) {
            StringBuilder template = new StringBuilder(""TestPropertyValues"");
            boolean appendOf = true;
            for (J.MethodInvocation methodInvocation : collectedMethods) {
                for (int j = isNamedEnvironmentMethod(methodInvocation) ? 2 : 1; j < methodInvocation.getArguments().size(); j++) {
                    template.append(""."").append(appendOf ? ""of"" : ""and"").append(""(#{any()})"");
                    appendOf = false;
                }
            }
            if (isNamedEnvironmentMethod(collectedMethods.get(0))) {
                template.append("".applyTo(#{any()}, TestPropertyValues.Type.MAP, #{any()})"");
            } else {
                template.append("".applyTo(#{any()})"");
            }
            return template.toString();
        }

        private boolean isAddEnvironmentMethod(J.MethodInvocation method) {
            return APP_CONTEXT.matches(method) || ENVIRONMENT.matches(method) || isNamedEnvironmentMethod(method);
        }

        private boolean isNamedEnvironmentMethod(J.MethodInvocation method) {
            return NAMED_ENVIRONMENT.matches(method);
        }
    }

    private static class RemoveEnvironmentTestUtilsVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            Optional<ReplaceEnvironmentUtilsMarker> maybeMarker = m.getMarkers().findFirst(ReplaceEnvironmentUtilsMarker.class);
            if (maybeMarker.isPresent()) {
                ReplaceEnvironmentUtilsMarker marker = maybeMarker.get();
                m = JavaTemplate.builder(marker.templateString)
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion()
                        .classpathFromResources(ctx, ""spring-boot-test-2.*""))
                    .imports(""org.springframework.boot.test.util.TestPropertyValues"")
                    .build().apply(
                        getCursor(),
                        m.getCoordinates().replace(),
                        marker.parameters.toArray()
                );

                maybeRemoveImport(""org.springframework.boot.test.util.EnvironmentTestUtils.addEnvironment"");
                maybeAddImport(""org.springframework.boot.test.util.TestPropertyValues"");
            }
            return m;
        }
    }
}
",{}
Unconditionally adds `@DependsOnDatabaseInitialization` to Spring Beans and Components depending on `javax.sql.DataSource`,"Beans of certain well-known types, such as `JdbcTemplate`, will be ordered so that they are initialized ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class DatabaseComponentAndBeanInitializationOrderingUnconditionally extends Recipe {

    private static final String JAVAX_SQL_DATA_SOURCE = ""javax.sql.DataSource"";
    private static final List<String> WELL_KNOW_DATA_SOURCE_TYPES = Arrays.asList(
            ""com.zaxxer.hikari.HikariDataSource"",
            ""javax.persistence.EntityManagerFactory"",
            ""liquibase.integration.spring.SpringLiquibase"",
            ""org.jooq.DSLContext"",
            ""org.springframework.jdbc.core.JdbcTemplate"",
            ""org.springframework.jdbc.core.JdbcOperations"",
            ""org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations"",
            ""org.springframework.orm.jpa.AbstractEntityManagerFactoryBean""
    );

    @Override
    public String getDisplayName() {
        return ""Unconditionally adds `@DependsOnDatabaseInitialization` to Spring Beans and Components depending on `javax.sql.DataSource`"";
    }

    @Override
    public String getDescription() {
        return ""Beans of certain well-known types, such as `JdbcTemplate`, will be ordered so that they are initialized "" +
                ""after the database has been initialized. If you have a bean that works with the `DataSource` directly, "" +
                ""annotate its class or `@Bean` method with `@DependsOnDatabaseInitialization` to ensure that it too is "" +
                ""initialized after the database has been initialized. See the "" +
                ""[release notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#initialization-ordering) "" +
                ""for more. This recipe will not check if the `@DependsOnDatabaseInitialization` annotation is on the classpath. "" +
                ""This recipe is best combined with a precondition, as seen in `DatabaseComponentAndBeanInitializationOrdering`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        AnnotationMatcher dataSourceAnnotationMatcher = new AnnotationMatcher(""@org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitialization"");
        AnnotationMatcher beanAnnotationMatcher = new AnnotationMatcher(""@org.springframework.context.annotation.Bean"");
        List<AnnotationMatcher> componentAnnotationMatchers = Arrays.asList(
                new AnnotationMatcher(""@org.springframework.stereotype.Repository""),
                new AnnotationMatcher(""@org.springframework.stereotype.Component""),
                new AnnotationMatcher(""@org.springframework.stereotype.Service""),
                new AnnotationMatcher(""@org.springframework.boot.test.context.TestComponent""));

        return Preconditions.check(Preconditions.or(
                new UsesType<>(""org.springframework.stereotype.Repository"", false),
                new UsesType<>(""org.springframework.stereotype.Repository"", false),
                new UsesType<>(""org.springframework.stereotype.Component"", false),
                new UsesType<>(""org.springframework.stereotype.Service"", false),
                new UsesType<>(""org.springframework.boot.test.context.TestComponent"", false),
                new UsesType<>(""org.springframework.context.annotation.Bean"", false)
        ), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                if (method.getMethodType() != null) {
                    if (!isInitializationAnnoPresent(md.getLeadingAnnotations()) && isBean(md) &&
                            requiresInitializationAnnotation(method.getMethodType().getReturnType())) {
                        md = JavaTemplate.builder(""@DependsOnDatabaseInitialization"")
                                .imports(""org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitialization"")
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""spring-boot-2.*""))
                                .build()
                                .apply(
                                        getCursor(),
                                        md.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))
                                );
                        maybeAddImport(""org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitialization"");
                    }
                }
                return md;
            }

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (!isInitializationAnnoPresent(cd.getLeadingAnnotations()) && isComponent(cd) &&
                        requiresInitializationAnnotation(cd.getType())) {
                    cd = JavaTemplate.builder(""@DependsOnDatabaseInitialization"")
                            .imports(""org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitialization"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-boot-2.*""))
                            .build()
                            .apply(
                                    getCursor(),
                                    cd.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))
                            );
                    maybeAddImport(""org.springframework.boot.sql.init.dependency.DependsOnDatabaseInitialization"");
                }
                return cd;
            }

            private boolean isComponent(J.ClassDeclaration cd) {
                for (J.Annotation classAnno : cd.getLeadingAnnotations()) {
                    for (AnnotationMatcher componentMatcher : componentAnnotationMatchers) {
                        if (componentMatcher.matches(classAnno)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private boolean isBean(J.MethodDeclaration methodDeclaration) {
                for (J.Annotation leadingAnnotation : methodDeclaration.getLeadingAnnotations()) {
                    if (beanAnnotationMatcher.matches(leadingAnnotation)) {
                        return true;
                    }
                }
                return false;
            }

            @SuppressWarnings(""BooleanMethodIsAlwaysInverted"")
            private boolean isInitializationAnnoPresent(@Nullable List<J.Annotation> annotations) {
                return annotations != null && annotations.stream().anyMatch(dataSourceAnnotationMatcher::matches);
            }

            private boolean requiresInitializationAnnotation(@Nullable JavaType type) {
                if (type == null) {
                    return false;
                }
                if (isWellKnownDataSourceInitializationType(type)) {
                    return false;
                }
                if (type instanceof JavaType.FullyQualified) {
                    JavaType.FullyQualified fq = (JavaType.FullyQualified) type;
                    // type fields
                    for (JavaType.Variable var : fq.getMembers()) {
                        if (isDataSourceType(var.getType())) {
                            return true;
                        }
                    }
                    // type methods
                    for (JavaType.Method method : fq.getMethods()) {
                        if (isDataSourceType(method.getReturnType())) {
                            return true;
                        }
                        for (JavaType parameterType : method.getParameterTypes()) {
                            if (isDataSourceType(parameterType)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            private boolean isDataSourceType(@Nullable JavaType type) {
                return TypeUtils.isAssignableTo(JAVAX_SQL_DATA_SOURCE, type);
            }

            private boolean isWellKnownDataSourceInitializationType(@Nullable JavaType type) {
                if (type != null) {
                    for (String wellKnowDataSourceType : WELL_KNOW_DATA_SOURCE_TYPES) {
                        if (TypeUtils.isAssignableTo(wellKnowDataSourceType, type)) {
                            return true;
                        }
                    }
                }
                return false;
            }
        });
    }
}
",{}
Migrate ,Migrate ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.properties.AddProperty;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;

@EqualsAndHashCode(callSuper = false)
@Value
class MigrateDatabaseCredentialsForToolProperties extends Recipe {
    @Language(""markdown"")
    String tool;

    @Override
    public String getDisplayName() {
        return ""Migrate "" + tool + "" credentials"";
    }

    @Override
    public String getDescription() {
        return ""Migrate "" + tool + "" credentials."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                if (FindProperties.find(file, ""spring."" + tool + "".username"", true).isEmpty() &&
                        FindProperties.find(file, ""spring."" + tool + "".password"", true).isEmpty()) {
                    doAfterVisit(new FindProperties(""spring."" + tool + "".url"", true).getVisitor());
                }
                return file;
            }
        }, new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                doAfterVisit(new AddProperty(""spring."" + tool + "".username"", ""${spring.datasource.username}"", null, null).getVisitor());
                doAfterVisit(new AddProperty(""spring."" + tool + "".password"", ""${spring.datasource.password}"", null, null).getVisitor());
                return file;
            }
        });
    }
}
",{}
Adjust configuration classes to use the `WebServerFactoryCustomizer` interface,Find any classes implementing `EmbeddedServletContainerCustomizer` and change the interface to ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import static java.util.Objects.requireNonNull;

public class ChangeEmbeddedServletContainerCustomizer extends Recipe {

    private static final String DEPRECATED_INTERFACE_FQN = ""org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer"";

    @Override
    public String getDisplayName() {
        return ""Adjust configuration classes to use the `WebServerFactoryCustomizer` interface"";
    }

    @Override
    public String getDescription() {
        return ""Find any classes implementing `EmbeddedServletContainerCustomizer` and change the interface to "" +
                ""`WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(DEPRECATED_INTERFACE_FQN, false), new JavaIsoVisitor<ExecutionContext>() {
            private J.@Nullable ParameterizedType webFactoryCustomizerIdentifier;

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);

                return c.withImplements(
                        ListUtils.map(c.getImplements(), i -> {
                            if (TypeUtils.isOfClassType(i.getType(), DEPRECATED_INTERFACE_FQN)) {
                                maybeAddImport(""org.springframework.boot.web.server.WebServerFactoryCustomizer"");
                                maybeAddImport(""org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory"");
                                maybeRemoveImport(DEPRECATED_INTERFACE_FQN);
                                return getWebFactoryCustomizerIdentifier(ctx);
                            }
                            return i;
                        })
                );
            }

            private J.ParameterizedType getWebFactoryCustomizerIdentifier(ExecutionContext ctx) {
                // Really no need to use a JavaTemplate in this recipe, we just compile a stubbed out class and extract
                // the J.ParameterizedType from the class's stub's implements.
                if (webFactoryCustomizerIdentifier == null) {
                    JavaParser parser = JavaParser
                            .fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-boot-2.*"")
                            .build();
                    J.CompilationUnit cu = parser.parse(
                                    ""import org.springframework.boot.web.server.WebServerFactoryCustomizer;\n"" +
                                    ""import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;\n"" +
                                    ""public abstract class Template implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {}""
                            )
                            .map(J.CompilationUnit.class::cast)
                            .findFirst()
                            .get();

                    webFactoryCustomizerIdentifier = (J.ParameterizedType) requireNonNull(cu.getClasses()
                            .get(0).getImplements()).get(0);
                }

                return webFactoryCustomizerIdentifier.withId(Tree.randomId());
            }
        });
    }
}
",{}
Replace `@ExtendWith` and `@ContextConfiguration` with `@SpringJunitConfig`,"Replaces `@ExtendWith(SpringRunner.class)` and `@ContextConfiguration` with `@SpringJunitConfig`, ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CopyOnWriteArrayList;

public class ReplaceExtendWithAndContextConfiguration extends Recipe {
    private static final String FQN_EXTEND_WITH = ""org.junit.jupiter.api.extension.ExtendWith"";
    private static final String FQN_CONTEXT_CONFIGURATION = ""org.springframework.test.context.ContextConfiguration"";
    private static final String FQN_SPRING_JUNIT_CONFIG = ""org.springframework.test.context.junit.jupiter.SpringJUnitConfig"";

    @Override
    public String getDisplayName() {
        return ""Replace `@ExtendWith` and `@ContextConfiguration` with `@SpringJunitConfig`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces `@ExtendWith(SpringRunner.class)` and `@ContextConfiguration` with `@SpringJunitConfig`, "" +
                ""preserving attributes on `@ContextConfiguration`, unless `@ContextConfiguration(loader = ...)` is used."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.and(new UsesType<>(FQN_EXTEND_WITH, false), new UsesType<>(FQN_CONTEXT_CONFIGURATION, false)),
                new JavaIsoVisitor<ExecutionContext>() {
                    private final AnnotationMatcher CONTEXT_CONFIGURATION_ANNOTATION_MATCHER = new AnnotationMatcher(""@"" + FQN_CONTEXT_CONFIGURATION, true);

                    {
                        doAfterVisit(new UnnecessarySpringExtension().getVisitor());
                    }

                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        J.Annotation a = super.visitAnnotation(annotation, ctx);

                        if (CONTEXT_CONFIGURATION_ANNOTATION_MATCHER.matches(a) && getCursor().getParentOrThrow().getValue() instanceof J.ClassDeclaration) {
                            // @SpringJUnitConfig supports every attribute on @ContextConfiguration except loader()
                            // If it's present, skip the transformation since removing @ContextConfiguration will do harm
                            Optional<J.Assignment> loaderArg = findLoaderArgument(a);
                            if (loaderArg.isPresent()) {
                                return a;
                            }

                            // @ContextConfiguration value() is an alias for locations()
                            // @SpringJUnitConfig value() is an alias for classes()
                            // Since these are incompatible, we need to map value() to locations()
                            // If value() is present (either explicitly or implicitly), replace it with locations()
                            // Note that it's invalid to specify both value() and locations() on @ContextConfiguration
                            if (a.getArguments() != null) {
                                List<Expression> newArgs = new CopyOnWriteArrayList<>(a.getArguments());
                                replaceValueArgumentWithLocations(a, newArgs);
                                a = a.withArguments(newArgs);
                            }

                            // Change the @ContextConfiguration annotation to @SpringJUnitConfig
                            maybeRemoveImport(FQN_CONTEXT_CONFIGURATION);
                            maybeAddImport(FQN_SPRING_JUNIT_CONFIG);
                            a = (J.Annotation) new ChangeType(FQN_CONTEXT_CONFIGURATION, FQN_SPRING_JUNIT_CONFIG, false)
                                    .getVisitor().visitNonNull(a, ctx, getCursor().getParentOrThrow());
                            a = autoFormat(a, ctx);
                        }

                        return a;
                    }

                    private void replaceValueArgumentWithLocations(J.Annotation a, List<Expression> newArgs) {
                        for (int i = 0; i < newArgs.size(); i++) {
                            Expression expression = newArgs.get(i);
                            if (expression instanceof J.Assignment) {
                                J.Assignment assignment = (J.Assignment) expression;
                                String name = ((J.Identifier) assignment.getVariable()).getSimpleName();
                                if (""value"".equals(name)) {
                                    J.Assignment as = createLocationsAssignment(a, assignment.getAssignment())
                                            .withPrefix(expression.getPrefix());
                                    newArgs.set(i, as);
                                    break;
                                }
                            } else {
                                // The implicit assignment to ""value""
                                J.Assignment as = createLocationsAssignment(a, expression).withPrefix(expression.getPrefix());
                                newArgs.set(i, as);
                                break;
                            }
                        }
                    }

                    private J.Assignment createLocationsAssignment(J.Annotation annotation, Expression value) {
                        return (J.Assignment) ((J.Annotation)
                            JavaTemplate.builder(""locations = #{any(String)}"")
                                .contextSensitive().build().apply(
                                    getCursor(),
                                    annotation.getCoordinates().replaceArguments(),
                                    value
                                )).getArguments().get(0);
                    }
                });
    }

    private static Optional<J.Assignment> findLoaderArgument(J.Annotation annotation) {
        if (annotation.getArguments() == null) {
            return Optional.empty();
        }
        return annotation.getArguments().stream()
                .filter(arg -> arg instanceof J.Assignment &&
                        ((J.Assignment) arg).getVariable() instanceof J.Identifier &&
                        ""loader"".equals(((J.Identifier) ((J.Assignment) arg).getVariable()).getSimpleName()))
                .map(J.Assignment.class::cast)
                .findFirst();
    }
}
",{}
Migrate ,Migrate ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.yaml.CoalesceProperties;
import org.openrewrite.yaml.MergeYaml;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

@EqualsAndHashCode(callSuper = false)
@Value
class MigrateDatabaseCredentialsForToolYaml extends Recipe {
    @Language(""markdown"")
    String tool;

    @Override
    public String getDisplayName() {
        return ""Migrate "" + tool + "" credentials"";
    }

    @Override
    public String getDescription() {
        return ""Migrate "" + tool + "" credentials."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new YamlVisitor<ExecutionContext>() {
            @Override
            public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                if (FindProperty.find(documents, ""spring."" + tool + "".username"", true).isEmpty() &&
                        FindProperty.find(documents, ""spring."" + tool + "".password"", true).isEmpty()) {
                    doAfterVisit(new FindProperty(""spring."" + tool + "".url"", true, null).getVisitor());
                }
                return documents;
            }
        }, new YamlVisitor<ExecutionContext>() {
            @Override
            public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                doAfterVisit(new MergeYaml(""$.spring."" + tool, ""username: ${spring.datasource.username}"", true, null, null, null, null, null).getVisitor());
                doAfterVisit(new MergeYaml(""$.spring."" + tool, ""password: ${spring.datasource.password}"", true, null, null, null, null, null).getVisitor());
                doAfterVisit(new CoalesceProperties(null, null).getVisitor());
                return documents;
            }
        });
    }
}
",{}
Use `ErrorProperties#IncludeStacktrace.ON_PARAM`,`ErrorProperties#IncludeStacktrace.ON_TRACE_PARAM` was deprecated in 2.3.x and removed in 2.5.0.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Flag;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

public class MigrateErrorPropertiesIncludeStackTraceConstants extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use `ErrorProperties#IncludeStacktrace.ON_PARAM`"";
    }

    @Override
    public String getDescription() {
        return ""`ErrorProperties#IncludeStacktrace.ON_TRACE_PARAM` was deprecated in 2.3.x and removed in 2.5.0."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.autoconfigure.web.ErrorProperties$IncludeStacktrace"", false),
                new MigrateErrorPropertiesIncludeStackTraceConstants.UpdateDeprecatedConstantFieldNames());
    }

    private static class UpdateDeprecatedConstantFieldNames extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.FullyQualified ORIGINAL_FQN =
                JavaType.ShallowClass.build(""org.springframework.boot.autoconfigure.web.ErrorProperties$IncludeStacktrace"");

        private final Map<String, String> updateDeprecatedFields = new HashMap<>();

        UpdateDeprecatedConstantFieldNames() {
            updateDeprecatedFields.put(""ON_TRACE_PARAM"", ""ON_PARAM"");
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

            if (!classDecl.getSimpleName().equals(ORIGINAL_FQN.getClassName())) {
                maybeRemoveImport(ORIGINAL_FQN);
            }

            return cd;
        }

        @Override
        public J.Import visitImport(J.Import anImport, ExecutionContext ctx) {
            J.Identifier name = anImport.getQualid().getName();
            if (anImport.isStatic() && updateDeprecatedFields.containsKey(name.getSimpleName()) &&
                    TypeUtils.isOfClassType(anImport.getQualid().getTarget().getType(), ORIGINAL_FQN.getFullyQualifiedName())) {
                return anImport.withQualid(anImport.getQualid().withName(name.withSimpleName(updateDeprecatedFields.get(name.getSimpleName()))));
            }
            return super.visitImport(anImport, ctx);
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);
            if (isTargetClass() &&
                    TypeUtils.isOfType(ORIGINAL_FQN, fa.getTarget().getType()) &&
                    updateDeprecatedFields.containsKey(fa.getName().getSimpleName())) {

                fa = fa.withName(fa.getName().withSimpleName(updateDeprecatedFields.get(fa.getName().getSimpleName())));
                String className;
                if (fa.getTarget() instanceof J.Identifier) {
                    className = ORIGINAL_FQN.getClassName().substring(ORIGINAL_FQN.getClassName().lastIndexOf(""."") + 1);
                } else {
                    className = ORIGINAL_FQN.getClassName();
                }

                fa = fa.withTarget(new J.Identifier(
                        Tree.randomId(),
                        fa.getTarget().getPrefix(),
                        fa.getTarget().getMarkers(),
                        emptyList(),
                        className,
                        ORIGINAL_FQN,
                        null));
            }
            return fa;
        }

        @Override
        public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
            J.Identifier id = super.visitIdentifier(identifier, ctx);
            if (isTargetClass() && isTargetFieldType(id) && updateDeprecatedFields.containsKey(id.getSimpleName())) {
                JavaType.Variable fieldType = id.getFieldType();
                id = new J.Identifier(
                        Tree.randomId(),
                        id.getPrefix(),
                        id.getMarkers(),
                        emptyList(),
                        updateDeprecatedFields.get(id.getSimpleName()),
                        id.getType(),
                        fieldType == null ? null : new JavaType.Variable(
                                null,
                                Flag.flagsToBitMap(fieldType.getFlags()),
                                updateDeprecatedFields.get(id.getSimpleName()),
                                ORIGINAL_FQN,
                                ORIGINAL_FQN,
                                emptyList()));
            }
            return id;
        }

        private boolean isTargetClass() {
            Cursor parentCursor = getCursor().dropParentUntil(
                    is -> is instanceof SourceFile ||
                            is instanceof J.ClassDeclaration);
            return parentCursor.getValue() instanceof J.ClassDeclaration &&
                    !((J.ClassDeclaration) parentCursor.getValue()).getName().getSimpleName().equals(ORIGINAL_FQN.getClassName());
        }

        private boolean isTargetFieldType(J.Identifier identifier) {
            if (identifier.getFieldType() != null) {
                JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(identifier.getFieldType().getOwner());
                return fqn != null && ORIGINAL_FQN.getFullyQualifiedName().equals(fqn.getFullyQualifiedName());
            }
            return false;
        }
    }

}
",{}
Use `AutoConfiguration#imports`,Use `AutoConfiguration#imports` instead of the deprecated entry ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.Marker;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextParser;

import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.Collections.sort;
import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toSet;

@EqualsAndHashCode(callSuper = false)
@Value
public class MoveAutoConfigurationToImportsFile extends ScanningRecipe<MoveAutoConfigurationToImportsFile.Accumulator> {
    private static final String AUTOCONFIGURATION_FILE = ""org.springframework.boot.autoconfigure.AutoConfiguration.imports"";
    private static final String ENABLE_AUTO_CONFIG_KEY = ""org.springframework.boot.autoconfigure.EnableAutoConfiguration"";

    @Option(displayName = ""Preserve `spring.factories` files"",
            description = ""Don't delete the `spring.factories` for backward compatibility."",
            required = false)
    @Nullable
    Boolean preserveFactoriesFile;

    @Override
    public String getDisplayName() {
        return ""Use `AutoConfiguration#imports`"";
    }

    @Override
    public String getDescription() {
        return ""Use `AutoConfiguration#imports` instead of the deprecated entry "" +
               ""`EnableAutoConfiguration` in `spring.factories` when defining "" +
               ""autoconfiguration classes."";
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        // First pass will look for any spring.factories source files to collect any auto-config classes in those files
        // and remove them. We build a map to the path of the target import file (computed relative to the spring.factories
        // file) to a list of autoconfiguration classes from the spring.factories and any markers that may have been
        // on the factory class. If we end up creating a new file, we will copy the markers to this file as well.

        // We also look for any existing import files (because we may need to merge entries from the spring.factories into
        // an existing file).

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof PlainText) {
                    PlainText source = ((PlainText) tree);
                    Path sourcePath = source.getSourcePath();
                    if (sourcePath.endsWith(""spring.factories"")) {
                        Set<String> configs = new HashSet<>();
                        extractAutoConfigsFromSpringFactory(source, configs);
                        if (!configs.isEmpty()) {
                            acc.getExistingSpringFactories().add(sourcePath);
                            acc.getTargetImports().put(sourcePath.getParent().resolve(""spring/"" + AUTOCONFIGURATION_FILE),
                                    new TargetImports(configs, source.getMarkers().getMarkers()));
                            acc.getAllFoundConfigs().addAll(configs);
                        }
                    } else if (sourcePath.endsWith(AUTOCONFIGURATION_FILE)) {
                        acc.getExistingImportFiles().add(sourcePath);
                    }
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        List<SourceFile> newImportFiles = new ArrayList<>();
        for (Map.Entry<Path, TargetImports> entry : acc.getTargetImports().entrySet()) {
            if (entry.getValue().getAutoConfigurations().isEmpty() || acc.getExistingImportFiles().contains(entry.getKey())) {
                continue;
            }

            List<String> finalList = new ArrayList<>(entry.getValue().getAutoConfigurations());
            sort(finalList);

            PlainTextParser parser = new PlainTextParser();
            PlainText brandNewFile = parser.parse(String.join(""\n"", finalList))
                    .map(PlainText.class::cast)
                    .findFirst()
                    .get();
            newImportFiles.add(brandNewFile
                    .withSourcePath(entry.getKey())
                    .withMarkers(brandNewFile.getMarkers().withMarkers(entry.getValue().getMarkers()))
            );
        }

        if (!newImportFiles.isEmpty()) {
            return newImportFiles;
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        Set<Path> mergeTargets = acc.getExistingImportFiles().stream().filter(acc.getTargetImports()::containsKey).collect(toSet());
        if (mergeTargets.isEmpty() && acc.getAllFoundConfigs().isEmpty() && acc.getExistingSpringFactories().isEmpty()) {
            return TreeVisitor.noop();
        }

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile source = (SourceFile) tree;
                Path sourcePath = source.getSourcePath();
                if (tree instanceof PlainText) {
                    if (mergeTargets.contains(sourcePath)) {
                        //If there is both a spring.factories and an existing imports file, merge the contents of both into the import
                        tree = mergeEntries(source, acc.getTargetImports().get(sourcePath).getAutoConfigurations());
                    } else if (acc.getExistingSpringFactories().contains(sourcePath)) {
                        tree = extractAutoConfigsFromSpringFactory((PlainText) source, new HashSet<>());
                    }
                } else if (tree instanceof J.CompilationUnit) {
                    tree = new AddAutoConfigurationAnnotation(acc.getAllFoundConfigs()).visit(tree, ctx);
                }
                return tree;
            }
        };
    }

    private @Nullable PlainText extractAutoConfigsFromSpringFactory(PlainText springFactory, Set<String> configs) {
        String contents = springFactory.getText();
        int state = 0;
        int index = 0;

        StringBuilder currentKey = new StringBuilder();
        StringBuilder currentValue = new StringBuilder();
        int keyIndexStart = 0;
        int valueIndexEnd = 0;

        while (index < contents.length()) {
            if (contents.charAt(index) == '\\' && isLineBreakOrEof(contents, index + 1)) {
                //If this is a line continuous, advance to the next line and then chew up any white space.
                index = advanceToNextLine(contents, index);
                index = advancePastWhiteSpace(contents, index);
            }
            if (state == 0) {
                // Find New Key
                index = advancePastWhiteSpace(contents, index);
                if (index >= contents.length()) {
                    break;
                }
                if (contents.charAt(index) == '#') {
                    //Comment
                    index = advanceToNextLine(contents, index);
                } else {
                    state = 1;
                }
                continue;
            } else if (state == 1) {
                if (isLineBreakOrEof(contents, index)) {
                    //Building a key and encountered a line ending, if there is a key, the value is null, reset
                    //and continue;
                    currentKey.setLength(0);
                    currentValue.setLength(0);
                    state = 0;
                } else if (contents.charAt(index) == '=' || contents.charAt(index) == ':' || Character.isWhitespace(contents.charAt(index))) {
                    state = 2;
                } else {
                    if (currentKey.length() == 0) {
                        keyIndexStart = index;
                    }
                    currentKey.append(contents.charAt(index));
                }
            } else {
                //State == 2
                //Building Value
                if (isLineBreakOrEof(contents, index)) {
                    //End of value!
                    if (ENABLE_AUTO_CONFIG_KEY.contentEquals(currentKey)) {
                        //Found the key, lets break now.
                        index = advanceToNextLine(contents, index);
                        valueIndexEnd = Math.min(index, contents.length());
                        break;
                    } else {
                        currentKey.setLength(0);
                        currentValue.setLength(0);
                        state = 0;
                    }
                } else {
                    currentValue.append(contents.charAt(index));
                }
            }
            index++;
        }

        if (ENABLE_AUTO_CONFIG_KEY.contentEquals(currentKey)) {
            Stream.of(currentValue.toString().split("","")).map(String::trim).forEach(configs::add);
            if (Boolean.FALSE.equals(preserveFactoriesFile)) {
                String newContent = contents.substring(0, keyIndexStart) + contents.substring(valueIndexEnd == 0 ? contents.length() : valueIndexEnd);
                return newContent.isEmpty() ? null : springFactory.withText(newContent);
            }
        }
        return springFactory;
    }

    private static int advancePastWhiteSpace(String contents, int index) {
        while (index < contents.length() && contents.charAt(index) != '\r' && contents.charAt(index) != '\n' && Character.isWhitespace(contents.charAt(index))) {
            index++;
        }
        return index;
    }

    private static int advanceToNextLine(String contents, int index) {
        while (index < contents.length() && !isLineBreakOrEof(contents, index)) {
            index++;
        }
        if (index + 1 < contents.length() && contents.charAt(index) == '\r' && contents.charAt(index + 1) == '\n') {
            index = index + 2;
        } else {
            index++;
        }
        return index;
    }

    private static boolean isLineBreakOrEof(String contents, int index) {
        if (index == contents.length()) {
            return true;
        }
        char first = contents.charAt(index);
        Character second = index + 1 < contents.length() ? contents.charAt(index + 1) : null;
        return (second != null && first == '\r' && second == '\n') || first == '\r' || first == '\n';
    }

    private static SourceFile mergeEntries(SourceFile before, Set<String> configClasses) {
        PlainText plainText = (PlainText) before;
        Set<String> original = new HashSet<>(Arrays.asList(plainText.getText().split(""\n"")));
        Set<String> merged = new TreeSet<>(configClasses);
        merged.addAll(original);

        if (merged.size() != original.size()) {
            return plainText.withText(String.join(""\n"", merged));
        }
        return before;
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class AddAutoConfigurationAnnotation extends JavaIsoVisitor<ExecutionContext> {
        private static final String AUTO_CONFIGURATION_FQN = ""org.springframework.boot.autoconfigure.AutoConfiguration"";
        private static final String CONFIGURATION_FQN = ""org.springframework.context.annotation.Configuration"";
        private static final AnnotationMatcher CONFIGURATION_MATCHER = new AnnotationMatcher(CONFIGURATION_FQN);

        Set<String> fullyQualifiedConfigClasses;

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);

            if (c.getType() != null && fullyQualifiedConfigClasses.contains(c.getType().getFullyQualifiedName())) {
                c = maybeAddAutoconfiguration(c, ctx);
                c = maybeRemoveConfiguration(c);
            }
            return c;
        }

        private J.ClassDeclaration maybeRemoveConfiguration(J.ClassDeclaration c) {
            maybeRemoveImport(CONFIGURATION_FQN);
            return c.withLeadingAnnotations(ListUtils.map(c.getLeadingAnnotations(), annotation ->
                    CONFIGURATION_MATCHER.matches(annotation) ? null : annotation));
        }

        private J.ClassDeclaration maybeAddAutoconfiguration(J.ClassDeclaration c, ExecutionContext ctx) {
            if (FindAnnotations.find(c, AUTO_CONFIGURATION_FQN).isEmpty()) {
                maybeAddImport(AUTO_CONFIGURATION_FQN);
                return JavaTemplate.builder(""@AutoConfiguration"")
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-boot-autoconfigure-2.7.*""))
                        .imports(AUTO_CONFIGURATION_FQN)
                        .build()
                        .apply(getCursor(), c.getCoordinates().addAnnotation(comparing(J.Annotation::getSimpleName)));
            }
            return c;
        }
    }

    @Value
    static class Accumulator {
        Set<Path> existingSpringFactories = new HashSet<>();
        Set<Path> existingImportFiles = new HashSet<>();
        Set<String> allFoundConfigs = new HashSet<>();
        Map<Path, TargetImports> targetImports = new HashMap<>();
    }

    /**
     * Used to track the auto configurations defined in `spring.factories` (along with any markers on that file)
     */
    @Value
    static class TargetImports {
        Set<String> autoConfigurations;
        List<Marker> markers;
    }
}
",{}
Merge Spring `bootstrap.yml` with `application.yml`,"In Spring Boot 2.4, support for `bootstrap.yml` was removed. It's properties should be merged with `application.yml`.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import lombok.Data;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.spring.ExpandProperties;
import org.openrewrite.yaml.CoalescePropertiesVisitor;
import org.openrewrite.yaml.MergeYamlVisitor;
import org.openrewrite.yaml.YamlParser;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class MergeBootstrapYamlWithApplicationYaml extends ScanningRecipe<MergeBootstrapYamlWithApplicationYaml.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Merge Spring `bootstrap.yml` with `application.yml`"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Boot 2.4, support for `bootstrap.yml` was removed. It's properties should be merged with `application.yml`."";
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile source = (SourceFile) tree;
                Path sourcePath = source.getSourcePath();
                if (acc.getBootstrapYaml() == null && PathUtils.matchesGlob(sourcePath, ""**/main/resources/bootstrap.y*ml"")) {
                    acc.setBootstrapYaml(source);
                } else if (acc.getApplicationYaml() == null && PathUtils.matchesGlob(sourcePath, ""**/main/resources/application.y*ml"")) {
                    acc.setApplicationYaml(source);
                }
                return source;
            }
        };
    }

    @Override
    public Collection<SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        if (acc.getBootstrapYaml() instanceof Yaml.Documents && acc.getApplicationYaml() == null) {
            // rename
            Yaml.Documents yaml = (Yaml.Documents) acc.getBootstrapYaml();
            String fileName = PathUtils.matchesGlob(yaml.getSourcePath(), ""**/*.yaml"") ? ""application.yaml"" : ""application.yml"";
            Optional<SourceFile> newApplicationYaml = YamlParser.builder().build()
                                .parse("""")
                                .map(brandNewFile -> (SourceFile) brandNewFile
                                        .withSourcePath(yaml.getSourcePath().resolveSibling(fileName)))
                    .findFirst();
            if (newApplicationYaml.isPresent()) {
                acc.applicationYaml = newApplicationYaml.get();
                return singletonList(newApplicationYaml.get());
            }
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        if (!(acc.getBootstrapYaml() instanceof Yaml.Documents && acc.getApplicationYaml() instanceof Yaml.Documents)) {
            return TreeVisitor.noop();
        }

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile source = (SourceFile) tree;
                Path sourcePath = source.getSourcePath();
                if (sourcePath.equals(acc.getBootstrapYaml().getSourcePath())) {
                    // delete bootstrap.yml file
                    source = null;
                } else if (acc.getApplicationYaml() != null && sourcePath.equals(acc.getApplicationYaml().getSourcePath())) {
                    // update application.yml file
                    AtomicBoolean merged = new AtomicBoolean(false);

                    Yaml.Documents a = (Yaml.Documents) new ExpandProperties(null).getVisitor().visit(acc.getApplicationYaml(), ctx);
                    Yaml.Documents b = (Yaml.Documents) new ExpandProperties(null).getVisitor().visit(acc.getBootstrapYaml(), ctx);
                    assert a != null;
                    assert b != null;

                    //noinspection unchecked
                    source = new CoalescePropertiesVisitor<Integer>(null, null).visitDocuments(a.withDocuments(ListUtils.map(a.getDocuments(), doc -> {
                        if (doc == null) {
                            return null;
                        }
                        if (merged.compareAndSet(false, true) && FindProperty.find(doc, ""spring.config.activate.on-profile"", true).isEmpty()) {
                            Yaml.Document mergedDocument = doc;
                            Yaml.Document mergedDocumentOrNull;
                            for (Yaml.Document d : b.getDocuments()) {
                                if (FindProperty.find(d, ""spring.config.activate.on-profile"", true).isEmpty()) {
                                    mergedDocumentOrNull = (Yaml.Document) new MergeYamlVisitor<Integer>(mergedDocument.getBlock(), d.getBlock(), true, null, null, null).visit(mergedDocument, 0, new Cursor(new Cursor(null, a), mergedDocument));
                                    if (mergedDocumentOrNull != null) {
                                        mergedDocument = mergedDocumentOrNull;
                                    }
                                }
                            }
                            return mergedDocument;
                        }
                        return doc;
                    })), 0);
                }
                return source;
            }
        };
    }

    @Data
    static class Accumulator {
        @Nullable SourceFile bootstrapYaml;

        @Nullable SourceFile applicationYaml;
    }
}
",{}
Convert `HeadersConfigurer` chained calls into Lambda DSL,Converts `HeadersConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.UsesType;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public final class HeadersConfigurerLambdaDsl extends Recipe {

    private static final String FQN_HEADERS_CONFIGURER = ""org.springframework.security.config.annotation.web.configurers.HeadersConfigurer"";

    private static final Collection<String> APPLICABLE_METHOD_NAMES = Arrays.asList(
            ""contentTypeOptions"", ""xssProtection"", ""cacheControl"", ""httpStrictTransportSecurity"", ""frameOptions"",
            ""contentSecurityPolicy"", ""referrerPolicy"", ""permissionsPolicy"", ""crossOriginOpenerPolicy"",
            ""crossOriginEmbedderPolicy"", ""crossOriginResourcePolicy"");

    private static final Map<String, String> ARG_REPLACEMENTS = new HashMap<String, String>() {{
        put(""contentSecurityPolicy"", ""policyDirectives"");
        put(""referrerPolicy"", ""policy"");
    }};

    @Override
    public String getDisplayName() {
        return ""Convert `HeadersConfigurer` chained calls into Lambda DSL"";
    }

    @Override
    public String getDescription() {
        return ""Converts `HeadersConfigurer` chained call from Spring Security pre 5.2.x into new lambda DSL style calls and removes `and()` methods."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(FQN_HEADERS_CONFIGURER, true),
                new ConvertToSecurityDslVisitor<>(FQN_HEADERS_CONFIGURER, APPLICABLE_METHOD_NAMES, ARG_REPLACEMENTS)
        );
    }

}
",{}
Use `org.springframework.boot.web.server.LocalServerPort`,"Updates the package and adds the necessary dependency if `LocalServerPort` is in use. The package of `LocalServerPort` was changed in Spring Boot 2.0, necessitating changes.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.dependencies.AddDependency;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.List;

import static java.util.Collections.singletonList;

public class MigrateLocalServerPortAnnotation extends Recipe {
    private static final AnnotationMatcher LOCAL_SERVER_PORT_MATCHER =
        new AnnotationMatcher(""@org.springframework.boot.context.embedded.LocalServerPort"");

    @Override
    public String getDisplayName() {
        return ""Use `org.springframework.boot.web.server.LocalServerPort`"";
    }

    @Override
    public String getDescription() {
        return ""Updates the package and adds the necessary dependency if `LocalServerPort` is in use. The package of `LocalServerPort` was changed in Spring Boot 2.0, necessitating changes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.context.embedded.LocalServerPort"", false),
            new JavaIsoVisitor<ExecutionContext>() {
                @Override
                public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                    J.Annotation a = super.visitAnnotation(annotation, ctx);
                    if (LOCAL_SERVER_PORT_MATCHER.matches(annotation)) {
                        a = a.withAnnotationType(a.getAnnotationType().withType(JavaType.buildType(""org.springframework.boot.web.server.LocalServerPort"")));
                        maybeRemoveImport(""org.springframework.boot.context.embedded.LocalServerPort"");
                        maybeAddImport(""org.springframework.boot.web.server.LocalServerPort"");
                    }
                    return a;
                }
            });
    }

    @Override
    public List<Recipe> getRecipeList() {
        return singletonList(new AddDependency(
            ""org.springframework.boot"",
            ""spring-boot-starter-web"",
            ""2.0.x"",
            null,
            ""org.springframework.boot.web.server.LocalServerPort"",
            null,
            null,
            null, null, null, null, null, null, null));
    }
}
",{}
Use `MultipartConfigFactory` with `DataSize` arguments,Methods to set `DataSize` with primitive arguments were deprecated in 2.1 and removed in 2.2.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

public class MigrateMultipartConfigFactory extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use `MultipartConfigFactory` with `DataSize` arguments"";
    }

    @Override
    public String getDescription() {
        return ""Methods to set `DataSize` with primitive arguments were deprecated in 2.1 and removed in 2.2."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.web.servlet.MultipartConfigFactory"", true),
                new JavaIsoVisitor<ExecutionContext>() {
                    final MethodMatcher setMaxFileSizeByLong = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setMaxFileSize(long)"");
                    final MethodMatcher setMaxRequestSizeByLong = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setMaxRequestSize(long)"");
                    final MethodMatcher setFileSizeThresholdByInt = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setFileSizeThreshold(int)"");

                    final MethodMatcher setMaxFileSizeByString = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setMaxFileSize(java.lang.String)"");
                    final MethodMatcher setMaxRequestSizeByString = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setMaxRequestSize(java.lang.String)"");
                    final MethodMatcher setFileSizeThresholdByString = new MethodMatcher(""org.springframework.boot.web.servlet.MultipartConfigFactory setFileSizeThreshold(java.lang.String)"");

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                        if (setMaxFileSizeByLong.matches(m) || setMaxRequestSizeByLong.matches(m) || setFileSizeThresholdByInt.matches(m)) {
                            m = JavaTemplate.builder(""DataSize.ofBytes(#{any()})"")
                                            .imports(""org.springframework.util.unit.DataSize"")
                                            .javaParser(JavaParser.fromJavaVersion()
                                                    .classpathFromResources(ctx, ""spring-core-5.*"", ""spring-boot-2.*""))
                                            .build().apply(
                                    getCursor(),
                                    m.getCoordinates().replaceArguments(),
                                    m.getArguments().get(0));
                        } else if (setMaxFileSizeByString.matches(m) || setMaxRequestSizeByString.matches(m) || setFileSizeThresholdByString.matches(m)) {
                            m = JavaTemplate
                                .builder(""DataSize.parse(#{any(java.lang.String)})"")
                                .imports(""org.springframework.util.unit.DataSize"")
                                .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-core-5.*"", ""spring-boot-2.*""))
                                .build().apply(
                                    getCursor(),
                                    m.getCoordinates().replaceArguments(),
                                    m.getArguments().get(0));
                        }
                        maybeAddImport(""org.springframework.util.unit.DataSize"");
                        return m;
                    }
                });
    }
}
",{}
Migrate `@OutputCaptureRule` to `@ExtendWith(OutputCaptureExtension.class)`,Use the JUnit Jupiter extension instead of JUnit 4 rule.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import lombok.SneakyThrows;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindMethods;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.text.RuleBasedCollator;
import java.util.Comparator;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

public class OutputCaptureExtension extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate `@OutputCaptureRule` to `@ExtendWith(OutputCaptureExtension.class)`"";
    }

    @Override
    public String getDescription() {
        return ""Use the JUnit Jupiter extension instead of JUnit 4 rule."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(""org.springframework.boot.test.system.OutputCaptureRule"", false),
                new UsesType<>(""org.springframework.boot.test.rule.OutputCapture"", false)
        ), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            @SneakyThrows
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);

                c = c.withBody(c.getBody().withStatements(ListUtils.map(c.getBody().getStatements(), s -> {
                    if (!(s instanceof J.VariableDeclarations)) {
                        return s;
                    }

                    J.VariableDeclarations field = (J.VariableDeclarations) s;
                    JavaType.FullyQualified fieldType = field.getTypeAsFullyQualified();
                    if (TypeUtils.isOfClassType(fieldType, ""org.springframework.boot.test.system.OutputCaptureRule"") ||
                            TypeUtils.isOfClassType(fieldType, ""org.springframework.boot.test.rule.OutputCapture"")) {

                        String fieldName = field.getVariables().get(0).getSimpleName();

                        //Add the CapturedOutput parameter to any method that has a method call to OutputCapture
                        doAfterVisit(new AddCapturedOutputParameter(fieldName));

                        //Convert any method invocations from OutputCaptureRule.expect(Matcher) -> Matcher.match(CapturedOutput.getAll())
                        doAfterVisit(new ConvertExpectMethods(fieldName));

                        //Covert any remaining method calls from OutputCapture -> CapturedOutput
                        doAfterVisit(new ChangeMethodTargetToVariable(""org.springframework.boot.test.rule.OutputCapture *(..)"",
                                fieldName, ""org.springframework.boot.test.system.CapturedOutput"", false).getVisitor());
                        doAfterVisit(new ChangeMethodTargetToVariable(""org.springframework.boot.test.system.OutputCaptureRule *(..)"",
                                fieldName, ""org.springframework.boot.test.system.CapturedOutput"", false).getVisitor());

                        getCursor().putMessageOnFirstEnclosing(J.ClassDeclaration.class, ""addOutputCaptureExtension"", true);

                        maybeRemoveImport(""org.springframework.boot.test.system.OutputCaptureRule"");
                        maybeRemoveImport(""org.springframework.boot.test.rule.OutputCapture"");
                        maybeRemoveImport(""org.junit.Rule"");

                        return null;
                    }
                    return s;
                })));
                updateCursor(c);

                if (classDecl.getBody().getStatements().size() != c.getBody().getStatements().size()) {
                    JavaTemplate addOutputCaptureExtension = JavaTemplate.builder(""@ExtendWith(OutputCaptureExtension.class)"")
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-boot-test-2.*"", ""junit-jupiter-api-5.*""))
                            .imports(""org.junit.jupiter.api.extension.ExtendWith"",
                                    ""org.springframework.boot.test.system.OutputCaptureExtension"")
                            .build();

                    c = addOutputCaptureExtension.apply(
                        getCursor(),
                        c.getCoordinates()
                            .addAnnotation(Comparator.comparing(
                                J.Annotation::getSimpleName,
                                new RuleBasedCollator(""< ExtendWith"")
                            ))
                    );

                    maybeAddImport(""org.springframework.boot.test.system.OutputCaptureExtension"");
                    maybeAddImport(""org.junit.jupiter.api.extension.ExtendWith"");
                }

                return c;
            }
        });
    }

    private static final MethodMatcher OUTPUT_CAPTURE_MATCHER = new MethodMatcher(
            ""org.springframework.boot.test.rule.OutputCapture expect(..)""
    );
    private static final MethodMatcher OUTPUT_CAPTURE_RULE_MATCHER = new MethodMatcher(
            ""org.springframework.boot.test.system.OutputCaptureRule expect(..)""
    );

    private static final class ConvertExpectMethods extends JavaIsoVisitor<ExecutionContext> {
        private final String variableName;

        private ConvertExpectMethods(String variableName) {
            this.variableName = variableName;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (!OUTPUT_CAPTURE_MATCHER.matches(m) && !OUTPUT_CAPTURE_RULE_MATCHER.matches(m)) {
                return m;
            }

            JavaTemplate matchesTemplate = JavaTemplate.builder(""#{any()}.matches(#{}.getAll())"")
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-boot-test-2.*"", ""junit-jupiter-api-5.*""))
                    .build();
            return matchesTemplate.apply(getCursor(), m.getCoordinates().replace(), m.getArguments().get(0), variableName);
        }
    }

    private static final class AddCapturedOutputParameter extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.Class CAPTURED_OUTPUT_TYPE = JavaType.ShallowClass.build(""org.springframework.boot.test.system.CapturedOutput"");
        private final String variableName;

        private AddCapturedOutputParameter(String variableName) {
            this.variableName = variableName;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
            if (!FindMethods.find(m, ""org.springframework.boot.test.rule.OutputCapture *(..)"").isEmpty() ||
                    !FindMethods.find(m, ""org.springframework.boot.test.system.OutputCaptureRule *(..)"").isEmpty()) {
                // FIXME need addParameter coordinate here...
                // m = parameter.build().apply(m.getCoordinates().replaceParameters());

                J.VariableDeclarations param = new J.VariableDeclarations(Tree.randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        emptyList(),
                        emptyList(),
                        new J.Identifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), ""CapturedOutput"", CAPTURED_OUTPUT_TYPE, null),
                        null,
                        emptyList(),
                        singletonList(new JRightPadded<>(
                                new J.VariableDeclarations.NamedVariable(Tree.randomId(),
                                        Space.format("" ""),
                                        Markers.EMPTY,
                                        new J.Identifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), variableName, CAPTURED_OUTPUT_TYPE, null),
                                        emptyList(),
                                        null,
                                        null),
                                Space.EMPTY,
                                Markers.EMPTY
                        ))
                );

                if (m.getParameters().iterator().next() instanceof J.Empty) {
                    m = m.withParameters(singletonList(param));
                } else {
                    m = m.withParameters(ListUtils.concat(m.getParameters(), param.withPrefix(Space.format("" ""))));
                }

                maybeAddImport(""org.springframework.boot.test.system.CapturedOutput"");
            }
            return m;
        }
    }
}
",{}
Use `spring-boot.run.agents` configuration key in `spring-boot-maven-plugin`,Migrate the `spring-boot.run.agent` Maven plugin configuration key to `spring-boot.run.agents`. Deprecated in 2.2.x.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.search.FindPlugin;
import org.openrewrite.xml.XmlVisitor;
import org.openrewrite.xml.search.FindTags;
import org.openrewrite.xml.tree.Xml;

public class SpringBootMavenPluginMigrateAgentToAgents extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use `spring-boot.run.agents` configuration key in `spring-boot-maven-plugin`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate the `spring-boot.run.agent` Maven plugin configuration key to `spring-boot.run.agents`. Deprecated in 2.2.x."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MavenVisitor<ExecutionContext> precondition = new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                if (FindPlugin.find(document, ""org.springframework.boot"", ""spring-boot-maven-plugin"").stream().noneMatch(plugin -> FindTags.find(plugin, ""//configuration/agent"").isEmpty())) {
                    document = SearchResult.found(document);
                }
                return document;
            }
        };
        return Preconditions.check(precondition, new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                FindPlugin.find(document, ""org.springframework.boot"", ""spring-boot-maven-plugin"").forEach(plugin ->
                        FindTags.find(plugin, ""//configuration/agent"").forEach(agentTag ->
                                doAfterVisit(new ChangeTagKeyVisitor<>(agentTag, ""agents""))
                        )
                );
                return super.visitDocument(document, ctx);
            }
        });
    }

    private static class ChangeTagKeyVisitor<P> extends XmlVisitor<P> {
        private final Xml.Tag scope;
        private final String newKeyName;

        public ChangeTagKeyVisitor(Xml.Tag scope, String newKeyName) {
            this.scope = scope;
            this.newKeyName = newKeyName;
        }

        @Override
        public Xml visitTag(Xml.Tag tag, P p) {
            Xml.Tag t = (Xml.Tag) super.visitTag(tag, p);
            if (scope.isScope(tag)) {
                t = t.withName(newKeyName);
            }
            return t;
        }
    }

}
",{}
Migrate to recommended constants in `LogbackLoggingSystemProperties` from deprecated values in `LoggingSystemProperties`,Replaces field and static access of deprecated fields in `LoggingSystemProperties` with the recommendations from `LogbackLoggingSystemProperties`. Deprecated in 2.4.x and removed in 2.6.0.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.AddImport;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

public class MigrateLoggingSystemPropertyConstants extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Migrate to recommended constants in `LogbackLoggingSystemProperties` from deprecated values in `LoggingSystemProperties`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces field and static access of deprecated fields in `LoggingSystemProperties` with the recommendations from `LogbackLoggingSystemProperties`. Deprecated in 2.4.x and removed in 2.6.0."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.logging.LoggingSystemProperties"", false),
                new MigrateLoggingSystemPropertyConstants.UpdateDeprecatedConstantFieldNames());
    }

    private static class UpdateDeprecatedConstantFieldNames extends JavaIsoVisitor<ExecutionContext> {
        private static final JavaType.FullyQualified ORIGINAL_FQN =
                JavaType.ShallowClass.build(""org.springframework.boot.logging.LoggingSystemProperties"");
        private static final JavaType.FullyQualified NEW_FQN =
                JavaType.ShallowClass.build(""org.springframework.boot.logging.logback.LogbackLoggingSystemProperties"");

        private final Map<String, String> updateDeprecatedFields = new HashMap<>();

        UpdateDeprecatedConstantFieldNames() {
            updateDeprecatedFields.put(""FILE_CLEAN_HISTORY_ON_START"", ""ROLLINGPOLICY_CLEAN_HISTORY_ON_START"");
            updateDeprecatedFields.put(""FILE_MAX_HISTORY"", ""ROLLINGPOLICY_MAX_HISTORY"");
            updateDeprecatedFields.put(""FILE_MAX_SIZE"", ""ROLLINGPOLICY_MAX_FILE_SIZE"");
            updateDeprecatedFields.put(""FILE_TOTAL_SIZE_CAP"", ""ROLLINGPOLICY_TOTAL_SIZE_CAP"");
            updateDeprecatedFields.put(""ROLLING_FILE_NAME_PATTERN"", ""ROLLINGPOLICY_FILE_NAME_PATTERN"");
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);

            if (!classDecl.getSimpleName().equals(ORIGINAL_FQN.getClassName())) {
                maybeRemoveImport(ORIGINAL_FQN);
                maybeAddImport(NEW_FQN);
            }

            return cd;
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ctx);
            if (TypeUtils.isOfType(ORIGINAL_FQN, fa.getTarget().getType()) &&
                    updateDeprecatedFields.containsValue(fa.getName().getSimpleName())) {

                if (fa.getTarget() instanceof J.FieldAccess) {
                    fa = TypeTree.build(NEW_FQN.getFullyQualifiedName() + ""."" + fa.getName().getSimpleName())
                            .withPrefix(fa.getPrefix());
                } else {
                    fa = fa.withName(fa.getName().withSimpleName(fa.getName().getSimpleName()));
                    fa = fa.withTarget(new J.Identifier(
                            Tree.randomId(),
                            fa.getTarget().getPrefix(),
                            fa.getTarget().getMarkers(),
                            emptyList(),
                            NEW_FQN.getClassName(),
                            NEW_FQN,
                            null));
                }
            }
            return fa;
        }

        @Override
        public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
            J.Identifier id = super.visitIdentifier(identifier, ctx);
            if (isTargetFieldType(id) && updateDeprecatedFields.containsKey(id.getSimpleName())) {
                JavaType.Variable fieldType = id.getFieldType();
                id = new J.Identifier(
                        Tree.randomId(),
                        id.getPrefix(),
                        id.getMarkers(),
                        emptyList(),
                        updateDeprecatedFields.get(id.getSimpleName()),
                        id.getType(),
                        new JavaType.Variable(
                                null,
                                fieldType == null ? 0 : Flag.flagsToBitMap(fieldType.getFlags()),
                                updateDeprecatedFields.get(id.getSimpleName()),
                                NEW_FQN,
                                id.getType(),
                                emptyList()));

                J.CompilationUnit cu = getCursor().firstEnclosing(J.CompilationUnit.class);
                if (cu != null) {
                    for (J.Import anImport : cu.getImports()) {
                        if (anImport.isStatic() && TypeUtils.isOfType(anImport.getQualid().getTarget().getType(), ORIGINAL_FQN) &&
                                (updateDeprecatedFields.containsKey(anImport.getQualid().getName().getSimpleName()) ||
                                        ""*"".equals(anImport.getQualid().getName().getSimpleName()))) {
                            maybeRemoveImport(ORIGINAL_FQN);
                            doAfterVisit(new AddImport<>(NEW_FQN.getFullyQualifiedName(), id.getSimpleName(), false));
                        }
                    }
                }
            }
            return id;
        }

        private boolean isTargetFieldType(J.Identifier identifier) {
            if (identifier.getFieldType() != null) {
                JavaType.FullyQualified fqn = TypeUtils.asFullyQualified((identifier.getFieldType()).getOwner());
                return fqn != null && ORIGINAL_FQN.getFullyQualifiedName().equals(fqn.getFullyQualifiedName());
            }
            return false;
        }
    }
}
",{}
Move SAML relying party identity provider property to asserting party,Renames spring.security.saml2.relyingparty.registration.(any).identityprovider to ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.jspecify.annotations.NonNull;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;

public class SamlRelyingPartyPropertyApplicationPropertiesMove extends Recipe {
    private static final String REGEX_PATTERN = ""(spring\\.security\\.saml2\\.relyingparty\\.registration\\..*)(\\.identityprovider)(.*)"";

    @Override
    public String getDisplayName() {
        return ""Move SAML relying party identity provider property to asserting party"";
    }

    @Override
    public String getDescription() {
        return ""Renames spring.security.saml2.relyingparty.registration.(any).identityprovider to "" +
                ""spring.security.saml2.relyingparty.registration.(any).assertingparty."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return new PropertiesVisitor<ExecutionContext>() {

            @Override
            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {

                if (entry.getKey().matches(REGEX_PATTERN)) {
                    return super.visitEntry(updateEntry(entry), ctx);
                }

                return super.visitEntry(entry, ctx);
            }


            private Properties.@NonNull Entry updateEntry(Properties.Entry entry) {
                return entry.withKey(entry.getKey().replaceAll(REGEX_PATTERN, ""$1.assertingparty$3""));
            }
        };
    }
}
",{}
Remove `@SpringExtension`,`@SpringBootTest` and all test slice annotations already applies `@SpringExtension` as of Spring Boot 2.1.0.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Arrays;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singletonList;

public class UnnecessarySpringExtension extends Recipe {

    private static final String EXTEND_WITH = ""org.junit.jupiter.api.extension.ExtendWith"";
    private static final String SPRING_EXTENSION = ""org.springframework.test.context.junit.jupiter.SpringExtension"";
    private static final String EXTEND_WITH_SPRING_EXTENSION_ANNOTATION_PATTERN = String.format(""@%s(%s.class)"", EXTEND_WITH, SPRING_EXTENSION);
    private static final AnnotationMatcher EXTENDS_WITH_SPRING_EXACT_MATCHER = new AnnotationMatcher(EXTEND_WITH_SPRING_EXTENSION_ANNOTATION_PATTERN, false);

    @Override
    public String getDisplayName() {
        return ""Remove `@SpringExtension`"";
    }

    @Override
    public String getDescription() {
        return ""`@SpringBootTest` and all test slice annotations already applies `@SpringExtension` as of Spring Boot 2.1.0."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(SPRING_EXTENSION, false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        Set<J.Annotation> extendsWithMetaAnnotations = FindAnnotations.find(classDecl, EXTEND_WITH_SPRING_EXTENSION_ANNOTATION_PATTERN, true);
                        if (1 < extendsWithMetaAnnotations.size() || extendsWithMetaAnnotations.size() == 1 && usesOlderSpringTestAnnotation(classDecl)) {
                            return classDecl.withLeadingAnnotations(ListUtils.map(classDecl.getLeadingAnnotations(), annotation -> {
                                if (EXTENDS_WITH_SPRING_EXACT_MATCHER.matches(annotation)) {
                                    Expression expression = annotation.getArguments().get(0);
                                    if (expression instanceof J.FieldAccess) {
                                        doAfterVisit(new RemoveAnnotationVisitor(EXTENDS_WITH_SPRING_EXACT_MATCHER));
                                        maybeRemoveImport(SPRING_EXTENSION);
                                    } else if (expression instanceof J.NewArray &&
                                            ((J.NewArray) expression).getInitializer() != null) {
                                        if (((J.NewArray) expression).getInitializer().size() == 1) {
                                            doAfterVisit(new RemoveAnnotationVisitor(EXTENDS_WITH_SPRING_EXACT_MATCHER));
                                            maybeRemoveImport(SPRING_EXTENSION);
                                        } else {
                                            maybeRemoveImport(EXTEND_WITH);
                                            maybeRemoveImport(SPRING_EXTENSION);
                                            J.Annotation newAnnotation = annotation.withArguments(singletonList(((J.NewArray) expression)
                                                    .withInitializer(ListUtils.map(((J.NewArray) expression).getInitializer(),
                                                            e -> TypeUtils.isAssignableTo(""java.lang.Class<"" + SPRING_EXTENSION + "">"", e.getType()) ? null : e))));
                                            return maybeAutoFormat(annotation, newAnnotation, ctx);
                                        }
                                    }
                                }
                                return annotation;
                            }));
                        }
                        return super.visitClassDeclaration(classDecl, ctx);
                    }

                    private final List<String> SPRING_BOOT_TEST_ANNOTATIONS = Arrays.asList(
                            ""org.springframework.boot.test.context.SpringBootTest"",
                            ""org.springframework.boot.test.autoconfigure.jdbc.JdbcTest"",
                            ""org.springframework.boot.test.autoconfigure.web.client.RestClientTest"",
                            ""org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest"",
                            ""org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest"",
                            ""org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest"",
                            ""org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest"",
                            ""org.springframework.boot.test.autoconfigure.jooq.JooqTest"",
                            ""org.springframework.boot.test.autoconfigure.json.JsonTest"",
                            ""org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest"",
                            ""org.springframework.boot.test.autoconfigure.data.jdbc.DataJdbcTest"",
                            ""org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest"",
                            ""org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest"",
                            ""org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest"",
                            ""org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest"",
                            ""org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest"",
                            ""org.springframework.batch.test.context.SpringBatchTest"",
                            ""org.springframework.test.context.junit.jupiter.SpringJUnitConfig""
                    );

                    /**
                     * When upgrading from 1.5 the `@SpringBootTest` annotation is not yet meta annotated.
                     */
                    private boolean usesOlderSpringTestAnnotation(J.ClassDeclaration classDecl) {
                        return classDecl.getLeadingAnnotations().stream()
                                .anyMatch(leadingAnnotation -> {
                                    JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(leadingAnnotation.getType());
                                    return fullyQualified != null && SPRING_BOOT_TEST_ANNOTATIONS.contains(fullyQualified.getFullyQualifiedName());
                                });
                    }
                });
    }
}
",{}
Add missing `@Configuration` annotation,Class having `@Bean` annotation over any methods but missing `@Configuration` annotation over the declaring class would have `@Configuration` annotation added.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Comparator;

public class AddConfigurationAnnotationIfBeansPresent extends Recipe {

    private static final String FQN_BEAN = ""org.springframework.context.annotation.Bean"";
    private static final String CONFIGURATION_PACKAGE = ""org.springframework.context.annotation"";
    private static final String CONFIGURATION_SIMPLE_NAME = ""Configuration"";
    private static final String FQN_CONFIGURATION = CONFIGURATION_PACKAGE + ""."" + CONFIGURATION_SIMPLE_NAME;
    private static final AnnotationMatcher BEAN_ANNOTATION_MATCHER = new AnnotationMatcher(""@"" + FQN_BEAN, true);
    private static final AnnotationMatcher CONFIGURATION_ANNOTATION_MATCHER = new AnnotationMatcher(""@"" + FQN_CONFIGURATION, true);


    @Override
    public String getDisplayName() {
        return ""Add missing `@Configuration` annotation"";
    }

    @Override
    public String getDescription() {
        return ""Class having `@Bean` annotation over any methods but missing `@Configuration` annotation over the declaring class would have `@Configuration` annotation added."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(FQN_BEAN, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);
                if (isApplicableClass(c, getCursor())) {
                    c = addConfigurationAnnotation(c);
                }
                return c;
            }

            private J.ClassDeclaration addConfigurationAnnotation(J.ClassDeclaration c) {
                maybeAddImport(FQN_CONFIGURATION);
                return JavaTemplate.builder(""@"" + CONFIGURATION_SIMPLE_NAME)
                    .imports(FQN_CONFIGURATION)
                    .javaParser(JavaParser.fromJavaVersion().dependsOn(""package "" + CONFIGURATION_PACKAGE +
                                                                       ""; public @interface "" + CONFIGURATION_SIMPLE_NAME + "" {}""))
                    .build().apply(
                        getCursor(),
                        c.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))
                    );
            }
        });
    }

    public static boolean isApplicableClass(J.ClassDeclaration classDecl, Cursor cursor) {
        if (classDecl.getKind() != J.ClassDeclaration.Kind.Type.Class) {
            return false;
        }

        boolean isStatic = false;
        for (J.Modifier m : classDecl.getModifiers()) {
            if (m.getType() == J.Modifier.Type.Abstract) {
                return false;
            }
            if (m.getType() == J.Modifier.Type.Static) {
                isStatic = true;
            }
        }

        if (!isStatic) {
            // no static keyword? check if it is top level class in the CU
            Object enclosing = cursor.dropParentUntil(it -> it instanceof J.ClassDeclaration || it == Cursor.ROOT_VALUE).getValue();
            if (enclosing instanceof J.ClassDeclaration) {
                return false;
            }
        }

        // check if '@Configuration' is already over the class
        for (J.Annotation a : classDecl.getLeadingAnnotations()) {
            JavaType.FullyQualified aType = TypeUtils.asFullyQualified(a.getType());
            if (aType != null && CONFIGURATION_ANNOTATION_MATCHER.matchesAnnotationOrMetaAnnotation(aType)) {
                // Found '@Configuration' annotation
                return false;
            }
        }
        // No '@Configuration' present. Check if any methods have '@Bean' annotation
        for (Statement s : classDecl.getBody().getStatements()) {
            if (s instanceof J.MethodDeclaration) {
                if (isBeanMethod((J.MethodDeclaration) s)) {
                    return true;
                }
            }
        }

        return false;
    }

    private static boolean isBeanMethod(J.MethodDeclaration methodDecl) {
        for (J.Modifier m : methodDecl.getModifiers()) {
            if (m.getType() == J.Modifier.Type.Abstract || m.getType() == J.Modifier.Type.Static) {
                return false;
            }
        }
        for (J.Annotation a : methodDecl.getLeadingAnnotations()) {
            JavaType.FullyQualified aType = TypeUtils.asFullyQualified(a.getType());
            if (aType != null && BEAN_ANNOTATION_MATCHER.matchesAnnotationOrMetaAnnotation(aType)) {
                return true;
            }
        }
        return false;
    }
}
",{}
"Use `DiskSpaceHealthIndicator(File, DataSize)`","`DiskSpaceHealthIndicator(File, long)` was deprecated in Spring Data 2.1 for removal in 2.2.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

public class MigrateDiskSpaceHealthIndicatorConstructor extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use `DiskSpaceHealthIndicator(File, DataSize)`"";
    }

    @Override
    public String getDescription() {
        return ""`DiskSpaceHealthIndicator(File, long)` was deprecated in Spring Data 2.1 for removal in 2.2."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.actuate.system.DiskSpaceHealthIndicator"", false), new JavaVisitor<ExecutionContext>() {
            final String diskSpaceHealthIndicatorFqn = ""org.springframework.boot.actuate.system.DiskSpaceHealthIndicator"";

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                if (TypeUtils.isOfClassType(newClass.getType(), diskSpaceHealthIndicatorFqn) &&
                        newClass.getConstructorType() != null &&
                        TypeUtils.isOfType(newClass.getConstructorType().getParameterTypes().get(0), JavaType.buildType(""java.io.File"")) &&
                        TypeUtils.isOfType(newClass.getConstructorType().getParameterTypes().get(1), JavaType.Primitive.Long)) {

                    maybeAddImport(""org.springframework.util.unit.DataSize"");
                    return JavaTemplate.builder(""new DiskSpaceHealthIndicator(#{any(java.io.File)}, DataSize.ofBytes(#{any(long)}))"")
                        .imports(""org.springframework.util.unit.DataSize"")
                        .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-boot-actuator-2.*"", ""spring-core-5.*""))
                        .build().apply(
                            getCursor(),
                            newClass.getCoordinates().replace(),
                            newClass.getArguments().get(0),
                            newClass.getArguments().get(1));
                }

                return super.visitNewClass(newClass, ctx);
            }
        });
    }
}
",{}
In Spring Boot 2.5 a `DefaultConfigurationCustomizer` can now be used in favour of defining one or more `*Provider` beans,"To streamline the customization of jOOQs `DefaultConfiguration`, ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2.search;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.Arrays;
import java.util.List;

/**
 * Migration for Spring Boot 2.4 to 2.5
 * <a href=""https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#customizing-jooqs-defaultconfiguration"">Customizing jOOQs DefaultConfiguration</a>
 */
@Incubating(since = ""4.16.0"")
public class CustomizingJooqDefaultConfiguration extends Recipe {
    private static final List<String> jooqTypes = Arrays.asList(
            ""org.jooq.conf.Settings"",
            ""org.jooq.ConnectionProvider"",
            ""org.jooq.ExecutorProvider"",
            ""org.jooq.TransactionProvider"",
            ""org.jooq.RecordMapperProvider"",
            ""org.jooq.RecordUnmapperProvider"",
            ""org.jooq.RecordListenerProvider"",
            ""org.jooq.ExecuteListenerProvider"",
            ""org.jooq.VisitListenerProvider"",
            ""org.jooq.TransactionListenerProvider""
    );

    @SuppressWarnings(""unchecked"")
    private static final TreeVisitor<?, ExecutionContext> precondition =
            Preconditions.or(jooqTypes.stream().map(t -> new UsesType<>(t, false)).toArray(UsesType[]::new));

    @Override
    public String getDisplayName() {
        return ""In Spring Boot 2.5 a `DefaultConfigurationCustomizer` can now be used in favour of defining one or more `*Provider` beans"";
    }

    @Override
    public String getDescription() {
        return ""To streamline the customization of jOOQs `DefaultConfiguration`, "" +
                ""a bean that implements `DefaultConfigurationCustomizer` can now be defined. "" +
                ""This customizer callback should be used in favour of defining one or more `*Provider` beans, "" +
                ""the support for which has now been deprecated. "" +
                ""See [Spring Boot 2.5 jOOQ customization](https://docs.spring.io/spring-boot/docs/2.5.x/reference/htmlsingle/#features.sql.jooq.customizing)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(precondition, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);

                if (isJooqCustomizationBean(md)) {
                    md = markAsMatch(md);
                }

                return md;
            }

            private J.MethodDeclaration markAsMatch(J.MethodDeclaration md) {
                return SearchResult.found(md);
            }

            private boolean isJooqCustomizationBean(J.MethodDeclaration md) {
                return !FindAnnotations.find(md, ""@org.springframework.context.annotation.Bean"").isEmpty() &&
                        returnsJooqCustomizationType(md);
            }

            private boolean returnsJooqCustomizationType(J.MethodDeclaration md) {
                JavaType.Method methodType = md.getMethodType();
                if (methodType != null) {
                    for (String jooqType : jooqTypes) {
                        if (TypeUtils.isOfClassType(methodType.getReturnType(), jooqType)) {
                            return true;
                        }
                    }
                }
                return false;
            }
        });
    }
}
",{}
Integration scheduler pool size,Spring Integration now reuses an available `TaskScheduler` rather than configuring its own. In a ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2.search;

import lombok.Data;
import lombok.Value;
import lombok.With;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.marker.Marker;
import org.openrewrite.marker.Markers;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.xml.tree.Xml;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.nio.file.Path;
import java.util.*;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toSet;

/**
 * @author Alex Boyko
 */
public class IntegrationSchedulerPoolRecipe extends ScanningRecipe<IntegrationSchedulerPoolRecipe.JavaProjects> {

    private static final Pattern APP_PROPS_FILE_REGEX = Pattern.compile(""^application.*\\.properties$"");
    private static final Pattern APP_YAML_FILE_REGEX = Pattern.compile(""^application.*\\.ya?ml$"");

    private static final String PROPERTY_KEY = ""spring.task.scheduling.pool.size"";

    private static final String PROPS_MIGRATION_MESSAGE = "" TODO: Consider Scheduler thread pool size for Spring Integration"";
    private static final String GENERAL_MIGRATION_MESSAGE = "" TODO: Scheduler thread pool size for Spring Integration either in properties or config server\n"";
    private static final String SPRING_BOOT_APPLICATION = ""org.springframework.boot.autoconfigure.SpringBootApplication"";

    @Override
    public String getDisplayName() {
        return ""Integration scheduler pool size"";
    }

    @Override
    public String getDescription() {
        return ""Spring Integration now reuses an available `TaskScheduler` rather than configuring its own. In a "" +
                ""typical application setup relying on the auto-configuration, this means that Spring Integration "" +
                ""uses the auto-configured task scheduler that has a pool size of 1. To restore Spring Integrations "" +
                ""default of 10 threads, use the `spring.task.scheduling.pool.size` property."";
    }

    private boolean isApplicableMavenProject(Xml.Document maven) {
        DependencyMatcher boot25Matcher = DependencyMatcher.build(""org.springframework.boot:spring-boot:2.4.X"").getValue();
        DependencyMatcher integrationMatcher = DependencyMatcher.build(""org.springframework.integration:spring-integration-core"").getValue();

        List<ResolvedDependency> deps = maven.getMarkers().findFirst(MavenResolutionResult.class)
                .orElseThrow(() -> new IllegalStateException(""Maven visitors should not be visiting XML documents without a Maven marker""))
                .getDependencies().getOrDefault(Scope.Compile, emptyList());

        boolean boot25 = false;
        boolean si = false;

        for (ResolvedDependency d : deps) {
            if (!boot25) {
                assert boot25Matcher != null;
                boot25 = boot25Matcher.matches(d.getGroupId(), d.getArtifactId(), d.getVersion());
            }
            if (!si) {
                assert integrationMatcher != null;
                si = integrationMatcher.matches(d.getGroupId(), d.getArtifactId());
            }
            if (boot25 && si) {
                return true;
            }
        }
        return false;
    }

    @Override
    public JavaProjects getInitialValue(ExecutionContext ctx) {
        return new JavaProjects();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(JavaProjects acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                if (tree.getMarkers().findFirst(CommentAdded.class).isPresent()) {
                    // already processed in a previous cycle
                    tree.getMarkers().findFirst(JavaProject.class).ifPresent(acc.getProcessedProjects()::add);
                    tree.getMarkers().findFirst(JavaProject.class).ifPresent(acc.getApplicableProjects()::remove);
                    return tree;
                }

                Optional<JavaProject> maybeJavaProject = tree.getMarkers().findFirst(JavaProject.class);
                if (!maybeJavaProject.isPresent() || acc.getProcessedProjects().contains(maybeJavaProject.get())) {
                    return tree;
                }

                SourceFile source = (SourceFile) tree;
                String fileName = source.getSourcePath().getFileName().toString();
                JavaProject javaProject = maybeJavaProject.get();

                if (source instanceof Xml.Document) {
                    Xml.Document xml = (Xml.Document) source;
                    Optional<MavenResolutionResult> maybeMavenMarker = source.getMarkers().findFirst(MavenResolutionResult.class);
                    if (maybeMavenMarker.isPresent() && isApplicableMavenProject(xml)) {
                        acc.getApplicableProjects().add(javaProject);
                    }
                } else if (source instanceof Properties && APP_PROPS_FILE_REGEX.matcher(fileName).matches()) {
                    if (!FindProperties.find((Properties) source, PROPERTY_KEY, false).isEmpty()) {
                        acc.getSourceToCommentByProject().put(javaProject, source.getSourcePath());
                    }
                } else if (source instanceof Yaml.Documents && APP_YAML_FILE_REGEX.matcher(fileName).matches()) {
                    if (!FindProperty.find((Yaml) source, PROPERTY_KEY, false).isEmpty()) {
                        acc.getSourceToCommentByProject().put(javaProject, source.getSourcePath());
                    }
                } else if (source instanceof JavaSourceFile && acc.getSourceToCommentByProject().get(javaProject) == null) {
                    JavaSourceFile javaSourceFile = (JavaSourceFile) source;
                    if (javaSourceFile.getTypesInUse().getTypesInUse().stream().anyMatch(t -> t instanceof
                            JavaType.Class && ((JavaType.Class) t).getFullyQualifiedName().equals(SPRING_BOOT_APPLICATION))) {
                        new JavaIsoVisitor<Integer>() {
                            final AnnotationMatcher annotationMatcher = new AnnotationMatcher('@' + SPRING_BOOT_APPLICATION);

                            @Override
                            public J.Annotation visitAnnotation(J.Annotation annotation, Integer p) {
                                if (annotationMatcher.matches(annotation)) {
                                    acc.getSourceToCommentByProject().put(javaProject, source.getSourcePath());
                                }
                                return annotation;
                            }
                        }.visit(javaSourceFile, 0);
                    }
                }
                return source;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(JavaProjects acc) {
        Set<Path> sourcesToComment = acc.getSourceToCommentByProject().entrySet().stream()
                .filter(e -> acc.getApplicableProjects().contains(e.getKey()))
                .map(Map.Entry::getValue).collect(toSet());

        if (sourcesToComment.isEmpty()) {
            return TreeVisitor.noop();
        }

        // Leave the comment about scheduler pool size next to 'spring.task.scheduling.pool.size' property in the external properties file (props or yaml)
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile) || !sourcesToComment.contains(((SourceFile) tree).getSourcePath())) {
                    return tree;
                }

                SourceFile source = (SourceFile) tree;
                if (source instanceof Properties) {
                    Set<Properties.Entry> foundEntries = FindProperties.find((Properties) source, PROPERTY_KEY, false);
                    if (!foundEntries.isEmpty()) {
                        // There should only be one exact match!
                        Properties.Entry entry = foundEntries.iterator().next();
                        source = (SourceFile) new PropertiesVisitor<ExecutionContext>() {
                            @Override
                            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                                int idx = file.getContent().indexOf(entry);
                                if (idx >= 0) {
                                    Properties.Comment comment = new Properties.Comment(Tree.randomId(), ""\n"", Markers.EMPTY, Properties.Comment.Delimiter.HASH_TAG, PROPS_MIGRATION_MESSAGE);
                                    return file.withContent(ListUtils.insertAll(file.getContent(), idx, singletonList(comment)));
                                }
                                throw new RuntimeException(""Entry must be present in the properties file!"");
                            }
                        }.visitNonNull(source, ctx);
                        source = source.withMarkers(source.getMarkers().addIfAbsent(new CommentAdded(Tree.randomId())));
                    }
                } else if (source instanceof Yaml) {
                    Set<Yaml.Block> foundEntriesValues = FindProperty.find((Yaml) source, PROPERTY_KEY, false);
                    if (!foundEntriesValues.isEmpty()) {
                        source = (SourceFile) new YamlIsoVisitor<ExecutionContext>() {
                            @Override
                            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                                if (foundEntriesValues.contains(entry.getValue())) {
                                    entry = entry.withPrefix(""\n#"" + PROPS_MIGRATION_MESSAGE + entry.getPrefix());
                                }
                                return super.visitMappingEntry(entry, ctx);
                            }
                        }.visitNonNull(source, ctx);
                        source = source.withMarkers(source.getMarkers().addIfAbsent(new CommentAdded(Tree.randomId())));
                    }
                } else if (source instanceof JavaSourceFile) {
                    JavaIsoVisitor<ExecutionContext> commentVisitor = new JavaIsoVisitor<ExecutionContext>() {
                        final AnnotationMatcher annotationMatcher = new AnnotationMatcher('@' + SPRING_BOOT_APPLICATION);

                        @Override
                        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                            if (annotationMatcher.matches(annotation)) {
                                annotation = annotation.withComments(ListUtils.concat(annotation.getComments(), new TextComment(false, GENERAL_MIGRATION_MESSAGE, """", Markers.EMPTY)));
                            }
                            return annotation;
                        }
                    };
                    SourceFile after = (SourceFile) commentVisitor.visitNonNull(source, ctx);
                    if (after != source) {
                        source = after.withMarkers(after.getMarkers().addIfAbsent(new CommentAdded(Tree.randomId())));
                    }
                }
                return source;
            }
        };
    }

    @Data
    static class JavaProjects {
        Set<JavaProject> applicableProjects = new HashSet<>();
        Set<JavaProject> processedProjects = new HashSet<>();
        Map<JavaProject, Path> sourceToCommentByProject = new HashMap<>();
    }

    @Value
    @With
    static class CommentAdded implements Marker {
        UUID id;
    }
}
",{}
Applications using logging shutdown hooks,Spring Boot registers a logging shutdown hook by default for JAR-based applications to ensure that ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot2.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

/**
 * Mark POM's of projects where logging shutdown hook may need to be disabled
 *
 * @author Alex Boyko
 */
public class LoggingShutdownHooks extends ScanningRecipe<AtomicBoolean> {

    @Override
    public String getDisplayName() {
        return ""Applications using logging shutdown hooks"";
    }

    @Override
    public String getDescription() {
        return ""Spring Boot registers a logging shutdown hook by default for JAR-based applications to ensure that "" +
                ""logging resources are released when the JVM exits. If your application is deployed as a WAR then "" +
                ""the shutdown hook is not registered since the servlet container usually handles logging concerns. "" +
                ""\n\n"" +
                ""Most applications will want the shutdown hook. However, if your application has complex context "" +
                ""hierarchies, then you may need to disable it. You can use the `logging.register-shutdown-hook` "" +
                ""property to do that."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                if (acc.get()) {
                    return document;
                }
                MavenResolutionResult model = getResolutionResult();
                //Default packaging, if not specified is ""jar""
                if (!""jar"".equals(model.getPom().getPackaging())) {
                    return document;
                }
                DependencyMatcher matcher = requireNonNull(DependencyMatcher.build(""org.springframework.boot:spring-boot:2.4.X"").getValue());
                for (ResolvedDependency d : getResolutionResult().getDependencies().getOrDefault(Scope.Compile, emptyList())) {
                    if (matcher.matches(d.getGroupId(), d.getArtifactId(), d.getVersion())) {
                        acc.set(true);
                    }
                }
                return document;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        return Preconditions.firstAcceptable(
                Preconditions.check(acc.get(),
                        new FindAnnotations(""@org.springframework.boot.autoconfigure.SpringBootApplication"", null).getVisitor()));
    }

}
",{}
Downgrade Jakarta Servlet API to 5.0 when using Jetty,Jetty does not yet support Servlet 6.0. This recipe will detect the presence of the `spring-boot-starter-jetty` as a ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.AddProperty;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.search.FindDependency;
import org.openrewrite.xml.tree.Xml;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class DowngradeServletApiWhenUsingJetty extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Downgrade Jakarta Servlet API to 5.0 when using Jetty"";
    }

    @Override
    public String getDescription() {
        return ""Jetty does not yet support Servlet 6.0. This recipe will detect the presence of the `spring-boot-starter-jetty` as a "" +
                ""first-order dependency and will add the maven property `jakarta-servlet.version` setting it's value to `5.0.0`. This "" +
                ""will downgrade the `jakarta-servlet` artifact if the pom's parent extends from the spring-boot-parent."";
    }

    @Override
    public Set<String> getTags() {
        return new HashSet<>(Arrays.asList(""spring"", ""boot"", ""jetty""));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindDependency(""org.springframework.boot"", ""spring-boot-starter-jetty"", null, null), new MavenVisitor<ExecutionContext>() {
            @Override
            public @Nullable Xml visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree == null) {
                    return null;
                }
                return (Xml) new AddProperty(""jakarta-servlet.version"", ""5.0.0"", false, false).getVisitor().visit(tree, ctx);
            }
        });
    }
}
",{}
Add `@Configuration` to classes with `@EnableXXXSecurity` annotations,"Prior to Spring Security 6, `@EnableXXXSecurity` implicitly had `@Configuration`. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.*;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import static java.util.Collections.singletonList;

@EqualsAndHashCode(callSuper = false)
@Value
public class ConfigurationOverEnableSecurity extends Recipe {

    @Option(displayName = ""Force add `@Configuration`"",
            description = ""Force add `@Configuration` regardless current Boot version."",
            example = ""true"")
    boolean forceAddConfiguration;

    private static final String CONFIGURATION_FQN = ""org.springframework.context.annotation.Configuration"";

    private static final List<String> EXCLUSIONS = singletonList(""org.springframework.security.config.annotation.rsocket.EnableRSocketSecurity"");

    private static final String ENABLE_SECURITY_ANNOTATION_PATTERN = ""@org.springframework.security.config.annotation..*.Enable*Security"";

    private static final AnnotationMatcher SECURITY_ANNOTATION_MATCHER = new AnnotationMatcher(ENABLE_SECURITY_ANNOTATION_PATTERN, true);

    @Override
    public String getDisplayName() {
        return ""Add `@Configuration` to classes with `@EnableXXXSecurity` annotations"";
    }

    @Override
    public String getDescription() {
        return ""Prior to Spring Security 6, `@EnableXXXSecurity` implicitly had `@Configuration`. "" +
                ""`Configuration` was removed from the definitions of the `@EnableSecurity` definitions in Spring Security 6. "" +
                ""Consequently classes annotated with `@EnableXXXSecurity` coming from pre-Boot 3 should have `@Configuration` annotation added."";
    }

    private JavaVisitor<ExecutionContext> precondition() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J preVisit(J tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof JavaSourceFile) {
                    for (JavaType type : ((JavaSourceFile) tree).getTypesInUse().getTypesInUse()) {
                        if (SECURITY_ANNOTATION_MATCHER.matchesAnnotationOrMetaAnnotation(TypeUtils.asFullyQualified(type))) {
                            return SearchResult.found(tree);
                        }
                    }
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(precondition(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);
                // Avoid searching within the class declaration's body, lest we accidentally find an inner class's annotation
                //noinspection DataFlowIssue
                J.ClassDeclaration bodiless = c.withBody(null);

                Set<J.Annotation> securityAnnotations = FindAnnotations.find(bodiless,
                        ENABLE_SECURITY_ANNOTATION_PATTERN, true);
                if (securityAnnotations.isEmpty() || isExcluded(securityAnnotations)) {
                    return c;
                }

                boolean alreadyHasConfigurationAnnotation = !FindAnnotations.find(bodiless, ""@"" + CONFIGURATION_FQN,
                        false).isEmpty();
                if (alreadyHasConfigurationAnnotation) {
                    return c;
                }

                if (!forceAddConfiguration) {
                    J.Annotation securityAnnotation = securityAnnotations.stream().findFirst().get();
                    boolean securityAnnotationHasConfiguration = new AnnotationMatcher(""@"" + CONFIGURATION_FQN, true)
                            .matchesAnnotationOrMetaAnnotation(TypeUtils.asFullyQualified(securityAnnotation.getType()));

                    // The framework 6.+ (Boot 3+) removed `@Configuration` from `@EnableXXXSecurity`, so if it has not
                    // `@Configuration`, means it is already in version framework 6.+ (Boot 3+), and expected no change.
                    // Otherwise, we want to add `@Configuration`.
                    boolean isBoot3orPlus = !securityAnnotationHasConfiguration;
                    if (isBoot3orPlus) {
                        return c;
                    }
                }

                maybeAddImport(CONFIGURATION_FQN);

                return JavaTemplate.builder(""@Configuration"")
                    .imports(CONFIGURATION_FQN)
                    .javaParser(JavaParser.fromJavaVersion()
                        .classpathFromResources(ctx, ""spring-context-5.3.+""))
                    .build()
                    .apply(
                        getCursor(),
                        c.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName))
                    );
            }

            private boolean isExcluded(Set<J.Annotation> securityAnnotations) {
                return (securityAnnotations.stream()
                        .map(a -> TypeUtils.asFullyQualified(a.getType()))
                        .filter(Objects::nonNull)
                        .anyMatch(it -> EXCLUSIONS.contains(it.getFullyQualifiedName())));
            }
        });
    }
}
","{
  ""forceAddConfiguration"": ""boolean field""
}"
Enable Spring Batch Annotation,Add or remove the `@EnableBatchProcessing` annotation from a Spring Boot application.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

public class RemoveEnableBatchProcessing extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Enable Spring Batch Annotation"";
    }

    @Override
    public String getDescription() {
        return ""Add or remove the `@EnableBatchProcessing` annotation from a Spring Boot application."";
    }

    private static final String ENABLE_BATCH_PROCESSING = ""org.springframework.batch.core.configuration.annotation.EnableBatchProcessing"";

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(ENABLE_BATCH_PROCESSING, true), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (!FindAnnotations.find(classDecl, ""@org.springframework.boot.autoconfigure.SpringBootApplication"").isEmpty() &&
                    !FindAnnotations.find(classDecl, ""@"" + ENABLE_BATCH_PROCESSING).isEmpty()) {
                    return classDecl.withLeadingAnnotations(ListUtils.map(classDecl.getLeadingAnnotations(), a -> {
                        if (TypeUtils.isOfClassType(a.getType(), ENABLE_BATCH_PROCESSING)) {
                            maybeRemoveImport(ENABLE_BATCH_PROCESSING);
                            return null;
                        }
                        return a;
                    }));
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }
        });
    }
}
",{}
Bean methods should return concrete types,Replace Bean method return types with concrete types being returned. This is required for Spring 6 AOT.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;

public class PreciseBeanType extends Recipe {
    private static final String BEAN = ""org.springframework.context.annotation.Bean"";

    private static final String MSG_KEY = ""returnType"";

    @Override
    public String getDisplayName() {
        return ""Bean methods should return concrete types"";
    }

    @Override
    public String getDescription() {
        return ""Replace Bean method return types with concrete types being returned. This is required for Spring 6 AOT."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(BEAN, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
                Object o = getCursor().pollMessage(MSG_KEY);
                if (o != null && (method.getReturnTypeExpression() != null && !o.equals(method.getReturnTypeExpression().getType())) && isBeanMethod(m)) {
                    if (o instanceof JavaType.FullyQualified) {
                        JavaType.FullyQualified actualType = (JavaType.FullyQualified) o;
                        if (m.getReturnTypeExpression() instanceof J.Identifier) {
                            J.Identifier identifierReturnExpr = (J.Identifier) m.getReturnTypeExpression();
                            maybeAddImport(actualType);
                            if (identifierReturnExpr.getType() instanceof JavaType.FullyQualified) {
                                maybeRemoveImport((JavaType.FullyQualified) identifierReturnExpr.getType());
                            }
                            m = m.withReturnTypeExpression(identifierReturnExpr
                                    .withType(actualType)
                                    .withSimpleName(actualType.getClassName())
                            );
                        } else if (m.getReturnTypeExpression() instanceof J.ParameterizedType) {
                            J.ParameterizedType parameterizedType = (J.ParameterizedType) m.getReturnTypeExpression();
                            maybeAddImport(actualType);
                            if (parameterizedType.getType() instanceof JavaType.FullyQualified) {
                                maybeRemoveImport((JavaType.FullyQualified) parameterizedType.getType());
                            }
                            m = m.withReturnTypeExpression(parameterizedType
                                    .withType(actualType)
                                    .withClazz(TypeTree.build(actualType.getClassName()).withType(actualType))
                            );
                        }

                    } else if (o instanceof JavaType.Array) {
                        JavaType.Array actualType = (JavaType.Array) o;
                        if (m.getReturnTypeExpression() instanceof J.ArrayType && actualType.getElemType() instanceof JavaType.FullyQualified) {
                            JavaType.FullyQualified actualElementType = (JavaType.FullyQualified) actualType.getElemType();
                            J.ArrayType arrayType = (J.ArrayType) m.getReturnTypeExpression();
                            maybeAddImport(actualElementType);
                            if (arrayType.getElementType() instanceof JavaType.FullyQualified) {
                                maybeRemoveImport((JavaType.FullyQualified) arrayType.getElementType());
                            }
                            m = m.withReturnTypeExpression(arrayType
                                    .withElementType(TypeTree.build(actualElementType.getClassName()).withType(actualType))
                            );
                        }
                    }
                }
                return m;
            }

            private boolean isBeanMethod(J.MethodDeclaration m) {
                for (J.Annotation leadingAnnotation : m.getLeadingAnnotations()) {
                    if (TypeUtils.isOfClassType(leadingAnnotation.getType(), BEAN)) {
                        return true;
                    }
                }
                return false;
            }

            @Override
            public J.Return visitReturn(J.Return _return, ExecutionContext ctx) {
                if (_return.getExpression() != null && _return.getExpression().getType() != null) {
                    Cursor methodCursor = getCursor();
                    while (methodCursor != null && !(methodCursor.getValue() instanceof J.Lambda || methodCursor.getValue() instanceof J.MethodDeclaration)) {
                        methodCursor = methodCursor.getParent();
                    }
                    if (methodCursor != null && methodCursor.getValue() instanceof J.MethodDeclaration) {
                        methodCursor.putMessage(MSG_KEY, _return.getExpression().getType());
                    }
                }
                return super.visitReturn(_return, ctx);
            }
        });
    }
}
",{}
Add trailing slash to Spring routes,"This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeUtils;

import static org.openrewrite.java.tree.Space.EMPTY;

public class AddRouteTrailingSlash extends Recipe {
    private static final String GET_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.GetMapping"";
    private static final String REQUEST_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.RequestMapping"";
    private static final String POST_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.PostMapping"";
    private static final String PUT_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.PutMapping"";
    private static final String PATCH_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.PatchMapping"";
    private static final String DELETE_ANNOTATION_TYPE = ""org.springframework.web.bind.annotation.DeleteMapping"";

    @Override
    public String getDisplayName() {
        return ""Add trailing slash to Spring routes"";
    }

    @Override
    public String getDescription() {
        return ""This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing "" +
               ""slash matching configuration option has been deprecated and its default value set to false. This "" +
               ""means that previously, a controller `@GetMapping(\""/some/greeting\"")` would match both `GET "" +
               ""/some/greeting` and `GET /some/greeting/`, but it doesn't match `GET /some/greeting/` anymore by "" +
               ""default and will result in an HTTP 404 error. This recipe is to add declaration of additional route "" +
               ""explicitly on the controller handler (like `@GetMapping(\""/some/greeting\"", \""/some/greeting/\"")`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                J.Annotation anno = super.visitAnnotation(annotation, ctx);
                if (anno.getType() == null ||
                    !isHttpVerbMappingAnnotation(anno.getType().toString()) ||
                    anno.getArguments() == null) {
                    return anno;
                }

                if (anno.getArguments().size() == 1 && isStringLiteral(anno.getArguments().get(0))) {
                    J.Literal str = (J.Literal) anno.getArguments().get(0);
                    if (shouldAddTrailingSlashArgument(str.getValue().toString())) {
                        J.Annotation replacement = JavaTemplate.builder(""{#{any(String)}, #{any(String)}}"")
                                .build()
                                .apply(getCursor(),
                                        anno.getCoordinates().replaceArguments(),
                                        (Object[]) buildTwoStringsArray(str));
                        return autoFormat(replacement, ctx);
                    }
                } else {
                    // replace value
                    J.Annotation replacement = anno.withArguments(ListUtils.map(anno.getArguments(), exp -> {
                        if (exp instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) exp;
                            if (assignment.getVariable() instanceof J.Identifier &&
                                ""value"".equals(((J.Identifier) assignment.getVariable()).getSimpleName()) &&
                                isStringLiteral(assignment.getAssignment())) {

                                J.Literal str = (J.Literal) assignment.getAssignment();
                                if (shouldAddTrailingSlashArgument(str.getValue().toString())) {
                                    return JavaTemplate.builder(""value = {#{any(String)}, #{any(String)}}"")
                                            .contextSensitive()
                                            .build()
                                            .<J.Annotation>apply(getCursor(),
                                                    anno.getCoordinates().replaceArguments(),
                                                    (Object[]) buildTwoStringsArray(str)).getArguments().get(0);
                                }
                            }
                        }
                        return exp;
                    }));
                    return maybeAutoFormat(annotation, replacement, ctx);
                }

                return anno;
            }
        };
    }

    private boolean shouldAddTrailingSlashArgument(String str) {
        return !str.endsWith(""/"") && !str.endsWith(""*"");
    }

    private J[] buildTwoStringsArray(J.Literal path) {
        String oriPath = path.getValue().toString();
        String pathWithTrailingSlash = oriPath + '/';
        return new J[]{
                path.withId(Tree.randomId())
                        .withPrefix(EMPTY),
                path.withId(Tree.randomId())
                        .withPrefix(Space.SINGLE_SPACE)
                        .withValue(pathWithTrailingSlash)
                        .withValueSource(""\"""" + pathWithTrailingSlash + ""\"""")
        };
    }

    private static boolean isHttpVerbMappingAnnotation(String fqn) {
        return GET_ANNOTATION_TYPE.equals(fqn) ||
               REQUEST_ANNOTATION_TYPE.equals(fqn) ||
               POST_ANNOTATION_TYPE.equals(fqn) ||
               PUT_ANNOTATION_TYPE.equals(fqn) ||
               PATCH_ANNOTATION_TYPE.equals(fqn) ||
               DELETE_ANNOTATION_TYPE.equals(fqn);
    }


    private static boolean isStringLiteral(Expression expression) {
        return expression instanceof J.Literal && TypeUtils.isString(((J.Literal) expression).getType());
    }
}
",{}
Remove Unnecessary `@ConstructorBinding`,As of Boot 3.0 `@ConstructorBinding` is no longer needed at the type level on `@ConfigurationProperties` classes and should be removed.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Javadoc;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

/**
 * @author Alex Boyko
 */
public class RemoveConstructorBindingAnnotation extends Recipe {

    private static final String ANNOTATION_CONSTRUCTOR_BINDING = ""org.springframework.boot.context.properties.ConstructorBinding"";
    private static final String ANNOTATION_CONFIG_PROPERTIES = ""org.springframework.boot.context.properties.ConfigurationProperties"";

    @Override
    public String getDisplayName() {
        return ""Remove Unnecessary `@ConstructorBinding`"";
    }

    @Override
    public String getDescription() {
        return ""As of Boot 3.0 `@ConstructorBinding` is no longer needed at the type level on `@ConfigurationProperties` classes and should be removed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.boot.context.properties.ConstructorBinding"", false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);

                // Collect the class constructors.
                List<J.MethodDeclaration> constructors = c.getBody().getStatements().stream()
                        .filter(org.openrewrite.java.tree.J.MethodDeclaration.class::isInstance)
                        .map(org.openrewrite.java.tree.J.MethodDeclaration.class::cast)
                        .filter(J.MethodDeclaration::isConstructor)
                        .collect(toList());

                if (constructors.size() == 1) {
                    Optional<J.Annotation> bindingAnnotation = constructors.get(0).getLeadingAnnotations().stream()
                            .filter(a -> TypeUtils.isOfClassType(a.getType(), ANNOTATION_CONSTRUCTOR_BINDING))
                            .findAny();

                    // A single class constructor with a ConstructorBinding annotation is present.
                    if (bindingAnnotation.isPresent()) {
                        c = c.withBody(c.getBody().withStatements(
                                ListUtils.map(c.getBody().getStatements(), s -> {
                                    if (s == constructors.get(0)) {
                                        J.MethodDeclaration m = (J.MethodDeclaration) s;
                                        // Only visit the `J.MethodDeclaration` subtree and remove the target annotation.
                                        maybeRemoveImport(ANNOTATION_CONSTRUCTOR_BINDING);
                                        return new RemoveTargetAnnotation(bindingAnnotation.get()).visitMethodDeclaration(m, ctx);
                                    }
                                    return s;
                                }))
                        );
                    }
                }

                if (c.getLeadingAnnotations().stream().anyMatch(a -> TypeUtils.isOfClassType(a.getType(), ANNOTATION_CONFIG_PROPERTIES))) {
                    c = c.withLeadingAnnotations(ListUtils.map(c.getLeadingAnnotations(), anno -> {
                        if (TypeUtils.isOfClassType(anno.getType(), ANNOTATION_CONSTRUCTOR_BINDING)) {
                            if (constructors.size() <= 1) {
                                maybeRemoveImport(ANNOTATION_CONSTRUCTOR_BINDING);
                                return null;
                            }
                            return anno.withComments(maybeAddJavaDoc(anno.getComments(), anno.getPrefix().getIndent()));
                        }
                        return anno;
                    }));
                }
                return c;
            }

            /**
             * Adds the target Javadoc if it does not exist in the list of comments.
             * Generates a properly structured Javadoc to enable autoformatting features
             * like {@link org.openrewrite.xml.format.NormalizeLineBreaks}.
             */
            private List<Comment> maybeAddJavaDoc(List<Comment> comments, String indent) {
                String message = ""You need to remove ConstructorBinding on class level and move it to appropriate"";
                if (comments.isEmpty() || comments.stream()
                        .filter(org.openrewrite.java.tree.Javadoc.DocComment.class::isInstance)
                        .map(org.openrewrite.java.tree.Javadoc.DocComment.class::cast)
                        .flatMap(o -> o.getBody().stream().filter(org.openrewrite.java.tree.Javadoc.Text.class::isInstance))
                        .noneMatch(o -> o.print(getCursor()).equals(message))) {

                    List<Javadoc> javadoc = new ArrayList<>();
                    javadoc.add(new Javadoc.LineBreak(randomId(), ""\n"" + indent + "" * "", Markers.EMPTY));
                    javadoc.add(new Javadoc.Text(randomId(), Markers.EMPTY, ""TODO:""));
                    javadoc.add(new Javadoc.LineBreak(randomId(), ""\n"" + indent + "" * "", Markers.EMPTY));
                    javadoc.add(new Javadoc.Text(randomId(), Markers.EMPTY, message));
                    javadoc.add(new Javadoc.LineBreak(randomId(), ""\n"" + indent + "" * "", Markers.EMPTY));
                    javadoc.add(new Javadoc.Text(randomId(), Markers.EMPTY, ""constructor.""));
                    javadoc.add(new Javadoc.LineBreak(randomId(), ""\n"" + indent + "" "", Markers.EMPTY));

                    List<Comment> newComments = new ArrayList<>(comments);
                    newComments.add(new Javadoc.DocComment(randomId(), Markers.EMPTY, javadoc, ""\n"" + indent));
                    return newComments;
                }
                return comments;
            }

            /**
             * Removes a target annotation from a `Tree`.
             *
             * Note:
             * This may be useful in other Spring recipes to remove specific annotations
             * based on a set of criteria.
             *
             * Move the visitor into a new class if it's reused.
             */
            class RemoveTargetAnnotation extends JavaIsoVisitor<ExecutionContext> {
                private final J.Annotation targetToRemove;

                public RemoveTargetAnnotation(J.Annotation targetToRemove) {
                    this.targetToRemove = targetToRemove;
                }

                @Override
                public J.@Nullable Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                    if (targetToRemove == annotation) {
                        return null;
                    }
                    return super.visitAnnotation(annotation, ctx);
                }
            }
        });
    }

}
",{}
Migrate `WebMvcTagsProvider` to `DefaultServerRequestObservationConvention`,Migrate `WebMvcTagsProvider` to `DefaultServerRequestObservationConvention` as part of Spring Boot 3.2 removals.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.search.FindImplementations;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.nCopies;

public class MigrateWebMvcTagsToObservationConvention extends Recipe {

    private static final String DEFAULTSERVERREQUESTOBSERVATIONCONVENTION_FQ = ""org.springframework.http.server.observation.DefaultServerRequestObservationConvention"";
    private static final String HTTPSERVLETREQUEST_FQ = ""jakarta.servlet.http.HttpServletRequest"";
    private static final String HTTPSERVLETRESPONSE_FQ = ""jakarta.servlet.http.HttpServletResponse"";
    private static final String KEYVALUE_FQ = ""io.micrometer.common.KeyValue"";
    private static final String KEYVALUES_FQ = ""io.micrometer.common.KeyValues"";
    private static final String SERVERREQUESTOBSERVATIONCONVENTION_FQ = ""org.springframework.http.server.observation.ServerRequestObservationContext"";
    private static final String TAG_FQ = ""io.micrometer.core.instrument.Tag"";
    private static final String TAGS_FQ = ""io.micrometer.core.instrument.Tags"";
    private static final String WEBMVCTAGS_FQ = ""org.springframework.boot.actuate.metrics.web.servlet.WebMvcTags"";
    private static final String WEBMVCTAGSPROVIDER_FQ = ""org.springframework.boot.actuate.metrics.web.servlet.WebMvcTagsProvider"";
    private static final MethodMatcher GET_TAGS = new MethodMatcher(""* getTags(jakarta.servlet.http.HttpServletRequest, jakarta.servlet.http.HttpServletResponse, java.lang.Object, java.lang.Throwable)"");
    private static final MethodMatcher GET_LONG_REQUEST_TAGS = new MethodMatcher(""* getLongRequestTags(jakarta.servlet.http.HttpServletRequest, java.lang.Object)"");
    private static final MethodMatcher GET_HIGH_CARD_KEY_VALUES = new MethodMatcher(""* getHighCardinalityKeyValues(org.springframework.http.server.observation.ServerRequestObservationContext)"");
    private static final MethodMatcher TAG_OF = new MethodMatcher(""io.micrometer.core.instrument.Tag of(java.lang.String, java.lang.String)"");
    private static final MethodMatcher TAGS_AND_STRING_STRING = new MethodMatcher(""io.micrometer.core.instrument.Tags and(java.lang.String, java.lang.String)"");
    private static final MethodMatcher TAGS_AND_STRING_ARRAY = new MethodMatcher(""io.micrometer.core.instrument.Tags and(java.lang.String[])"");
    private static final MethodMatcher TAGS_AND_TAG_ARRAY = new MethodMatcher(""io.micrometer.core.instrument.Tags and(io.micrometer.core.instrument.Tag[])"");
    private static final MethodMatcher TAGS_AND_TAG_ITERABLE = new MethodMatcher(""io.micrometer.core.instrument.Tags and(java.lang.Iterable)"");
    private static final MethodMatcher TAGS_OF_STRING_STRING = new MethodMatcher(""io.micrometer.core.instrument.Tags of(java.lang.String, java.lang.String)"");
    private static final MethodMatcher TAGS_OF_STRING_ARRAY = new MethodMatcher(""io.micrometer.core.instrument.Tags of(java.lang.String[])"");
    private static final MethodMatcher TAGS_OF_TAG_ARRAY = new MethodMatcher(""io.micrometer.core.instrument.Tags of(io.micrometer.core.instrument.Tag[])"");
    private static final MethodMatcher TAGS_OF_TAG_ITERABLE = new MethodMatcher(""io.micrometer.core.instrument.Tags of(java.lang.Iterable)"");
    private static final MethodMatcher TAGS_OF_ANY = new MethodMatcher(""io.micrometer.core.instrument.Tags of(..)"");

    @Override
    public String getDisplayName() {
        return ""Migrate `WebMvcTagsProvider` to `DefaultServerRequestObservationConvention`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate `WebMvcTagsProvider` to `DefaultServerRequestObservationConvention` as part of Spring Boot 3.2 removals."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new FindImplementations(WEBMVCTAGSPROVIDER_FQ).getVisitor(),
                        Preconditions.not(new DeclaresMethod<>(GET_LONG_REQUEST_TAGS)
                        )),
                new JavaVisitor<ExecutionContext>() {
                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        J.MethodDeclaration getTagsMethod = null;
                        List<Statement> getTagsBodyStatements = new ArrayList<>();
                        for (Statement stmt : classDecl.getBody().getStatements()) {
                            if (stmt instanceof J.MethodDeclaration) {
                                J.MethodDeclaration md = (J.MethodDeclaration) stmt;
                                if (GET_TAGS.matches(md, classDecl)) {
                                    getTagsMethod = md;
                                    if (getTagsMethod.getBody() != null) {
                                        getTagsBodyStatements.addAll(getTagsMethod.getBody().getStatements().subList(0, getTagsMethod.getBody().getStatements().size() - 1));
                                        Statement ret = getTagsMethod.getBody().getStatements().get(getTagsMethod.getBody().getStatements().size() - 1);
                                        if (ret instanceof J.Return && ((J.Return) ret).getExpression() instanceof J.MethodInvocation) {
                                            if (TAGS_OF_ANY.matches(((J.Return) ret).getExpression())) {
                                                getTagsBodyStatements.add((Statement) ((J.Return) ret).getExpression());
                                            }
                                        }
                                        break;
                                    }

                                }
                            }
                        }

                        String tmpl = ""class "" + classDecl.getSimpleName() + "" extends DefaultServerRequestObservationConvention {\n"" +
                                ""    @Override\n"" +
                                ""    public KeyValues getHighCardinalityKeyValues(ServerRequestObservationContext context) {\n"" +
                                ""        KeyValues values = super.getHighCardinalityKeyValues(context);\n"" +
                                ""        return values;"" +
                                ""    }\n"" +
                                ""}"";
                        J.ClassDeclaration newClassDeclaration = JavaTemplate.builder(tmpl)
                                .contextSensitive()
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+"", ""spring-web-6.+"", ""jakarta.servlet-api""))
                                .imports(DEFAULTSERVERREQUESTOBSERVATIONCONVENTION_FQ, KEYVALUES_FQ, HTTPSERVLETREQUEST_FQ, HTTPSERVLETRESPONSE_FQ, SERVERREQUESTOBSERVATIONCONVENTION_FQ)
                                .build()
                                .apply(getCursor(), classDecl.getCoordinates().replace());

                        J.ClassDeclaration finalNewClassDeclaration = newClassDeclaration;
                        final J.MethodDeclaration finalGetTagsMethod = getTagsMethod;
                        newClassDeclaration = newClassDeclaration
                                .withId(classDecl.getId())
                                .withLeadingAnnotations(classDecl.getLeadingAnnotations())
                                .withModifiers(classDecl.getModifiers())
                                .withPrefix(classDecl.getPrefix())
                                .withBody(newClassDeclaration.getBody().withStatements(ListUtils.map(classDecl.getBody().getStatements(), stmt -> {
                                    if (stmt.equals(finalGetTagsMethod)) {
                                        J.MethodDeclaration md = (J.MethodDeclaration) finalNewClassDeclaration.getBody().getStatements().get(0);
                                        md = md.withPrefix(stmt.getPrefix());
                                        //noinspection DataFlowIssue
                                        return md.withBody(md.getBody().withStatements(ListUtils.insertAll(md.getBody().getStatements(), md.getBody().getStatements().size() - 1, getTagsBodyStatements)));
                                    }
                                    return stmt;
                                })));
                        maybeAddImport(DEFAULTSERVERREQUESTOBSERVATIONCONVENTION_FQ);
                        maybeAddImport(KEYVALUE_FQ);
                        maybeAddImport(KEYVALUES_FQ);
                        maybeAddImport(SERVERREQUESTOBSERVATIONCONVENTION_FQ);
                        maybeRemoveImport(HTTPSERVLETREQUEST_FQ);
                        maybeRemoveImport(HTTPSERVLETRESPONSE_FQ);
                        maybeRemoveImport(TAG_FQ);
                        maybeRemoveImport(TAGS_FQ);
                        maybeRemoveImport(WEBMVCTAGS_FQ);
                        maybeRemoveImport(WEBMVCTAGSPROVIDER_FQ);
                        updateCursor(newClassDeclaration);
                        return (J.ClassDeclaration) super.visitClassDeclaration(newClassDeclaration, ctx);
                    }

                    @Override
                    public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                        J.MethodDeclaration m = (J.MethodDeclaration) super.visitMethodDeclaration(method, ctx);
                        J.ClassDeclaration cd = getCursor().firstEnclosing(J.ClassDeclaration.class);
                        if (cd != null && GET_HIGH_CARD_KEY_VALUES.matches(m, cd)) {
                            J.VariableDeclarations methodParam = (J.VariableDeclarations) m.getParameters().get(0);
                            J.Identifier methodParamIdentifier = methodParam.getVariables().get(0).getName();
                            Boolean addHttpServletResponse = getCursor().pollMessage(""addHttpServletResponse"");
                            Boolean addHttpServletRequest = getCursor().pollMessage(""addHttpServletRequest"");
                            if (Boolean.TRUE.equals(addHttpServletResponse) && m.getBody() != null) {
                                m = JavaTemplate.builder(""HttpServletResponse response = #{any()}.getResponse();"")
                                        .imports(HTTPSERVLETRESPONSE_FQ)
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""jakarta.servlet-api"", ""spring-web-6.+"", ""micrometer-observation-1.11.+""))
                                        .build()
                                        .apply(updateCursor(m), m.getBody().getCoordinates().firstStatement(), methodParamIdentifier);
                            }
                            if (Boolean.TRUE.equals(addHttpServletRequest) && m.getBody() != null) {
                                m = JavaTemplate.builder(""HttpServletRequest request = #{any()}.getCarrier();"")
                                        .imports(HTTPSERVLETREQUEST_FQ)
                                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""jakarta.servlet-api"", ""spring-web-6.+"", ""micrometer-observation-1.11.+""))
                                        .build()
                                        .apply(updateCursor(m), m.getBody().getCoordinates().firstStatement(), methodParamIdentifier);
                            }
                        }
                        return m;
                    }

                    @Override
                    public Statement visitStatement(Statement statement, ExecutionContext ctx) {
                        Statement s = (Statement) super.visitStatement(statement, ctx);
                        if (s instanceof J.VariableDeclarations) {
                            J.VariableDeclarations vd = (J.VariableDeclarations) s;
                            if (TypeUtils.isOfType(vd.getType(), JavaType.buildType(TAGS_FQ))) {
                                if (vd.getVariables().get(0).getInitializer() != null) {
                                    //noinspection DataFlowIssue
                                    return refactorTagsUsage(ctx, vd.getCoordinates(), (J.MethodInvocation) vd.getVariables().get(0).getInitializer(), vd);
                                }
                            }
                            return vd;
                        }
                        if (s instanceof J.Assignment) {
                            J.Assignment a = (J.Assignment) s;
                            if (TypeUtils.isOfType(a.getType(), JavaType.buildType(TAGS_FQ))) {
                                return refactorTagsUsage(ctx, a.getCoordinates(), (J.MethodInvocation) a.getAssignment(), a);
                            }
                            return a;
                        }
                        if (s instanceof J.MethodInvocation) {
                            J.MethodInvocation mi = (J.MethodInvocation) s;
                            if (TAGS_OF_ANY.matches(mi)) {
                                return refactorTagsUsage(ctx, mi.getCoordinates(), mi, mi);
                            }
                        }
                        return s;
                    }

                    private Statement refactorTagsUsage(ExecutionContext ctx, org.openrewrite.java.tree.CoordinateBuilder.Statement coords, J.MethodInvocation init, Statement original) {
                        J.MethodDeclaration insideMethod = getCursor().firstEnclosing(J.MethodDeclaration.class);
                        if (insideMethod != null && insideMethod.getBody() != null) {
                            J.Identifier returnIdentifier = (J.Identifier) ((J.Return) insideMethod.getBody().getStatements().get(insideMethod.getBody().getStatements().size() - 1)).getExpression();

                            if (returnIdentifier != null) {
                                if (TAGS_AND_STRING_STRING.matches(init) || TAGS_OF_STRING_STRING.matches(init)) {
                                    J.MethodInvocation createKeyValue = JavaTemplate.builder(""KeyValue.of(#{any(java.lang.String)}, #{any(java.lang.String)})"")
                                            .imports(KEYVALUE_FQ)
                                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+""))
                                            .build()
                                            .apply(getCursor(), coords.replace(), init.getArguments().get(0), init.getArguments().get(1));
                                    return JavaTemplate.builder(""#{any()}.and(#{any(io.micrometer.common.KeyValue)})"")
                                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+""))
                                            .build()
                                            .apply(getCursor(), coords.replace(), returnIdentifier, createKeyValue);
                                }
                                if (TAGS_AND_STRING_ARRAY.matches(init) || TAGS_OF_STRING_ARRAY.matches(init)) {
                                    List<J> args = new ArrayList<>();
                                    for (int i = 0; i < init.getArguments().size(); i += 2) {
                                        args.add(JavaTemplate.builder(""KeyValue.of(#{any(java.lang.String)}, #{any(java.lang.String)})"")
                                                .imports(KEYVALUE_FQ)
                                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+""))
                                                .build()
                                                .apply(getCursor(), coords.replace(), init.getArguments().get(i), init.getArguments().get(i + 1)));
                                    }
                                    return getMultiKeyValueStatement(ctx, coords, args, returnIdentifier);
                                }
                                if (TAGS_AND_TAG_ARRAY.matches(init) || TAGS_OF_TAG_ARRAY.matches(init)) {
                                    List<Expression> validArgs = ListUtils.map(init.getArguments(), expression -> {
                                        if (expression instanceof J.MethodInvocation && ((J.MethodInvocation) expression).getMethodType() != null && TypeUtils.isOfType(((J.MethodInvocation) expression).getMethodType().getDeclaringType(), JavaType.buildType(WEBMVCTAGS_FQ))) {
                                            //noinspection DataFlowIssue
                                            return null;
                                        }
                                        return expression;
                                    });
                                    if (validArgs.isEmpty()) {
                                        //noinspection DataFlowIssue
                                        return null;
                                    }
                                    List<J> args = new ArrayList<>();
                                    for (Expression arg : validArgs) {
                                        if (arg instanceof J.MethodInvocation && TAG_OF.matches(arg)) {
                                            args.add(JavaTemplate.builder(""KeyValue.of(#{any(java.lang.String)}, #{any(java.lang.String)})"")
                                                    .imports(KEYVALUE_FQ)
                                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+""))
                                                    .build()
                                                    .apply(getCursor(), coords.replace(), ((J.MethodInvocation) arg).getArguments().get(0), ((J.MethodInvocation) arg).getArguments().get(1)));
                                        } else {
                                            args.add(JavaTemplate.builder(""KeyValue.of(#{any()}.getKey(), #{any()}.getValue())"")
                                                    .imports(KEYVALUE_FQ)
                                                    .contextSensitive()
                                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-core-1.11.+"", ""micrometer-commons-1.11.+""))
                                                    .build()
                                                    .apply(getCursor(), coords.replace(), arg, arg));
                                        }

                                    }
                                    return getMultiKeyValueStatement(ctx, coords, args, returnIdentifier);
                                }
                                if (TAGS_AND_TAG_ITERABLE.matches(init) || TAGS_OF_TAG_ITERABLE.matches(init)) {
                                    Expression iterable = init.getArguments().get(0);
                                    String template = ""for (Tag tag : #{any()}) {\n"" +
                                            ""    #{any()}.and(KeyValue.of(tag.getKey(), tag.getValue()));\n"" +
                                            ""}\n"";
                                    J.ForEachLoop foreach = JavaTemplate.builder(template)
                                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-core-1.11.+"", ""micrometer-commons-1.11.+""))
                                            .imports(TAG_FQ, KEYVALUE_FQ)
                                            .build()
                                            .apply(getCursor(), coords.replace(), iterable, returnIdentifier);
                                    return foreach.withControl(foreach.getControl().withIterable(foreach.getControl().getIterable().withPrefix(Space.SINGLE_SPACE)));
                                }
                            }
                        }
                        return original;
                    }

                    private Statement getMultiKeyValueStatement(ExecutionContext ctx, CoordinateBuilder.Statement coords, List<J> args, J.Identifier returnIdentifier) {
                        String keyValueVarArg = ""#{any(io.micrometer.common.KeyValue)}"";
                        String keyValueVarArgsCombined = String.join("", "", nCopies(args.size(), keyValueVarArg));
                        return JavaTemplate.builder(""#{any()}.and("" + keyValueVarArgsCombined + "")"")
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""micrometer-commons-1.11.+""))
                                .build()
                                .apply(getCursor(), coords.replace(), ListUtils.insert(args, returnIdentifier, 0).toArray());
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                        J.MethodDeclaration enclosingMethod = getCursor().firstEnclosing(J.MethodDeclaration.class);
                        if (enclosingMethod != null && ""getHighCardinalityKeyValues"".equals(enclosingMethod.getSimpleName())) {
                            if (m.getMethodType() != null && TypeUtils.isOfType(m.getMethodType().getDeclaringType(), JavaType.buildType(HTTPSERVLETREQUEST_FQ))) {
                                getCursor().putMessageOnFirstEnclosing(J.MethodDeclaration.class, ""addHttpServletRequest"", true);
                            }
                            if (m.getMethodType() != null && TypeUtils.isOfType(m.getMethodType().getDeclaringType(), JavaType.buildType(HTTPSERVLETRESPONSE_FQ))) {
                                getCursor().putMessageOnFirstEnclosing(J.MethodDeclaration.class, ""addHttpServletResponse"", true);
                            }
                        }

                        return m;
                    }
                });
    }
}
",{}
Replace `RestTemplateBuilder.requestFactory(Function)` with `requestFactoryBuilder`,"`RestTemplateBuilder.requestFactory(java.util.function.Function)` was deprecated since Spring Boot 3.4, in favor of `requestFactoryBuilder(ClientHttpRequestFactoryBuilder)`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;

public class ReplaceRestTemplateBuilderRequestFactoryMethod extends Recipe {

    private static final MethodMatcher REQUEST_FACTORY_MATCHER = new MethodMatcher(""org.springframework.boot.web.client.RestTemplateBuilder requestFactory(java.util.function.Function)"");

    @Override
    public String getDisplayName() {
        return ""Replace `RestTemplateBuilder.requestFactory(Function)` with `requestFactoryBuilder`"";
    }

    @Override
    public String getDescription() {
        return ""`RestTemplateBuilder.requestFactory(java.util.function.Function)` was deprecated since Spring Boot 3.4, in favor of `requestFactoryBuilder(ClientHttpRequestFactoryBuilder)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(REQUEST_FACTORY_MATCHER), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (REQUEST_FACTORY_MATCHER.matches(mi) && mi.getSelect() != null) {
                    J replacement = JavaTemplate.builder(""#{any()}.requestFactoryBuilder(settings -> #{any()}.apply(ClientHttpRequestFactorySettings.of(settings)))"")
                            .imports(""org.springframework.boot.web.client.ClientHttpRequestFactorySettings"")
                            .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-web-6.2"", ""spring-boot-3.+""))
                            .build()
                            .apply(getCursor(), mi.getCoordinates().replace(), mi.getSelect(), mi.getArguments().get(0));
                    doAfterVisit(ShortenFullyQualifiedTypeReferences.modifyOnly(replacement));
                    return replacement;
                }
                return mi;
            }
        });
    }
}
",{}
Add `@Valid` to nested properties in `@ConfigurationProperties`,Adds `@Valid` annotation to fields in `@ConfigurationProperties` classes that contain nested properties with validation constraints.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.Comparator;

public class AddValidToNestedConfigProperties extends Recipe {

    private static final String CONFIGURATION_PROPERTIES = ""org.springframework.boot.context.properties.ConfigurationProperties"";
    private static final String VALIDATED = ""org.springframework.validation.annotation.Validated"";
    private static final String JAKARTA_VALIDATION_VALID = ""jakarta.validation.Valid"";

    @Override
    public String getDisplayName() {
        return ""Add `@Valid` to nested properties in `@ConfigurationProperties`"";
    }

    @Override
    public String getDescription() {
        return ""Adds `@Valid` annotation to fields in `@ConfigurationProperties` classes that contain nested properties with validation constraints."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new UsesType<>(CONFIGURATION_PROPERTIES, true),
                        new UsesType<>(VALIDATED, true)
                ),
                new JavaIsoVisitor<ExecutionContext>() {
                    boolean visitedTopLevelClass = false;

                    @Override
                    public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                        if (visitedTopLevelClass) {
                            return super.visitClassDeclaration(classDecl, ctx);
                        }
                        visitedTopLevelClass = true;
                        if (!FindAnnotations.find(classDecl, ""@"" + CONFIGURATION_PROPERTIES).isEmpty() &&
                                !FindAnnotations.find(classDecl, ""@"" + VALIDATED).isEmpty()) {
                            return super.visitClassDeclaration(classDecl, ctx);
                        }
                        return classDecl;
                    }

                    @Override
                    public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations varDecl, ExecutionContext ctx) {
                        JavaType.FullyQualified type = TypeUtils.asFullyQualified(varDecl.getType());
                        if (type != null && !isPrimitiveOrCommonType(type) &&
                                FindAnnotations.find(varDecl, ""@javax.validation.Valid"").isEmpty() &&
                                FindAnnotations.find(varDecl, ""@"" + JAKARTA_VALIDATION_VALID).isEmpty()) {
                            maybeAddImport(JAKARTA_VALIDATION_VALID);
                            return JavaTemplate.builder(""@Valid"")
                                    .imports(JAKARTA_VALIDATION_VALID)
                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""jakarta.validation-api""))
                                    .build()
                                    .apply(getCursor(), varDecl.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                        }
                        return super.visitVariableDeclarations(varDecl, ctx);
                    }

                    private boolean isPrimitiveOrCommonType(JavaType.FullyQualified type) {
                        String name = type.getFullyQualifiedName();
                        return name.startsWith(""java."") ||
                                name.startsWith(""javax."") ||
                                name.startsWith(""sun."") ||
                                name.startsWith(""com.sun."") ||
                                name.startsWith(""jdk."");
                    }
                });
    }
}
",{}
Add `SetUseTrailingSlashMatch()` in configuration,"This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;

import java.util.concurrent.atomic.AtomicBoolean;

public class AddSetUseTrailingSlashMatch extends Recipe {
    private static final MethodMatcher WEB_MVC_setUseTrailingSlashMatch = new MethodMatcher(
            ""org.springframework.web.servlet.config.annotation.PathMatchConfigurer setUseTrailingSlashMatch(java.lang.Boolean)""
    );
    private static final MethodMatcher WEB_FLUX_setUseTrailingSlashMatch = new MethodMatcher(
            ""org.springframework.web.reactive.config.PathMatchConfigurer setUseTrailingSlashMatch(java.lang.Boolean)""
    );

    private static final String WEB_MVC_CONFIGURER = ""org.springframework.web.servlet.config.annotation.WebMvcConfigurer"";
    private static final String WEB_FLUX_CONFIGURER = ""org.springframework.web.reactive.config.WebFluxConfigurer"";

    private static final String WEB_MVC_PATH_MATCH_CONFIGURER = ""org.springframework.web.servlet.config.annotation.PathMatchConfigurer"";
    private static final String WEB_FLUX_PATH_MATCH_CONFIGURER = ""org.springframework.web.reactive.config.PathMatchConfigurer"";

    @Override
    public String getDisplayName() {
        return ""Add `SetUseTrailingSlashMatch()` in configuration"";
    }

    @Override
    public String getDescription() {
        return ""This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing "" +
               ""slash matching configuration option has been deprecated and its default value set to false. "" +
               ""This means that previously, a controller `@GetMapping(\""/some/greeting\"")` would match both "" +
               ""`GET /some/greeting` and `GET /some/greeting/`, but it doesn't match `GET /some/greeting/` "" +
               ""anymore by default and will result in an HTTP 404 error. This recipe is change the default with "" +
               ""the global Spring MVC or Webflux configuration."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(WEB_MVC_CONFIGURER, false),
                new UsesType<>(WEB_FLUX_CONFIGURER, false)
        ), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                boolean isWebConfigClass = false;
                boolean isWebMVC = false;
                if (classDecl.getImplements() != null) {
                    for (TypeTree impl : classDecl.getImplements()) {
                        JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(impl.getType());
                        if (fullyQualified != null &&
                                (WEB_MVC_CONFIGURER.equals(fullyQualified.getFullyQualifiedName()) ||
                                        WEB_FLUX_CONFIGURER.equals(fullyQualified.getFullyQualifiedName()))
                        ) {
                            isWebMVC = WEB_MVC_CONFIGURER.equals(fullyQualified.getFullyQualifiedName());
                            isWebConfigClass = true;
                            break;
                        }
                    }
                }

                if (!isWebConfigClass) {
                    return classDecl;
                }

                // Check whether this class has `configurePathMatch` method
                // 1. if it already has, then check if it calls method `setUseTrailingSlashMatch`.
                //      (1) if it has `setUseTrailingSlashMatch` called, do nothing.
                //      (2) if it has not `setUseTrailingSlashMatch` called, add `setUseTrailingSlashMatch(true)` to
                //      this method
                // 2. if it has not `configurePathMatch` method, add it to this class.
                boolean configMethodExists = classDecl.getBody().getStatements().stream()
                        .filter(org.openrewrite.java.tree.J.MethodDeclaration.class::isInstance)
                        .map(J.MethodDeclaration.class::cast)
                        .anyMatch(methodDeclaration -> isWebMVCConfigurerMatchMethod(methodDeclaration) ||
                                isWebFluxconfigurePathMatchingMethod(methodDeclaration));

                if (configMethodExists) {
                    return super.visitClassDeclaration(classDecl, ctx);
                }
                // add a `configurePathMatch` or `configurePathMatching` method to this class
                JavaTemplate webMvcConfigurePathMatchTemplate = JavaTemplate.builder(
                        ""@Override public void configurePathMatch(PathMatchConfigurer configurer) { configurer"" +
                                "".setUseTrailingSlashMatch(true); }"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-webmvc-5"", ""spring-context-5"", ""spring-web-5""))
                        .imports(WEB_MVC_PATH_MATCH_CONFIGURER,
                                ""org.springframework.web.servlet.config.annotation.WebMvcConfigurer"",
                                ""org.springframework.context.annotation.Configuration"")
                        .build();

                JavaTemplate webFluxConfigurePathMatchingTemplate =
                        JavaTemplate.builder(
                                ""@Override public void configurePathMatching(PathMatchConfigurer configurer) { configurer"" +
                                        "".setUseTrailingSlashMatch(true); }"")
                                .contextSensitive()
                                .javaParser(JavaParser.fromJavaVersion()
                                        .classpathFromResources(ctx, ""spring-webflux-5"", ""spring-context-5"", ""spring-web-5""))
                                .imports(WEB_FLUX_PATH_MATCH_CONFIGURER,
                                        ""org.springframework.web.reactive.config.WebFluxConfigurer"",
                                        ""org.springframework.context.annotation.Configuration"")
                                .build();

                JavaTemplate template = isWebMVC ? webMvcConfigurePathMatchTemplate : webFluxConfigurePathMatchingTemplate;
                classDecl = template.apply(getCursor(), classDecl.getBody().getCoordinates().lastStatement());

                String importPathMatchConfigurer = isWebMVC ? WEB_MVC_PATH_MATCH_CONFIGURER : WEB_FLUX_PATH_MATCH_CONFIGURER;
                maybeAddImport(importPathMatchConfigurer, false);
                return classDecl;
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method,
                                                              ExecutionContext ctx) {

                if (isWebMVCConfigurerMatchMethod(method) || isWebFluxconfigurePathMatchingMethod(method)) {

                    if (findSetUseTrailingSlashMatchMethodCall.find(method)) {
                        // do nothing
                        return method;
                    }
                    // add statement

                    JavaTemplate webMvcTemplate = JavaTemplate.builder(""#{any()}.setUseTrailingSlashMatch(true);"")
                            .contextSensitive()
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-webmvc-5"", ""spring-context-5"", ""spring-web-5""))
                            .imports(WEB_MVC_PATH_MATCH_CONFIGURER,
                                    ""org.springframework.web.servlet.config.annotation.WebMvcConfigurer"",
                                    ""org.springframework.context.annotation.Configuration"")
                            .build();

                    JavaTemplate webFluxTemplate = JavaTemplate.builder(""#{any()}.setUseTrailingSlashMatch(true);"")
                            .contextSensitive()
                            .javaParser(JavaParser.fromJavaVersion()
                                    .classpathFromResources(ctx, ""spring-webflux-5"", ""spring-context-5"", ""spring-web-5""))
                            .imports(WEB_MVC_PATH_MATCH_CONFIGURER,
                                    ""org.springframework.web.reactive.config.WebFluxConfigurer"",
                                    ""org.springframework.context.annotation.Configuration"")
                            .build();

                    JavaTemplate template = isWebMVCConfigurerMatchMethod(method) ? webMvcTemplate : webFluxTemplate;
                    return  template.apply(
                            getCursor(),
                            method.getBody().getCoordinates().lastStatement(),
                            ((J.VariableDeclarations) method.getParameters().get(0)).getVariables().get(0).getName()
                    );
                }

                return method;
            }
        });
    }

    private static boolean isWebMVCConfigurerMatchMethod(J.MethodDeclaration method) {
        return ""configurePathMatch"".equals(method.getName().getSimpleName()) &&
               method.getMethodType().getParameterTypes().size() == 1 &&
               WEB_MVC_PATH_MATCH_CONFIGURER.equals(method.getMethodType().getParameterTypes().get(0).toString());
    }

    private static boolean isWebFluxconfigurePathMatchingMethod(J.MethodDeclaration method) {
        return ""configurePathMatching"".equals(method.getName().getSimpleName()) &&
               method.getMethodType().getParameterTypes().size() == 1 &&
               WEB_FLUX_PATH_MATCH_CONFIGURER.equals(method.getMethodType().getParameterTypes().get(0).toString());
    }

    private static class findSetUseTrailingSlashMatchMethodCall extends JavaIsoVisitor<AtomicBoolean> {
        static boolean find(J j) {
            return new findSetUseTrailingSlashMatchMethodCall()
                    .reduce(j, new AtomicBoolean()).get();
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean found) {
            if (found.get()) {
                return method;
            }
            if (WEB_MVC_setUseTrailingSlashMatch.matches(method) ||
                WEB_FLUX_setUseTrailingSlashMatch.matches(method)) {
                found.set(true);
                return method;
            }

            return super.visitMethodInvocation(method, found);
        }
    }
}
",{}
Remove `SolrAutoConfiguration`,`SolrAutoConfiguration` was removed in Spring Boot 3; remove references to it from exclusions on annotations.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class RemoveSolrAutoConfigurationExclude extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove `SolrAutoConfiguration`"";
    }

    @Override
    public String getDescription() {
        return ""`SolrAutoConfiguration` was removed in Spring Boot 3; remove references to it from exclusions on annotations."";
    }

    private static final String SPRING_BOOT_APPLICATION = ""org.springframework.boot.autoconfigure.SpringBootApplication"";
    private static final String ENABLE_AUTO_CONFIGURATION = ""org.springframework.boot.autoconfigure.EnableAutoConfiguration"";
    private static final AnnotationMatcher SBA_MATCHER = new AnnotationMatcher(SPRING_BOOT_APPLICATION);
    private static final AnnotationMatcher EAC_MATCHER = new AnnotationMatcher(ENABLE_AUTO_CONFIGURATION);

    private static final String SOLR_AUTO_CONFIGURATION = ""SolrAutoConfiguration"";
    private static final String SOLR_AUTOCONFIGURATION_FQN = ""org.springframework.boot.autoconfigure.solr."" + SOLR_AUTO_CONFIGURATION;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                        new UsesType<>(SPRING_BOOT_APPLICATION, true),
                        new UsesType<>(ENABLE_AUTO_CONFIGURATION, true)),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        J.Annotation a = super.visitAnnotation(annotation, ctx);
                        if (!SBA_MATCHER.matches(a) && !EAC_MATCHER.matches(a)) {
                            return a;
                        }
                        maybeRemoveImport(SOLR_AUTOCONFIGURATION_FQN);

                        return a.withArguments(ListUtils.map(a.getArguments(), it -> {
                            if (it instanceof J.Assignment) {
                                J.Assignment as = (J.Assignment) it;
                                if (as.getAssignment() == null || !""exclude"".equals(((J.Identifier) as.getVariable()).getSimpleName())) {
                                    return it;
                                }
                                if (isSolrAutoConfigurationClassReference(as.getAssignment())) {
                                    return null;
                                }
                                if (as.getAssignment() instanceof J.NewArray) {
                                    J.NewArray array = (J.NewArray) as.getAssignment();
                                    List<Expression> newInitializer = ListUtils.map(array.getInitializer(),
                                            expr -> isSolrAutoConfigurationClassReference(expr) ? null : expr);
                                    //noinspection DataFlowIssue
                                    if (newInitializer.isEmpty()) {
                                        return null;
                                    }
                                    return maybeAutoFormat(it, as.withAssignment(array.withInitializer(newInitializer)), ctx);
                                }
                            }
                            return it;
                        }));
                    }

                    private boolean isSolrAutoConfigurationClassReference(Expression expr) {
                        return expr instanceof J.FieldAccess &&
                               TypeUtils.isAssignableTo(SOLR_AUTOCONFIGURATION_FQN, ((J.FieldAccess) expr).getTarget().getType());
                    }
                });
    }
}
",{}
Maintain trailing slash URL mappings,"This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.boot3;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;

import java.util.concurrent.atomic.AtomicBoolean;

public class MaintainTrailingSlashURLMappings extends ScanningRecipe<AtomicBoolean> {

    private static final String WEB_MVC_CONFIGURER = ""org.springframework.web.servlet.config.annotation.WebMvcConfigurer"";
    private static final String WEB_FLUX_CONFIGURER = ""org.springframework.web.reactive.config.WebFluxConfigurer"";

    @Override
    public String getDisplayName() {
        return ""Maintain trailing slash URL mappings"";
    }

    @Override
    public String getDescription() {
        return ""This is part of Spring MVC and WebFlux URL Matching Changes, as of Spring Framework 6.0, the trailing "" +
               ""slash matching configuration option has been deprecated and its default value set to false. "" +
               ""This means that previously, a controller `@GetMapping(\""/some/greeting\"")` would match both "" +
               ""`GET /some/greeting` and `GET /some/greeting/`, but it doesn't match `GET /some/greeting/` "" +
               ""anymore by default and will result in an HTTP 404 error. This recipe is to maintain trailing slash in "" +
               ""all HTTP url mappings."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (!acc.get() && classDecl.getImplements() != null) {
                    for (TypeTree impl : classDecl.getImplements()) {
                        JavaType.FullyQualified fullyQualified = TypeUtils.asFullyQualified(impl.getType());
                        if (fullyQualified != null &&
                                (WEB_MVC_CONFIGURER.equals(fullyQualified.getFullyQualifiedName()) ||
                                        WEB_FLUX_CONFIGURER.equals(fullyQualified.getFullyQualifiedName()))) {
                            acc.set(true);
                        }
                    }
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (acc.get()) {
                    return new AddSetUseTrailingSlashMatch().getVisitor().visit(tree, ctx);
                }
                return new AddRouteTrailingSlash().getVisitor().visit(tree, ctx);
            }
        };
    }
}
",{}
Migrate `Docket` to `GroupedOpenAPI`,"Migrate a `Docket` bean to a `GroupedOpenAPI` bean preserving group name, packages and paths. ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.doc;

import lombok.*;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.spring.AddSpringProperty;
import org.openrewrite.java.spring.IsPossibleSpringConfigFile;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.tree.Yaml;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

import static org.openrewrite.Preconditions.and;
import static org.openrewrite.Preconditions.or;

public class MigrateDocketBeanToGroupedOpenApiBean extends ScanningRecipe<MigrateDocketBeanToGroupedOpenApiBean.DocketBeanAccumulator> {

    private static final AnnotationMatcher BEAN_ANNOTATIONMATCHER = new AnnotationMatcher(""@org.springframework.context.annotation.Bean"");
    private static final TypeMatcher DOCKET_TYPEMATCHER = new TypeMatcher(""springfox.documentation.spring.web.plugins.Docket"");
    private static final TypeMatcher DOCUMENTATIONTYPE_TYPEMATCHER = new TypeMatcher(""springfox.documentation.spi.DocumentationType"");
    private static final TypeMatcher APISELECTORBUILDER_TYPEMATCHER = new TypeMatcher(""springfox.documentation.spring.web.plugins.ApiSelectorBuilder"");
    private static final ArgumentExtractor REQUESTHANDLERSELECTORS_ARGUMENT_EXTRACTOR = new ArgumentExtractor(Arrays.asList(new MethodMatcher(""springfox.documentation.builders.RequestHandlerSelectors any()"", true), new MethodMatcher(""springfox.documentation.builders.RequestHandlerSelectors basePackage(..)"", true)));
    private static final ArgumentExtractor PATHSELECTOR_ARGUMENT_EXTRACTOR = new ArgumentExtractor(Arrays.asList(new MethodMatcher(""springfox.documentation.builders.PathSelectors any()"", true), new MethodMatcher(""springfox.documentation.builders.PathSelectors ant(..)"", true)));


    @Override
    public String getDisplayName() {
        return ""Migrate `Docket` to `GroupedOpenAPI`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate a `Docket` bean to a `GroupedOpenAPI` bean preserving group name, packages and paths. "" +
                ""When possible the recipe will prefer property based configuration."";
    }

    @Override
    public DocketBeanAccumulator getInitialValue(ExecutionContext ctx) {
        return new DocketBeanAccumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(DocketBeanAccumulator acc) {
        return Preconditions.check(shouldVisit(), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof J.CompilationUnit) {
                    return new JavaBeanConfigurationScanner(acc).visitNonNull(tree, ctx);
                }
                if (isApplicationProperties(tree)) {
                    acc.hasProperties = true;
                }
                return super.visit(tree, ctx);
            }
        });
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(DocketBeanAccumulator acc) {
        if (acc.docketDefinitions.size() != 1) {
            return TreeVisitor.noop();
        }
        DocketDefinition docketDefinition = acc.docketDefinitions.get(0);
        return Preconditions.check(shouldVisit(), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                boolean canConfigureInProperties = canConfigureInProperties(acc, docketDefinition);
                if (tree instanceof J.CompilationUnit) {
                    return new DocketBeanVisitor(canConfigureInProperties, docketDefinition).visitNonNull(tree, ctx);
                }
                if (isApplicationProperties(tree) && canConfigureInProperties) {
                    Tree result = addSpringProperty(ctx, tree, ""springdoc.api-docs.path"", ""/v3/api-docs"");
                    result = addSpringProperty(ctx, result, ""springdoc.swagger-ui.path"", ""/swagger-ui.html"");
                    if (docketDefinition.groupName == null) {
                        result = formatGroupProperties(ctx, result, ""springdoc"", docketDefinition);
                    } else {
                        result = addSpringProperty(ctx, result, ""springdoc.group-configs[0]"" + "".group"", docketDefinition.groupName.toString());
                        result = formatGroupProperties(ctx, result, ""springdoc.group-configs[0]"", docketDefinition);
                    }
                    return result;
                }
                return tree;
            }
        });
    }

    private static TreeVisitor<?, ExecutionContext> shouldVisit() {
        return or(new IsPossibleSpringConfigFile(),
                and(new UsesType<>(""springfox.documentation.spring.web.plugins.Docket"", true),
                        new UsesType<>(""org.springframework.context.annotation.Bean"", true)));
    }

    private static boolean isApplicationProperties(@Nullable Tree tree) {
        return (tree instanceof Properties.File && ""application.properties"".equals(((Properties.File) tree).getSourcePath().getFileName().toString())) ||
                (tree instanceof Yaml.Documents && ((Yaml.Documents) tree).getSourcePath().getFileName().toString().matches(""application\\.ya*ml""));
    }

    private static boolean canConfigureInProperties(DocketBeanAccumulator acc, DocketDefinition docketDefinition) {
        return acc.hasProperties &&
                (docketDefinition.groupName == null || docketDefinition.groupName instanceof J.Literal) &&
                (docketDefinition.apis == null || docketDefinition.apis instanceof J.Literal) &&
                (docketDefinition.paths == null || docketDefinition.paths instanceof J.Literal);
    }

    private Tree formatGroupProperties(ExecutionContext ctx, Tree properties, String prefix, DocketDefinition docketDefinition) {
        if (docketDefinition.paths == null && docketDefinition.apis == null) {
            properties = addSpringProperty(ctx, properties, prefix + "".paths-to-match"", ""/**"");
        } else {
            if (docketDefinition.paths instanceof J.Literal && ((J.Literal) docketDefinition.paths).getValueSource() != null) {
                properties = addSpringProperty(ctx, properties, prefix + "".paths-to-match"", ((J.Literal) docketDefinition.paths).getValueSource());
            }
            if (docketDefinition.apis instanceof J.Literal) {
                if (((J.Literal) docketDefinition.apis).getValueSource() != null) {
                    properties = addSpringProperty(ctx, properties, prefix + "".packages-to-scan"", ((J.Literal) docketDefinition.apis).getValueSource());
                }
            }
        }
        return properties;
    }

    private static Tree addSpringProperty(ExecutionContext ctx, Tree properties, String property, String value) {
        return new AddSpringProperty(property, value, null, null).getVisitor().visitNonNull(properties, ctx);
    }


    @RequiredArgsConstructor
    private static class JavaBeanConfigurationScanner extends JavaIsoVisitor<ExecutionContext> {
        private final DocketBeanAccumulator acc;

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (md.getLeadingAnnotations().stream().anyMatch(BEAN_ANNOTATIONMATCHER::matches) && DOCKET_TYPEMATCHER.matches(md.getReturnTypeExpression())) {
                DocketDefinition.Builder docketDefinitionBuilder = new JavaIsoVisitor<DocketDefinition.Builder>() {
                    @Override
                    public J.NewClass visitNewClass(J.NewClass newClass, DocketDefinition.Builder builder) {
                        J.NewClass nc = super.visitNewClass(newClass, builder);
                        if (builder.isValid() && !DOCKET_TYPEMATCHER.matches(newClass.getType()) ||
                                !DOCUMENTATIONTYPE_TYPEMATCHER.matches(newClass.getArguments().get(0).getType()) ||
                                !""SWAGGER_2"".equals(((J.FieldAccess) newClass.getArguments().get(0)).getName().getSimpleName())) {
                            builder.invalidate();
                        }
                        return nc;
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, DocketDefinition.Builder builder) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, builder);
                        if (!builder.isValid() || mi.getSelect() == null) {
                            return mi;
                        }
                        if (APISELECTORBUILDER_TYPEMATCHER.matches(mi.getSelect().getType()) &&
                                ""paths"".equals(mi.getSimpleName())) {
                            PATHSELECTOR_ARGUMENT_EXTRACTOR.visit(mi.getArguments(), new ArgumentExtractor.ArgumentExtractorResult(builder, builder::setPaths));
                        } else if (APISELECTORBUILDER_TYPEMATCHER.matches(mi.getSelect().getType()) &&
                                ""apis"".equals(mi.getSimpleName())) {
                            REQUESTHANDLERSELECTORS_ARGUMENT_EXTRACTOR.visit(mi.getArguments(), new ArgumentExtractor.ArgumentExtractorResult(builder, builder::setApis));
                        } else if (DOCKET_TYPEMATCHER.matches(mi.getSelect().getType()) &&
                                ""groupName"".equals(mi.getSimpleName())) {
                            builder.setGroupName(mi.getArguments().get(0));
                        }
                        return mi;
                    }
                }.reduce(md, new DocketDefinition.Builder());
                if (docketDefinitionBuilder.isValid()) {
                    acc.docketDefinitions.add(docketDefinitionBuilder.build());
                }
            }
            return md;
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class ArgumentExtractor extends JavaIsoVisitor<ArgumentExtractor.ArgumentExtractorResult> {

        List<MethodMatcher> methodMatchers;

        @Override
        public @Nullable J visit(@Nullable Tree tree, ArgumentExtractorResult argumentExtractorResult) {
            if (argumentExtractorResult.builder.isValid() &&
                    tree instanceof J.MethodInvocation &&
                    ((J.MethodInvocation) tree).getSelect() != null &&
                    methodMatchers.stream().anyMatch(e -> e.matches(((J.MethodInvocation) tree)))) {
                return super.visit(tree, argumentExtractorResult);
            }
            argumentExtractorResult.builder.invalidate();
            return (J) tree;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ArgumentExtractorResult argumentExtractorResult) {
            new JavaIsoVisitor<ArgumentExtractorResult>() {
                @Override
                public J.Literal visitLiteral(J.Literal literal, ArgumentExtractorResult argumentExtractorResult) {
                    argumentExtractorResult.success.accept(literal);
                    return literal;
                }

                @Override
                public J.Identifier visitIdentifier(J.Identifier identifier, ArgumentExtractorResult argumentExtractorResult) {
                    argumentExtractorResult.success.accept(identifier);
                    return identifier;
                }
            }.visit(method.getArguments(), argumentExtractorResult);
            return method;
        }

        @Value
        static class ArgumentExtractorResult {
            DocketDefinition.Builder builder;
            Consumer<Expression> success;
        }
    }

    public static class DocketBeanAccumulator {
        public boolean hasProperties = false;
        public List<DocketDefinition> docketDefinitions = new ArrayList<>();
    }

    @Value
    public static class DocketDefinition {
        @Nullable
        Expression groupName;

        @Nullable
        Expression paths;

        @Nullable
        Expression apis;

        static class Builder {
            @Getter
            private boolean valid = true;

            @Setter
            @Nullable
            private Expression paths = null;

            @Setter
            @Nullable
            private Expression apis = null;

            @Setter
            @Nullable
            private Expression groupName = null;

            public void invalidate() {
                valid = false;
            }

            public DocketDefinition build() {
                return new DocketDefinition(groupName, paths, apis);
            }
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class DocketBeanVisitor extends JavaIsoVisitor<ExecutionContext> {
        boolean removeMethod;
        DocketDefinition docketDefinition;

        @Override
        public J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (service(AnnotationService.class).matches(getCursor(), BEAN_ANNOTATIONMATCHER) &&
                    DOCKET_TYPEMATCHER.matches(md.getReturnTypeExpression())) {
                maybeRemoveImport(""springfox.documentation.builders.PathSelectors"");
                maybeRemoveImport(""springfox.documentation.builders.RequestHandlerSelectors"");
                maybeRemoveImport(""springfox.documentation.spi.DocumentationType"");
                maybeRemoveImport(""springfox.documentation.spring.web.plugins.Docket"");

                if (removeMethod) {
                    maybeRemoveImport(""org.springframework.context.annotation.Bean"");
                    return null; // Remove the bean method when switching to properties
                }

                List<Expression> args = new ArrayList<>();
                StringBuilder template = new StringBuilder()
                        .append(""@Bean\n"")
                        .append(""public GroupedOpenApi "").append(method.getSimpleName()).append(""() {\n"")
                        .append(""return GroupedOpenApi.builder()\n"");
                if (docketDefinition.groupName == null) {
                    template.append("".group(\""public\"")\n"");
                } else {
                    args.add(docketDefinition.groupName);
                    template.append("".group(#{any()})\n"");
                }
                if (docketDefinition.paths == null && docketDefinition.apis == null) {
                    template.append("".pathsToMatch(\""/**\"")\n"");
                } else {
                    if (docketDefinition.paths != null) {
                        args.add(docketDefinition.paths);
                        template.append("".pathsToMatch(#{any()})\n"");
                    }
                    if (docketDefinition.apis != null) {
                        args.add(docketDefinition.apis);
                        template.append("".packagesToScan(#{any()})\n"");
                    }
                }
                template.append("".build();\n"")
                        .append(""}"");

                maybeAddImport(""org.springdoc.core.models.GroupedOpenApi"", false);
                maybeAddImport(""org.springframework.context.annotation.Bean"", false);
                return JavaTemplate.builder(template.toString())
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context"", ""springdoc-openapi-starter-common""))
                        .imports(""org.springdoc.core.models.GroupedOpenApi"", ""org.springframework.context.annotation.Bean"").build()
                        .apply(getCursor(), method.getCoordinates().replace(), args.toArray());
            }
            return md;
        }
    }
}
",{}
Removes @Import(BeanValidatorPluginsConfiguration.class),"As Springdoc OpenAPI supports Bean Validation out of the box, the BeanValidatorPluginsConfiguration is no longer supported nor needed. ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.doc;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class RemoveBeanValidatorPluginsConfiguration extends Recipe {

    private static final String ANNOTATION_IMPORT = ""org.springframework.context.annotation.Import"";
    private static final AnnotationMatcher IMPORT_MATCHER = new AnnotationMatcher(""@"" + ANNOTATION_IMPORT);
    private static final String BEAN_VALIDATOR_PLUGINS_CONFIGURATION = ""springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration"";
    private static final TypeMatcher BEAN_VALIDATOR_TYPEMATCHER = new TypeMatcher(""springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration"");

    @Override
    public String getDisplayName() {
        return ""Removes @Import(BeanValidatorPluginsConfiguration.class)"";
    }

    @Override
    public String getDescription() {
        return ""As Springdoc OpenAPI supports Bean Validation out of the box, the BeanValidatorPluginsConfiguration is no longer supported nor needed. "" +
                ""Thus remove @Import(BeanValidatorPluginsConfiguration.class)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                new UsesType<>(ANNOTATION_IMPORT, false),
                new UsesType<>(BEAN_VALIDATOR_PLUGINS_CONFIGURATION, false)
                ), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = super.visitClassDeclaration(classDecl, ctx);


                AtomicBoolean changed = new AtomicBoolean(false);
                List<J.Annotation> leadingAnnotations = new ArrayList<>();
                for (J.Annotation a : c.getLeadingAnnotations()) {
                    if (a.getArguments() != null && IMPORT_MATCHER.matches(a)) {
                        if (a.getArguments().size() == 1 && isBeanValidator(a.getArguments().get(0))) {
                            maybeRemoveImport(ANNOTATION_IMPORT);
                            maybeRemoveImport(BEAN_VALIDATOR_PLUGINS_CONFIGURATION);
                            return (J.ClassDeclaration) new RemoveAnnotationVisitor(IMPORT_MATCHER).visitNonNull(c, ctx, getCursor().getParentOrThrow());
                        }
                        leadingAnnotations.add(a.withArguments(ListUtils.map(a.getArguments(), e -> {
                            if (e instanceof J.NewArray && ((J.NewArray) e).getInitializer() != null) {
                                List<Expression> initializer = ((J.NewArray) e).getInitializer();
                                for (Expression ex : initializer) {
                                    if (isBeanValidator(ex)) {
                                        changed.set(true);
                                        return ((J.NewArray) e).withInitializer(ListUtils.filter(initializer, it -> it != ex));
                                    }
                                }
                            }
                            return e;
                        })));
                    } else {
                        leadingAnnotations.add(a);
                    }
                }

                if (changed.get()) {
                    maybeRemoveImport(ANNOTATION_IMPORT);
                    maybeRemoveImport(BEAN_VALIDATOR_PLUGINS_CONFIGURATION);
                    return c.withLeadingAnnotations(leadingAnnotations);
                }
                return c;
            }

            private boolean isBeanValidator(Expression e) {
                if (e instanceof J.NewArray && ((J.NewArray) e).getInitializer() != null && ((J.NewArray) e).getInitializer().size() == 1) {
                     e = ((J.NewArray) e).getInitializer().get(0);
                }
                return e.getType() instanceof JavaType.Parameterized && BEAN_VALIDATOR_TYPEMATCHER.matches(((JavaType.Parameterized) e.getType()).getTypeParameters().get(0));
            }
        });
    }
}
",{}
Use `new SimpleMongoClientDbFactory(String)`,Replace usage of deprecated `new SimpleMongoDbFactory(new MongoClientURI(String))` with `new SimpleMongoClientDbFactory(String)`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.MethodCall;

public class RefactorSimpleMongoDbFactory extends Recipe {

    private static final String COM_MONGODB_MONGO_CLIENT_URI = ""com.mongodb.MongoClientURI"";
    private static final String SIMPLE_MONGO_DB_FACTORY = ""org.springframework.data.mongodb.core.SimpleMongoDbFactory"";
    private static final MethodMatcher SIMPLE_FACTORY_CONSTRUCTOR = new MethodMatcher(SIMPLE_MONGO_DB_FACTORY + "" <constructor>(..)"", true);
    private static final MethodMatcher MONGO_CLIENT_CONSTRUCTOR = new MethodMatcher(COM_MONGODB_MONGO_CLIENT_URI + "" <constructor>(String)"", true);

    private static final String SIMPLE_MONGO_CLIENT_DB_FACTORY = ""org.springframework.data.mongodb.core.SimpleMongoClientDbFactory"";

    @Override
    public String getDisplayName() {
        return ""Use `new SimpleMongoClientDbFactory(String)`"";
    }

    @Override
    public String getDescription() {
        return ""Replace usage of deprecated `new SimpleMongoDbFactory(new MongoClientURI(String))` with `new SimpleMongoClientDbFactory(String)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaVisitor<ExecutionContext> javaVisitor = new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                if (SIMPLE_FACTORY_CONSTRUCTOR.matches(newClass)) {
                    Expression expression = newClass.getArguments().get(0);
                    if (MONGO_CLIENT_CONSTRUCTOR.matches(expression)) {
                        Expression uri = ((MethodCall) expression).getArguments().get(0);
                        maybeRemoveImport(SIMPLE_MONGO_DB_FACTORY);
                        maybeRemoveImport(COM_MONGODB_MONGO_CLIENT_URI);
                        maybeAddImport(SIMPLE_MONGO_CLIENT_DB_FACTORY);
                        return JavaTemplate
                                .builder(""new SimpleMongoClientDbFactory(#{any(java.lang.String)})"")
                                .imports(SIMPLE_MONGO_CLIENT_DB_FACTORY)
                                .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-data-mongodb-2"", ""mongo-java-driver""))
                                .build()
                                .apply(getCursor(), newClass.getCoordinates().replace(), uri);
                    }
                }
                return super.visitNewClass(newClass, ctx);
            }
        };
        return Preconditions.check(
                Preconditions.and(
                        new UsesMethod<>(SIMPLE_FACTORY_CONSTRUCTOR),
                        new UsesMethod<>(MONGO_CLIENT_CONSTRUCTOR)
                ),
                javaVisitor
        );
    }
}
",{}
MigrateQueryToNativeQuery,,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotationAttribute;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.trait.Annotated;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;

import java.time.Duration;

public class MigrateQueryToNativeQuery extends Recipe {

    private static final String DATA_JPA_QUERY_FQN = ""org.springframework.data.jpa.repository.Query"";
    private static final String DATA_JPA_NATIVE_QUERY_FQN = ""org.springframework.data.jpa.repository.NativeQuery"";
    private static final Annotated.Matcher MATCHER = new Annotated.Matcher(""@"" + DATA_JPA_QUERY_FQN + ""(nativeQuery=true)"");

    @Override
    public String getDisplayName() {
        // language=markdown
        return ""Replace `@Query` annotation by `@NativeQuery` when possible"";
    }

    @Override
    public String getDescription() {
        // language=markdown
        return ""Replace `@Query` annotation by `@NativeQuery` when `nativeQuery = true`. "" +
                ""`@NativeQuery` was introduced in Spring Data JPA 3.4."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(DATA_JPA_QUERY_FQN, false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        J.Annotation an = super.visitAnnotation(annotation, ctx);

                        if (!MATCHER.get(getCursor()).isPresent()) {
                            return an;
                        }

                        an = (J.Annotation) new RemoveAnnotationAttribute(DATA_JPA_QUERY_FQN, ""nativeQuery"")
                                .getVisitor().visitNonNull(an, ctx, getCursor().getParentOrThrow());
                        an = (J.Annotation) new ChangeType(DATA_JPA_QUERY_FQN, DATA_JPA_NATIVE_QUERY_FQN, false)
                                .getVisitor().visitNonNull(an, ctx, getCursor().getParentOrThrow());
                        maybeRemoveImport(DATA_JPA_QUERY_FQN);
                        maybeAddImport(DATA_JPA_NATIVE_QUERY_FQN);
                        if (an.getArguments() != null && an.getArguments().size() == 1) {
                            an = an.withArguments(ListUtils.mapFirst(an.getArguments(), v -> {
                                if (v instanceof J.Assignment &&
                                        ((J.Assignment) v).getVariable() instanceof J.Identifier &&
                                        ""value"".equals(((J.Identifier) ((J.Assignment) v).getVariable()).getSimpleName())) {
                                    return ((J.Assignment) v).getAssignment().withPrefix(Space.EMPTY);
                                }
                                return v;
                            }));
                        }
                        return an;
                    }
                }
        );
    }
}
",{}
Convert `JdbcTemplate.queryForLong(..)` to `queryForObject(..)`,"Replaces calls to `JdbcTemplate.queryForLong(..)` with `queryForObject(String, Class, Object...)`.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.emptyList;

public class JdbcTemplateQueryForLongMigration extends Recipe {

    private static final MethodMatcher QUERY_FOR_LONG_MATCHER = new MethodMatcher(""org.springframework.jdbc.core.JdbcTemplate queryForLong(..)"");

    @Override
    public String getDisplayName() {
        return ""Convert `JdbcTemplate.queryForLong(..)` to `queryForObject(..)`"";
    }

    @Override
    public String getDescription() {
        return ""Replaces calls to `JdbcTemplate.queryForLong(..)` with `queryForObject(String, Class, Object...)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaIsoVisitor<ExecutionContext> visitor = new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (QUERY_FOR_LONG_MATCHER.matches(mi)) {
                    JavaType.Method oldMethodType = mi.getMethodType();
                    List<String> newParameterNames = new ArrayList<>(oldMethodType.getParameterNames());
                    newParameterNames.add(1, ""requiredType"");
                    List<JavaType> newParameterTypes = new ArrayList<>(oldMethodType.getParameterTypes());
                    newParameterTypes.add(1, JavaType.ShallowClass.build(""java.lang.Class""));
                    List<Expression> newArguments = new ArrayList<>(mi.getArguments());
                    newArguments.add(1, longDotClass());
                    JavaType.Method newMethodType = oldMethodType.withName(""queryForObject"")
                            .withParameterNames(newParameterNames)
                            .withParameterTypes(newParameterTypes);
                    return mi.withName(mi.getName().withSimpleName(""queryForObject"").withType(newMethodType))
                            .withMethodType(newMethodType)
                            .withArguments(newArguments);
                }
                return mi;
            }

            private J.FieldAccess longDotClass() {
                return new J.FieldAccess(
                        Tree.randomId(),
                        Space.SINGLE_SPACE,
                        Markers.EMPTY,
                        new J.Identifier(
                                Tree.randomId(),
                                Space.EMPTY,
                                Markers.EMPTY,
                                emptyList(),
                                ""Long"",
                                JavaType.ShallowClass.build(""java.lang.Long""),
                                null
                        ),
                        new JLeftPadded<>(
                                Space.EMPTY,
                                new J.Identifier(
                                        Tree.randomId(),
                                        Space.EMPTY,
                                        Markers.EMPTY,
                                        emptyList(),
                                        ""class"",
                                        JavaType.ShallowClass.build(""java.lang.Class""),
                                        null),
                                Markers.EMPTY
                        ),
                        null
                );
            }
        };
        return Preconditions.check(new UsesMethod<>(QUERY_FOR_LONG_MATCHER), visitor);
    }
}
",{}
Use `QuerydslPredicateExecutor<T>`,"`QuerydslJpaRepository<T, ID extends Serializable>` was deprecated in Spring Data 2.1.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.java.tree.TypeUtils;


public class MigrateQuerydslJpaRepository extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use `QuerydslPredicateExecutor<T>`"";
    }

    @Override
    public String getDescription() {
        return ""`QuerydslJpaRepository<T, ID extends Serializable>` was deprecated in Spring Data 2.1."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(""org.springframework.data.jpa.repository.support.QuerydslJpaRepository"", false), new JavaVisitor<ExecutionContext>() {
            final String originalFqn = ""org.springframework.data.jpa.repository.support.QuerydslJpaRepository"";
            final String targetFqn = ""org.springframework.data.jpa.repository.support.QuerydslJpaPredicateExecutor"";

            @Override
            public J visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                J.CompilationUnit c = (J.CompilationUnit) super.visitCompilationUnit(cu, ctx);
                doAfterVisit(new ChangeType(originalFqn, targetFqn, false).getVisitor());
                return c;
            }

            @Override
            public J visitParameterizedType(J.ParameterizedType type, ExecutionContext ctx) {
                J.ParameterizedType t = (J.ParameterizedType) super.visitParameterizedType(type, ctx);
                if (t.getClazz() instanceof J.Identifier && TypeUtils.isOfType(TypeUtils.asFullyQualified(t.getClazz().getType()),
                        TypeUtils.asFullyQualified(JavaType.ShallowClass.build(originalFqn))) &&
                        t.getTypeParameters() != null && t.getTypeParameters().size() == 2) {
                    t = t.withTypeParameters(t.getTypeParameters().subList(0, 1));
                }
                return t;
            }

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                if (newClass.getClazz() != null && TypeUtils.isOfClassType(newClass.getClazz().getType(), originalFqn)) {
                    String template = ""new QuerydslJpaPredicateExecutor(#{any(org.springframework.data.jpa.repository.support.JpaEntityInformation)}, "" +
                            ""#{any(javax.persistence.EntityManager)}, "" +
                            ""#{any(org.springframework.data.querydsl.EntityPathResolver)}, null)"";

                    J.FieldAccess entityPathResolver = TypeTree.build(""SimpleEntityPathResolver.INSTANCE"");
                    return JavaTemplate.builder(template)
                        .imports(targetFqn)
                        .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx,
                                ""javax.persistence-api-2.*"",
                                ""spring-data-commons-2.*"",
                                ""spring-data-jpa-2.*""
                            ))
                        .build().apply(
                            getCursor(),
                            newClass.getCoordinates().replace(),
                            newClass.getArguments().get(0),
                            newClass.getArguments().get(1),
                            newClass.getArguments().size() == 3 ? newClass.getArguments().get(2) : entityPathResolver);
                }
                return super.visitNewClass(newClass, ctx);
            }
        });
    }
}
",{}
Use TLS for JDBC connection strings,"Increasingly, for compliance reasons (e.g. [NACHA](https://www.nacha.org/sites/default/files/2022-06/End_User_Briefing_Supplementing_Data_Security_UPDATED_FINAL.pdf)), JDBC connection strings ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.properties.PropertiesIsoVisitor;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.yaml.JsonPathMatcher;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.net.URI;
import java.net.URISyntaxException;

@EqualsAndHashCode(callSuper = false)
@Value
public class UseTlsJdbcConnectionString extends Recipe {
    @Option(
            displayName = ""Property key"",
            description = ""The Spring property key to perform updates against. "" +
                    ""If this value is specified, the specified property will be used for searching, otherwise a default of `spring.datasource.url` "" +
                    ""will be used instead."",
            example = ""spring.datasource.url""
    )
    @Nullable
    String propertyKey;

    @Option(
            displayName = ""Old Port"",
            description = ""The non-TLS enabled port number to replace with the TLS-enabled port. "" +
                    ""If this value is specified, no changes will be made to jdbc connection strings which do not contain this port number. "",
            example = ""1234"")
    @Nullable
    Integer oldPort;

    @Option(
            displayName = ""TLS Port"",
            description = ""The TLS-enabled port to use."",
            example = ""1234"")
    @Nullable
    Integer port;

    @Option(
            displayName = ""Connection attribute"",
            description = ""A connection attribute, if any, indicating to the JDBC "" +
                    ""provider that this is a TLS connection."",
            example = ""sslConnection=true"")
    @Nullable
    String attribute;

    @Override
    public String getDisplayName() {
        return ""Use TLS for JDBC connection strings"";
    }

    @Override
    public String getDescription() {
        return ""Increasingly, for compliance reasons (e.g. [NACHA](https://www.nacha.org/sites/default/files/2022-06/End_User_Briefing_Supplementing_Data_Security_UPDATED_FINAL.pdf)), JDBC connection strings "" +
                ""should be TLS-enabled. This recipe will update the port and "" +
                ""optionally add a connection attribute to indicate that the "" +
                ""connection is TLS-enabled."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        String attr = attribute;
        if (attr != null) {
            attr = attr.trim();
            if (!attr.endsWith("";"")) {
                attr = attr + ';';
            }
        }
        String validatedAttribute = attr;

        String actualPropertyKey = propertyKey == null ? ""spring.datasource.url"" : propertyKey;
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof Yaml.Documents) {
                    doAfterVisit(new UseTlsJdbcConnectionStringYaml(actualPropertyKey, oldPort, port, validatedAttribute).getVisitor());
                } else if (tree instanceof Properties.File) {
                    doAfterVisit(new UseTlsJdbcConnectionStringProperties(actualPropertyKey, oldPort, port, validatedAttribute).getVisitor());
                }
                return tree;
            }
        };
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class UseTlsJdbcConnectionStringYaml extends Recipe {
        String propertyKey;

        @Nullable
        Integer oldPort;

        @Nullable
        Integer port;

        @Nullable
        String attribute;

        @Override
        public String getDisplayName() {
            return ""Use TLS for JDBC connection strings"";
        }

        @Override
        public String getDescription() {
            return ""Use TLS for JDBC connection strings."";
        }

        private TreeVisitor<?, ExecutionContext> precondition() {
            return new YamlVisitor<ExecutionContext>() {
                @Override
                public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                    if (!FindProperty.find(documents, propertyKey, true).isEmpty()) {
                        return SearchResult.found(documents);
                    }
                    return documents;
                }
            };
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Preconditions.check(precondition(), new YamlIsoVisitor<ExecutionContext>() {
                final JsonPathMatcher jdbcUrl = new JsonPathMatcher(""$."" + propertyKey);

                @Override
                public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                    Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);

                    if (jdbcUrl.matches(getCursor())) {
                        String connectionString = ((Yaml.Scalar) e.getValue()).getValue();
                        try {
                            URI jdbcUrl = URI.create(connectionString);
                            if (oldPort != null && !jdbcUrl.getSchemeSpecificPart().contains("":"" + oldPort + ""/"")) {
                                return e;
                            }
                            URI updatedJdbcUrl = maybeUpdateJdbcConnectionString(jdbcUrl, port, attribute);

                            if (updatedJdbcUrl != jdbcUrl) {
                                e = e.withValue(((Yaml.Scalar) e.getValue()).withValue(updatedJdbcUrl.toString()));
                            }
                        } catch (URISyntaxException | IllegalArgumentException ignored) {
                            // do nothing
                        }
                    }
                    return e;
                }
            });
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class UseTlsJdbcConnectionStringProperties extends Recipe {
        String propertyKey;

        @Nullable
        Integer oldPort;

        @Nullable
        Integer port;

        @Nullable
        String attribute;

        @Override
        public String getDisplayName() {
            return ""Use TLS for JDBC connection strings"";
        }

        @Override
        public String getDescription() {
            return ""Use TLS for JDBC connection strings."";
        }

        private TreeVisitor<?, ExecutionContext> precondition() {
            return new PropertiesVisitor<ExecutionContext>() {
                @Override
                public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                    if (!FindProperties.find(file, propertyKey, true).isEmpty()) {
                        return SearchResult.found(file);
                    }
                    return file;
                }
            };
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Preconditions.check(precondition(), new PropertiesIsoVisitor<ExecutionContext>() {
                @Override
                public Properties.Entry visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                    Properties.Entry e = super.visitEntry(entry, ctx);

                    if (NameCaseConvention.equalsRelaxedBinding(entry.getKey(), propertyKey)) {
                        String connectionString = entry.getValue().getText();
                        try {
                            URI jdbcUrl = URI.create(connectionString);
                            if (oldPort != null && !jdbcUrl.getSchemeSpecificPart().contains("":"" + oldPort + ""/"")) {
                                return e;
                            }
                            URI updatedJdbcUrl = maybeUpdateJdbcConnectionString(jdbcUrl, port, attribute);

                            if (updatedJdbcUrl != jdbcUrl) {
                                e = e.withValue(e.getValue().withText(updatedJdbcUrl.toString()));
                            }
                        } catch (URISyntaxException | IllegalArgumentException ignored) {
                            // do nothing
                        }
                    }
                    return e;
                }
            });
        }
    }

    private static URI maybeUpdateJdbcConnectionString(URI jdbcUrl, @Nullable Integer port, @Nullable String validatedAttribute) throws URISyntaxException {
        URI updatedJdbcUrl = jdbcUrl;
        if (port != null && !jdbcUrl.getSchemeSpecificPart().contains("":"" + port + ""/"")) {
            updatedJdbcUrl = new URI(jdbcUrl.getScheme(), jdbcUrl.getSchemeSpecificPart()
                    .replaceFirst("":\\d+/"", "":"" + port + ""/""), jdbcUrl.getFragment());
        }
        if (validatedAttribute != null && !jdbcUrl.getSchemeSpecificPart().contains(validatedAttribute)) {
            updatedJdbcUrl = new URI(updatedJdbcUrl.getScheme(),
                    updatedJdbcUrl.getSchemeSpecificPart() +
                            (updatedJdbcUrl.getSchemeSpecificPart().endsWith("";"") ? """" : "":"") +
                            validatedAttribute,
                    updatedJdbcUrl.getFragment());
        }
        return updatedJdbcUrl;
    }
}
",{}
Make AuditorAware.getCurrentAuditor return `Optional`,"As of Spring boot 2.0, the `AuditorAware.getCurrentAuditor` method should return an `Optional`. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.spring.util.MemberReferenceToMethodInvocation;
import org.openrewrite.java.tree.*;

public class MigrateAuditorAwareToOptional extends Recipe {

    private static final TypeMatcher isAuditorAware = new TypeMatcher(""org.springframework.data.domain.AuditorAware"", true);
    private static final MethodMatcher isCurrentAuditor = new MethodMatcher(""org.springframework.data.domain.AuditorAware getCurrentAuditor()"", true);
    private static final TypeMatcher isOptional = new TypeMatcher(""java.util.Optional"");

    @Override
    public String getDisplayName() {
        return ""Make AuditorAware.getCurrentAuditor return `Optional`"";
    }

    @Override
    public String getDescription() {
        return ""As of Spring boot 2.0, the `AuditorAware.getCurrentAuditor` method should return an `Optional`. "" +
               ""This recipe will update the implementations of this method to return an `Optional` using the `ofNullable`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        ImplementationVisitor implementationVisitor = new ImplementationVisitor();
        FunctionalVisitor functionalVisitor = new FunctionalVisitor(implementationVisitor);
        return Preconditions.check(new UsesType<>(""org.springframework.data.domain.AuditorAware"", true), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                tree = implementationVisitor.visit(tree, ctx);
                tree = functionalVisitor.visit(tree, ctx);
                return (J) tree;
            }
        });
    }

    private static class ImplementationVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            TypeTree returnType = method.getReturnTypeExpression();
            if (method.getMethodType() == null || !isCurrentAuditor.matches(method.getMethodType()) ||
                returnType == null || returnType.getType().toString().matches(""java.util.Optional<.*>"")) {
                return method;
            }
            Space space = returnType.getPrefix();
            returnType = TypeTree.build(""java.util.Optional<"" + returnType.getType() + "">"");
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx).withReturnTypeExpression(returnType.withPrefix(space));
            doAfterVisit(ShortenFullyQualifiedTypeReferences.modifyOnly(md));
            maybeAddImport(""java.util.Optional"");
            return md;
        }

        @Override
        public J.Return visitReturn(J.Return return_, ExecutionContext ctx) {
            Expression expression = return_.getExpression();
            if (expression == null) {
                return return_;
            }
            J.Return altered = JavaTemplate.builder(""Optional.ofNullable(#{any()})"")
                    .imports(""java.util.Optional"")
                    .build()
                    .apply(getCursor(), expression.getCoordinates().replace(), expression);
            if (altered == null) {
                return return_;
            }
            maybeAddImport(""java.util.Optional"");

            return altered;
        }
    }

    @RequiredArgsConstructor
    private static class FunctionalVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final JavaIsoVisitor<ExecutionContext> implementationVisitor;

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (!isAuditorAware.matches(method.getReturnTypeExpression()) || method.getBody() == null || method.getBody().getStatements().size() != 1) {
                return method;
            }
            Statement statement = method.getBody().getStatements().get(0);
            if (!(statement instanceof J.Return)) {
                return method;
            }
            return super.visitMethodDeclaration(method, ctx);
        }

        @Override
        public J.Return visitReturn(J.Return return_, ExecutionContext ctx) {
            Expression expression = return_.getExpression();
            if (expression instanceof J.MemberReference) {
                J.MemberReference memberReference = (J.MemberReference) expression;
                JavaType.Method methodType = memberReference.getMethodType();
                if (methodType == null || isOptional.matches(methodType.getReturnType())) {
                    return return_;
                }
                expression = (Expression) new MemberReferenceToMethodInvocation().visitNonNull(memberReference, ctx, new Cursor(getCursor(), expression).getParent());
            }
            if (expression instanceof J.Lambda) {
                J.Lambda lambda = ((J.Lambda) expression);
                J body = lambda.getBody();
                if (body instanceof J.MethodInvocation &&
                        (((J.MethodInvocation) body).getMethodType() != null && isOptional.matches(((J.MethodInvocation) body).getMethodType().getReturnType()))) {
                    return return_;
                }
                if (body instanceof J.Literal || body instanceof J.MethodInvocation) {
                    body = JavaTemplate.builder(""Optional.ofNullable(#{any()})"")
                            .contextSensitive()
                            .imports(""java.util.Optional"")
                            .build()
                            .apply(new Cursor(getCursor(), lambda), lambda.getCoordinates().replace(), body);
                    JavaType.Method methodType = ((J.MethodInvocation) body).getMethodType();
                    if (methodType != null) {
                        methodType = methodType.withReturnType(JavaType.buildType(""java.util.Optional""));
                    }
                    body = ((J.MethodInvocation) body).withMethodType(methodType);
                    maybeAddImport(""java.util.Optional"");
                    return return_.withExpression(lambda.withBody(body));
                }
                return super.visitReturn(return_, ctx);
            }
            if (expression instanceof J.MethodInvocation) {
                JavaType.Method methodType = ((J.MethodInvocation) expression).getMethodType();
                if (methodType != null && (isOptional.matches(methodType.getReturnType()) || isAuditorAware.matches(methodType.getReturnType()))) {
                    return return_;
                }
                maybeAddImport(""java.util.Optional"");
                return return_.withExpression(JavaTemplate.builder(""Optional.ofNullable(#{any()})"")
                        .imports(""java.util.Optional"")
                        .build()
                        .apply(new Cursor(getCursor(), expression), expression.getCoordinates().replace(), expression));
            }
            if (expression instanceof J.NewClass && isAuditorAware.matches(((J.NewClass) expression).getClazz().getType())) {
                implementationVisitor.setCursor(new Cursor(getCursor(), expression));
                maybeAddImport(""java.util.Optional"");
                return return_.withExpression(implementationVisitor.visitNewClass((J.NewClass) expression, ctx));
            }
            return return_;
        }
    }
}
",{}
Use `JpaSort.of(..)`,Equivalent constructors in `JpaSort` were deprecated in Spring Data 2.3.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.data;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import static java.util.stream.Collectors.joining;

public class MigrateJpaSort extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use `JpaSort.of(..)`"";
    }

    @Override
    public String getDescription() {
        return ""Equivalent constructors in `JpaSort` were deprecated in Spring Data 2.3."";
    }

    private TreeVisitor<?, ExecutionContext> precondition() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                if (cu.getPackageDeclaration() != null &&
                        ""org.springframework.data.jpa.domain"".equals(cu.getPackageDeclaration().getPackageName())) {
                    return cu;
                }

                doAfterVisit(new UsesType<>(""org.springframework.data.jpa.domain.JpaSort"", false));
                return cu;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(precondition(), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                if (newClass.getClazz() != null && TypeUtils.isOfClassType(newClass.getClazz().getType(), ""org.springframework.data.jpa.domain.JpaSort"")) {
                    newClass.getArguments();
                    String template = newClass.getArguments().stream()
                            .map(arg -> TypeUtils.asFullyQualified(arg.getType()))
                            .map(type -> ""#{any("" + (type == null ? """" : type.getFullyQualifiedName()) + "")}"")
                            .collect(joining("","", ""JpaSort.of("", "")""));

                    return JavaTemplate.builder(template)
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                            .classpathFromResources(ctx, ""spring-data-commons-2.*"",
                                ""spring-data-jpa-2.3.*"", ""javax.persistence-api-2.*""))
                        .imports(""org.springframework.data.jpa.domain.JpaSort"")
                        .build()
                        .apply(
                            getCursor(),
                            newClass.getCoordinates().replace(),
                            newClass.getArguments().toArray()
                            );
                }

                return super.visitNewClass(newClass, ctx);
            }
        });
    }
}
",{}
Migrate `@RequestMapping` on `FeignClient` to `@FeignClient` path attribute,Support for `@RequestMapping` over a `FeignClient` interface was removed in Spring Cloud OpenFeign 2.2.10.RELEASE.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.cloud2022;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.AddOrUpdateAnnotationAttribute;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.RemoveAnnotation;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;

public class MigrateRequestMappingOnFeignClient extends Recipe {

    private static final String FEIGN_CLIENT = ""org.springframework.cloud.openfeign.FeignClient"";

    private static final String REQUEST_MAPPING = ""org.springframework.web.bind.annotation.RequestMapping"";

    @Override
    public String getDisplayName() {
        return ""Migrate `@RequestMapping` on `FeignClient` to `@FeignClient` path attribute"";
    }

    @Override
    public String getDescription() {
        return ""Support for `@RequestMapping` over a `FeignClient` interface was removed in Spring Cloud OpenFeign 2.2.10.RELEASE."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.and(
                new UsesType<>(FEIGN_CLIENT, false),
                new UsesType<>(REQUEST_MAPPING, false)),
            new JavaIsoVisitor<ExecutionContext>() {
                @Override
                public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                    J.Annotation requestMapping = classDecl.getLeadingAnnotations().stream()
                        .filter(a -> TypeUtils.isOfClassType(a.getType(), REQUEST_MAPPING))
                        .findFirst().orElse(null);
                    J.Annotation feignClient = classDecl.getLeadingAnnotations().stream()
                        .filter(a -> TypeUtils.isOfClassType(a.getType(), FEIGN_CLIENT))
                        .findFirst().orElse(null);

                    if (requestMapping != null && feignClient != null) {
                        J.ClassDeclaration cd = classDecl;
                        if (requestMapping.getArguments() == null || requestMapping.getArguments().isEmpty()) {
                            cd = removeRequestMapping(cd, ctx);
                        } else if (requestMapping.getArguments().size() == 1) {
                            String pathValueFromRequestMapping = getPathValue(requestMapping.getArguments().get(0));
                            if (pathValueFromRequestMapping != null && !hasPathAttribute(feignClient)) {
                                cd = removeRequestMapping(cd, ctx);
                                cd = addAttributeToFeignClient(cd, ctx, pathValueFromRequestMapping);
                            }
                        }
                        return cd;
                    }
                    return super.visitClassDeclaration(classDecl, ctx);
                }

                private boolean hasPathAttribute(J.Annotation annotation) {
                    if (annotation.getArguments() == null || annotation.getArguments().isEmpty()) {
                        return false;
                    }
                    return annotation.getArguments().stream().anyMatch(arg -> {
                        if (arg instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) arg;
                            if (assignment.getVariable() instanceof J.Identifier) {
                                J.Identifier variable = (J.Identifier) assignment.getVariable();
                                return ""path"".equals(variable.getSimpleName());
                            }
                        }
                        return false;
                    });
                }

                private J.ClassDeclaration addAttributeToFeignClient(J.ClassDeclaration cd, ExecutionContext ctx, String path) {
                    return cd.withLeadingAnnotations(
                        ListUtils.map(cd.getLeadingAnnotations(), a -> (J.Annotation)
                            new AddOrUpdateAnnotationAttribute(FEIGN_CLIENT, ""path"",
                                path, null, true, false).getVisitor()
                                .visit(a, ctx, getCursor().getParentOrThrow())));
                }

                private J.ClassDeclaration removeRequestMapping(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                    maybeRemoveImport(REQUEST_MAPPING);
                    return classDecl.withLeadingAnnotations(ListUtils.map(classDecl.getLeadingAnnotations(),
                        a -> (J.Annotation) new RemoveAnnotation(REQUEST_MAPPING).getVisitor()
                            .visit(a, ctx, getCursor().getParentOrThrow())));
                }

                private String getPathValue(Expression arg) {
                    if (arg instanceof J.Literal) {
                        J.Literal literal = (J.Literal) arg;
                        return (String) literal.getValue();
                    }
                    if (arg instanceof J.Assignment) {
                        J.Assignment assignment = (J.Assignment) arg;
                        if (assignment.getVariable() instanceof J.Identifier) {
                            J.Identifier variable = (J.Identifier) assignment.getVariable();
                            if (""path"".equals(variable.getSimpleName()) || ""value"".equals(variable.getSimpleName())) {
                                Expression expression = assignment.getAssignment();
                                if (expression instanceof J.Literal) {
                                    J.Literal value = (J.Literal) expression;
                                    return (String) value.getValue();
                                }
                            }
                        }
                    } else if (arg instanceof J.NewArray) {
                        List<Expression> initializer = ((J.NewArray) arg).getInitializer();
                        if (initializer != null && initializer.size() == 1) {
                            return getPathValue(initializer.get(0));
                        }
                    }
                    return null;
                }
            });
    }

}
",{}
Add logging.pattern.level for traceId and spanId,"Add `logging.pattern.level` for traceId and spanId which was previously set by default, if not already set.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.cloud2022;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.spring.AddSpringProperty;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;

public class AddLoggingPatternLevelForSleuth extends ScanningRecipe<AtomicBoolean> {
    @Override
    public String getDisplayName() {
        return ""Add logging.pattern.level for traceId and spanId"";
    }

    @Override
    public String getDescription() {
        return ""Add `logging.pattern.level` for traceId and spanId which was previously set by default, if not already set."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                if (!acc.get()) {
                    DependencyMatcher matcher = DependencyMatcher.build(""org.springframework.cloud:spring-cloud-starter-sleuth:X"").getValue();
                    List<ResolvedDependency> dependencies = getResolutionResult().getDependencies().getOrDefault(Scope.Compile, emptyList());
                    acc.set(dependencies.stream().anyMatch(d -> matcher.matches(d.getGroupId(), d.getArtifactId(), d.getVersion())));
                }
                return document;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        AddSpringProperty addSpringProperty = new AddSpringProperty(
                ""logging.pattern.level"",
                // The ${spring.application.name:} could not be escaped in yaml so far
                ""\""%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]\"""",
                ""Logging pattern containing traceId and spanId; no longer provided through Sleuth by default"",
                null);
        return Preconditions.check(acc.get(), addSpringProperty.getVisitor());
    }
}
",{}
Replace global method security with method security,`@EnableGlobalMethodSecurity` and `<global-method-security>` are deprecated in favor of ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.RemoveMethodInvocationsVisitor;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

import java.util.List;

import static java.util.stream.Collectors.toList;

public class ReplaceGlobalMethodSecurityWithMethodSecurity extends Recipe {
    private static final AnnotationMatcher ENABLE_GLOBAL_METHOD_SECURITY_MATCHER =
            new AnnotationMatcher(""@org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity"");

    private static final String EnableGlobalMethodSecurityFqn = ""org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity"";
    private static final String EnableMethodSecurityFqn = ""org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity"";

    @Override
    public String getDisplayName() {
        return ""Replace global method security with method security"";
    }

    @Override
    public String getDescription() {
        return ""`@EnableGlobalMethodSecurity` and `<global-method-security>` are deprecated in favor of "" +
               ""`@EnableMethodSecurity` and `<method-security>`, respectively. The new annotation and XML "" +
               ""element activate Springs pre-post annotations by default and use AuthorizationManager internally."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesType<>(""org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity"", false),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        annotation = super.visitAnnotation(annotation, ctx);
                        if (ENABLE_GLOBAL_METHOD_SECURITY_MATCHER.matches(annotation)) {
                            maybeAddImport(EnableMethodSecurityFqn);
                            maybeRemoveImport(EnableGlobalMethodSecurityFqn);
                            J.Annotation replacementAnnotation = JavaTemplate.builder(""@EnableMethodSecurity(prePostEnabled = false)"")
                                    .javaParser(JavaParser.fromJavaVersion()
                                            .classpathFromResources(ctx, ""spring-security-config-5.8.+""))
                                    .imports(EnableMethodSecurityFqn)
                                    .build()
                                    .apply(getCursor(), annotation.getCoordinates().replace());

                            List<Expression> oldArgs = annotation.getArguments();
                            if (oldArgs == null || oldArgs.isEmpty()) {
                                return replacementAnnotation;
                            }

                            List<Expression> newArgs = oldArgs;
                            if (oldArgs.stream().noneMatch(this::hasPrePostEnabled)) {
                                newArgs.add(replacementAnnotation.getArguments().get(0));
                            } else {
                                newArgs = oldArgs.stream().filter(arg -> !hasPrePostEnabled(arg)).collect(toList());
                            }
                            return autoFormat(replacementAnnotation.withArguments(newArgs), ctx);
                        }
                        return annotation;
                    }

                    private boolean hasPrePostEnabled(Expression arg) {
                        if (arg instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) arg;
                            return ""prePostEnabled"".equals(((J.Identifier) assignment.getVariable()).getSimpleName()) &&
                                   RemoveMethodInvocationsVisitor.isTrue(assignment.getAssignment());
                        }
                        return false;
                    }
                }
        );
    }

}
",{}
Use new `SCryptPasswordEncoder` factory methods,In Spring Security 5.8 some `SCryptPasswordEncoder` constructors have been deprecated in favor of factory methods. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;
import java.util.Objects;

import static org.openrewrite.java.spring.internal.LocalVariableUtils.resolveExpression;

@EqualsAndHashCode(callSuper = false)
@Value
public class UpdateSCryptPasswordEncoder extends Recipe {

    private static final String SCRYPT_PASSWORD_ENCODER_CLASS = ""org.springframework.security.crypto.scrypt.SCryptPasswordEncoder"";

    private static final MethodMatcher DEFAULT_CONSTRUCTOR_MATCHER = new MethodMatcher(SCRYPT_PASSWORD_ENCODER_CLASS + "" <constructor>()"");
    private static final MethodMatcher FULL_CONSTRUCTOR_MATCHER = new MethodMatcher(SCRYPT_PASSWORD_ENCODER_CLASS + "" <constructor>(int, int, int, int, int)"");

    private static final Integer DEFAULT_CPU_COST = 65_536;
    private static final Integer DEFAULT_MEMORY_COST = 8;
    private static final Integer DEFAULT_PARALLELIZATION = 1;
    private static final Integer DEFAULT_KEY_LENGTH = 32;
    private static final Integer DEFAULT_SALT_LENGTH = 16;

    private static final Integer DEFAULT_V41_CPU_COST = 16_384;
    private static final Integer DEFAULT_V41_MEMORY_COST = 8;
    private static final Integer DEFAULT_V41_PARALLELIZATION = 1;
    private static final Integer DEFAULT_V41_KEY_LENGTH = 32;
    private static final Integer DEFAULT_V41_SALT_LENGTH = 64;

    @Override
    public String getDisplayName() {
        return ""Use new `SCryptPasswordEncoder` factory methods"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 5.8 some `SCryptPasswordEncoder` constructors have been deprecated in favor of factory methods. "" +
                ""Refer to the [ Spring Security migration docs](https://docs.spring.io/spring-security/reference/5.8/migration/index.html#_update_scryptpasswordencoder) for more information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(SCRYPT_PASSWORD_ENCODER_CLASS, false), new JavaVisitor<ExecutionContext>() {

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J j = super.visitNewClass(newClass, ctx);
                if (j instanceof J.NewClass && TypeUtils.isOfClassType(((J.NewClass) j).getType(), SCRYPT_PASSWORD_ENCODER_CLASS)) {
                    newClass = (J.NewClass) j;
                    if (DEFAULT_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        maybeAddImport(SCRYPT_PASSWORD_ENCODER_CLASS);
                        return newV41FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                    }
                    List<Expression> arguments = newClass.getArguments();
                    if (FULL_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        Expression cpuCost = arguments.get(0);
                        Expression memoryCost = arguments.get(1);
                        Expression parallelization = arguments.get(2);
                        Expression keyLength = arguments.get(3);
                        Expression saltLength = arguments.get(4);
                        maybeAddImport(SCRYPT_PASSWORD_ENCODER_CLASS);
                        if (resolvedValueMatchesLiteral(cpuCost, DEFAULT_CPU_COST) &&
                                resolvedValueMatchesLiteral(memoryCost, DEFAULT_MEMORY_COST) &&
                                resolvedValueMatchesLiteral(parallelization, DEFAULT_PARALLELIZATION) &&
                                resolvedValueMatchesLiteral(keyLength, DEFAULT_KEY_LENGTH) &&
                                resolvedValueMatchesLiteral(saltLength, DEFAULT_SALT_LENGTH)) {
                            return newV58FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                        if (resolvedValueMatchesLiteral(cpuCost, DEFAULT_V41_CPU_COST) &&
                                resolvedValueMatchesLiteral(memoryCost, DEFAULT_V41_MEMORY_COST) &&
                                resolvedValueMatchesLiteral(parallelization, DEFAULT_V41_PARALLELIZATION) &&
                                resolvedValueMatchesLiteral(keyLength, DEFAULT_V41_KEY_LENGTH) &&
                                resolvedValueMatchesLiteral(saltLength, DEFAULT_V41_SALT_LENGTH)) {
                            return newV41FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                    }
                }
                return j;
            }

            boolean resolvedValueMatchesLiteral(Expression expression, Object value) {
                Expression resolvedExpression = resolveExpression(expression, getCursor());
                return resolvedExpression instanceof J.Literal && Objects.equals(((J.Literal) resolvedExpression).getValue(), value);
            }

            private JavaTemplate newV41FactoryMethodTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""SCryptPasswordEncoder.defaultsForSpringSecurity_v4_1()"")
                        .imports(SCRYPT_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }

            private JavaTemplate newV58FactoryMethodTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8()"")
                        .imports(SCRYPT_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }
        });
    }
}
",{}
Use new `Argon2PasswordEncoder` factory methods,In Spring Security 5.8 some `Argon2PasswordEncoder` constructors have been deprecated in favor of factory methods. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;
import java.util.Objects;

import static org.openrewrite.java.spring.internal.LocalVariableUtils.resolveExpression;

@EqualsAndHashCode(callSuper = false)
@Value
public class UpdateArgon2PasswordEncoder extends Recipe {

    private static final String ARGON2_PASSWORD_ENCODER_CLASS = ""org.springframework.security.crypto.argon2.Argon2PasswordEncoder"";

    private static final MethodMatcher DEFAULT_CONSTRUCTOR_MATCHER = new MethodMatcher(ARGON2_PASSWORD_ENCODER_CLASS + "" <constructor>()"");
    private static final MethodMatcher FULL_CONSTRUCTOR_MATCHER = new MethodMatcher(ARGON2_PASSWORD_ENCODER_CLASS + "" <constructor>(int, int, int, int, int)"");

    private static final Integer DEFAULT_SALT_LENGTH = 16;
    private static final Integer DEFAULT_HASH_LENGTH = 32;
    private static final Integer DEFAULT_PARALLELISM = 1;
    private static final Integer DEFAULT_MEMORY = 16_384;
    private static final Integer DEFAULT_ITERATIONS = 2;

    private static final Integer DEFAULT_V52_SALT_LENGTH = 16;
    private static final Integer DEFAULT_V52_HASH_LENGTH = 32;
    private static final Integer DEFAULT_V52_PARALLELISM = 1;
    private static final Integer DEFAULT_V52_MEMORY = 4_096;
    private static final Integer DEFAULT_V52_ITERATIONS = 3;

    @Override
    public String getDisplayName() {
        return ""Use new `Argon2PasswordEncoder` factory methods"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 5.8 some `Argon2PasswordEncoder` constructors have been deprecated in favor of factory methods. "" +
                ""Refer to the [ Spring Security migration docs](https://docs.spring.io/spring-security/reference/5.8/migration/index.html#_update_argon2passwordencoder) for more information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(ARGON2_PASSWORD_ENCODER_CLASS, false), new JavaVisitor<ExecutionContext>() {

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J j = super.visitNewClass(newClass, ctx);
                if (j instanceof J.NewClass && TypeUtils.isOfClassType(((J.NewClass) j).getType(), ARGON2_PASSWORD_ENCODER_CLASS)) {
                    newClass = (J.NewClass) j;
                    if (DEFAULT_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        maybeAddImport(ARGON2_PASSWORD_ENCODER_CLASS);

                        return newV52FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                    }
                    List<Expression> arguments = newClass.getArguments();
                    if (FULL_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        Expression saltLength = arguments.get(0);
                        Expression hashLength = arguments.get(1);
                        Expression parallelism = arguments.get(2);
                        Expression memory = arguments.get(3);
                        Expression iterations = arguments.get(4);
                        maybeAddImport(ARGON2_PASSWORD_ENCODER_CLASS);
                        if (resolvedValueMatchesLiteral(saltLength, DEFAULT_SALT_LENGTH) &&
                                resolvedValueMatchesLiteral(hashLength, DEFAULT_HASH_LENGTH) &&
                                resolvedValueMatchesLiteral(parallelism, DEFAULT_PARALLELISM) &&
                                resolvedValueMatchesLiteral(memory, DEFAULT_MEMORY) &&
                                resolvedValueMatchesLiteral(iterations, DEFAULT_ITERATIONS)) {
                            return newV58FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                        if (resolvedValueMatchesLiteral(saltLength, DEFAULT_V52_SALT_LENGTH) &&
                                resolvedValueMatchesLiteral(hashLength, DEFAULT_V52_HASH_LENGTH) &&
                                resolvedValueMatchesLiteral(parallelism, DEFAULT_V52_PARALLELISM) &&
                                resolvedValueMatchesLiteral(memory, DEFAULT_V52_MEMORY) &&
                                resolvedValueMatchesLiteral(iterations, DEFAULT_V52_ITERATIONS)) {
                            return newV52FactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                    }
                }
                return j;
            }

            boolean resolvedValueMatchesLiteral(Expression expression, Object value) {
                Expression resolvedExpression = resolveExpression(expression, getCursor());
                return resolvedExpression instanceof J.Literal && Objects.equals(((J.Literal) resolvedExpression).getValue(), value);
            }

            private JavaTemplate newV52FactoryMethodTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""Argon2PasswordEncoder.defaultsForSpringSecurity_v5_2()"")
                        .imports(ARGON2_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }

            private JavaTemplate newV58FactoryMethodTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8()"")
                        .imports(ARGON2_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }
        });
    }
}
",{}
Use the new `securityMatcher()` method,"In Spring Security 5.8, the `HttpSecurity#antMatcher()`, `HttpSecurity#mvcMatcher()`, and `HttpSecurity#regexMatcher()` methods were deprecated ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

@EqualsAndHashCode(callSuper = false)
@Value
public class UseNewSecurityMatchers extends Recipe {

    private static final String HTTP_SECURITY_CLASS = ""org.springframework.security.config.annotation.web.builders.HttpSecurity"";
    private static final MethodMatcher HTTP_SECURITY_MATCHER = new MethodMatcher(HTTP_SECURITY_CLASS + "" *Matcher(String)"");


    @Override
    public String getDisplayName() {
        return ""Use the new `securityMatcher()` method"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 5.8, the `HttpSecurity#antMatcher()`, `HttpSecurity#mvcMatcher()`, and `HttpSecurity#regexMatcher()` methods were deprecated "" +
                ""in favor of new `HttpSecurity#securityMatcher()` method. Refer to the [Spring Security docs](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/config.html#use-new-security-matchers) "" +
                ""for more information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(HTTP_SECURITY_CLASS, true), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                if (HTTP_SECURITY_MATCHER.matches(mi) && mi.getMethodType() != null) {
                    return securityMatcherTemplate(ctx).apply(getCursor(), mi.getCoordinates().replaceMethod(), mi.getArguments().get(0));
                }
                return mi;
            }

            private JavaTemplate securityMatcherTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""securityMatcher(#{any(String)})"")
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-web-5.8.+"", ""spring-security-config-5.8.+""))
                        .build();
            }
        });
    }
}
",{}
"Replace `HttpSecurity.authorizeRequests(...)` with `HttpSecurity.authorizeHttpRequests(...)` and `ExpressionUrlAuthorizationConfigurer`, `AbstractInterceptUrlConfigurer` with `AuthorizeHttpRequestsConfigurer`, etc",Replace `HttpSecurity.authorizeRequests(...)` deprecated in Spring Security 6 with `HttpSecurity.authorizeHttpRequests(...)` and all method calls on the resultant object respectively. Replace deprecated `AbstractInterceptUrlConfigurer` and its deprecated subclasses with `AuthorizeHttpRequestsConfigurer` and its corresponding subclasses.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.ChangeType;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;

public class AuthorizeHttpRequests extends Recipe {

    private static final String MSG_ADD_COMMENT = ""add-comment"";

    private static final String AUTHORIZE_HTTP_REQUESTS = ""authorizeHttpRequests"";

    private static final MethodMatcher MATCH_AUTHORIZE_REQUESTS = new MethodMatcher(
            ""org.springframework.security.config.annotation.web.builders.HttpSecurity authorizeRequests(..)"");

    private static final MethodMatcher MATCH_ACCESS_DECISION_MANAGER = new MethodMatcher(
            ""org.springframework.security.config.annotation.web.configurers.AbstractInterceptUrlConfigurer$AbstractInterceptUrlRegistry accessDecisionManager(..)"");

    @Override
    public String getDisplayName() {
        return ""Replace `HttpSecurity.authorizeRequests(...)` with `HttpSecurity.authorizeHttpRequests(...)` and `ExpressionUrlAuthorizationConfigurer`, `AbstractInterceptUrlConfigurer` with `AuthorizeHttpRequestsConfigurer`, etc"";
    }

    @Override
    public String getDescription() {
        return ""Replace `HttpSecurity.authorizeRequests(...)` deprecated in Spring Security 6 with `HttpSecurity.authorizeHttpRequests(...)` and all method calls on the resultant object respectively. Replace deprecated `AbstractInterceptUrlConfigurer` and its deprecated subclasses with `AuthorizeHttpRequestsConfigurer` and its corresponding subclasses."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {
            private void changeTypesAfterVisit() {
                doAfterVisit(new ChangeType(
                        ""org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry"",
                        ""org.springframework.security.config.annotation.web.configurers.AuthorizeHttpRequestsConfigurer.AuthorizationManagerRequestMatcherRegistry"",
                        false).getVisitor());
                doAfterVisit(new ChangeType(
                        ""org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer"",
                        ""org.springframework.security.config.annotation.web.configurers.AuthorizeHttpRequestsConfigurer"",
                        false).getVisitor());
                doAfterVisit(new ChangeType(
                        ""org.springframework.security.config.annotation.web.configurers.AbstractInterceptUrlConfigurer"",
                        ""org.springframework.security.config.annotation.web.configurers.AuthorizeHttpRequestsConfigurer"",
                        false).getVisitor());
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J visited = super.visitMethodInvocation(method, ctx);
                if (visited instanceof J.MethodInvocation) {
                    J.MethodInvocation m = (J.MethodInvocation) visited;
                    JavaType.Method methodType = method.getMethodType();
                    if (methodType != null) {
                        if (MATCH_AUTHORIZE_REQUESTS.matches(methodType)) {
                            changeTypesAfterVisit();
                            return processAuthorizeRequests(m);
                        }
                        if (MATCH_ACCESS_DECISION_MANAGER.matches(methodType)) {
                            changeTypesAfterVisit();
                            return processAccessDecisionManager(m, ctx);
                        }
                    }
                    String commentToAdd = getCursor().pollMessage(MSG_ADD_COMMENT);
                    if (commentToAdd != null) {
                        return addTextCommentAfterSelect(m, commentToAdd);
                    }
                }
                return visited;
            }

            private J.MethodInvocation processAuthorizeRequests(J.MethodInvocation m) {
                JavaType.Method methodType = m.getMethodType();
                JavaType.Method newMethodType = methodType.getDeclaringType().getMethods().stream()
                        .filter(nm -> AUTHORIZE_HTTP_REQUESTS.equals(nm.getName()))
                        .filter(nm -> nm.getParameterTypes().size() == methodType.getParameterTypes().size())
                        .findFirst().orElse(null);
                if (newMethodType != null) {
                    m = m
                            .withName(m.getName().withSimpleName(AUTHORIZE_HTTP_REQUESTS))
                            .withMethodType(newMethodType);
                }
                return m;
            }

            private J processAccessDecisionManager(J.MethodInvocation m, ExecutionContext ctx) {
                StringBuilder commentText = new StringBuilder();
                commentText.append(""TODO: replace removed '."");
                commentText.append(m.getSimpleName());
                commentText.append('(');
                commentText.append(String.join("", "", m.getArguments().stream().map(a -> a.print(getCursor())).toArray(String[]::new)));
                commentText.append("");' with appropriate call to 'access(AuthorizationManager)' after antMatcher(...) call etc."");

                List<Comment> newComments = new ArrayList<>(m.getComments());
                newComments.addAll(m.getSelect().getComments());

                Expression selectExpr = m.getSelect();
                Cursor parentInvocationCursor = getCursor().getParent(2);
                if (parentInvocationCursor == null || !(parentInvocationCursor.getValue() instanceof J.MethodInvocation)) {
                    // top level method invocation
                    newComments.add(new TextComment(true, commentText.toString(), newComments.isEmpty() ? ""\n"" + m.getPrefix().getIndent() : newComments.get(0).getSuffix(), Markers.EMPTY));
                    selectExpr = selectExpr.withPrefix(m.getPrefix());
                } else {
                    // parent is method invocation
                    parentInvocationCursor.putMessage(MSG_ADD_COMMENT, commentText.toString());
                }
                return selectExpr.withComments(newComments);
            }

            private J.MethodInvocation addTextCommentAfterSelect(J.MethodInvocation m, String s) {
                J.MethodInvocation.Padding padding = m.getPadding();
                Space afterSelect = padding.getSelect().getAfter();
                List<Comment> newComments = new ArrayList<>(afterSelect.getComments());
                newComments.add(new TextComment(true, s, newComments.isEmpty() ? ""\n"" + afterSelect.getIndent() : newComments.get(0).getSuffix(), Markers.EMPTY));
                JRightPadded<Expression> paddedSelect = padding.getSelect().withAfter(afterSelect.withComments(newComments));
                return new J.MethodInvocation(m.getId(), m.getPrefix(), m.getMarkers(), paddedSelect, padding.getTypeParameters(), m.getName(), padding.getArguments(), m.getMethodType());
            }
        };
    }
}
",{}
Use the new `requestMatchers` methods,"In Spring Security 5.8, the `antMatchers`, `mvcMatchers`, and `regexMatchers` methods were deprecated ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import static java.util.stream.Collectors.joining;

@EqualsAndHashCode(callSuper = false)
@Value
public class UseNewRequestMatchers extends Recipe {

    private static final String CLAZZ = ""org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry"";
    private static final MethodMatcher ANT_MATCHERS = new MethodMatcher(CLAZZ + "" antMatchers(..)"");
    private static final MethodMatcher MVC_MATCHERS = new MethodMatcher(CLAZZ + "" mvcMatchers(..)"", true);
    private static final MethodMatcher REGEX_MATCHERS = new MethodMatcher(CLAZZ + "" regexMatchers(..)"");
    private static final MethodMatcher CSRF_MATCHERS = new MethodMatcher(""org.springframework.security.config.annotation.web.configurers.CsrfConfigurer ignoringAntMatchers(..)"");

    @Override
    public String getDisplayName() {
        return ""Use the new `requestMatchers` methods"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 5.8, the `antMatchers`, `mvcMatchers`, and `regexMatchers` methods were deprecated "" +
                ""in favor of new `requestMatchers` methods. Refer to the [Spring Security docs](https://docs.spring.io/spring-security/reference/5.8/migration/servlet/config.html#use-new-requestmatchers) "" +
                ""for more information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(
                        new UsesMethod<>(ANT_MATCHERS),
                        new UsesMethod<>(MVC_MATCHERS),
                        new UsesMethod<>(REGEX_MATCHERS)),
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
                        boolean isCsrfMatcher = CSRF_MATCHERS.matches(mi);
                        if ((ANT_MATCHERS.matches(mi) || MVC_MATCHERS.matches(mi) || REGEX_MATCHERS.matches(mi) || isCsrfMatcher) &&
                                mi.getSelect() != null) {
                            String parametersTemplate = mi.getArguments().stream().map(arg -> ""#{any()}"").collect(joining("", ""));
                            String replacementMethodName = isCsrfMatcher ? ""ignoringRequestMatchers"" : ""requestMatchers"";
                            J.MethodInvocation applied = JavaTemplate.builder(String.format(""%s(%s)"", replacementMethodName, parametersTemplate))
                                    .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-security-config-5.8""))
                                    .build().apply(getCursor(), mi.getCoordinates().replaceMethod(), mi.getArguments().toArray());
                            JavaType.Method newMethodType = mi.getMethodType().withName(replacementMethodName);
                            return applied
                                    .withSelect(mi.getSelect())
                                    .withName(mi.getName().withSimpleName(replacementMethodName).withType(newMethodType))
                                    .withMethodType(newMethodType);
                        }
                        return mi;
                    }
                });
    }
}
",{}
Use new `Pbkdf2PasswordEncoder` factory methods,In Spring Security 5.8 some `Pbkdf2PasswordEncoder` constructors have been deprecated in favor of factory methods. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import static java.util.Collections.unmodifiableMap;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.spring.internal.LocalVariableUtils.resolveExpression;

@EqualsAndHashCode(callSuper = false)
@Value
public class UpdatePbkdf2PasswordEncoder extends Recipe {

    private static final String PBKDF2_PASSWORD_ENCODER_CLASS = ""org.springframework.security.crypto.password.Pbkdf2PasswordEncoder"";

    private static final MethodMatcher DEFAULT_CONSTRUCTOR_MATCHER = new MethodMatcher(PBKDF2_PASSWORD_ENCODER_CLASS + "" <constructor>()"");
    private static final MethodMatcher ONE_ARG_CONSTRUCTOR_MATCHER = new MethodMatcher(PBKDF2_PASSWORD_ENCODER_CLASS + "" <constructor>(java.lang.CharSequence)"");
    private static final MethodMatcher TWO_ARG_CONSTRUCTOR_MATCHER = new MethodMatcher(PBKDF2_PASSWORD_ENCODER_CLASS + "" <constructor>(java.lang.CharSequence, int)"");
    private static final MethodMatcher THREE_ARG_CONSTRUCTOR_MATCHER = new MethodMatcher(PBKDF2_PASSWORD_ENCODER_CLASS + "" <constructor>(java.lang.CharSequence, int, int)"");
    private static final MethodMatcher VERSION5_5_FACTORY_MATCHER = new MethodMatcher(PBKDF2_PASSWORD_ENCODER_CLASS + "" defaultsForSpringSecurity_v5_5(..)"");

    private static final String DEFAULT_SECRET = """";
    private static final Integer DEFAULT_SALT_LENGTH = 8;
    private static final Integer DEFAULT_HASH_WIDTH = 256;
    private static final Integer DEFAULT_ITERATIONS = 185000;

    private static final Map<Integer, String> HASH_WIDTH_TO_ALGORITHM_MAP;

    static {
        Map<Integer, String> map = new HashMap<>();
        map.put(160, ""PBKDF2WithHmacSHA1"");
        map.put(DEFAULT_HASH_WIDTH, ""PBKDF2WithHmacSHA256"");
        map.put(512, ""PBKDF2WithHmacSHA512"");
        HASH_WIDTH_TO_ALGORITHM_MAP = unmodifiableMap(map);
    }

    @Override
    public String getDisplayName() {
        return ""Use new `Pbkdf2PasswordEncoder` factory methods"";
    }

    @Override
    public String getDescription() {
        return ""In Spring Security 5.8 some `Pbkdf2PasswordEncoder` constructors have been deprecated in favor of factory methods. "" +
                ""Refer to the [ Spring Security migration docs](https://docs.spring.io/spring-security/reference/5.8/migration/index.html#_update_pbkdf2passwordencoder) for more information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(PBKDF2_PASSWORD_ENCODER_CLASS, false), new JavaVisitor<ExecutionContext>() {

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J j = super.visitNewClass(newClass, ctx);
                if (j instanceof J.NewClass && TypeUtils.isOfClassType(((J.NewClass) j).getType(), PBKDF2_PASSWORD_ENCODER_CLASS)) {
                    newClass = (J.NewClass) j;
                    if (DEFAULT_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS);
                        return newFactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                    }
                    List<Expression> arguments = newClass.getArguments();
                    if (ONE_ARG_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        Expression secret = arguments.get(0);
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS);
                        if (resolvedValueMatchesLiteral(secret, DEFAULT_SECRET)) {
                            return newFactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                        String algorithm = HASH_WIDTH_TO_ALGORITHM_MAP.get(DEFAULT_HASH_WIDTH);
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS + "".SecretKeyFactoryAlgorithm"", algorithm);
                        return newConstructorTemplate(ctx, algorithm).apply(getCursor(), newClass.getCoordinates().replace(), secret, newIntLiteral(DEFAULT_SALT_LENGTH), newIntLiteral(DEFAULT_ITERATIONS));
                    }
                    if (TWO_ARG_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        Expression secret = arguments.get(0);
                        Expression saltLength = arguments.get(1);
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS);
                        if (resolvedValueMatchesLiteral(secret, DEFAULT_SECRET) &&
                                resolvedValueMatchesLiteral(saltLength, DEFAULT_SALT_LENGTH)) {
                            return newFactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                        String algorithm = HASH_WIDTH_TO_ALGORITHM_MAP.get(DEFAULT_HASH_WIDTH);
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS + "".SecretKeyFactoryAlgorithm"", algorithm);
                        return newConstructorTemplate(ctx, algorithm).apply(getCursor(), newClass.getCoordinates().replace(), secret, saltLength, newIntLiteral(DEFAULT_ITERATIONS));
                    }
                    if (THREE_ARG_CONSTRUCTOR_MATCHER.matches(newClass)) {
                        Expression secret = arguments.get(0);
                        Expression iterations = arguments.get(1);
                        Expression hashWidth = arguments.get(2);
                        Integer knownHashWidth = hashWidth instanceof J.Literal && hashWidth.getType() == JavaType.Primitive.Int ? (Integer) ((J.Literal) hashWidth).getValue() : null;
                        maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS);
                        if (resolvedValueMatchesLiteral(secret, DEFAULT_SECRET) &&
                                resolvedValueMatchesLiteral(iterations, DEFAULT_ITERATIONS) &&
                                DEFAULT_HASH_WIDTH.equals(knownHashWidth)) {
                            return newFactoryMethodTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace());
                        }
                        String algorithm = HASH_WIDTH_TO_ALGORITHM_MAP.get(knownHashWidth);
                        if (algorithm != null) {
                            maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS + "".SecretKeyFactoryAlgorithm"", algorithm);
                            return newConstructorTemplate(ctx, algorithm).apply(getCursor(), newClass.getCoordinates().replace(), secret, newIntLiteral(DEFAULT_SALT_LENGTH), iterations);
                        }
                        return newDeprecatedConstructorTemplate(ctx).apply(getCursor(), newClass.getCoordinates().replace(), secret, newIntLiteral(DEFAULT_SALT_LENGTH), iterations, hashWidth);
                    }
                }
                return j;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J j = super.visitMethodInvocation(method, ctx);
                if (j instanceof J.MethodInvocation && VERSION5_5_FACTORY_MATCHER.matches(((J.MethodInvocation) j))) {
                    maybeAddImport(PBKDF2_PASSWORD_ENCODER_CLASS);
                    method = (J.MethodInvocation) j;
                    return newFactoryMethodTemplate(ctx).apply(getCursor(), method.getCoordinates().replace());
                }
                return j;
            }

            boolean resolvedValueMatchesLiteral(Expression expression, Object value) {
                Expression resolvedExpression = resolveExpression(expression, getCursor());
                return resolvedExpression instanceof J.Literal && Objects.equals(((J.Literal) resolvedExpression).getValue(), value);
            }

            private JavaTemplate newFactoryMethodTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8()"")
                        .imports(PBKDF2_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }

            private JavaTemplate newConstructorTemplate(ExecutionContext ctx, String algorithm) {
                return JavaTemplate.builder(""new Pbkdf2PasswordEncoder(#{any(java.lang.CharSequence)}, #{any(int)}, #{any(int)}, "" + algorithm + "")"")
                        .imports(PBKDF2_PASSWORD_ENCODER_CLASS)
                        .staticImports(PBKDF2_PASSWORD_ENCODER_CLASS + "".SecretKeyFactoryAlgorithm."" + algorithm)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }

            private JavaTemplate newDeprecatedConstructorTemplate(ExecutionContext ctx) {
                return JavaTemplate.builder(""new Pbkdf2PasswordEncoder(#{any(java.lang.CharSequence)}, #{any(int)}, #{any(int)}, #{any(int)})"")
                        .imports(PBKDF2_PASSWORD_ENCODER_CLASS)
                        .javaParser(JavaParser.fromJavaVersion()
                                .classpathFromResources(ctx, ""spring-security-crypto-5.8.+""))
                        .build();
            }
        });
    }

    private static J.Literal newIntLiteral(int i) {
        return new J.Literal(randomId(), Space.EMPTY, Markers.EMPTY, i, Integer.toString(i), null, JavaType.Primitive.Int);
    }
}
",{}
Spring Security 5.4 introduces the ability to configure `HttpSecurity` by creating a `SecurityFilterChain` bean,"The Spring Security `WebSecurityConfigurerAdapter` was deprecated 5.7, this recipe will transform `WebSecurityConfigurerAdapter` classes by using a component based approach. Check out the [spring-security-without-the-websecurityconfigureradapter](https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter) blog for more details.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.spring.security5;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toSet;

/**
 * @author Alex Boyko
 */
public class WebSecurityConfigurerAdapter extends Recipe {

    private static final Collection<J.Modifier.Type> EXPLICIT_ACCESS_LEVELS = Arrays.asList(J.Modifier.Type.Public,
            J.Modifier.Type.Private, J.Modifier.Type.Protected);

    private static final String FQN_CONFIGURATION = ""org.springframework.context.annotation.Configuration"";
    private static final String FQN_WEB_SECURITY_CONFIGURER_ADAPTER = ""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter"";
    private static final String FQN_SECURITY_FILTER_CHAIN = ""org.springframework.security.web.SecurityFilterChain"";
    private static final String FQN_OVERRIDE = ""java.lang.Override"";
    private static final String FQN_WEB_SECURITY_CUSTOMIZER = ""org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer"";
    private static final String FQN_INMEMORY_AUTH_CONFIG = ""org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer"";
    private static final String FQN_INMEMORY_AUTH_MANAGER = ""org.springframework.security.provisioning.InMemoryUserDetailsManager"";
    private static final String FQN_JDBC_AUTH_CONFIG = ""org.springframework.security.config.annotation.authentication.configurers.provisioning.JdbcUserDetailsManagerConfigurer"";
    private static final String FQN_LDAP_AUTH_CONFIG = ""org.springframework.security.config.annotation.authentication.configurers.ldap.LdapAuthenticationProviderConfigurer"";
    private static final String FQN_AUTH_MANAGER_BUILDER = ""org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder"";
    private static final String FQN_USER = ""org.springframework.security.core.userdetails.User"";
    private static final String FQN_USER_DETAILS_BUILDER = ""org.springframework.security.core.userdetails.User$UserBuilder"";
    private static final String FQN_USER_DETAILS = ""org.springframework.security.core.userdetails.UserDetails"";
    private static final String FQN_BEAN = ""org.springframework.context.annotation.Bean"";

    private static final MethodMatcher CONFIGURE_HTTP_SECURITY_METHOD_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter configure(org.springframework.security.config.annotation.web.builders.HttpSecurity)"", true);
    private static final MethodMatcher CONFIGURE_WEB_SECURITY_METHOD_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter configure(org.springframework.security.config.annotation.web.builders.WebSecurity)"", true);
    private static final MethodMatcher CONFIGURE_AUTH_MANAGER_SECURITY_METHOD_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter configure(org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder)"", true);

    private static final MethodMatcher USER_DETAILS_SERVICE_BEAN_METHOD_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter  userDetailsServiceBean()"", true);
    private static final MethodMatcher AUTHENTICATION_MANAGER_BEAN_METHOD_MATCHER =
            new MethodMatcher(""org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter  authenticationManagerBean()"", true);

    private static final MethodMatcher AUTH_INMEMORY_WITH_USER =
            new MethodMatcher(""org.springframework.security.config.annotation.authentication.configurers.provisioning.UserDetailsManagerConfigurer withUser(..)"");

    private static final String HAS_CONFLICT = ""has-conflict"";

    private static final String FLATTEN_CLASSES = ""flatten-classes"";

    private enum AuthType {
        NONE,
        LDAP,
        JDBC,
        INMEMORY
    }

    @Override
    public String getDisplayName() {
        return ""Spring Security 5.4 introduces the ability to configure `HttpSecurity` by creating a `SecurityFilterChain` bean"";
    }

    @Override
    public String getDescription() {
        return ""The Spring Security `WebSecurityConfigurerAdapter` was deprecated 5.7, this recipe will transform `WebSecurityConfigurerAdapter` classes by using a component based approach. Check out the [spring-security-without-the-websecurityconfigureradapter](https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter) blog for more details."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(FQN_WEB_SECURITY_CONFIGURER_ADAPTER, false), new JavaIsoVisitor<ExecutionContext>() {

            @Override
            public J.@Nullable ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                boolean isWebSecurityConfigurerAdapterClass = TypeUtils.isAssignableTo(FQN_WEB_SECURITY_CONFIGURER_ADAPTER, classDecl.getType()) &&
                        isAnnotatedWith(classDecl.getLeadingAnnotations(), FQN_CONFIGURATION);
                boolean hasConflict = false;
                if (isWebSecurityConfigurerAdapterClass) {
                    for (Statement s : classDecl.getBody().getStatements()) {
                        if (s instanceof J.MethodDeclaration) {
                            J.MethodDeclaration method = (J.MethodDeclaration) s;
                            if (isConflictingMethod(method)) {
                                hasConflict = true;
                                break;
                            }
                        }
                    }
                    getCursor().putMessage(HAS_CONFLICT, hasConflict);
                    maybeRemoveImport(FQN_WEB_SECURITY_CONFIGURER_ADAPTER);
                }
                classDecl = super.visitClassDeclaration(classDecl, ctx);
                if (!isWebSecurityConfigurerAdapterClass) {
                    classDecl = processAnyClass(classDecl, ctx);
                } else if (!hasConflict) {
                    classDecl = processSecurityAdapterClass(classDecl);
                }
                return classDecl;
            }

            private J.@Nullable ClassDeclaration processSecurityAdapterClass(J.ClassDeclaration classDecl) {
                classDecl = classDecl.withExtends(null);
                // Flatten configuration classes if applicable
                Cursor enclosingClassCursor = getCursor().getParent();
                while (enclosingClassCursor != null && !(enclosingClassCursor.getValue() instanceof J.ClassDeclaration)) {
                    enclosingClassCursor = enclosingClassCursor.getParent();
                }
                if (enclosingClassCursor != null && enclosingClassCursor.getValue() instanceof J.ClassDeclaration) {
                    J.ClassDeclaration enclosingClass = enclosingClassCursor.getValue();
                    if (enclosingClass.getType() != null && isMetaAnnotated(enclosingClass.getType(), FQN_CONFIGURATION, new HashSet<>()) && canMergeClassDeclarations(enclosingClass, classDecl)) {
                        // can flatten. Outer class is annotated as configuration bean
                        List<J.ClassDeclaration> classesToFlatten = enclosingClassCursor.getMessage(FLATTEN_CLASSES);
                        if (classesToFlatten == null) {
                            classesToFlatten = new ArrayList<>();
                            enclosingClassCursor.putMessage(FLATTEN_CLASSES, classesToFlatten);
                        }
                        // only applicable to former subclasses of WebSecurityConfigurerAdapter - other classes won't be flattened
                        classesToFlatten.add(classDecl);
                        maybeRemoveImport(FQN_CONFIGURATION);
                        classDecl = null; // remove class
                    }
                }
                return classDecl;
            }

            private boolean canMergeClassDeclarations(J.ClassDeclaration a, J.ClassDeclaration b) {
                Set<String> aVars = getAllVarNames(a);
                Set<String> bVars = getAllVarNames(b);
                for (String av : aVars) {
                    if (bVars.contains(av)) {
                        return false;
                    }
                }
                Set<String> aMethods = getAllMethodSignatures(a);
                Set<String> bMethods = getAllMethodSignatures(b);
                for (String am : aMethods) {
                    if (bMethods.contains(am)) {
                        return false;
                    }
                }
                return true;
            }

            private Set<String> getAllVarNames(J.ClassDeclaration c) {
                return c.getBody().getStatements().stream()
                        .filter(J.VariableDeclarations.class::isInstance)
                        .map(J.VariableDeclarations.class::cast)
                        .flatMap(vd -> vd.getVariables().stream())
                        .map(v -> v.getName().getSimpleName())
                        .collect(toSet());
            }

            private Set<String> getAllMethodSignatures(J.ClassDeclaration c) {
                return c.getBody().getStatements().stream()
                        .filter(J.MethodDeclaration.class::isInstance)
                        .map(J.MethodDeclaration.class::cast)
                        .map(this::simpleMethodSignature)
                        .collect(toSet());
            }

            private String simpleMethodSignature(J.MethodDeclaration method) {
                String fullSignature = MethodMatcher.methodPattern(method);
                int firstSpaceIdx = fullSignature.indexOf(' ');
                return firstSpaceIdx < 0 ? fullSignature : fullSignature.substring(firstSpaceIdx + 1);
            }

            private J.ClassDeclaration processAnyClass(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                // regular class case
                List<J.ClassDeclaration> toFlatten = getCursor().pollMessage(FLATTEN_CLASSES);
                if (toFlatten != null) {
                    // The message won't be 'null' for a configuration class
                    List<Statement> statements = new ArrayList<>(classDecl.getBody().getStatements().size() + toFlatten.size());
                    statements.addAll(classDecl.getBody().getStatements());
                    for (J.ClassDeclaration fc : toFlatten) {
                        for (Statement s : fc.getBody().getStatements()) {
                            if (s instanceof J.MethodDeclaration) {
                                J.MethodDeclaration m = (J.MethodDeclaration) s;
                                if (isAnnotatedWith(m.getLeadingAnnotations(), FQN_BEAN) && m.getMethodType() != null) {
                                    JavaType.FullyQualified beanType = TypeUtils.asFullyQualified(m.getMethodType().getReturnType());
                                    if (beanType == null) {
                                        continue;
                                    }
                                    String uniqueName = computeBeanNameFromClassName(fc.getSimpleName(), beanType.getClassName());
                                    List<J.Annotation> fcLeadingAnnotations = ListUtils.map(fc.getLeadingAnnotations(),
                                            anno -> TypeUtils.isOfClassType(anno.getType(), FQN_CONFIGURATION) ? null : anno);
                                    s = m
                                            .withName(m.getName().withSimpleName(uniqueName))
                                            .withMethodType(m.getMethodType().withName(uniqueName))
                                            .withLeadingAnnotations(ListUtils.concatAll(m.getLeadingAnnotations(), fcLeadingAnnotations));
                                    s = autoFormat(s, ctx, new Cursor(getCursor(), classDecl.getBody()));
                                }
                            }
                            statements.add(s);
                        }
                    }
                    classDecl = classDecl.withBody(classDecl.getBody().withStatements(statements));
                }
                return classDecl;
            }

            private boolean isConflictingMethod(J.MethodDeclaration m) {
                String methodName = m.getSimpleName();
                JavaType.Method methodType = m.getMethodType();
                return (methodType == null && (""authenticationManagerBean"".equals(methodName) || ""userDetailsServiceBean"".equals(methodName))) ||
                        (USER_DETAILS_SERVICE_BEAN_METHOD_MATCHER.matches(methodType) ||
                                AUTHENTICATION_MANAGER_BEAN_METHOD_MATCHER.matches(methodType) ||
                                (CONFIGURE_AUTH_MANAGER_SECURITY_METHOD_MATCHER.matches(methodType) && inConflictingAuthConfigMethod(m)));
            }

            private boolean inConflictingAuthConfigMethod(J.MethodDeclaration m) {
                AuthType authType = getAuthType(m);
                return authType != WebSecurityConfigurerAdapter.AuthType.INMEMORY;
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration m, ExecutionContext ctx) {
                Cursor classCursor = getCursor().dropParentUntil(it -> it instanceof J.ClassDeclaration || it == Cursor.ROOT_VALUE);
                if (!(classCursor.getValue() instanceof J.ClassDeclaration)) {
                    return m;
                }
                if (isConflictingMethod(m)) {
                    m = SearchResult.found(m, ""Migrate manually based on https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter"");
                } else if (!classCursor.getMessage(HAS_CONFLICT, true)) {
                    J.ClassDeclaration c = classCursor.getValue();
                    if (CONFIGURE_HTTP_SECURITY_METHOD_MATCHER.matches(m, c)) {
                        m = changeToBeanMethod(m, c, FQN_SECURITY_FILTER_CHAIN, ""filterChain"", true, ctx);
                    } else if (CONFIGURE_WEB_SECURITY_METHOD_MATCHER.matches(m, c)) {
                        m = changeToBeanMethod(m, c, FQN_WEB_SECURITY_CUSTOMIZER, ""webSecurityCustomizer"", false, ctx);
                    } else if (CONFIGURE_AUTH_MANAGER_SECURITY_METHOD_MATCHER.matches(m, c)) {
                        AuthType authType = getAuthType(m);
                        switch (authType) {
                            case INMEMORY:
                                m = changeToBeanMethod(m, c, FQN_INMEMORY_AUTH_MANAGER, ""inMemoryAuthManager"", false, ctx);
                                break;
                            case JDBC:
                                //TODO: implement
                                break;
                            case LDAP:
                                //TODO: implement
                                break;
                            default:
                                throw new IllegalStateException();
                        }
                    }
                }
                return super.visitMethodDeclaration(m, ctx);
            }

            private J.MethodDeclaration changeToBeanMethod(J.MethodDeclaration m, J.ClassDeclaration c, String fqnReturnType, String newMethodName, boolean keepParams, ExecutionContext ctx) {
                JavaType.FullyQualified inmemoryAuthConfigType = (JavaType.FullyQualified) JavaType.buildType(fqnReturnType);
                JavaType.Method type = m.getMethodType();
                if (type != null) {
                    type = type.withName(newMethodName).withReturnType(inmemoryAuthConfigType);
                    if (!keepParams) {
                        for (JavaType pt : type.getParameterTypes()) {
                            maybeRemoveImport(TypeUtils.asFullyQualified(pt));
                        }
                        type = type.withParameterTypes(emptyList()).withParameterNames(emptyList());
                    }
                }
                Space returnPrefix = m.getReturnTypeExpression() == null ? Space.EMPTY : m.getReturnTypeExpression().getPrefix();
                m = m.withLeadingAnnotations(ListUtils.map(m.getLeadingAnnotations(), anno -> {
                            if (TypeUtils.isOfClassType(anno.getType(), FQN_OVERRIDE)) {
                                maybeRemoveImport(FQN_OVERRIDE);
                                return null;
                            }
                            return anno;
                        }))
                        .withReturnTypeExpression(new J.Identifier(Tree.randomId(), returnPrefix, Markers.EMPTY, emptyList(), inmemoryAuthConfigType.getClassName(), inmemoryAuthConfigType, null))
                        .withName(m.getName().withSimpleName(newMethodName))
                        .withMethodType(type)
                        .withModifiers(ListUtils.map(m.getModifiers(), modifier -> EXPLICIT_ACCESS_LEVELS.contains(modifier.getType()) ? null : modifier));

                if (!keepParams) {
                    m = m.withParameters(emptyList());
                }

                maybeAddImport(inmemoryAuthConfigType);
                maybeAddImport(FQN_BEAN);
                return JavaTemplate.builder(""@Bean"")
                        .imports(FQN_BEAN)
                        .javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, ""spring-context-6""))
                        .build()
                        // not calling `updateCursor()` here because `visitBlock()` currently requires the original to be stored in the cursor
                        .apply(new Cursor(getCursor().getParentOrThrow(), m),
                                m.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
            }

            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                J.Block b = super.visitBlock(block, ctx);
                updateCursor(b);
                if (getCursor().getParent() != null && getCursor().getParent().getValue() instanceof J.MethodDeclaration) {
                    J.MethodDeclaration parentMethod = getCursor().getParent().getValue();
                    Cursor classDeclCursor = getCursor().dropParentUntil(it -> it instanceof J.ClassDeclaration || it == Cursor.ROOT_VALUE);
                    if (!(classDeclCursor.getValue() instanceof J.ClassDeclaration)) {
                        return b;
                    }
                    J.ClassDeclaration classDecl = classDeclCursor.getValue();
                    if (!classDeclCursor.getMessage(HAS_CONFLICT, true)) {
                        if (CONFIGURE_HTTP_SECURITY_METHOD_MATCHER.matches(parentMethod, classDecl)) {
                            b = handleHttpSecurity(b, parentMethod);
                        } else if (CONFIGURE_WEB_SECURITY_METHOD_MATCHER.matches(parentMethod, classDecl)) {
                            b = handleWebSecurity(b, parentMethod);
                        } else if (CONFIGURE_AUTH_MANAGER_SECURITY_METHOD_MATCHER.matches(parentMethod, classDecl)) {
                            AuthType authType = getAuthType(parentMethod);
                            switch (authType) {
                                case INMEMORY:
                                    b = handleAuthInMemory(b, parentMethod);
                                    break;
                                case LDAP:
                                    //TODO: implement
                                    break;
                                case JDBC:
                                    //TODO: implement
                                    break;
                            }
                        }
                    }
                }
                return b;
            }

            private J.Block handleHttpSecurity(J.Block b, J.MethodDeclaration parentMethod) {
                return JavaTemplate.builder(""return #{any(org.springframework.security.config.annotation.SecurityBuilder)}.build();"")
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion()
                        .dependsOn(""package org.springframework.security.config.annotation;"" +
                                   ""public interface SecurityBuilder<O> {\n"" +
                                   ""    O build() throws Exception;"" +
                                   ""}""))
                    .imports(""org.springframework.security.config.annotation.SecurityBuilder"")
                    .build()
                    .apply(
                        getCursor(),
                        b.getCoordinates().lastStatement(),
                        ((J.VariableDeclarations) parentMethod.getParameters().get(0)).getVariables().get(0).getName()
                    );
            }

            private J.Block handleWebSecurity(J.Block b, J.MethodDeclaration parentMethod) {
                String t = ""return ("" + ((J.VariableDeclarations) parentMethod.getParameters().get(0)).getVariables().get(0).getName().getSimpleName() + "") -> #{any()};"";
                b = JavaTemplate.builder(t)
                    .contextSensitive()
                    .javaParser(JavaParser.fromJavaVersion())
                    .build()
                    .apply(
                        getCursor(),
                        b.getCoordinates().firstStatement(), b
                    );
                return b.withStatements(ListUtils.map(b.getStatements(), (index, stmt) -> {
                    if (index == 0) {
                        return stmt;
                    }
                    return null;
                }));
            }

            private J.Block handleAuthInMemory(J.Block b, J.MethodDeclaration parentMethod) {
                Expression userExpr = findUserParameterExpression(b.getStatements().get(b.getStatements().size() - 1));
                String typeStr = """";
                if (userExpr != null) {
                    if (userExpr.getType() instanceof JavaType.Primitive) {
                        typeStr = ((JavaType.Primitive) userExpr.getType()).getClassName();
                    } else if (userExpr.getType() instanceof JavaType.FullyQualified) {
                        typeStr = ((JavaType.FullyQualified) userExpr.getType()).getFullyQualifiedName();
                    }
                }
                String t;
                Object[] templateParams = new Object[0];
                switch (typeStr) {
                    case FQN_USER_DETAILS_BUILDER:
                        t = ""return new InMemoryUserDetailsManager(#{any()}.build());"";
                        templateParams = new Object[]{userExpr};
                        break;
                    case FQN_USER_DETAILS:
                        t = ""return new InMemoryUserDetailsManager(#{any()});"";
                        templateParams = new Object[]{userExpr};
                        break;
                    case ""java.lang.String"":
                        t = ""return new InMemoryUserDetailsManager(User.builder().username(#{any()}).build());"";
                        templateParams = new Object[]{userExpr};
                        maybeAddImport(FQN_USER);
                        break;
                    default:
                        t = ""return new InMemoryUserDetailsManager();"";
                        b = SearchResult.found(b, ""Unrecognized type of user expression "" + userExpr + ""\n.Please correct manually"");
                }
                JavaTemplate template = JavaTemplate.builder(t)
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion()
                                .dependsOn(
                                        ""package org.springframework.security.core.userdetails;\n"" +
                                                ""public interface UserDetails {}\n"",

                                        ""package org.springframework.security.provisioning;\n"" +
                                                ""public class InMemoryUserDetailsManager {\n"" +
                                                ""    public InMemoryUserDetailsManager(org.springframework.security.core.userdetails.UserDetails user) {}\n"" +
                                                ""}"",

                                        ""package org.springframework.security.core.userdetails;\n"" +
                                                ""public class User {\n"" +
                                                ""   public static UserBuilder builder() {}\n"" +
                                                ""   public interface UserBuilder {\n"" +
                                                ""       UserBuilder username(String s);\n"" +
                                                ""       UserDetails build();\n"" +
                                                ""   }\n"" +
                                                ""}\n""
                                ))
                        .imports(FQN_INMEMORY_AUTH_MANAGER, FQN_USER_DETAILS_BUILDER, FQN_USER)
                        .build();
                List<Statement> allExceptLastStatements = b.getStatements();
                allExceptLastStatements.remove(b.getStatements().size() - 1);
                b = b.withStatements(allExceptLastStatements);
                b = template.apply(updateCursor(b), b.getCoordinates().lastStatement(), templateParams);
                maybeAddImport(FQN_INMEMORY_AUTH_MANAGER);
                maybeRemoveImport(FQN_AUTH_MANAGER_BUILDER);
                return b;
            }
        });
    }

    private static String computeBeanNameFromClassName(String className, String beanType) {
        String lowerCased = Character.toLowerCase(className.charAt(0)) + className.substring(1);
        String newName = lowerCased
                .replace(""WebSecurityConfigurerAdapter"", beanType)
                .replace(""SecurityConfigurerAdapter"", beanType)
                .replace(""ConfigurerAdapter"", beanType)
                .replace(""Adapter"", beanType);
        if (lowerCased.equals(newName)) {
            newName = newName + beanType;
        }
        return newName;
    }

    private static boolean isMetaAnnotated(JavaType.FullyQualified t, String fqn, Set<JavaType.FullyQualified> visited) {
        for (JavaType.FullyQualified a : t.getAnnotations()) {
            if (!visited.contains(a)) {
                visited.add(a);
                if (fqn.equals(a.getFullyQualifiedName())) {
                    return true;
                }
                boolean metaAnnotated = isMetaAnnotated(a, fqn, visited);
                if (metaAnnotated) {
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean isAnnotatedWith(Collection<J.Annotation> annotations, String annotationType) {
        return annotations.stream().anyMatch(a -> TypeUtils.isOfClassType(a.getType(), annotationType));
    }

    private static AuthType getAuthType(J.MethodDeclaration m) {
        if (m.getBody() == null || m.getBody().getStatements().isEmpty()) {
            return AuthType.NONE;
        }
        Statement lastStatement = m.getBody().getStatements().get(m.getBody().getStatements().size() - 1);
        if (lastStatement instanceof J.MethodInvocation) {
            for (J.MethodInvocation invocation = (J.MethodInvocation) lastStatement; invocation != null; ) {
                Expression target = invocation.getSelect();
                if (target != null) {
                    JavaType.FullyQualified type = TypeUtils.asFullyQualified(target.getType());
                    if (type != null) {
                        switch (type.getFullyQualifiedName()) {
                            case FQN_INMEMORY_AUTH_CONFIG:
                                return AuthType.INMEMORY;
                            case FQN_LDAP_AUTH_CONFIG:
                                return AuthType.LDAP;
                            case FQN_JDBC_AUTH_CONFIG:
                                return AuthType.JDBC;
                        }
                    }
                    if (target instanceof J.MethodInvocation) {
                        invocation = (J.MethodInvocation) target;
                        continue;
                    }
                }
                invocation = null;
            }

        }
        return AuthType.NONE;
    }

    private @Nullable Expression findUserParameterExpression(Statement s) {
        AtomicReference<@Nullable Expression> context = new AtomicReference<>();
        new JavaIsoVisitor<AtomicReference<Expression>>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicReference<Expression> ref) {
                if (AUTH_INMEMORY_WITH_USER.matches(method)) {
                    ref.set(method.getArguments().get(0));
                    return method;
                }
                return super.visitMethodInvocation(method, ref);
            }
        }.visit(s, context);
        return context.get();
    }
}
",{}
"Add `io.spring.dependency-management` plugin, if in use",Prior to Spring Boot 2.0 the dependency management plugin was applied automatically as part of the overall spring boot plugin. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.spring;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.plugins.AddBuildPlugin;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.marker.SearchResult;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

@EqualsAndHashCode(callSuper = false)
@Value
public class AddSpringDependencyManagementPlugin extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add `io.spring.dependency-management` plugin, if in use"";
    }

    @Override
    public String getDescription() {
        return ""Prior to Spring Boot 2.0 the dependency management plugin was applied automatically as part of the overall spring boot plugin. "" +
               ""Afterwards the dependency-management plugin must be applied explicitly, or Gradle's `platform()` feature may be used instead. "" +
               ""This recipe makes usage of io-spring.dependency-management explicit in anticipation of upgrade to Spring Boot 2.0 or later."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                Preconditions.and(
                        new IsBuildGradle<>(),
                        new UsesSpringDependencyManagement()
                ),
                new AddBuildPlugin(""io.spring.dependency-management"", ""1.0.6.RELEASE"", null, null, false).getVisitor()
        );
    }

    private static class UsesSpringDependencyManagement extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) tree;
                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);
                if (!maybeGp.isPresent()) {
                    return cu;
                }
                GradleProject gp = maybeGp.get();
                if (gp.getPlugins().stream().anyMatch(plugin -> ""io.spring.dependency-management"".equals(plugin.getId()) ||
                        ""io.spring.gradle.dependencymanagement.DependencyManagementPlugin"".equals(plugin.getFullyQualifiedClassName())) &&
                    usesDependencyManagementDsl(cu)
                ) {
                    return SearchResult.found(cu);
                }
            }
            return super.visit(tree, ctx);
        }
    }

    private static boolean usesDependencyManagementDsl(JavaSourceFile cu) {
        AtomicBoolean found = new AtomicBoolean(false);
        new UsesDependencyManagementDslVisitor().visit(cu, found);
        return found.get();
    }

    private static class UsesDependencyManagementDslVisitor extends GroovyIsoVisitor<AtomicBoolean> {
        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean found) {
            if (""dependencyManagement"".equals(method.getSimpleName())) {
                found.set(true);
                return method;
            }
            return super.visitMethodInvocation(method, found);
        }

        @Override
        public @Nullable J visit(@Nullable Tree tree, AtomicBoolean found) {
            if (found.get()) {
                return (J) tree;
            }
            return super.visit(tree, found);
        }
    }
}
",{}
