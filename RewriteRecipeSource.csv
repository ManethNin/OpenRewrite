Recipe name,Recipe description,Recipe type,Recipe source code,Recipe options
The name of the recipe.,The description of the recipe.,"Differentiate between Java and YAML recipes, as they may be two independent data sets used in LLM fine-tuning.",The full source code of the recipe.,JSON format of recipe options.
Fail if run on not-maven,Super description.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.AllArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.openrewrite.*;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.maven.Assertions.pomXml;
import static org.openrewrite.xml.Assertions.xml;

@Execution(ExecutionMode.SAME_THREAD)
class AssertionsTest implements RewriteTest {

    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new MavenOnlyRecipe());
    }

    private static final AtomicInteger xmlCount = new AtomicInteger();

    @BeforeEach
    void reset() {
        xmlCount.set(0);
    }

    @Test
    void xmlAndPomXmlUseCorrectParserWhenPomXmlIsFirst() {
        rewriteRun(
          pomXml(
            """"""
              <project>
                  <groupId>org.openrewrite</groupId>
                  <artifactId>test</artifactId>
                  <version>1.0.0</version>
                  <dependencies>
                      <dependency>
                          <groupId>com.fasterxml.jackson</groupId>
                          <artifactId>jackson-base</artifactId>
                          <version>2.14.2</version>
                      </dependency>
                  </dependencies>
              </project>
              """"""
          ),
          xml(""""""
              <?xml version=""1.0"" encoding=""UTF-8"" ?>
              <suppressions xmlns=""https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd"">
              </suppressions>"""""",
            spec -> spec.path(""suppressions.xml""))
        );
        assertThat(xmlCount.get()).isEqualTo(2);
    }

    @Test
    void xmlAndPomXmlUseCorrectParserWhenPomXmlIsLast() {
        rewriteRun(
          xml(""""""
              <?xml version=""1.0"" encoding=""UTF-8"" ?>
              <suppressions xmlns=""https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd"">
              </suppressions>"""""",
            spec -> spec.path(""suppressions.xml"")
          ),
          pomXml(
            """"""
              <project>
                  <groupId>org.openrewrite</groupId>
                  <artifactId>test</artifactId>
                  <version>1.0.0</version>
                  <dependencies>
                      <dependency>
                          <groupId>com.fasterxml.jackson</groupId>
                          <artifactId>jackson-base</artifactId>
                          <version>2.14.2</version>
                      </dependency>
                  </dependencies>
              </project>
              """"""
          )
        );
        assertThat(xmlCount.get()).isEqualTo(2);
    }

    @AllArgsConstructor
    private static class MavenOnlyRecipe extends Recipe {
        @Override
        public String getDisplayName() {
            return ""Fail if run on not-maven"";
        }

        @Override
        public String getDescription() {
            return ""Super description."";
        }

        @Override
        public List<Recipe> getRecipeList() {
            return singletonList(new NonMavenRecipe());
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new MavenIsoVisitor<ExecutionContext>() {
                @Nullable
                private String filename;

                @Override
                public Xml visit(@Nullable Tree tree, ExecutionContext ctx) {
                    SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                    filename = sourceFile.getSourcePath().getFileName().toString();
                    return (Xml) sourceFile;
                }

                @Override
                public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                    assertThat(filename).isEqualTo(""pom.xml"");
                    return super.visitTag(tag, ctx);
                }
            };
        }
    }

    private static class NonMavenRecipe extends Recipe {
        @Override
        public String getDisplayName() {
            return ""Fail if run on maven"";
        }

        @Override
        public String getDescription() {
            return ""Super description."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new XmlIsoVisitor<>() {
                @Override
                public Xml visit(@Nullable Tree tree, ExecutionContext ctx) {
                    SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                    xmlCount.incrementAndGet();
                    return (Xml) sourceFile;
                }
            };
        }
    }
}
",{}
"Change Maven managed dependency groupId, artifactId and optionally the version","Change the groupId, artifactId and optionally the version of a specified Maven managed dependency.",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.MavenMetadata;
import org.openrewrite.maven.tree.ResolvedManagedDependency;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.*;

import static java.util.Collections.max;
import static org.openrewrite.Validated.test;
import static org.openrewrite.internal.StringUtils.isBlank;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeManagedDependencyGroupIdAndArtifactId extends Recipe {
    @EqualsAndHashCode.Exclude
    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old groupId"",
            description = ""The old groupId to replace. The groupId is the first part of a managed dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""org.openrewrite.recipe"")
    String oldGroupId;

    @Option(displayName = ""Old artifactId"",
            description = ""The old artifactId to replace. The artifactId is the second part of a managed dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""rewrite-testing-frameworks"")
    String oldArtifactId;

    @Option(displayName = ""New groupId"",
            description = ""The new groupId to use."",
            example = ""corp.internal.openrewrite.recipe"")
    String newGroupId;

    @Option(displayName = ""New artifactId"",
            description = ""The new artifactId to use."",
            example = ""rewrite-testing-frameworks"")
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""The new version to use."",
            example = ""2.0.0"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    public ChangeManagedDependencyGroupIdAndArtifactId(String oldGroupId, String oldArtifactId, String newGroupId, String newArtifactId, @Nullable String newVersion) {
        this.oldGroupId = oldGroupId;
        this.oldArtifactId = oldArtifactId;
        this.newGroupId = newGroupId;
        this.newArtifactId = newArtifactId;
        this.newVersion = newVersion;
        this.versionPattern = null;
    }

    @JsonCreator
    public ChangeManagedDependencyGroupIdAndArtifactId(String oldGroupId, String oldArtifactId, String newGroupId, String newArtifactId, @Nullable String newVersion, @Nullable String versionPattern) {
        this.oldGroupId = oldGroupId;
        this.oldArtifactId = oldArtifactId;
        this.newGroupId = newGroupId;
        this.newArtifactId = newArtifactId;
        this.newVersion = newVersion;
        this.versionPattern = versionPattern;
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated.and(test(
                ""coordinates"",
                ""newGroupId OR newArtifactId must be different from before"",
                this,
                r -> {
                    boolean sameGroupId = isBlank(r.newGroupId) || Objects.equals(r.oldGroupId, r.newGroupId);
                    boolean sameArtifactId = isBlank(r.newArtifactId) || Objects.equals(r.oldArtifactId, r.newArtifactId);
                    return !(sameGroupId && sameArtifactId);
                }
        ));
    }

    @Override
    public String getDisplayName() {
        return ""Change Maven managed dependency groupId, artifactId and optionally the version"";
    }

    @Override
    public String getDescription() {
        return ""Change the groupId, artifactId and optionally the version of a specified Maven managed dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Nullable
            final VersionComparator versionComparator = newVersion != null ? Semver.validate(newVersion, versionPattern).getValue() : null;
            @Nullable
            private Collection<String> availableVersions;
            private boolean isNewDependencyPresent;

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                isNewDependencyPresent = checkIfNewDependencyPresents(newGroupId, newArtifactId, newVersion);
                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (isManagedDependencyTag(oldGroupId, oldArtifactId)) {
                    if (t.getChild(""groupId"").isPresent()) {
                        t = changeChildTagValue(t, ""groupId"", newGroupId, ctx);
                    }
                    if (t.getChild(""artifactId"").isPresent()) {
                        t = changeChildTagValue(t, ""artifactId"", newArtifactId, ctx);
                    }
                    if (newVersion != null) {
                        try {
                            Optional<Xml.Tag> versionTag = t.getChild(""version"");
                            if (versionTag.isPresent()) {
                                String resolvedArtifactId = newArtifactId;
                                if (resolvedArtifactId.contains(""${"")) {
                                    ResolvedPom pom = getResolutionResult().getPom();
                                    Map<String, String> properties = pom.getProperties();
                                    resolvedArtifactId = ResolvedPom.placeholderHelper.replacePlaceholders(newArtifactId, properties::get);
                                }
                                String resolvedNewVersion = resolveSemverVersion(ctx, newGroupId, resolvedArtifactId, getResolutionResult().getPom().getValue(versionTag.get().getValue().orElse(null)));
                                t = changeChildTagValue(t, ""version"", resolvedNewVersion, ctx);
                            }
                        } catch (MavenDownloadingException e) {
                            return e.warn(t);
                        }
                    }
                    if (t != tag) {
                        maybeUpdateModel();
                        doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());
                        if (isNewDependencyPresent) {
                            doAfterVisit(new RemoveContentVisitor<>(t, true, true));
                            maybeUpdateModel();
                        }
                    }
                }
                return t;
            }

            private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable String artifactId, @Nullable String version) {
                if ((groupId == null) || (artifactId == null)) {
                    return false;
                }
                ResolvedManagedDependency managedDependency = findManagedDependency(groupId, artifactId);
                if (managedDependency != null) {
                    return compareVersions(version, managedDependency.getVersion());
                } else {
                    return false;
                }
            }

            private boolean compareVersions(@Nullable String targetVersion, @Nullable String foundVersion) {
                if (targetVersion == null) {
                    return true;
                }
                if ((versionComparator != null) && (foundVersion != null)) {
                    return versionComparator.isValid(targetVersion, foundVersion);
                } else {
                    return targetVersion.equals(foundVersion);
                }
            }

            @SuppressWarnings(""ConstantConditions"")
            private String resolveSemverVersion(ExecutionContext ctx, String groupId, String artifactId, @Nullable String currentVersion) throws MavenDownloadingException {
                if (versionComparator == null) {
                    return newVersion;
                }
                String finalCurrentVersion = currentVersion != null ? currentVersion : newVersion;
                if (availableVersions == null) {
                    availableVersions = new ArrayList<>();
                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));
                    for (String v : mavenMetadata.getVersioning().getVersions()) {
                        if (versionComparator.isValid(finalCurrentVersion, v)) {
                            availableVersions.add(v);
                        }
                    }

                }
                return availableVersions.isEmpty() ? newVersion : max(availableVersions, versionComparator);
            }
        };
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field"",
  ""newGroupId"": ""String field"",
  ""newArtifactId"": ""String field""
}"
Remove redundant explicit dependency and plugin versions,Remove explicitly-specified dependency/plugin versions when a parent POM's `dependencyManagement`/`pluginManagement` ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.ExactVersion;
import org.openrewrite.semver.LatestIntegration;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import java.util.*;

import static java.util.Collections.emptyList;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveRedundantDependencyVersions extends Recipe {
    @Option(displayName = ""Group"",
            description = ""Group glob expression pattern used to match dependencies that should be managed."" +
                          ""Group is the first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.*"",
            required = false)
    @Nullable
    String groupPattern;

    @Option(displayName = ""Artifact"",
            description = ""Artifact glob expression pattern used to match dependencies that should be managed."" +
                          ""Artifact is the second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava*"",
            required = false)
    @Nullable
    String artifactPattern;

    @Option(displayName = ""Only if versions match"",
            description = ""Deprecated; use `onlyIfManagedVersionIs` instead. "" +
                          ""Only remove the explicit version if it exactly matches the managed dependency version. "" +
                          ""When `false` explicit versions will be removed if they are older than or equal to the managed dependency version. "" +
                          ""Default `true`."",
            required = false)
    @Nullable
    @Deprecated
    @SuppressWarnings(""DeprecatedIsStillUsed"")
    Boolean onlyIfVersionsMatch;

    @Option(displayName = ""Only if managed version is ..."",
            description = ""Only remove the explicit version if the managed version has the specified comparative relationship to the explicit version. "" +
                          ""For example, `gte` will only remove the explicit version if the managed version is the same or newer. "" +
                          ""Default `eq`."",
            valid = {""ANY"", ""EQ"", ""LT"", ""LTE"", ""GT"", ""GTE""},
            required = false)
    @Nullable
    Comparator onlyIfManagedVersionIs;

    @Option(displayName = ""Except"",
            description = ""Accepts a list of GAVs. Dependencies matching a GAV will be ignored by this recipe. "" +
                          ""GAV versions are ignored if provided."",
            example = ""com.jcraft:jsch"",
            required = false)
    @Nullable
    List<String> except;

    public RemoveRedundantDependencyVersions(@Nullable String groupPattern, @Nullable String artifactPattern,
                                             @Nullable Comparator onlyIfManagedVersionIs, @Nullable List<String> except) {
        this(groupPattern, artifactPattern, null, onlyIfManagedVersionIs, except);
    }

    @JsonCreator
    private RemoveRedundantDependencyVersions(@Nullable String groupPattern, @Nullable String artifactPattern,
                                             @Nullable Boolean onlyIfVersionsMatch, @Nullable Comparator onlyIfManagedVersionIs,
                                             @Nullable List<String> except) {
        this.groupPattern = groupPattern;
        this.artifactPattern = artifactPattern;
        this.onlyIfVersionsMatch = onlyIfVersionsMatch;
        this.onlyIfManagedVersionIs = onlyIfManagedVersionIs;
        this.except = except;
    }

    public enum Comparator {
        ANY,
        EQ,
        LT,
        LTE,
        GT,
        GTE
    }

    @Override
    public String getDisplayName() {
        return ""Remove redundant explicit dependency and plugin versions"";
    }

    @Override
    public String getDescription() {
        return ""Remove explicitly-specified dependency/plugin versions when a parent POM's `dependencyManagement`/`pluginManagement` "" +
               ""specifies the version."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = Validated.none();
        if (except != null) {
            for (int i = 0; i < except.size(); i++) {
                final String retainVersion = except.get(i);
                validated = validated.and(Validated.test(
                        String.format(""except[%d]"", i),
                        ""did not look like a two-or-three-part GAV"",
                        retainVersion,
                        maybeGav -> {
                            final int gavParts = maybeGav.split("":"").length;
                            return gavParts == 2 || gavParts == 3;
                        }));
            }
        }
        if (onlyIfVersionsMatch != null && onlyIfManagedVersionIs != null) {
            validated = validated.and(Validated.invalid(""onlyIfVersionsMatch"", onlyIfVersionsMatch, ""is deprecated in favor of onlyIfManagedVersionIs, and they cannot be used together""));
        }
        return validated;
    }

    private Comparator determineComparator() {
        if (onlyIfVersionsMatch != null) {
            return onlyIfVersionsMatch ? Comparator.EQ : Comparator.GTE;
        }
        if (onlyIfManagedVersionIs != null) {
            return onlyIfManagedVersionIs;
        }
        return Comparator.EQ;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Comparator comparator = determineComparator();
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document d = super.visitDocument(document, ctx);
                if (d != document) {
                    d = (Xml.Document) new RemoveEmptyDependenciesTags().visitNonNull(d, ctx);
                    d = (Xml.Document) new RemoveEmptyPluginsTags().visitNonNull(d, ctx);
                    if (comparator != Comparator.EQ) {
                        maybeUpdateModel();
                    }
                }
                return d;
            }

            @Override
            public  Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag()) {
                    ResolvedDependency d = findDependency(tag);
                    if (d != null &&
                            matchesGroup(d) &&
                            matchesArtifact(d) &&
                            matchesVersion(d) &&
                            isNotExcepted(d.getGroupId(), d.getArtifactId())) {
                        Xml.Tag version = tag.getChild(""version"").orElse(null);
                        return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));
                    }
                } else if (isManagedDependencyTag()) {
                    ResolvedManagedDependency managed = findManagedDependency(tag);
                    if (managed != null &&
                            matchesGroup(managed) &&
                            matchesArtifact(managed) &&
                            matchesVersion(managed, ctx) &&
                            isNotExcepted(managed.getGroupId(), managed.getArtifactId())) {
                        if (tag.getChild(""exclusions"").isPresent()) {
                            return tag;
                        }
                        return null;
                    }
                } else if (isPluginTag()) {
                    if (isManagedPluginTag()) {
                        Xml.Tag version = tag.getChild(""version"").orElse(null);
                        if (version == null) {
                            // version is not managed here
                            return tag;
                        }
                        Plugin p = findManagedPlugin(tag);
                        if (p != null && matchesGroup(p) && matchesArtifact(p) && matchesManagedVersion(p, ctx)) {
                            Set<String> gavTags = new HashSet<>(Arrays.asList(""groupId"", ""artifactId"", ""version""));
                            if (tag.getChildren().stream().allMatch(t -> gavTags.contains(t.getName()))) {
                                // only the version was specified for this managed plugin, so no need to keep the declaration
                                return null;
                            }
                            // some other element is also declared (executions, configuration, dependenciesâ€¦), so just remove the version
                            return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));
                        }
                    } else {
                        Plugin p = findPlugin(tag);
                        if (p != null && matchesGroup(p) && matchesArtifact(p) && matchesVersion(p)) {
                            Xml.Tag version = tag.getChild(""version"").orElse(null);
                            return tag.withContent(ListUtils.map(tag.getContent(), c -> c == version ? null : c));
                        }
                    }
                }
                return super.visitTag(tag, ctx);
            }

            private boolean matchesGroup(ResolvedManagedDependency d) {
                return StringUtils.isNullOrEmpty(groupPattern) || matchesGlob(d.getGroupId(), groupPattern);
            }

            private boolean matchesGroup(ResolvedDependency d) {
                return StringUtils.isNullOrEmpty(groupPattern) || matchesGlob(d.getGroupId(), groupPattern);
            }

            private boolean matchesGroup(Plugin p) {
                return StringUtils.isNullOrEmpty(groupPattern) || matchesGlob(p.getGroupId(), groupPattern);
            }

            private boolean matchesArtifact(ResolvedManagedDependency d) {
                return StringUtils.isNullOrEmpty(artifactPattern) || matchesGlob(d.getArtifactId(), artifactPattern);
            }

            private boolean matchesArtifact(ResolvedDependency d) {
                return StringUtils.isNullOrEmpty(artifactPattern) || matchesGlob(d.getArtifactId(), artifactPattern);
            }

            private boolean matchesArtifact(Plugin p) {
                return StringUtils.isNullOrEmpty(artifactPattern) || matchesGlob(p.getArtifactId(), artifactPattern);
            }

            /**
             * This compares a managed dependency version to the version which would be used if only the parent's
             * dependency management were in effect. This enables detection of managed dependency versions which
             * could be left to the parent.
             */
            private boolean matchesVersion(ResolvedManagedDependency d, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                if (d.getRequested().getVersion() == null || mrr.getPom().getRequested().getParent() == null) {
                    return false;
                }
                try {
                    GroupArtifactVersion parentGav = mrr.getPom().getRequested().getParent().getGav();
                    MavenPomDownloader mpd = new MavenPomDownloader(mrr.getProjectPoms(), ctx, mrr.getMavenSettings(), mrr.getActiveProfiles());
                    ResolvedPom parentPom = mpd.download(parentGav, null, mrr.getPom(), mrr.getPom().getRepositories())
                            .resolve(emptyList(), mpd, ctx);
                    ResolvedManagedDependency parentManagedVersion = parentPom.getDependencyManagement().stream()
                            .filter(dep -> dep.getGroupId().equals(d.getGroupId()) && dep.getArtifactId().equals(d.getArtifactId()))
                            .findFirst()
                            .orElse(null);
                    if (parentManagedVersion == null) {
                        return false;
                    }
                    String versionAccordingToParent = parentManagedVersion.getVersion();
                    if (versionAccordingToParent == null) {
                        return false;
                    }
                    return matchesComparator(versionAccordingToParent, d.getRequested().getVersion());
                } catch (Exception e) {
                    return false;
                }
            }

            private boolean matchesVersion(ResolvedDependency d) {
                if (d.getRequested().getVersion() == null) {
                    return false;
                }
                String managedVersion = getResolutionResult().getPom().getManagedVersion(d.getGroupId(),
                        d.getArtifactId(), d.getRequested().getType(), d.getRequested().getClassifier());
                return matchesComparator(managedVersion, d.getRequested().getVersion());
            }

            private boolean matchesVersion(Plugin p) {
                if (p.getVersion() == null) {
                    return false;
                }
                String managedVersion = getManagedPluginVersion(getResolutionResult().getPom(), p.getGroupId(), p.getArtifactId());
                return matchesComparator(managedVersion, p.getVersion());
            }


            /**
             * This compares a managed plugin version to the version which would be used if only the parent's
             * plugin management were in effect. This enables detection of managed plugin versions which
             * could be left to the parent.
             */
            private boolean matchesManagedVersion(Plugin p, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                if (p.getVersion() == null || mrr.getPom().getRequested().getParent() == null) {
                    return false;
                }
                try {
                    GroupArtifactVersion parentGav = mrr.getPom().getRequested().getParent().getGav();
                    MavenPomDownloader mpd = new MavenPomDownloader(mrr.getProjectPoms(), ctx, mrr.getMavenSettings(), mrr.getActiveProfiles());
                    ResolvedPom parentPom = mpd.download(parentGav, null, mrr.getPom(), mrr.getPom().getRepositories())
                            .resolve(emptyList(), mpd, ctx);
                    return parentPom.getPluginManagement().stream()
                            .filter(plugin -> plugin.getGroupId().equals(p.getGroupId()) && plugin.getArtifactId().equals(p.getArtifactId()))
                            .findFirst()
                            .map(Plugin::getVersion)
                            .map(versionAccordingToParent -> matchesComparator(parentPom.getValue(versionAccordingToParent), p.getVersion()))
                            .orElse(false);
                } catch (Exception e) {
                    return false;
                }
            }

            private boolean matchesComparator(@Nullable String managedVersion, String requestedVersion) {
                if (managedVersion == null) {
                    return false;
                }
                if (comparator == Comparator.ANY) {
                    return true;
                }
                if (!isExact(managedVersion)) {
                    return false;
                }
                int comparison = new LatestIntegration(null)
                        .compare(null, managedVersion,
                                Objects.requireNonNull(getResolutionResult().getPom().getValue(requestedVersion)));
                if (comparison < 0) {
                    return comparator == Comparator.LT || comparator == Comparator.LTE;
                } else if (comparison > 0) {
                    return comparator == Comparator.GT || comparator == Comparator.GTE;
                } else {
                    return comparator == Comparator.EQ || comparator == Comparator.LTE || comparator == Comparator.GTE;
                }
            }

            private boolean isExact(String managedVersion) {
                Validated<VersionComparator> maybeVersionComparator = Semver.validate(managedVersion, null);
                return maybeVersionComparator.isValid() && maybeVersionComparator.getValue() instanceof ExactVersion;
            }

            private boolean isNotExcepted(String groupId, String artifactId) {
                if (except == null) {
                    return true;
                }
                for (final String gav : except) {
                    String[] split = gav.split("":"");
                    String exceptedGroupId = split[0];
                    String exceptedArtifactId = split[1];
                    if (matchesGlob(groupId, exceptedGroupId) &&
                        matchesGlob(artifactId, exceptedArtifactId)) {
                        return false;
                    }
                }
                return true;
            }
        };
    }

    private static @Nullable String getManagedPluginVersion(ResolvedPom resolvedPom, String groupId, String artifactId) {
        for (Plugin p : ListUtils.concatAll(resolvedPom.getPluginManagement(), resolvedPom.getRequested().getPluginManagement())) {
            if (Objects.equals(p.getGroupId(), groupId) && Objects.equals(p.getArtifactId(), artifactId)) {
                return resolvedPom.getValue(p.getVersion());
            }
        }
        return null;
    }

    private static class RemoveEmptyDependenciesTags extends MavenIsoVisitor<ExecutionContext> {
        @Override
        public  Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag t = super.visitTag(tag, ctx);
            if ((""dependencyManagement"".equals(t.getName()) || ""dependencies"".equals(t.getName())) && (t.getContent() == null || t.getContent().isEmpty())) {
                return null;
            }
            return t;
        }
    }

    private static class RemoveEmptyPluginsTags extends MavenIsoVisitor<ExecutionContext> {
        @Override
        public  Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag t = super.visitTag(tag, ctx);
            if ((""pluginManagement"".equals(t.getName()) || ""plugins"".equals(t.getName())) && (t.getContent() == null || t.getContent().isEmpty())) {
                return null;
            }
            return t;
        }
    }
}
",{}
Add Maven profile,Add a maven profile to a `pom.xml` file.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddProfile extends Recipe {

    @Option(displayName = ""id"",
            description = ""The profile id."",
            example = ""default"")
    String id;

    @Option(displayName = ""Activation"",
            description = ""activation details of a maven profile, provided as raw XML."",
            example = ""<activation><foo>foo</foo></activation>"",
            required = false)
    @Nullable
    String activation;

    @Option(displayName = ""Properties"",
            description = ""properties of a maven profile, provided as raw XML."",
            example = ""<properties><foo>foo</foo><bar>bar</bar></properties>"",
            required = false)
    @Nullable
    String properties;

    @Option(displayName = ""build"",
            description = ""build details of a maven profile, provided as raw XML."",
            example = ""<build><foo>foo</foo></build>"",
            required = false)
    @Nullable
    String build;

    @Override
    public String getDisplayName() {
        return ""Add Maven profile"";
    }

    @Override
    public String getDescription() {
        return ""Add a maven profile to a `pom.xml` file."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AddProfile.AddProfileVisitor();
    }

    private class AddProfileVisitor extends MavenIsoVisitor<ExecutionContext> {

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag t = super.visitTag(tag, ctx);

            if (isProjectTag()) {
                Optional<Xml.Tag> maybeProfiles = t.getChild(""profiles"");
                Xml.Tag profiles;
                if (maybeProfiles.isPresent()) {
                    profiles = maybeProfiles.get();
                } else {
                    t = (Xml.Tag) new AddToTagVisitor<>(t, Xml.Tag.build(""<profiles/>"")).visitNonNull(t, ctx, getCursor().getParentOrThrow());
                    //noinspection OptionalGetWithoutIsPresent
                    profiles = t.getChild(""profiles"").get();
                }

                Optional<Xml.Tag> maybeProfile = profiles.getChildren().stream()
                        .filter(profile ->
                                profile.getChildValue(""id"").get().equals(id)
                        )
                        .findAny();

                if (maybeProfile.isPresent()) {
                    Xml.Tag profile = maybeProfile.get();

                    t = (Xml.Tag) new RemoveContentVisitor(profile, false, false).visitNonNull(t, ctx, getCursor().getParentOrThrow());

                }
                Xml.Tag profileTag = Xml.Tag.build(""<profile>\n"" +
                                                   ""<id>"" + id + ""</id>\n"" +
                                                   (activation != null ? activation.trim() + ""\n"" : """") +
                                                   (properties != null ? properties.trim() + ""\n"" : """") +
                                                   (build != null ? build.trim() + ""\n"" : """") +
                                                   ""</profile>"");
                t = (Xml.Tag) new AddToTagVisitor<>(profiles, profileTag).visitNonNull(t, ctx, getCursor().getParentOrThrow());

            }

            return t;
        }
    }
}
","{
  ""id"": ""String field""
}"
Remove Maven managed dependency,Removes a single managed dependency from the <dependencyManagement><dependencies> section of the pom.xml.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveManagedDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a managed dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a managed dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Scope"",
            description = ""Only remove managed dependencies if they are in this scope. If `runtime`, this will "" +
                          ""also remove managed dependencies in the 'compile' scope because `compile` dependencies are part of the runtime dependency set."",
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"",
            required = false)
    @Nullable
    String scope;

    @Override
    public String getDisplayName() {
        return ""Remove Maven managed dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Removes a single managed dependency from the <dependencyManagement><dependencies> section of the pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveManagedDependencyVisitor();
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""scope"", ""Scope must be one of compile, runtime, test, or provided"",
                scope, s -> Scope.Invalid != Scope.fromName(s)));
    }

    private class RemoveManagedDependencyVisitor extends MavenIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isManagedDependencyTag(groupId, artifactId)) {
                Scope checkScope = scope != null ? Scope.fromName(scope) : null;
                boolean isBomImport = tag.getChildValue(""scope"").map(""import""::equalsIgnoreCase).orElse(false);
                if (isBomImport || findManagedDependency(tag, checkScope) != null) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                    maybeUpdateModel();
                }
            }

            return super.visitTag(tag, ctx);
        }
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Maven dependency scope,Add or alter the scope of the specified dependency.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyScope extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    /**
     * If null, strips the scope from an existing dependency.
     */
    @Option(displayName = ""New scope"",
            description = ""Scope to apply to specified Maven dependency. "" +
                    ""May be omitted, which indicates that no scope should be added and any existing scope be removed from the dependency."",
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"",
            required = false)
    @Nullable
    String newScope;

    @Override
    public String getDisplayName() {
        return ""Change Maven dependency scope"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s` to `%s`"", groupId, artifactId, newScope);
    }

    @Override
    public String getDescription() {
        return ""Add or alter the scope of the specified dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag()) {
                    if (groupId.equals(tag.getChildValue(""groupId"").orElse(getResolutionResult().getPom().getGroupId())) &&
                            artifactId.equals(tag.getChildValue(""artifactId"").orElse(null))) {
                        Optional<Xml.Tag> scope = tag.getChild(""scope"");
                        if (scope.isPresent()) {
                            if (newScope == null) {
                                doAfterVisit(new RemoveContentVisitor<>(scope.get(), false, true));
                            } else if (!newScope.equals(scope.get().getValue().orElse(null))) {
                                doAfterVisit(new ChangeTagValueVisitor<>(scope.get(), newScope));
                            }
                        } else if (newScope != null) {
                            doAfterVisit(new AddToTagVisitor<>(tag, Xml.Tag.build(""<scope>"" + newScope + ""</scope>"")));
                        }
                    }
                }

                return super.visitTag(tag, ctx);
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Update Maven wrapper,Update the version of Maven used in an existing Maven wrapper.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.*;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.BuildTool;
import org.openrewrite.marker.Markers;
import org.openrewrite.maven.utilities.MavenWrapper;
import org.openrewrite.properties.PropertiesIsoVisitor;
import org.openrewrite.properties.PropertiesParser;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.text.PlainText;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.PathUtils.equalIgnoringSeparators;
import static org.openrewrite.internal.StringUtils.isBlank;
import static org.openrewrite.maven.utilities.MavenWrapper.*;

/**
 * This recipe expects for the specified repository to be a Maven layout with `maven-metadata.xml` files containing all
 * the following REQUIRED publications:
 * <br/>
 * org.apache.maven.wrapper:maven-wrapper:{wrapperVersion}
 * org.apache.maven.wrapper:maven-wrapper-distribution:{wrapperVersion}
 * org.apache.maven:apache-maven:{distributionVersion}
 */
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@EqualsAndHashCode(callSuper = false)
public class UpdateMavenWrapper extends ScanningRecipe<UpdateMavenWrapper.MavenWrapperState> {
    private static final String DISTRIBUTION_URL_KEY = ""distributionUrl"";
    private static final String DISTRIBUTION_SHA_256_SUM_KEY = ""distributionSha256Sum"";
    private static final String WRAPPER_URL_KEY = ""wrapperUrl"";
    private static final String WRAPPER_SHA_256_SUM_KEY = ""wrapperSha256Sum"";

    @Getter
    @Option(displayName = ""New wrapper version"",
            description = ""An exact version number or node-style semver selector used to select the wrapper version number."",
            example = ""3.x"",
            required = false)
    @Nullable
    final String wrapperVersion;

    @Getter
    @Option(displayName = ""Wrapper Distribution type"",
            description = ""The distribution of the Maven wrapper to use.\n\n"" +
                          ""* \""bin\"" uses a `maven-wrapper.jar` compiled binary.\n"" +
                          ""* \""only-script\"" uses a lite version of `mvnw`/`mvnw.cmd` using wget/curl or powershell. (required wrapper 3.2.0 or newer)\n"" +
                          ""* \""script\"" downloads `maven-wrapper.jar` or `MavenWrapperDownloader.java` to then download a full distribution.\n"" +
                          ""* \""source\"" uses `MavenWrapperDownloader.java` source file.\n\n"" +
                          ""Defaults to \""bin\""."",
            valid = {""bin"", ""only-script"", ""script"", ""source""},
            required = false)
    @Nullable
    final String wrapperDistribution;

    @Getter
    @Option(displayName = ""New distribution version"",
            description = ""An exact version number or node-style semver selector used to select the Maven version number."",
            example = ""3.x"",
            required = false)
    @Nullable
    final String distributionVersion;

    @Getter
    @Option(displayName = ""Repository URL"",
            description = ""The URL of the repository to download the Maven wrapper and distribution from. Supports repositories "" +
                          ""with a Maven layout. Defaults to `https://repo.maven.apache.org/maven2`."",
            example = ""https://repo.maven.apache.org/maven2"",
            required = false)
    @Nullable
    final String repositoryUrl;

    @Getter
    @Option(displayName = ""Add if missing"",
            description = ""Add a Maven wrapper, if it's missing. Defaults to `true`."",
            required = false)
    @Nullable
    final Boolean addIfMissing;

    @Getter
    @Option(displayName = ""Enforce checksum verification for maven-wrapper.jar"",
            description = ""Enforce checksum verification for the maven-wrapper.jar. Enabling this feature may sporadically "" +
                          ""result in build failures, such as [MWRAPPER-103](https://issues.apache.org/jira/browse/MWRAPPER-103). Defaults to `false`."",
            required = false)
    @Nullable
    final Boolean enforceWrapperChecksumVerification;

    @Override
    public String getDisplayName() {
        return ""Update Maven wrapper"";
    }

    @Override
    public String getDescription() {
        return ""Update the version of Maven used in an existing Maven wrapper."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (wrapperVersion != null) {
            validated = validated.and(Semver.validate(wrapperVersion, null));
        }
        if (distributionVersion != null) {
            validated = validated.and(Semver.validate(distributionVersion, null));
        }
        return validated;
    }

    @NonFinal
    @Nullable
    transient MavenWrapper mavenWrapper;

    private MavenWrapper getMavenWrapper(ExecutionContext ctx) {
        if (mavenWrapper == null) {
            mavenWrapper = MavenWrapper.create(wrapperVersion, wrapperDistribution, distributionVersion, repositoryUrl, ctx);
        }
        return mavenWrapper;
    }

    static class MavenWrapperState {
        boolean needsWrapperUpdate = false;

        @Nullable BuildTool updatedMarker;

        boolean addMavenWrapperProperties = true;
        boolean addMavenWrapperDownloader = true;
        boolean addMavenWrapperJar = true;
        boolean addMavenShellScript = true;
        boolean addMavenBatchScript = true;
    }

    @Override
    public MavenWrapperState getInitialValue(ExecutionContext ctx) {
        return new MavenWrapperState();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(MavenWrapperState acc) {
        return Preconditions.or(
                new PropertiesVisitor<ExecutionContext>() {
                    @Override
                    public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                        if (!super.isAcceptable(sourceFile, ctx)) {
                            return false;
                        }

                        if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_PROPERTIES_LOCATION)) {
                            acc.addMavenWrapperProperties = false;
                        } else if (!PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_PROPERTIES_LOCATION_RELATIVE_PATH)) {
                            return false;
                        }

                        Optional<BuildTool> maybeBuildTool = sourceFile.getMarkers().findFirst(BuildTool.class);
                        if (!maybeBuildTool.isPresent()) {
                            return false;
                        }
                        BuildTool buildTool = maybeBuildTool.get();
                        if (buildTool.getType() != BuildTool.Type.Maven) {
                            return false;
                        }

                        MavenWrapper mavenWrapper = getMavenWrapper(ctx);

                        VersionComparator versionComparator = requireNonNull(Semver.validate(isBlank(distributionVersion) ? ""latest.release"" : distributionVersion, null).getValue());
                        int compare = versionComparator.compare(null, buildTool.getVersion(), mavenWrapper.getDistributionVersion());
                        // maybe we want to update the distribution url
                        if (compare < 0) {
                            acc.needsWrapperUpdate = true;
                            acc.updatedMarker = buildTool.withVersion(mavenWrapper.getDistributionVersion());
                            return true;
                        } else {
                            return compare == 0;
                        }
                    }

                    @Override
                    public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                        Properties p = super.visitFile(file, ctx);
                        if (FindProperties.find(p, DISTRIBUTION_SHA_256_SUM_KEY, null).isEmpty() ||
                            (FindProperties.find(p, WRAPPER_SHA_256_SUM_KEY, null).isEmpty() && Boolean.TRUE.equals(enforceWrapperChecksumVerification))) {
                            acc.needsWrapperUpdate = true;
                        }
                        return p;
                    }

                    @Override
                    public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                        MavenWrapper mavenWrapper = getMavenWrapper(ctx);
                        if (""distributionUrl"".equals(entry.getKey())) {
                            // Typical example: https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.8.0/apache-maven-3.8.0-bin.zip
                            String currentDistributionUrl = entry.getValue().getText();
                            if (!mavenWrapper.getDistributionUrl().equals(currentDistributionUrl)) {
                                acc.needsWrapperUpdate = true;
                            }
                        } else if (""wrapperUrl"".equals(entry.getKey())) {
                            // Typical example: https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar
                            String currentWrapperUrl = entry.getValue().getText();
                            if (!mavenWrapper.getWrapperUrl().equals(currentWrapperUrl)) {
                                acc.needsWrapperUpdate = true;
                            }
                        }
                        return entry;
                    }
                },
                new TreeVisitor<Tree, ExecutionContext>() {
                    @Override
                    public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                        if (!super.isAcceptable(sourceFile, ctx)) {
                            return false;
                        }

                        MavenWrapper mavenWrapper = getMavenWrapper(ctx);

                        if (sourceFile instanceof Quark || sourceFile instanceof Remote) {
                            if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_JAR_LOCATION)) {
                                acc.addMavenWrapperJar = false;
                                if (mavenWrapper.getWrapperDistributionType() != DistributionType.Bin) {
                                    acc.needsWrapperUpdate = true;
                                }
                                return true;
                            } else if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_DOWNLOADER_LOCATION)) {
                                acc.addMavenWrapperDownloader = false;
                                if (mavenWrapper.getWrapperDistributionType() != DistributionType.Source) {
                                    acc.needsWrapperUpdate = true;
                                }
                                return true;
                            }
                        }

                        if (sourceFile instanceof PlainText) {
                            if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_BATCH_LOCATION)) {
                                acc.addMavenBatchScript = false;
                                return true;
                            } else if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_SCRIPT_LOCATION)) {
                                acc.addMavenShellScript = false;
                                return true;
                            }
                        }

                        return false;
                    }
                }
        );
    }

    @Override
    public Collection<SourceFile> generate(MavenWrapperState acc, ExecutionContext ctx) {
        if (Boolean.FALSE.equals(addIfMissing)) {
            return emptyList();
        }

        MavenWrapper mavenWrapper = getMavenWrapper(ctx);
        if (mavenWrapper.getWrapperDistributionType() == DistributionType.Bin) {
            if (!(acc.addMavenWrapperJar || acc.addMavenWrapperProperties || acc.addMavenBatchScript || acc.addMavenShellScript)) {
                return emptyList();
            }
        } else if (mavenWrapper.getWrapperDistributionType() == DistributionType.OnlyScript) {
            if (!(acc.addMavenWrapperProperties || acc.addMavenBatchScript || acc.addMavenShellScript)) {
                return emptyList();
            }
        } else {
            if (!(acc.addMavenWrapperDownloader || acc.addMavenWrapperProperties || acc.addMavenBatchScript || acc.addMavenShellScript)) {
                return emptyList();
            }
        }

        List<SourceFile> mavenWrapperFiles = new ArrayList<>();
        ZonedDateTime now = ZonedDateTime.now();

        if (acc.addMavenWrapperProperties) {
            @Language(""properties"")
            String mavenWrapperPropertiesText = ASF_LICENSE_HEADER +
                                                DISTRIBUTION_URL_KEY + ""="" + mavenWrapper.getDistributionUrl() + ""\n"" +
                                                DISTRIBUTION_SHA_256_SUM_KEY + ""="" + mavenWrapper.getDistributionChecksum().getHexValue();
            if (mavenWrapper.getWrapperDistributionType() != DistributionType.OnlyScript) {
                mavenWrapperPropertiesText += ""\n"" +
                                              WRAPPER_URL_KEY + ""="" + mavenWrapper.getWrapperUrl();
                if (Boolean.TRUE.equals(enforceWrapperChecksumVerification)) {
                    mavenWrapperPropertiesText += ""\n"" +
                            WRAPPER_SHA_256_SUM_KEY + ""="" + mavenWrapper.getWrapperChecksum().getHexValue();
                }
            }
            //noinspection UnusedProperty
            Properties.File mavenWrapperProperties = new PropertiesParser().parse(mavenWrapperPropertiesText)
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException(""Could not parse as properties""))
                    .withSourcePath(WRAPPER_PROPERTIES_LOCATION);
            mavenWrapperFiles.add(mavenWrapperProperties);
        }

        FileAttributes wrapperScriptAttributes = new FileAttributes(now, now, now, true, true, true, 1L);
        if (acc.addMavenShellScript) {
            String mvnwText = unixScript(mavenWrapper, ctx);
            PlainText mvnw = PlainText.builder()
                    .text(mvnwText)
                    .sourcePath(WRAPPER_SCRIPT_LOCATION)
                    .fileAttributes(wrapperScriptAttributes)
                    .build();
            mavenWrapperFiles.add(mvnw);
        }

        if (acc.addMavenBatchScript) {
            String mvnwCmdText = batchScript(mavenWrapper, ctx);
            PlainText mvnwCmd = PlainText.builder()
                    .text(mvnwCmdText)
                    .sourcePath(WRAPPER_BATCH_LOCATION)
                    .fileAttributes(wrapperScriptAttributes)
                    .build();
            mavenWrapperFiles.add(mvnwCmd);
        }

        if (mavenWrapper.getWrapperDistributionType() == DistributionType.Bin && acc.addMavenWrapperJar) {
            mavenWrapperFiles.add(mavenWrapper.wrapperJar());
        } else if (mavenWrapper.getWrapperDistributionType() == DistributionType.Source && acc.addMavenWrapperDownloader) {
            mavenWrapperFiles.add(mavenWrapper.wrapperDownloader());
        }

        return mavenWrapperFiles;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(MavenWrapperState acc) {
        if (!acc.needsWrapperUpdate) {
            return TreeVisitor.noop();
        }

        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }

                SourceFile sourceFile = (SourceFile) tree;
                if (acc.updatedMarker != null) {
                    Optional<BuildTool> maybeCurrentMarker = sourceFile.getMarkers().findFirst(BuildTool.class);
                    if (maybeCurrentMarker.isPresent()) {
                        BuildTool currentMarker = maybeCurrentMarker.get();
                        if (currentMarker.getType() != BuildTool.Type.Maven) {
                            return sourceFile;
                        }
                        VersionComparator versionComparator = requireNonNull(Semver.validate(isBlank(distributionVersion) ? ""latest.release"" : distributionVersion, null).getValue());
                        int compare = versionComparator.compare(null, currentMarker.getVersion(), acc.updatedMarker.getVersion());
                        if (compare < 0) {
                            sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(acc.updatedMarker));
                        } else {
                            return sourceFile;
                        }
                    }
                }

                MavenWrapper mavenWrapper = getMavenWrapper(ctx);

                if (sourceFile instanceof PlainText && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_SCRIPT_LOCATION_RELATIVE_PATH)) {
                    String mvnwText = unixScript(mavenWrapper, ctx);
                    PlainText mvnw = (PlainText) setExecutable(sourceFile);
                    if (!mvnwText.equals(mvnw.getText())) {
                        mvnw = mvnw.withText(mvnwText);
                    }
                    return mvnw;
                }
                if (sourceFile instanceof PlainText && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_BATCH_LOCATION_RELATIVE_PATH)) {
                    String mvnwCmdText = batchScript(mavenWrapper, ctx);
                    PlainText mvnwCmd = (PlainText) setExecutable(sourceFile);
                    if (!mvnwCmdText.equals(mvnwCmd.getText())) {
                        mvnwCmd = mvnwCmd.withText(mvnwCmdText);
                    }
                    return mvnwCmd;
                }

                if (sourceFile instanceof Properties.File && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_PROPERTIES_LOCATION_RELATIVE_PATH)) {
                    return new WrapperPropertiesVisitor(mavenWrapper).visitNonNull(sourceFile, ctx);
                }
                if (mavenWrapper.getWrapperDistributionType() == DistributionType.Bin) {
                    if ((sourceFile instanceof Quark || sourceFile instanceof Remote) && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_JAR_LOCATION_RELATIVE_PATH)) {
                        return mavenWrapper.wrapperJar(sourceFile);
                    }

                    if (PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_DOWNLOADER_LOCATION_RELATIVE_PATH)) {
                        return null;
                    }
                } else if (mavenWrapper.getWrapperDistributionType() == DistributionType.Source) {
                    if ((sourceFile instanceof Quark || sourceFile instanceof Remote) && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_DOWNLOADER_LOCATION_RELATIVE_PATH)) {
                        return mavenWrapper.wrapperDownloader(sourceFile);
                    }

                    if (PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_JAR_LOCATION_RELATIVE_PATH)) {
                        return null;
                    }
                } else if (PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_JAR_LOCATION_RELATIVE_PATH) ||
                           PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_DOWNLOADER_LOCATION_RELATIVE_PATH)) {
                    return null;
                }
                return sourceFile;
            }
        };
    }

    private static <T extends SourceFile> T setExecutable(T sourceFile) {
        FileAttributes attributes = sourceFile.getFileAttributes();
        if (attributes == null) {
            ZonedDateTime now = ZonedDateTime.now();
            return sourceFile.withFileAttributes(new FileAttributes(now, now, now, true, true, true, 1L));
        } else if (!attributes.isExecutable()) {
            return sourceFile.withFileAttributes(attributes.withExecutable(true));
        }
        return sourceFile;
    }

    private String unixScript(MavenWrapper mavenWrapper, ExecutionContext ctx) {
        return StringUtils.readFully(mavenWrapper.mvnw().getInputStream(ctx));
    }

    private String batchScript(MavenWrapper mavenWrapper, ExecutionContext ctx) {
        return StringUtils.readFully(mavenWrapper.mvnwCmd().getInputStream(ctx));
    }

    @AllArgsConstructor
    private class WrapperPropertiesVisitor extends PropertiesIsoVisitor<ExecutionContext> {
        MavenWrapper mavenWrapper;

        @Override
        public Properties.File visitFile(Properties.File file, ExecutionContext ctx) {
            Properties.File p = super.visitFile(file, ctx);
            Checksum mavenDistributionChecksum = mavenWrapper.getDistributionChecksum();
            if (FindProperties.find(p, DISTRIBUTION_SHA_256_SUM_KEY, null).isEmpty() && mavenDistributionChecksum != null) {
                Properties.Value propertyValue = new Properties.Value(Tree.randomId(), """", Markers.EMPTY, mavenDistributionChecksum.getHexValue());
                Properties.Entry entry = new Properties.Entry(Tree.randomId(), ""\n"", Markers.EMPTY, DISTRIBUTION_SHA_256_SUM_KEY, """", Properties.Entry.Delimiter.EQUALS, propertyValue);
                p = p.withContent(ListUtils.concat(p.getContent(), entry));
            }
            if (mavenWrapper.getWrapperDistributionType() != DistributionType.OnlyScript && Boolean.TRUE.equals(enforceWrapperChecksumVerification)) {
                Checksum wrapperJarChecksum = mavenWrapper.getWrapperChecksum();
                if (FindProperties.find(p, WRAPPER_SHA_256_SUM_KEY, null).isEmpty() && wrapperJarChecksum != null) {
                    Properties.Value propertyValue = new Properties.Value(Tree.randomId(), """", Markers.EMPTY, wrapperJarChecksum.getHexValue());
                    Properties.Entry entry = new Properties.Entry(Tree.randomId(), ""\n"", Markers.EMPTY, WRAPPER_SHA_256_SUM_KEY, """", Properties.Entry.Delimiter.EQUALS, propertyValue);
                    p = p.withContent(ListUtils.concat(p.getContent(), entry));
                }
            }
            return p;
        }

        @Override
        public  Properties.@Nullable Entry visitEntry(Properties.Entry entry, ExecutionContext ctx) {
            if (DISTRIBUTION_URL_KEY.equals(entry.getKey())) {
                Properties.Value value = entry.getValue();
                if (!mavenWrapper.getDistributionUrl().equals(value.getText())) {
                    return entry.withValue(value.withText(mavenWrapper.getDistributionUrl()));
                }
            } else if (DISTRIBUTION_SHA_256_SUM_KEY.equals(entry.getKey())) {
                Properties.Value value = entry.getValue();
                Checksum mavenDistributionChecksum = mavenWrapper.getDistributionChecksum();
                if (mavenDistributionChecksum != null && !mavenDistributionChecksum.getHexValue().equals(value.getText())) {
                    return entry.withValue(value.withText(mavenDistributionChecksum.getHexValue()));
                }
            } else if (WRAPPER_URL_KEY.equals(entry.getKey())) {
                if (mavenWrapper.getWrapperDistributionType() != DistributionType.OnlyScript) {
                    Properties.Value value = entry.getValue();
                    if (!mavenWrapper.getWrapperUrl().equals(value.getText())) {
                        return entry.withValue(value.withText(mavenWrapper.getWrapperUrl()));
                    }
                } else {
                    //noinspection ConstantConditions
                    return null;
                }
            } else if (WRAPPER_SHA_256_SUM_KEY.equals(entry.getKey())) {
                if (mavenWrapper.getWrapperDistributionType() != DistributionType.OnlyScript &&
                        Boolean.TRUE.equals(enforceWrapperChecksumVerification)) {
                    Properties.Value value = entry.getValue();
                    Checksum wrapperJarChecksum = mavenWrapper.getWrapperChecksum();
                    if (wrapperJarChecksum != null && !wrapperJarChecksum.getHexValue().equals(value.getText())) {
                        return entry.withValue(value.withText(wrapperJarChecksum.getHexValue()));
                    }
                } else {
                    //noinspection ConstantConditions
                    return null;
                }
            }
            return entry;
        }
    }
}
",{}
Upgrade transitive Maven dependencies,Upgrades the version of a transitive dependency in a Maven pom file. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.semver.Semver;
import org.openrewrite.xml.tree.Xml;

import java.util.LinkedHashSet;
import java.util.Set;

import static java.util.stream.Collectors.toCollection;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradeTransitiveDependencyVersion extends ScanningRecipe<AddManagedDependency.Scanned> {

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Override
    public String getDisplayName() {
        return ""Upgrade transitive Maven dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Upgrades the version of a transitive dependency in a Maven pom file. "" +
               ""Leaves direct dependencies unmodified. "" +
               ""Can be paired with the regular Upgrade Dependency Version recipe to upgrade a dependency everywhere, "" +
               ""regardless of whether it is direct or transitive."";
    }

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.apache.logging.log4j:ARTIFACT_ID:VERSION'."",
            example = ""org.apache.logging.log4j"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.apache.logging.log4j:log4j-bom:VERSION'."",
            example = ""log4j-bom"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""latest.release"")
    String version;

    @Option(displayName = ""Scope"",
            description = ""An optional scope to use for the dependency management tag."",
            example = ""import"",
            valid = {""import"", ""runtime"", ""provided"", ""test""},
            required = false)
    @Nullable
    String scope;

    @Option(displayName = ""Type"",
            description = ""An optional type to use for the dependency management tag."",
            valid = {""jar"", ""pom"", ""war""},
            example = ""pom"",
            required = false)
    @Nullable
    String type;

    @Option(displayName = ""Classifier"",
            description = ""An optional classifier to use for the dependency management tag"",
            example = ""test"",
            required = false)
    @Nullable
    String classifier;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Releases only"",
            description = ""Whether to exclude snapshots from consideration when using a semver selector"",
            required = false)
    @Nullable
    Boolean releasesOnly;

    @Option(displayName = ""Only if using glob expression for group:artifact"",
            description = ""Only add managed dependencies to projects having a dependency matching the expression."",
            example = ""org.apache.logging.log4j:log4j*"",
            required = false)
    @Nullable
    String onlyIfUsing;

    @Option(displayName = ""Add to the root pom"",
            description = ""Add to the root pom where root is the eldest parent of the pom within the source set."",
            required = false)
    @Nullable
    Boolean addToRootPom;

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Semver.validate(version, versionPattern));
    }

    @Override
    public AddManagedDependency.Scanned getInitialValue(ExecutionContext ctx) {
        return addManagedDependency().getInitialValue(ctx);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AddManagedDependency.Scanned acc) {
        return addManagedDependency().getScanner(acc);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AddManagedDependency.Scanned acc) {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Set<ResolvedDependency> matchingDependencies = getResolutionResult().findDependencies(groupId, artifactId, null)
                        .stream()
                        .filter(ResolvedDependency::isTransitive)
                        .collect(toCollection(LinkedHashSet::new));
                if (matchingDependencies.isEmpty()) {
                    return document;
                }
                Xml.Document d = document;
                for (ResolvedDependency matchingDependency : matchingDependencies) {
                    d = (Xml.Document) addManagedDependency(matchingDependency.getGroupId(), matchingDependency.getArtifactId())
                            .getVisitor(acc)
                            .visitNonNull(d, ctx);
                }
                return d;
            }
        };
    }

    private AddManagedDependency addManagedDependency() {
        return addManagedDependency(groupId, artifactId);
    }

    private AddManagedDependency addManagedDependency(String groupId, String artifactId) {
        return new AddManagedDependency(groupId, artifactId, version, scope, type, classifier, versionPattern, releasesOnly, onlyIfUsing, addToRootPom);
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""version"": ""String field""
}"
Change Maven dependency classifier,Add or alter the classifier of the specified dependency.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyClassifier extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""guava"")
    String artifactId;

    /**
     * If null, strips the scope from an existing dependency.
     */
    @Option(displayName = ""New classifier"",
            description = ""Classifier to apply to specified Maven dependency. "" +
                          ""May be omitted, which indicates that no classifier should be added and any existing scope be removed from the dependency."",
            example = ""jar"",
            required = false)
    @Nullable
    String newClassifier;

    @Option(displayName = ""Change Maven managed dependency"",
            description = ""This flag can be set to explicitly change the classifier in Maven management dependency section. Default `false`."",
            example = ""true"",
            required = false)
    @Nullable
    Boolean changeManagedDependency;

    @Override
    public String getDisplayName() {
        return ""Change Maven dependency classifier"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s` to `%s`"", groupId, artifactId, newClassifier);
    }

    @Override
    public String getDescription() {
        return ""Add or alter the classifier of the specified dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag(groupId, artifactId) ||
                        (Boolean.TRUE.equals(changeManagedDependency) && isManagedDependencyTag(groupId, artifactId))) {
                    Optional<Xml.Tag> classifier = tag.getChild(""classifier"");
                    if (classifier.isPresent()) {
                        if (newClassifier == null) {
                            doAfterVisit(new RemoveContentVisitor<>(classifier.get(), false, true));
                        } else if (!newClassifier.equals(classifier.get().getValue().orElse(null))) {
                            doAfterVisit(new ChangeTagValueVisitor<>(classifier.get(), newClassifier));
                        }
                    } else if (newClassifier != null) {
                        doAfterVisit(new AddToTagVisitor<>(tag, Xml.Tag.build(""<classifier>"" + newClassifier + ""</classifier>"")));
                    }
                }
                return super.visitTag(tag, ctx);
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Maven parent,"Change the parent pom of a Maven pom.xml by matching the existing parent via groupId and artifactId, ",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.InlineMe;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.AddOrUpdateChild;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.*;
import static org.openrewrite.internal.StringUtils.matchesGlob;
import static org.openrewrite.maven.RemoveRedundantDependencyVersions.Comparator.GTE;
import static org.openrewrite.maven.tree.Parent.DEFAULT_RELATIVE_PATH;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeParentPom extends Recipe {
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old group ID"",
            description = ""The group ID of the Maven parent pom to be changed away from."",
            example = ""org.springframework.boot"")
    String oldGroupId;

    @Option(displayName = ""New group ID"",
            description = ""The group ID of the new maven parent pom to be adopted. If this argument is omitted it defaults to the value of `oldGroupId`."",
            example = ""org.springframework.boot"",
            required = false)
    @Nullable
    String newGroupId;

    @Option(displayName = ""Old artifact ID"",
            description = ""The artifact ID of the maven parent pom to be changed away from."",
            example = ""spring-boot-starter-parent"")
    String oldArtifactId;

    @Option(displayName = ""New artifact ID"",
            description = ""The artifact ID of the new maven parent pom to be adopted. If this argument is omitted it defaults to the value of `oldArtifactId`."",
            example = ""spring-boot-starter-parent"",
            required = false)
    @Nullable
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""29.X"")
    String newVersion;

    @Option(displayName = ""Old relative path"",
            description = ""The relativePath of the maven parent pom to be changed away from. "" +
                          ""Use an empty String to match `<relativePath />`, use `../pom.xml` to match the default value."",
            example = ""../../pom.xml"",
            required = false)
    @Nullable
    String oldRelativePath;

    @Option(displayName = ""New relative path"",
            description = ""New relative path attribute for parent lookup."",
            example = ""../pom.xml"",
            required = false)
    @Nullable
    String newRelativePath;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Allow version downgrades"",
            description = ""If the new parent has the same group/artifact, this flag can be used to only upgrade the "" +
                          ""version if the target version is newer than the current."",
            required = false)
    @Nullable
    Boolean allowVersionDowngrades;

    @Option(displayName = ""Except"",
            description = ""Accepts a list of GAVs that should be retained when calling `RemoveRedundantDependencyVersions`."",
            example = ""com.jcraft:jsch"",
            required = false)
    @Nullable
    List<String> except;

    @Override
    public String getDisplayName() {
        return ""Change Maven parent"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", newGroupId, newArtifactId, newVersion);
    }

    @Override
    public String getDescription() {
        return ""Change the parent pom of a Maven pom.xml by matching the existing parent via groupId and artifactId, "" +
                ""and updating it to a new groupId, artifactId, version, and optional relativePath. "" +
                ""Also updates the project to retain dependency management and properties previously inherited from the old parent that are no longer provided by the new parent. "" +
                ""Removes redundant dependency versions already managed by the new parent."";
    }

    @Deprecated
    @InlineMe(replacement = ""this(oldGroupId, newGroupId, oldArtifactId, newArtifactId, newVersion, oldRelativePath, newRelativePath, versionPattern, allowVersionDowngrades, null)"")
    public ChangeParentPom(String oldGroupId,
                           @Nullable String newGroupId,
                           String oldArtifactId,
                           @Nullable String newArtifactId,
                           String newVersion,
                           @Nullable String oldRelativePath,
                           @Nullable String newRelativePath,
                           @Nullable String versionPattern,
                           @Nullable Boolean allowVersionDowngrades) {
        this(oldGroupId, newGroupId, oldArtifactId, newArtifactId, newVersion, oldRelativePath, newRelativePath, versionPattern, allowVersionDowngrades, null);
    }

    @JsonCreator
    public ChangeParentPom(String oldGroupId,
                           @Nullable String newGroupId,
                           String oldArtifactId,
                           @Nullable String newArtifactId,
                           String newVersion,
                           @Nullable String oldRelativePath,
                           @Nullable String newRelativePath,
                           @Nullable String versionPattern,
                           @Nullable Boolean allowVersionDowngrades,
                           @Nullable List<String> except) {
        this.oldGroupId = oldGroupId;
        this.newGroupId = newGroupId;
        this.oldArtifactId = oldArtifactId;
        this.newArtifactId = newArtifactId;
        this.newVersion = newVersion;
        this.oldRelativePath = oldRelativePath;
        this.newRelativePath = newRelativePath;
        this.versionPattern = versionPattern;
        this.allowVersionDowngrades = allowVersionDowngrades;
        this.except = except;
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        //noinspection ConstantConditions
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        VersionComparator versionComparator = Semver.validate(newVersion, versionPattern).getValue();
        assert versionComparator != null;

        return Preconditions.check(new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Parent parent = getResolutionResult().getPom().getRequested().getParent();
                if (parent != null &&
                    matchesGlob(parent.getArtifactId(), oldArtifactId) &&
                    matchesGlob(parent.getGroupId(), oldGroupId)) {
                    return SearchResult.found(document);
                }
                return document;
            }
        }, new MavenIsoVisitor<ExecutionContext>() {
            @Nullable
            private Collection<String> availableVersions;

            @SuppressWarnings(""OptionalGetWithoutIsPresent"")
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (isParentTag()) {
                    MavenResolutionResult mrr = getResolutionResult();
                    ResolvedPom resolvedPom = mrr.getPom();

                    if (matchesGlob(resolvedPom.getValue(tag.getChildValue(""groupId"").orElse(null)), oldGroupId) &&
                        matchesGlob(resolvedPom.getValue(tag.getChildValue(""artifactId"").orElse(null)), oldArtifactId) &&
                        (oldRelativePath == null || matchesGlob(determineRelativePath(tag, resolvedPom), oldRelativePath))) {
                        String oldVersion = resolvedPom.getValue(tag.getChildValue(""version"").orElse(null));
                        assert oldVersion != null;
                        String currentGroupId = tag.getChildValue(""groupId"").orElse(oldGroupId);
                        String targetGroupId = newGroupId == null ? currentGroupId : newGroupId;
                        String currentArtifactId = tag.getChildValue(""artifactId"").orElse(oldArtifactId);
                        String targetArtifactId = newArtifactId == null ? currentArtifactId : newArtifactId;
                        String targetRelativePath = newRelativePath == null ? tag.getChildValue(""relativePath"").orElse(oldRelativePath) : newRelativePath;
                        try {
                            Optional<String> targetVersion = findAcceptableVersion(targetGroupId, targetArtifactId, oldVersion, ctx);
                            if (!targetVersion.isPresent() ||
                                (Objects.equals(targetGroupId, currentGroupId) &&
                                 Objects.equals(targetArtifactId, currentArtifactId) &&
                                 Objects.equals(targetVersion.get(), oldVersion) &&
                                 Objects.equals(targetRelativePath, oldRelativePath))) {
                                return t;
                            }

                            List<TreeVisitor<?, ExecutionContext>> changeParentTagVisitors = new ArrayList<>();

                            if (!currentGroupId.equals(targetGroupId)) {
                                changeParentTagVisitors.add(new ChangeTagValueVisitor<>(t.getChild(""groupId"").get(), targetGroupId));
                            }

                            if (!currentArtifactId.equals(targetArtifactId)) {
                                changeParentTagVisitors.add(new ChangeTagValueVisitor<>(t.getChild(""artifactId"").get(), targetArtifactId));
                            }

                            if (!oldVersion.equals(targetVersion.get())) {
                                changeParentTagVisitors.add(new ChangeTagValueVisitor<>(t.getChild(""version"").get(), targetVersion.get()));
                            }

                            // Retain managed versions from the old parent that are not managed in the new parent
                            MavenPomDownloader mpd = new MavenPomDownloader(mrr.getProjectPoms(), ctx, mrr.getMavenSettings(), mrr.getActiveProfiles());
                            ResolvedPom newParent = mpd.download(new GroupArtifactVersion(targetGroupId, targetArtifactId, targetVersion.get()), null, resolvedPom, resolvedPom.getRepositories())
                                    .resolve(emptyList(), mpd, ctx);
                            List<ResolvedManagedDependency> dependenciesWithoutExplicitVersions = getDependenciesUnmanagedByNewParent(mrr, newParent);
                            for (ResolvedManagedDependency dep : dependenciesWithoutExplicitVersions) {
                                changeParentTagVisitors.add(new AddManagedDependencyVisitor(
                                        dep.getGav().getGroupId(), dep.getGav().getArtifactId(), dep.getGav().getVersion(),
                                        dep.getScope() == null ? null : dep.getScope().toString().toLowerCase(), dep.getType(), dep.getClassifier()));
                            }

                            // Retain properties from the old parent that are not present in the new parent
                            Map<String, String> propertiesInUse = getPropertiesInUse(getCursor().firstEnclosingOrThrow(Xml.Document.class), ctx);
                            Map<String, String> newParentProps = newParent.getProperties();
                            for (Map.Entry<String, String> propInUse : propertiesInUse.entrySet()) {
                                if (!newParentProps.containsKey(propInUse.getKey()) && propInUse.getValue() != null) {
                                    changeParentTagVisitors.add(new AddPropertyVisitor(propInUse.getKey(), propInUse.getValue(), false));
                                }
                            }

                            // Update or add relativePath
                            Optional<Xml.Tag> existingRelativePath = t.getChild(""relativePath"");
                            if (oldRelativePath != null && !oldRelativePath.equals(targetRelativePath) && existingRelativePath.isPresent()) {
                                if (StringUtils.isBlank(targetRelativePath)) {
                                    // ChangeTagValueVisitor would keep the closing tag
                                    changeParentTagVisitors.add(new AddOrUpdateChild<>(t, Xml.Tag.build(""<relativePath />"")));
                                } else {
                                    changeParentTagVisitors.add(new ChangeTagValueVisitor<>(existingRelativePath.get(), targetRelativePath));
                                }
                            } else if (mismatches(existingRelativePath.orElse(null), targetRelativePath)) {
                                final Xml.Tag relativePathTag;
                                if (StringUtils.isBlank(targetRelativePath)) {
                                    relativePathTag = Xml.Tag.build(""<relativePath />"");
                                } else {
                                    relativePathTag = Xml.Tag.build(""<relativePath>"" + targetRelativePath + ""</relativePath>"");
                                }
                                doAfterVisit(new AddToTagVisitor<>(t, relativePathTag, new MavenTagInsertionComparator(t.getChildren())));
                                maybeUpdateModel();
                            }

                            if (!changeParentTagVisitors.isEmpty()) {
                                for (TreeVisitor<?, ExecutionContext> visitor : changeParentTagVisitors) {
                                    doAfterVisit(visitor);
                                }
                                maybeUpdateModel();
                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, GTE, except).getVisitor());
                            }
                        } catch (MavenDownloadingException e) {
                            for (Map.Entry<MavenRepository, String> repositoryResponse : e.getRepositoryResponses().entrySet()) {
                                MavenRepository repository = repositoryResponse.getKey();
                                metadataFailures.insertRow(ctx, new MavenMetadataFailures.Row(targetGroupId, targetArtifactId, newVersion,
                                        repository.getUri(), repository.getSnapshots(), repository.getReleases(), repositoryResponse.getValue()));
                            }
                            return e.warn(tag);
                        }
                    }
                }
                return t;
            }

            private boolean mismatches(Xml.@Nullable Tag relativePath, @Nullable String targetRelativePath) {
                if (relativePath == null) {
                    return targetRelativePath != null;
                }
                String relativePathValue = relativePath.getValue().orElse(null);
                if (relativePathValue == null) {
                    return !StringUtils.isBlank(targetRelativePath);
                }
                return !relativePathValue.equals(targetRelativePath);
            }

            private Optional<String> findAcceptableVersion(String groupId, String artifactId, String currentVersion,
                                                                ExecutionContext ctx) throws MavenDownloadingException {
                String finalCurrentVersion = !Semver.isVersion(currentVersion) ? ""0.0.0"" : currentVersion;

                if (availableVersions == null) {
                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));
                    //noinspection EqualsWithItself
                    availableVersions = mavenMetadata.getVersioning().getVersions().stream()
                            .filter(v -> versionComparator.isValid(finalCurrentVersion, v))
                            .filter(v -> Boolean.TRUE.equals(allowVersionDowngrades) || versionComparator.compare(finalCurrentVersion, finalCurrentVersion, v) <= 0)
                            .collect(toList());
                }
                if (Boolean.TRUE.equals(allowVersionDowngrades)) {
                    return availableVersions.stream()
                            .max((v1, v2) -> versionComparator.compare(finalCurrentVersion, v1, v2));
                }
                Optional<String> upgradedVersion = versionComparator.upgrade(finalCurrentVersion, availableVersions);
                if (upgradedVersion.isPresent()) {
                    return upgradedVersion;
                }
                return availableVersions.stream().filter(finalCurrentVersion::equals).findFirst();
            }
        });
    }

    private static @Nullable String determineRelativePath(Xml.Tag tag, ResolvedPom resolvedPom) {
        Optional<Xml.Tag> relativePath = tag.getChild(""relativePath"");
        if (relativePath.isPresent()) {
            return resolvedPom.getValue(relativePath.get().getValue().orElse(""""));
        }
        return DEFAULT_RELATIVE_PATH;
    }

    private static final Pattern PROPERTY_PATTERN = Pattern.compile(""\\$\\{([^}]+)}"");

    private static Map<String, String> getPropertiesInUse(Xml.Document pomXml, ExecutionContext ctx) {
        return new MavenIsoVisitor<Map<String, String>>() {
            @Nullable
            ResolvedPom resolvedPom = null;
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, Map<String, String> properties) {
                Xml.Tag t = super.visitTag(tag, properties);
                if (t.getContent() != null && t.getContent().size() == 1 && t.getContent().get(0) instanceof Xml.CharData) {
                    String text = ((Xml.CharData) t.getContent().get(0)).getText().trim();
                    Matcher m = PROPERTY_PATTERN.matcher(text);
                    while (m.find()) {
                        if (resolvedPom == null) {
                            resolvedPom = getResolutionResult().getPom();
                        }
                        String propertyName = m.group(1).trim();
                        if (resolvedPom.getProperties().containsKey(propertyName) && !isGlobalProperty(propertyName)) {
                            properties.put(m.group(1).trim(), resolvedPom.getProperties().get(propertyName));
                        }
                    }
                }
                return t;
            }

            private boolean isGlobalProperty(String propertyName) {
                return propertyName.startsWith(""project."") || propertyName.startsWith(""env."") ||
                        propertyName.startsWith(""settings."") || ""basedir"".equals(propertyName);
            }
        }.reduce(pomXml, new HashMap<>());
    }

    private List<ResolvedManagedDependency> getDependenciesUnmanagedByNewParent(MavenResolutionResult mrr, ResolvedPom newParent) {
        ResolvedPom resolvedPom = mrr.getPom();

        // Dependencies managed by the current pom's own dependency management are irrelevant to parent upgrade
        List<ManagedDependency> locallyManaged = resolvedPom.getRequested().getDependencyManagement();

        Set<GroupArtifactVersion> requestedWithoutExplicitVersion = resolvedPom.getRequested().getDependencies().stream()
                .filter(dep -> dep.getVersion() == null)
                // Dependencies explicitly managed by the current pom require no changes
                .filter(dep -> locallyManaged.stream()
                        .noneMatch(it -> {
                            String groupId = resolvedPom.getValue(it.getGroupId());
                            String artifactId = resolvedPom.getValue(it.getArtifactId());
                            return dep.getGroupId().equals(groupId) && dep.getArtifactId().equals(artifactId);
                        }))
                .map(dep -> new GroupArtifactVersion(dep.getGroupId(), dep.getArtifactId(), null))
                .collect(toCollection(LinkedHashSet::new));

        if (requestedWithoutExplicitVersion.isEmpty()) {
            return emptyList();
        }

        List<ResolvedManagedDependency> depsWithoutExplicitVersion = resolvedPom.getDependencyManagement().stream()
                .filter(dep -> requestedWithoutExplicitVersion.contains(dep.getGav().withVersion(null)))
                // Exclude dependencies managed by a bom imported by the current pom
                .filter(dep -> dep.getBomGav() == null || locallyManaged.stream()
                        .noneMatch(it -> {
                            String groupId = resolvedPom.getValue(it.getGroupId());
                            String artifactId = resolvedPom.getValue(it.getArtifactId());
                            return dep.getBomGav().getGroupId().equals(groupId) && dep.getBomGav().getArtifactId().equals(artifactId);
                        }))
                .collect(toList());

        if (depsWithoutExplicitVersion.isEmpty()) {
            return emptyList();
        }

        // Remove from the list any that would still be managed under the new parent
        Set<GroupArtifact> newParentManagedGa = newParent.getDependencyManagement().stream()
                .map(dep -> new GroupArtifact(dep.getGav().getGroupId(), dep.getGav().getArtifactId()))
                .collect(toSet());

        return depsWithoutExplicitVersion.stream()
                .filter(it -> !newParentManagedGa.contains(new GroupArtifact(it.getGav().getGroupId(), it.getGav().getArtifactId())))
                .collect(toList());
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field"",
  ""newVersion"": ""String field""
}"
Enable Develocity build cache,Add Develocity build cache configuration to any `.mvn/` Develocity configuration file that lack existing configuration.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.xml.XmlVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class EnableDevelocityBuildCache extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Enable Develocity build cache"";
    }

    @Override
    public String getDescription() {
        return ""Add Develocity build cache configuration to any `.mvn/` Develocity configuration file that lack existing configuration."";
    }

    @Option(displayName = ""Enable local build cache"",
            description = ""Value for `//develocity/buildCache/local/enabled`."",
            example = ""true"",
            required = false)
    @Nullable
    String localEnabled;

    @Option(displayName = ""Enable remote build cache"",
            description = ""Value for `//develocity/buildCache/remote/enabled`."",
            example = ""true"",
            required = false)
    @Nullable
    String remoteEnabled;

    @Option(displayName = ""Enable remote build cache store"",
            description = ""Value for `//develocity/buildCache/remote/storeEnabled`."",
            example = ""#{isTrue(env['CI'])}"",
            required = false)
    @Nullable
    String remoteStoreEnabled;

    @Override
    public Validated<Object> validate(ExecutionContext ctx) {
        return super.validate(ctx)
                .and(Validated.notBlank(""localEnabled"", localEnabled)
                        .or(Validated.notBlank(""remoteEnabled"", remoteEnabled))
                        .or(Validated.notBlank(""remoteStoreEnabled"", remoteStoreEnabled)));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles("".mvn/*.xml""), new XmlVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Tag rootTag = document.getRoot();

                if (""develocity"".equals(rootTag.getName()) && !rootTag.getChild(""buildCache"").isPresent()) {
                    Xml.Tag tag = Xml.Tag.build(buildCacheConfig());
                    rootTag = maybeAutoFormat(rootTag, rootTag.withContent(ListUtils.concat(rootTag.getChildren(), tag)), ctx);
                    return document.withRoot(rootTag);
                }
                return document;
            }

            private String buildCacheConfig() {
                StringBuilder sb = new StringBuilder(""<buildCache>"");
                if (!StringUtils.isBlank(localEnabled)) {
                    sb.append(""<local>"");
                    sb.append(""<enabled>"").append(localEnabled).append(""</enabled>"");
                    sb.append(""</local>"");
                }
                if (!StringUtils.isBlank(remoteEnabled) || !StringUtils.isBlank(remoteStoreEnabled)) {
                    sb.append(""<remote>"");
                    if (!StringUtils.isBlank(remoteEnabled)) {
                        sb.append(""<enabled>"").append(remoteEnabled).append(""</enabled>"");
                    }
                    if (!StringUtils.isBlank(remoteStoreEnabled)) {
                        sb.append(""<storeEnabled>"").append(remoteStoreEnabled).append(""</storeEnabled>"");
                    }
                    sb.append(""</remote>"");
                }
                sb.append(""</buildCache>"");
                return sb.toString();
            }
        });
    }
}
",{}
Increment Maven project version,"Increase Maven project version by incrementing either the major, minor, or patch version as defined by ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.marker.AlreadyIncremented;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.xml.ChangeTagValue;
import org.openrewrite.xml.tree.Xml;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.openrewrite.Tree.randomId;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class IncrementProjectVersion extends ScanningRecipe<Map<GroupArtifact, String>> {

    @Option(displayName = ""Group"",
            description = ""The group ID of the Maven project to change its version. This can be a glob expression."",
            example = ""org.openrewrite"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The artifact ID of the Maven project to change its version. This can be a glob expression."",
            example = ""*"")
    String artifactId;

    @Option(displayName = ""Semver digit"",
            description = ""`MAJOR` increments the first digit, `MINOR` increments the second digit, and `PATCH` "" +
                          ""increments the third digit."",
            example = ""PATCH"")
    SemverDigit digit;

    public enum SemverDigit {
        MAJOR,
        MINOR,
        PATCH
    }

    @Override
    public String getDisplayName() {
        return ""Increment Maven project version"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, digit);
    }

    @Override
    public String getDescription() {
        return ""Increase Maven project version by incrementing either the major, minor, or patch version as defined by "" +
               ""[semver](https://semver.org/). Other versioning schemes are not supported."";
    }

    @Override
    public Map<GroupArtifact, String> getInitialValue(ExecutionContext ctx) {
        return new HashMap<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Map<GroupArtifact, String> acc) {
        final Pattern SEMVER_PATTERN = Pattern.compile(""(\\d+)\\.(\\d+)\\.(\\d+)\\.?(\\d+)?(-.+)?$"");

        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (!isProjectTag()) {
                    return t;
                }
                ResolvedPom resolvedPom = getResolutionResult().getPom();
                if (!(matchesGlob(resolvedPom.getValue(t.getChildValue(""groupId"").orElse(null)), groupId) &&
                      matchesGlob(resolvedPom.getValue(t.getChildValue(""artifactId"").orElse(null)), artifactId))) {
                    return t;
                }
                Optional<Xml.Tag> versionTag = t.getChild(""version"");
                if (!(versionTag.isPresent() && versionTag.get().getValue().isPresent())) {
                    return t;
                }
                String versionTagValue = versionTag.get().getValue().get();
                String oldVersion = resolvedPom.getValue(versionTagValue);
                if (oldVersion == null) {
                    return t;
                }
                String newVersion = incrementSemverDigit(oldVersion);
                if (newVersion.equals(oldVersion)) {
                    return t;
                }
                acc.put(new GroupArtifact(
                                t.getChildValue(""groupId"").orElse(null), t.getChildValue(""artifactId"").orElse(null)),
                        newVersion);
                return t;
            }

            private String incrementSemverDigit(String oldVersion) {
                Matcher m = SEMVER_PATTERN.matcher(oldVersion);
                if (!m.matches()) {
                    return oldVersion;
                }
                String major = m.group(1);
                String minor = m.group(2);
                String patch = m.group(3);
                // Semver does not have a concept of a fourth number, but it is common enough to support
                String fourth = m.group(4);
                String extra = m.group(5);
                switch (digit) {
                    case MAJOR:
                        major = String.valueOf(Integer.parseInt(major) + 1);
                        minor = ""0"";
                        patch = ""0"";
                        break;
                    case MINOR:
                        minor = String.valueOf(Integer.parseInt(minor) + 1);
                        patch = ""0"";
                        break;
                    case PATCH:
                        patch = String.valueOf(Integer.parseInt(patch) + 1);
                        break;
                }
                if (fourth == null) {
                    fourth = """";
                } else {
                    fourth = "".0"";
                }
                if (extra == null) {
                    extra = """";
                }
                return major + ""."" + minor + ""."" + patch + fourth + extra;
            }
        };

    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Map<GroupArtifact, String> acc) {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (!(isProjectTag() || isParentTag()) ||
                    t.getMarkers().findFirst(AlreadyIncremented.class).isPresent()) {
                    return t;
                }
                String newVersion = acc.get(new GroupArtifact(
                        t.getChildValue(""groupId"").orElse(null),
                        t.getChildValue(""artifactId"").orElse(null)));
                String oldVersion = t.getChildValue(""version"").orElse(null);
                if (newVersion == null || newVersion.equals(oldVersion)) {
                    return t;
                }
                t = t.withMarkers(t.getMarkers().add(new AlreadyIncremented(randomId())));
                return (Xml.Tag) new ChangeTagValue(""version"", oldVersion, newVersion, null)
                        .getVisitor().visitNonNull(t, ctx);
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""digit"": ""SemverDigit field""
}"
Rename Maven property key,Rename the specified Maven project property key leaving the value unchanged.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class RenamePropertyKey extends Recipe {

    @Option(displayName = ""Old key"",
            description = ""The old name of the property key to be replaced."",
            example = ""junit.version"")
    String oldKey;

    @Option(displayName = ""New key"",
            description = ""The new property name to use."",
            example = ""version.org.junit"")
    String newKey;

    @Override
    public String getDisplayName() {
        return ""Rename Maven property key"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldKey, newKey);
    }

    @Override
    public String getDescription() {
        return ""Rename the specified Maven project property key leaving the value unchanged."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            final String oldKeyAsProperty = ""${"" + oldKey + ""}"";
            final String newKeyAsProperty = ""${"" + newKey + ""}"";

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (isPropertyTag() && oldKey.equals(t.getName())) {
                    t = t.withName(newKey);
                }
                if (t.getChildren().isEmpty()) {
                    Optional<String> value = t.getValue();
                    if (value.isPresent() && value.get().contains(oldKeyAsProperty)) {
                        String newValue = value.get().replace(oldKeyAsProperty, newKeyAsProperty);
                        doAfterVisit(new ChangeTagValueVisitor<>(t, newValue));
                    }
                }
                return t;
            }

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document d = super.visitDocument(document, ctx);
                if (d != document) {
                    maybeUpdateModel();
                }
                return d;
            }
        };
    }
}
","{
  ""oldKey"": ""String field"",
  ""newKey"": ""String field""
}"
Change Maven dependency,Change a Maven dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.InlineMe;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.*;

import static java.util.Collections.max;
import static org.openrewrite.Validated.required;
import static org.openrewrite.Validated.test;
import static org.openrewrite.internal.StringUtils.isBlank;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyGroupIdAndArtifactId extends Recipe {
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old groupId"",
            description = ""The old groupId to replace. The groupId is the first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob expressions."",
            example = ""org.openrewrite.recipe"")
    String oldGroupId;

    @Option(displayName = ""Old artifactId"",
            description = ""The old artifactId to replace. The artifactId is the second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob expressions."",
            example = ""rewrite-testing-frameworks"")
    String oldArtifactId;

    @Option(displayName = ""New groupId"",
            description = ""The new groupId to use. Defaults to the existing group id."",
            example = ""corp.internal.openrewrite.recipe"",
            required = false)
    @Nullable
    String newGroupId;

    @Option(displayName = ""New artifactId"",
            description = ""The new artifactId to use. Defaults to the existing artifact id."",
            example = ""rewrite-testing-frameworks"",
            required = false)
    @Nullable
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Override managed version"",
            description = ""If the new dependency has a managed version, this flag can be used to explicitly set the version on the dependency. The default for this flag is `false`."",
            required = false)
    @Nullable
    Boolean overrideManagedVersion;

    @Option(displayName = ""Update dependency management"",
            description = ""Also update the dependency management section. The default for this flag is `true`."",
            required = false)
    @Nullable
    Boolean changeManagedDependency;

    @InlineMe(replacement = ""this(oldGroupId, oldArtifactId, newGroupId, newArtifactId, newVersion, versionPattern, false, true)"")
    public ChangeDependencyGroupIdAndArtifactId(String oldGroupId, String oldArtifactId, @Nullable String newGroupId, @Nullable String newArtifactId, @Nullable String newVersion, @Nullable String versionPattern) {
        this(oldGroupId, oldArtifactId, newGroupId, newArtifactId, newVersion, versionPattern, false, true);
    }

    @JsonCreator
    public ChangeDependencyGroupIdAndArtifactId(String oldGroupId, String oldArtifactId, @Nullable String newGroupId, @Nullable String newArtifactId, @Nullable String newVersion, @Nullable String versionPattern, @Nullable Boolean overrideManagedVersion, @Nullable Boolean changeManagedDependency) {
        this.oldGroupId = oldGroupId;
        this.oldArtifactId = oldArtifactId;
        this.newGroupId = newGroupId;
        this.newArtifactId = newArtifactId;
        this.newVersion = newVersion;
        this.versionPattern = versionPattern;
        this.overrideManagedVersion = overrideManagedVersion;
        this.changeManagedDependency = changeManagedDependency;
    }

    @Override
    public String getDisplayName() {
        return ""Change Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", oldGroupId, oldArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Change a Maven dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before. "" +
               ""Matching `<dependencyManagement>` coordinates are also updated if a `newVersion` or `versionPattern` is provided."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        validated = validated.and(required(""newGroupId"", newGroupId).or(required(""newArtifactId"", newArtifactId)));
        return validated.and(test(
                ""coordinates"",
                ""newGroupId OR newArtifactId must be different from before"",
                this,
                r -> {
                    boolean sameGroupId = isBlank(r.newGroupId) || Objects.equals(r.oldGroupId, r.newGroupId);
                    boolean sameArtifactId = isBlank(r.newArtifactId) || Objects.equals(r.oldArtifactId, r.newArtifactId);
                    return !(sameGroupId && sameArtifactId);
                }
        ));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Nullable
            final VersionComparator versionComparator = newVersion != null ? Semver.validate(newVersion, versionPattern).getValue() : null;
            @Nullable
            private Collection<String> availableVersions;
            private boolean isNewDependencyPresent;

            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                isNewDependencyPresent = checkIfNewDependencyPresents(newGroupId, newArtifactId, newVersion);
                if (changeManagedDependency == null || changeManagedDependency) {
                    doAfterVisit(new ChangeManagedDependencyGroupIdAndArtifactId(
                            oldGroupId, oldArtifactId,
                            Optional.ofNullable(newGroupId).orElse(oldGroupId),
                            Optional.ofNullable(newArtifactId).orElse(oldArtifactId),
                            newVersion, versionPattern).getVisitor());
                }
                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                boolean isOldDependencyTag = isDependencyTag(oldGroupId, oldArtifactId);
                if (isOldDependencyTag && isNewDependencyPresent) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                    maybeUpdateModel();
                    return t;
                }
                if (isOldDependencyTag || isPluginDependencyTag(oldGroupId, oldArtifactId)) {
                    String groupId = newGroupId;
                    if (groupId != null) {
                        t = changeChildTagValue(t, ""groupId"", groupId, ctx);
                    } else {
                        groupId = t.getChildValue(""groupId"").orElseThrow(NoSuchElementException::new);
                    }
                    String artifactId = newArtifactId;
                    if (artifactId != null) {
                        t = changeChildTagValue(t, ""artifactId"", artifactId, ctx);
                    } else {
                        artifactId = t.getChildValue(""artifactId"").orElseThrow(NoSuchElementException::new);
                    }
                    String currentVersion = t.getChildValue(""version"").orElse(null);
                    if (newVersion != null) {
                        try {
                            String resolvedNewVersion = resolveSemverVersion(ctx, groupId, artifactId, currentVersion);
                            Optional<Xml.Tag> scopeTag = t.getChild(""scope"");
                            Scope scope = scopeTag.map(xml -> Scope.fromName(xml.getValue().orElse(""compile""))).orElse(Scope.Compile);
                            Optional<Xml.Tag> versionTag = t.getChild(""version"");

                            boolean configuredToOverrideManageVersion = overrideManagedVersion != null && overrideManagedVersion; // False by default
                            boolean configuredToChangeManagedDependency = changeManagedDependency == null || changeManagedDependency; // True by default

                            boolean versionTagPresent = versionTag.isPresent();
                            boolean oldDependencyManaged = isDependencyManaged(scope, oldGroupId, oldArtifactId);
                            boolean newDependencyManaged = isDependencyManaged(scope, groupId, artifactId);
                            if (versionTagPresent) {
                                // If the previous dependency had a version but the new artifact is managed, removed the version tag.
                                if (!configuredToOverrideManageVersion && newDependencyManaged || (oldDependencyManaged && configuredToChangeManagedDependency)) {
                                    t = (Xml.Tag) new RemoveContentVisitor<>(versionTag.get(), false, true).visit(t, ctx);
                                } else {
                                    // Otherwise, change the version to the new value.
                                    t = changeChildTagValue(t, ""version"", resolvedNewVersion, ctx);
                                }
                            } else if (configuredToOverrideManageVersion || !newDependencyManaged) {
                                //If the version is not present, add the version if we are explicitly overriding a managed version or if no managed version exists.
                                Xml.Tag newVersionTag = Xml.Tag.build(""<version>"" + resolvedNewVersion + ""</version>"");
                                //noinspection ConstantConditions
                                t = (Xml.Tag) new AddToTagVisitor<ExecutionContext>(t, newVersionTag, new MavenTagInsertionComparator(t.getChildren())).visitNonNull(t, ctx, getCursor().getParent());
                            }
                        } catch (MavenDownloadingException e) {
                            return e.warn(tag);
                        }
                    }
                    if (t != tag) {
                        maybeUpdateModel();
                    }
                }

                //noinspection ConstantConditions
                return t;
            }

            private boolean checkIfNewDependencyPresents(@Nullable String groupId, @Nullable String artifactId, @Nullable String version) {
                if ((groupId == null) || (artifactId == null)) {
                    return false;
                }
                List<ResolvedDependency> dependencies = findDependencies(groupId, artifactId);
                return dependencies.stream()
                        .filter(ResolvedDependency::isDirect)
                        .anyMatch(rd -> (version == null) || version.equals(rd.getVersion()));
            }

            private boolean isDependencyManaged(Scope scope, String groupId, String artifactId) {
                MavenResolutionResult result = getResolutionResult();
                for (ResolvedManagedDependency managedDependency : result.getPom().getDependencyManagement()) {
                    if (groupId.equals(managedDependency.getGroupId()) && artifactId.equals(managedDependency.getArtifactId())) {
                        return scope.isInClasspathOf(managedDependency.getScope());
                    }
                }
                return false;
            }

            @SuppressWarnings(""ConstantConditions"")
            private String resolveSemverVersion(ExecutionContext ctx, String groupId, String artifactId, @Nullable String currentVersion) throws MavenDownloadingException {
                if (versionComparator == null) {
                    return newVersion;
                }
                String finalCurrentVersion = currentVersion != null ? currentVersion : newVersion;
                if (availableVersions == null) {
                    availableVersions = new ArrayList<>();
                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));
                    for (String v : mavenMetadata.getVersioning().getVersions()) {
                        if (versionComparator.isValid(finalCurrentVersion, v)) {
                            availableVersions.add(v);
                        }
                    }

                }
                return availableVersions.isEmpty() ? newVersion : max(availableVersions, versionComparator);
            }
        };
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field""
}"
Add a configuration option for the Maven runtime,Add a new configuration option for the Maven runtime if not already present.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddRuntimeConfig extends ScanningRecipe<AddRuntimeConfig.Accumulator> {
    static final String POM_FILENAME = ""pom.xml"";
    static final String MVN_CONFIG_DIR = "".mvn"";
    static final String MAVEN_CONFIG_FILENAME = ""maven.config"";
    static final String MAVEN_CONFIG_PATH = MVN_CONFIG_DIR + ""/"" + MAVEN_CONFIG_FILENAME;
    static final String JVM_CONFIG_FILENAME = ""jvm.config"";
    static final String JVM_CONFIG_PATH = MVN_CONFIG_DIR + ""/"" + JVM_CONFIG_FILENAME;

    @Option(displayName = ""Config file"",
            description = ""The file name for setting the runtime configuration."",
            valid = {MAVEN_CONFIG_FILENAME, JVM_CONFIG_FILENAME},
            example = ""maven.config"")
    String relativeConfigFileName;

    @Option(displayName = ""Runtime flag"",
            description = ""The runtime flag name to be set."",
            example = ""-T"")
    String flag;

    @Option(displayName = ""Runtime flag argument"",
            description = ""The argument to set for the runtime flag. Some flags do not need to provide a value."",
            required = false,
            example = ""3"")
    @Nullable
    String argument;

    @Option(displayName = ""Separator between runtime flag and argument"",
            description = ""The separator to use if flag and argument have been provided."",
            valid = {"""", "" "", ""=""},
            example = ""="")
    Separator separator;

    @Getter
    public enum Separator {
        @SuppressWarnings(""DefaultAnnotationParam"")
        @JsonProperty("""")
        NONE(""""),

        @JsonProperty("" "")
        SPACE("" ""),

        @JsonProperty(""="")
        EQUALS(""="");

        private final String notation;

        Separator(String notation) {
            this.notation = notation;
        }
    }

    @Override
    public String getDisplayName() {
        return ""Add a configuration option for the Maven runtime"";
    }

    @Override
    public String getDescription() {
        return ""Add a new configuration option for the Maven runtime if not already present."";
    }

    @Data
    @RequiredArgsConstructor
    public static class Accumulator {
        final String targetRepresentation;
        boolean mavenProject;

        @Nullable
        Path matchingRuntimeConfigFile;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        String targetRepresentation = argument == null ? flag : flag + separator.getNotation() + argument;
        return new Accumulator(targetRepresentation);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof SourceFile) {
                    Path sourcePath = ((SourceFile) tree).getSourcePath();
                    switch (PathUtils.separatorsToUnix(sourcePath.toString())) {
                        case POM_FILENAME:
                            acc.setMavenProject(true);
                            break;
                        case MAVEN_CONFIG_PATH:
                        case JVM_CONFIG_PATH:
                            acc.setMatchingRuntimeConfigFile(sourcePath);
                            break;
                        default:
                            break;
                    }
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        if (acc.isMavenProject() && acc.getMatchingRuntimeConfigFile() == null) {
            return singletonList(PlainText.builder()
                    .text(acc.getTargetRepresentation())
                    .sourcePath(Paths.get(MVN_CONFIG_DIR, relativeConfigFileName))
                    .build());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return Preconditions.check(acc.isMavenProject() && acc.getMatchingRuntimeConfigFile() != null,
                new PlainTextVisitor<ExecutionContext>() {
                    @Override
                    public PlainText visitText(PlainText plainText, ExecutionContext ctx) {
                        if (plainText.getSourcePath().equals(acc.getMatchingRuntimeConfigFile())) {
                            return addOrReplaceConfig(plainText, acc);
                        }
                        return plainText;
                    }

                    private PlainText addOrReplaceConfig(PlainText plainText, Accumulator acc) {
                        String existingContent = plainText.getText();
                        Matcher matcher = Pattern.compile(Pattern.quote(flag) + ""[=\\s]?[a-zA-Z0-9]*"").matcher(existingContent);
                        if (matcher.find()) {
                            return plainText.withText(matcher.replaceAll(acc.getTargetRepresentation()));
                        }

                        String newText = StringUtils.isBlank(existingContent) ? existingContent : existingContent + determineConfigSeparator(plainText);
                        return plainText.withText(newText + acc.getTargetRepresentation());
                    }

                    private String determineConfigSeparator(PlainText plainText) {
                        // Use new line for maven.config, space for jvm.config
                        if (Paths.get(JVM_CONFIG_PATH).equals(plainText.getSourcePath())) {
                            return "" "";
                        }
                        return plainText.getText().contains(""\r\n"") ? ""\r\n"" : ""\n"";
                    }
                });
    }
}
","{
  ""relativeConfigFileName"": ""String field"",
  ""flag"": ""String field"",
  ""separator"": ""Separator field""
}"
Set Maven project packaging,Sets the packaging type of Maven projects. Either adds the packaging tag if it is missing or changes its context if present.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.internal.StringUtils.matchesGlob;
import static org.openrewrite.xml.AddOrUpdateChild.addOrUpdateChild;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterTagChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePackaging extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The groupId of the project whose packaging should be changed. Accepts glob patterns."",
            example = ""org.openrewrite.*"")
    String groupId;

    @Option(displayName = ""Group"",
            description = ""The artifactId of the project whose packaging should be changed. Accepts glob patterns."",
            example = ""rewrite-*"")
    String artifactId;

    @Option(displayName = ""Packaging"",
            description = ""The type of packaging to set. If `null` specified the packaging tag will be removed"",
            example = ""jar"")
    @Nullable
    String packaging;

    @Option(displayName = ""Old Packaging"",
            description = ""The old packaging type. If provided, will only change if the current packaging matches"",
            required = false,
            example = ""jar"")
    @Nullable
    String oldPackaging;

    @Override
    public String getDisplayName() {
        return ""Set Maven project packaging"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s` to `%s`"", groupId, artifactId, packaging);
    }

    @Override
    public String getDescription() {
        return ""Sets the packaging type of Maven projects. Either adds the packaging tag if it is missing or changes its context if present."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                ResolvedPom pom = getResolutionResult().getPom();
                if (!matchesGlob(pom.getGroupId(), groupId) || !matchesGlob(pom.getArtifactId(), artifactId)) {
                    return document;
                }
                Xml.Document xml = super.visitDocument(document, ctx);
                if (xml != document) {
                    return xml.withMarkers(xml.getMarkers().withMarkers(ListUtils.map(xml.getMarkers().getMarkers(), m -> {
                        if (m instanceof MavenResolutionResult) {
                            return getResolutionResult().withPom(pom.withRequested(pom.getRequested().withPackaging(packaging)));
                        }
                        return m;
                    })));
                }
                return xml;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (isProjectTag()) {
                    Optional<Xml.Tag> maybePackaging = t.getChild(""packaging"");
                    if (!maybePackaging.isPresent() || oldPackaging == null || oldPackaging.equals(maybePackaging.get().getValue().orElse(null))) {
                        if (packaging == null || ""jar"".equals(packaging)) {
                            t = filterTagChildren(t, it -> !""packaging"".equals(it.getName()));
                        } else {
                            t = addOrUpdateChild(t, Xml.Tag.build(""\n<packaging>"" + packaging + ""</packaging>""), getCursor().getParentOrThrow());
                        }
                    }
                }
                return t;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Remove exclusion,Remove any matching exclusion from any matching dependency.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedManagedDependency;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.Optional;

import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveExclusion extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Exclusion group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String exclusionGroupId;

    @Option(displayName = ""Exclusion artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String exclusionArtifactId;

    @Option(displayName = ""Only ineffective"",
            description = ""Default false. If enabled, matching exclusions will only be removed if they are ineffective (if the excluded dependency was not actually a transitive dependency of the target dependency)."",
            required = false)
    @Nullable
    Boolean onlyIneffective;

    @Override
    public String getDisplayName() {
        return ""Remove exclusion"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", exclusionGroupId, exclusionArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Remove any matching exclusion from any matching dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag(groupId, artifactId) || isManagedDependencyTag(groupId, artifactId)) {
                    Optional<Xml.Tag> maybeExclusions = tag.getChild(""exclusions"");
                    if (maybeExclusions.isPresent()) {
                        //noinspection unchecked
                        return tag.withContent(ListUtils.map((List<Content>) tag.getContent(), child -> {
                            if (child instanceof Xml.Tag && ""exclusions"".equals(((Xml.Tag) child).getName())) {
                                Xml.Tag e = (Xml.Tag) child;
                                if (e.getContent() != null) {
                                    e = e.withContent(ListUtils.map(e.getContent(), child2 -> {
                                        if (child2 instanceof Xml.Tag && ""exclusion"".equals(((Xml.Tag) child2).getName())) {
                                            GroupArtifact exclusion = getResolutionResult().getPom().getValues(groupArtifact((Xml.Tag) child2));
                                            if (matchesGlob(exclusion.getGroupId(), exclusionGroupId) &&
                                                matchesGlob(exclusion.getArtifactId(), exclusionArtifactId) &&
                                                !(isEffectiveExclusion(tag, exclusion) && Boolean.TRUE.equals(onlyIneffective))) {
                                                return null;
                                            }
                                        }
                                        return child2;
                                    }));

                                    if (e.getContent() == null || e.getContent().isEmpty()) {
                                        return null;
                                    } else if (e.getContent().stream().noneMatch(Xml.Tag.class::isInstance)) {
                                        return null;
                                    }
                                }
                                return e;
                            }
                            return child;
                        }));
                    }
                }
                return super.visitTag(tag, ctx);
            }

            private GroupArtifact groupArtifact(Xml.Tag tag) {
                return new GroupArtifact(
                        tag.getChildValue(""groupId"").orElseThrow(IllegalArgumentException::new),
                        tag.getChildValue(""artifactId"").orElseThrow(IllegalArgumentException::new)
                );
            }

            private boolean isEffectiveExclusion(Xml.Tag tag, GroupArtifact exclusion) {
                final ResolvedDependency dependency = findDependency(tag);
                if (dependency != null) {
                    return dependency.getEffectiveExclusions().contains(exclusion);
                }
                final ResolvedManagedDependency managedDependency = findManagedDependency(tag);
                // With current code, if a dependency is only in dependencyManagement (and not an active dependency in some scope),
                // then we never resolve its transitive dependencies and therefore cannot check if exclusions are effective.
                // So, default to assuming those exclusions are effective, to avoid incorrect removals.
                // Meanwhile, exclusions on bom imports aren't actually implemented in Maven (src https://issues.apache.org/jira/browse/MNG-5600),
                // so those are always ineffective
                return managedDependency != null && managedDependency.getRequested() != null;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""exclusionGroupId"": ""String field"",
  ""exclusionArtifactId"": ""String field""
}"
Add Maven plugin,Add the specified Maven plugin to the pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddPlugin extends Recipe {

    private static final XPathMatcher BUILD_MATCHER = new XPathMatcher(""/project/build"");

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""A fixed version of the plugin to add."",
            example = ""1.0.0"",
            required = false)
    @Nullable
    String version;

    @Language(""xml"")
    @Option(displayName = ""Configuration"",
            description = ""Optional plugin configuration provided as raw XML"",
            example = ""<configuration><foo>foo</foo></configuration>"",
            required = false)
    @Nullable
    String configuration;

    @Option(displayName = ""Dependencies"",
            description = ""Optional plugin dependencies provided as raw XML."",
            example = ""<dependencies><dependency><groupId>com.yourorg</groupId><artifactId>core-lib</artifactId><version>1.0.0</version></dependency></dependencies>"",
            required = false)
    @Nullable
    String dependencies;

    @Option(displayName = ""Executions"",
            description = ""Optional executions provided as raw XML."",
            example = ""<executions><execution><phase>generate-sources</phase><goals><goal>add-source</goal></goals></execution></executions>"",
            required = false)
    @Nullable
    String executions;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                    ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                    ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match. "" +
                    ""When not set, all source files are searched. "",
            required = false,
            example = ""**/*-parent/grpc-*/pom.xml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Add Maven plugin"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add the specified Maven plugin to the pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AddPluginVisitor();
    }

    private class AddPluginVisitor extends MavenIsoVisitor<ExecutionContext> {

        @Override
        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
            if (filePattern != null) {
                return PathUtils.matchesGlob(sourceFile.getSourcePath(), filePattern) && super.isAcceptable(sourceFile, ctx);
            }

            MavenResolutionResult mrr = sourceFile.getMarkers().findFirst(MavenResolutionResult.class).orElse(null);
            if (mrr == null || mrr.parentPomIsProjectPom()) {
                return false;
            }

            return super.isAcceptable(sourceFile, ctx);
        }

        @Override
        public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
            Xml.Tag root = document.getRoot();
            if (!root.getChild(""build"").isPresent()) {
                document = (Xml.Document) new AddToTagVisitor<>(root, Xml.Tag.build(""<build/>""))
                        .visitNonNull(document, ctx, getCursor().getParentOrThrow());
            }
            return super.visitDocument(document, ctx);
        }

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag t = super.visitTag(tag, ctx);

            if (BUILD_MATCHER.matches(getCursor())) {
                Optional<Xml.Tag> maybePlugins = t.getChild(""plugins"");
                Xml.Tag plugins;
                if (maybePlugins.isPresent()) {
                    plugins = maybePlugins.get();
                } else {
                    t = (Xml.Tag) new AddToTagVisitor<>(t, Xml.Tag.build(""<plugins/>"")).visitNonNull(t, ctx, getCursor().getParentOrThrow());
                    //noinspection OptionalGetWithoutIsPresent
                    plugins = t.getChild(""plugins"").get();
                }

                Optional<Xml.Tag> maybePlugin = plugins.getChildren().stream()
                        .filter(plugin ->
                                ""plugin"".equals(plugin.getName()) &&
                                        groupId.equals(plugin.getChildValue(""groupId"").orElse(null)) &&
                                        artifactId.equals(plugin.getChildValue(""artifactId"").orElse(null))
                        )
                        .findAny();

                if (maybePlugin.isPresent()) {
                    Xml.Tag plugin = maybePlugin.get();
                    if (version != null && !version.equals(plugin.getChildValue(""version"").orElse(null))) {
                        if (plugin.getChild(""version"").isPresent()) {
                            t = (Xml.Tag) new ChangeTagValueVisitor<>(plugin.getChild(""version"").get(), version).visitNonNull(t, ctx, getCursor().getParentOrThrow());
                        }
                    }
                } else {
                    Xml.Tag pluginTag = Xml.Tag.build(
                            ""<plugin>\n"" +
                            ""<groupId>"" + groupId + ""</groupId>\n"" +
                            ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                            (version != null ? ""<version>"" + version + ""</version>\n"" : """") +
                            (executions != null ? executions.trim() + ""\n"" : """") +
                            (configuration != null ? configuration.trim() + ""\n"" : """") +
                            (dependencies != null ? dependencies.trim() + ""\n"" : """") +
                            ""</plugin>"");
                    t = (Xml.Tag) new AddToTagVisitor<>(plugins, pluginTag).visitNonNull(t, ctx, getCursor().getParentOrThrow());
                }
            }

            return t;
        }
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Maven Project Version,Change the project version of a Maven pom.xml. Identifies the project to be changed by its groupId and artifactId. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Arrays;
import java.util.Collection;
import java.util.Optional;

import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeProjectVersion extends Recipe {
    // there are several implicitly defined version properties that we should never attempt to update
    private static final Collection<String> implicitlyDefinedVersionProperties = Arrays.asList(
            ""${version}"", ""${project.version}"", ""${pom.version}"", ""${project.parent.version}"",
            ""${revision}"", ""${sha1}"", ""${changelist}""
    );

    @Option(displayName = ""Group"",
            description = ""The group ID of the maven project to change its version. This can be a glob expression."",
            example = ""org.openrewrite"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The artifact ID of the maven project to change its version. This can be a glob expression."",
            example = ""*"")
    String artifactId;

    @Option(displayName = ""New version"",
            description = ""The new version to replace the maven project version."",
            example = ""8.4.2"")
    String newVersion;

    @Option(displayName = ""Override Parent Version"",
            description = ""This flag can be set to explicitly override the inherited parent version. Default `false`."",
            required = false)
    @Nullable
    Boolean overrideParentVersion;

    @Override
    public String getDisplayName() {
        return ""Change Maven Project Version"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, newVersion);
    }

    @Override
    public String getDescription() {
        return ""Change the project version of a Maven pom.xml. Identifies the project to be changed by its groupId and artifactId. "" +
               ""If the version is defined as a property, this recipe will only change the property value if the property exists within the same pom."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (isProjectTag()) {
                    ResolvedPom resolvedPom = getResolutionResult().getPom();

                    if (matchesGlob(resolvedPom.getValue(t.getChildValue(""groupId"").orElse(null)), groupId) &&
                        matchesGlob(resolvedPom.getValue(t.getChildValue(""artifactId"").orElse(null)), artifactId)) {
                        Optional<Xml.Tag> versionTag = t.getChild(""version"");
                        if (versionTag.isPresent() && versionTag.get().getValue().isPresent()) {
                            String versionTagValue = versionTag.get().getValue().get();
                            String oldVersion = resolvedPom.getValue(versionTagValue);
                            assert oldVersion != null;

                            // Skip if the current version tag value is already equal to the new version
                            if (!versionTagValue.equals(newVersion)) {
                                if (!oldVersion.equals(newVersion)) {
                                    if (versionTagValue.startsWith(""${"") && !implicitlyDefinedVersionProperties.contains(versionTagValue)) {
                                        doAfterVisit(new ChangePropertyValue(versionTagValue.substring(2, versionTagValue.length() - 1), newVersion, false, false).getVisitor());
                                    } else {
                                        doAfterVisit(new ChangeTagValueVisitor<>(versionTag.get(), newVersion));
                                    }
                                    maybeUpdateModel();
                                }
                            }
                        } else if (Boolean.TRUE.equals(overrideParentVersion)) {
                            // if the version is not present and the override parent version is set,
                            // add a new explicit version tag
                            Xml.Tag newVersionTag = Xml.Tag.build(""<version>"" + newVersion + ""</version>"");
                            doAfterVisit(new AddToTagVisitor<>(t, newVersionTag, new MavenTagInsertionComparator(t.getChildren())));
                            maybeUpdateModel();
                        }
                    }
                }
                return t;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newVersion"": ""String field""
}"
Upgrade Maven plugin version,"Upgrade the version of a plugin using Node Semver advanced range selectors, ",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.search.FindPlugin;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.MavenMetadata;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

/**
 * Upgrade the version of a plugin using Node Semver
 * <a href=""https://github.com/npm/node-semver#advanced-range-syntax"">advanced range selectors</a>, allowing
 * more precise control over version updates to patch or minor releases.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradePluginVersion extends Recipe {
    @EqualsAndHashCode.Exclude
    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'. "" +
                          ""Supports globs."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'. "" +
                          ""Supports globs."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)"",
            example = ""29.X"")
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    // needs implementation, left here as syntactic placeholder // todo
    @Option(displayName = ""Trust parent POM"",
            description = ""Even if the parent suggests a version that is older than what we are trying to upgrade to, trust it anyway. "" +
                          ""Useful when you want to wait for the parent to catch up before upgrading. The parent is not trusted by default."",
            required = false)
    @Nullable
    Boolean trustParent;

    @Option(displayName = ""Add version if missing"",
            description = ""If the plugin is missing a version, add the latest release. Defaults to false."",
            required = false)
    @Nullable
    Boolean addVersionIfMissing;

    @SuppressWarnings(""ConstantConditions"")
    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    @Override
    public String getDisplayName() {
        return ""Upgrade Maven plugin version"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, newVersion);
    }

    @Override
    public String getDescription() {
        return ""Upgrade the version of a plugin using Node Semver advanced range selectors, "" +
               ""allowing more precise control over version updates to patch or minor releases."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        VersionComparator versionComparator = requireNonNull(Semver.validate(newVersion, versionPattern).getValue());
        return Preconditions.check(new FindPlugin(groupId, artifactId), new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isPluginTag(groupId, artifactId)) {
                    Optional<Xml.Tag> versionTag = tag.getChild(""version"");
                    Optional<String> maybeVersionValue = versionTag.flatMap(Xml.Tag::getValue);
                    if (maybeVersionValue.isPresent() || Boolean.TRUE.equals(addVersionIfMissing)) {
                        final String versionLookup;
                        if (maybeVersionValue.isPresent()) {
                            String versionValue = maybeVersionValue.get();
                            versionLookup = versionValue.startsWith(""${"") ?
                                    super.getResolutionResult().getPom().getValue(versionValue.trim()) :
                                    versionValue;
                        } else {
                            versionLookup = ""0.0.0"";
                        }

                        try {
                            ResolvedPom resolvedPom = getResolutionResult().getPom();
                            String tagGroupId = resolvedPom.getValue(tag.getChildValue(""groupId"").orElse(groupId));
                            String tagArtifactId = resolvedPom.getValue(tag.getChildValue(""artifactId"").orElse(artifactId));
                            assert tagGroupId != null;
                            assert tagArtifactId != null;
                            findNewerDependencyVersion(tagGroupId, tagArtifactId, versionLookup, ctx).ifPresent(newer ->
                                    doAfterVisit(new ChangePluginVersionVisitor(tagGroupId, tagArtifactId, newer, Boolean.TRUE.equals(addVersionIfMissing)))
                            );
                        } catch (MavenDownloadingException e) {
                            return e.warn(tag);
                        }
                    }
                    return tag;
                }
                return super.visitTag(tag, ctx);
            }

            private Optional<String> findNewerDependencyVersion(String groupId, String artifactId,
                                                                String currentVersion, ExecutionContext ctx) throws MavenDownloadingException {
                MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadPluginMetadata(groupId, artifactId, ctx));
                Collection<String> availableVersions = new ArrayList<>();
                for (String v : mavenMetadata.getVersioning().getVersions()) {
                    if (versionComparator.isValid(currentVersion, v)) {
                        availableVersions.add(v);
                    }
                }
                return versionComparator.upgrade(currentVersion, availableVersions);
            }
        });
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class ChangePluginVersionVisitor extends MavenVisitor<ExecutionContext> {
        String groupId;
        String artifactId;
        String newVersion;
        boolean addVersionIfMissing;

        @Override
        public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isPluginTag(groupId, artifactId)) {
                Optional<Xml.Tag> versionTag = tag.getChild(""version"");
                if (versionTag.isPresent()) {
                    String version = versionTag.get().getValue().orElse(null);
                    if (version != null) {
                        if (version.trim().startsWith(""${"")) {
                            if (!newVersion.equals(getResolutionResult().getPom().getValue(version.trim()))) {
                                doAfterVisit(new ChangePropertyValue(version, newVersion, false, false).getVisitor());
                            }
                        } else if (!newVersion.equals(version)) {
                            doAfterVisit(new ChangeTagValueVisitor<>(versionTag.get(), newVersion));
                        }
                    }
                } else if (addVersionIfMissing) {
                    Xml.Tag newTag = Xml.Tag.build(""<version>"" + newVersion + ""</version>"");
                    doAfterVisit(new AddToTagVisitor<>(tag, newTag, new MavenTagInsertionComparator(tag.getChildren())));
                }
            }
            return super.visitTag(tag, ctx);
        }
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Add a comment to a `Maven` dependency,Adds a comment as the first element in a `Maven` dependency.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.util.ArrayList;
import java.util.List;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddCommentToMavenDependency extends Recipe {

    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find matching tags."",
            example = ""/project/dependencies/dependency"")
    String xPath;

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Comment text"",
            description = ""The text to add as a comment.."",
            example = ""This is excluded due to CVE <X> and will be removed when we upgrade the next version is available."")
    String commentText;

    @Override
    public String getDisplayName() {
        return ""Add a comment to a `Maven` dependency"";
    }

    @Override
    public String getDescription() {
        return ""Adds a comment as the first element in a `Maven` dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            final XPathMatcher matcher = new XPathMatcher(xPath);

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (matcher.matches(getCursor()) && this.isDependencyTag(groupId, artifactId)) {
                    if (tag.getContent() != null) {
                        List<Content> contents = new ArrayList<>(tag.getContent());
                        boolean containsComment = contents.stream()
                                .anyMatch(c -> c instanceof Xml.Comment &&
                                        commentText.equals(((Xml.Comment) c).getText()));
                        if (!containsComment) {
                            int insertPos = 0;
                            Xml.Comment customComment = new Xml.Comment(randomId(),
                                    contents.get(insertPos).getPrefix(),
                                    Markers.EMPTY,
                                    commentText);
                            contents.add(insertPos, customComment);
                            t = t.withContent(contents);
                        }
                    }
                }
                return t;
            }
        };
    }
}
","{
  ""xPath"": ""String field"",
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""commentText"": ""String field""
}"
Use Maven compiler plugin release configuration,Replaces any explicit `source` or `target` configuration (if present) on the `maven-compiler-plugin` with ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.xml.AddOrUpdateChild.addOrUpdateChild;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterTagChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class UseMavenCompilerPluginReleaseConfiguration extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project//build//plugins"");

    @Option(
            displayName = ""Release version"",
            description = ""The new value for the release configuration. This recipe prefers ${java.version} if defined."",
            example = ""11""
    )
    Integer releaseVersion;

    @Override
    public String getDisplayName() {
        return ""Use Maven compiler plugin release configuration"";
    }

    @Override
    public String getDescription() {
        return ""Replaces any explicit `source` or `target` configuration (if present) on the `maven-compiler-plugin` with "" +
                ""`release`, and updates the `release` value if needed. Will not downgrade the Java version if the current version is higher."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (!isPluginTag(""org.apache.maven.plugins"", ""maven-compiler-plugin"")) {
                    return t;
                }
                Optional<Xml.Tag> maybeCompilerPluginConfig = t.getChild(""configuration"");
                if (!maybeCompilerPluginConfig.isPresent()) {
                    return t;
                }
                Xml.Tag compilerPluginConfig = maybeCompilerPluginConfig.get();
                Optional<String> source = compilerPluginConfig.getChildValue(""source"");
                Optional<String> target = compilerPluginConfig.getChildValue(""target"");
                Optional<String> release = compilerPluginConfig.getChildValue(""release"");
                if (!source.isPresent() && !target.isPresent() && !release.isPresent()) {
                    return t; // Do not introduce a new tag if none of the values are present
                }
                if (currentNewerThanProposed(source) ||
                        currentNewerThanProposed(target) ||
                        currentNewerThanProposed(release)) {
                    return t;
                }

                Xml.Tag updated = filterTagChildren(t, compilerPluginConfig,
                        child -> !(""source"".equals(child.getName()) || ""target"".equals(child.getName())));
                String releaseVersionValue = hasJavaVersionProperty(getCursor().firstEnclosingOrThrow(Xml.Document.class)) ?
                        ""${java.version}"" : releaseVersion.toString();
                return addOrUpdateChild(updated, compilerPluginConfig,
                        Xml.Tag.build(""<release>"" + releaseVersionValue + ""</release>""), getCursor().getParentOrThrow());
            }
        };
    }

    private boolean currentNewerThanProposed(@SuppressWarnings(""OptionalUsedAsFieldOrParameterType"") Optional<String> config) {
        if (!config.isPresent()) {
            return false;
        }
        try {
            float currentVersion = Float.parseFloat(config.get());
            float proposedVersion = Float.parseFloat(releaseVersion.toString());
            return proposedVersion < currentVersion;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private boolean hasJavaVersionProperty(Xml.Document xml) {
        return xml.getMarkers().findFirst(MavenResolutionResult.class)
                .map(r -> r.getPom().getProperties().get(""java.version"") != null)
                .orElse(false);
    }
}
","{
  ""releaseVersion"": ""Integer field""
}"
Remove duplicate Maven dependencies,Removes duplicated dependencies in the `<dependencies>` and `<dependencyManagement>` sections of the `pom.xml`.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.tree.Dependency;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedManagedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.time.Duration;
import java.util.*;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveDuplicateDependencies extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove duplicate Maven dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Removes duplicated dependencies in the `<dependencies>` and `<dependencyManagement>` sections of the `pom.xml`."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Tag root = document.getRoot();
                if (root.getChild(""dependencies"").isPresent() || root.getChild(""dependencyManagement"").isPresent()) {
                    return SearchResult.found(document);
                }
                return document;
            }
        }, new MavenIsoVisitor<ExecutionContext>() {
            private final XPathMatcher DEPENDENCIES_MATCHER = new XPathMatcher(""/project/dependencies"");
            private final XPathMatcher MANAGED_DEPENDENCIES_MATCHER = new XPathMatcher(""/project/dependencyManagement/dependencies"");

            @SuppressWarnings(""DataFlowIssue"")
            @Override
            public Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependenciesTag()) {
                    getCursor().putMessage(""dependencies"", new HashMap<DependencyKey, Xml.Tag>());
                } else if (isManagedDependenciesTag()) {
                    getCursor().putMessage(""managedDependencies"", new HashMap<DependencyKey, Xml.Tag>());
                } else if (isDependencyTag()) {
                    Map<DependencyKey, Xml.Tag> dependencies = getCursor().getNearestMessage(""dependencies"");
                    DependencyKey dependencyKey = getDependencyKey(tag);
                    if (dependencyKey != null) {
                        Xml.Tag existing = dependencies.putIfAbsent(dependencyKey, tag);
                        if (existing != null && existing != tag) {
                            maybeUpdateModel();
                            return null;
                        }
                    }
                } else if (isManagedDependencyTag()) {
                    Map<DependencyKey, Xml.Tag> dependencies = getCursor().getNearestMessage(""managedDependencies"");
                    DependencyKey dependencyKey = getManagedDependencyKey(tag);
                    if (dependencyKey != null) {
                        // Additionally compare classifier and type, which are only partially compared in `findManagedDependency`
                        String classifier = getResolutionResult().getPom().getValue(tag.getChildValue(""classifier"").orElse(null));
                        String type = getResolutionResult().getPom().getValue(tag.getChildValue(""type"").orElse(""jar""));
                        if (Objects.equals(classifier, dependencyKey.getClassifier()) &&
                                Objects.equals(type, dependencyKey.getType())) {
                            Xml.Tag existing = dependencies.putIfAbsent(dependencyKey, tag);
                            if (existing != null && existing != tag) {
                                maybeUpdateModel();
                                return null;
                            }
                        }

                    }
                }
                return super.visitTag(tag, ctx);
            }

            private boolean isDependenciesTag() {
                return DEPENDENCIES_MATCHER.matches(getCursor());
            }

            private boolean isManagedDependenciesTag() {
                return MANAGED_DEPENDENCIES_MATCHER.matches(getCursor());
            }

            private @Nullable DependencyKey getDependencyKey(Xml.Tag tag) {
                Map<Scope, List<ResolvedDependency>> dependencies = getResolutionResult().getDependencies();
                Scope scope = tag.getChildValue(""scope"").map(Scope::fromName).orElse(Scope.Compile);
                if (dependencies.containsKey(scope)) {
                    for (ResolvedDependency resolvedDependency : dependencies.get(scope)) {
                        Dependency req = resolvedDependency.getRequested();
                        String reqGroup = req.getGroupId();
                        if ((reqGroup == null || reqGroup.equals(tag.getChildValue(""groupId"").orElse(null))) &&
                                Objects.equals(req.getArtifactId(), tag.getChildValue(""artifactId"").orElse(null)) &&
                                Objects.equals(Optional.ofNullable(req.getType()).orElse(""jar""), tag.getChildValue(""type"").orElse(""jar"")) &&
                                Objects.equals(req.getClassifier(), tag.getChildValue(""classifier"").orElse(null))) {
                            return DependencyKey.from(resolvedDependency, scope);
                        }
                    }
                }
                return null;
            }

            private @Nullable DependencyKey getManagedDependencyKey(Xml.Tag tag) {
                if (tag.getChildValue(""scope"").filter(""import""::equalsIgnoreCase).isPresent()) {
                    return DependencyKey.from(tag);
                }
                ResolvedManagedDependency resolvedDependency = findManagedDependency(tag);
                return resolvedDependency != null ? DependencyKey.from(resolvedDependency) : null;
            }
        });
    }

    @Value
    private static class DependencyKey {
        @Nullable
        String groupId;

        String artifactId;
        String type;

        @Nullable
        String classifier;

        Scope scope;

        public static DependencyKey from(ResolvedDependency dependency, Scope scope) {
            return new DependencyKey(dependency.getGroupId(), dependency.getArtifactId(), dependency.getType(), dependency.getClassifier(), scope);
        }

        public static DependencyKey from(ResolvedManagedDependency dependency) {
            return new DependencyKey(dependency.getGroupId(), dependency.getArtifactId(), dependency.getType(), dependency.getClassifier(), Scope.Compile);
        }

        public static @Nullable DependencyKey from(Xml.Tag tag) {
            return tag.getChildValue(""artifactId"").map(artifactId ->
                    new DependencyKey(
                            tag.getChildValue(""groupId"").orElse(null),
                            artifactId,
                            tag.getChildValue(""type"").orElse(""jar""),
                            tag.getChildValue(""classifier"").orElse(null),
                            tag.getChildValue(""scope"").map(Scope::fromName).orElse(Scope.Compile)
                    )).orElse(null);
        }
    }
}
",{}
Remove Maven plugin,Remove the specified Maven plugin from the POM.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.search.FindPlugin;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemovePlugin extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Override
    public String getDisplayName() {
        return ""Remove Maven plugin"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Remove the specified Maven plugin from the POM."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                for (Xml.Tag plugin : FindPlugin.find(document, groupId, artifactId)) {
                    doAfterVisit(new RemoveContentVisitor<>(plugin, true, true));
                }
                return super.visitDocument(document, ctx);
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Upgrade Maven parent project version,Set the parent pom version number according to a [version selector](https://docs.openrewrite.org/reference/dependency-version-selectors) ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.semver.Semver;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradeParentVersion extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.springframework.boot:spring-boot-parent:VERSION'."",
            example = ""org.springframework.boot"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.springframework.boot:spring-boot-parent:VERSION'."",
            example = ""spring-boot-parent"")
    String artifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""29.X"")
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Only external"",
            description = ""Only upgrade `<parent>` if external to the project, i.e. it has an empty `<relativePath>`. Defaults to `false`."",
            required = false)
    @Nullable
    Boolean onlyExternal;

    @Override
    public String getDisplayName() {
        return ""Upgrade Maven parent project version"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""to `%s:%s:%s`"", groupId, artifactId, newVersion);
    }

    @Override
    public String getDescription() {
        return ""Set the parent pom version number according to a [version selector](https://docs.openrewrite.org/reference/dependency-version-selectors) "" +
               ""or to a specific version number."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        //noinspection ConstantConditions
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new ChangeParentPom(
                groupId,
                null,
                artifactId,
                null,
                newVersion,
                Boolean.TRUE.equals(onlyExternal) ? """" : null,
                null,
                versionPattern,
                false,
                null)
                .getVisitor();
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newVersion"": ""String field""
}"
Update Maven Java project properties,,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.tree.Plugin;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpdateMavenProjectPropertyJavaVersion extends Recipe {

    private static final List<String> JAVA_VERSION_PROPERTIES = Arrays.asList(
            ""java.version"",
            ""jdk.version"",
            ""javaVersion"",
            ""jdkVersion"",
            ""maven.compiler.source"",
            ""maven.compiler.target"",
            ""maven.compiler.release"",
            ""release.version"");

    private static final List<XPathMatcher> JAVA_VERSION_XPATH_MATCHERS =
            JAVA_VERSION_PROPERTIES.stream()
                    .map(property -> ""/project/properties/"" + property)
                    .map(XPathMatcher::new).collect(toList());

    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build//plugins"");

    @Option(displayName = ""Java version"",
            description = ""The Java version to upgrade to."",
            example = ""11"")
    Integer version;

    @Override
    public String getDisplayName() {
        return ""Update Maven Java project properties"";
    }

    @Override
    public String getDescription() {
        //language=markdown
        return ""The Java version is determined by several project properties, including:\n\n"" +
               "" * `java.version`\n"" +
               "" * `jdk.version`\n"" +
               "" * `javaVersion`\n"" +
               "" * `jdkVersion`\n"" +
               "" * `maven.compiler.source`\n"" +
               "" * `maven.compiler.target`\n"" +
               "" * `maven.compiler.release`\n"" +
               "" * `release.version`\n\n"" +
               ""If none of these properties are in use and the maven compiler plugin is not otherwise configured, adds the `maven.compiler.release` property."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            boolean compilerPluginConfiguredExplicitly;

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                // Update properties already defined in the current pom
                Xml.Document d = super.visitDocument(document, ctx);

                // Return early if the parent appears to be within the current repository, as properties defined there will be updated
                if (getResolutionResult().getParent() != null && getResolutionResult().parentPomIsProjectPom()) {
                    // Unless the plugin config in the parent defines source/target/release with a property
                    for (Plugin plugin : getResolutionResult().getParent().getPom().getPlugins()) {
                        if (""org.apache.maven.plugins"".equals(plugin.getGroupId()) && ""maven-compiler-plugin"".equals(plugin.getArtifactId()) && plugin.getConfiguration() != null) {
                            for (String property : JAVA_VERSION_PROPERTIES) {
                                if (getResolutionResult().getPom().getRequested().getProperties().get(property) != null) {
                                    try {
                                        float parsed = Float.parseFloat(getResolutionResult().getPom().getProperties().get(property));
                                        if (parsed < version &&
                                            ((plugin.getConfiguration().get(""source"") != null && plugin.getConfiguration().get(""source"").textValue().contains(property)) ||
                                            (plugin.getConfiguration().get(""target"") != null && plugin.getConfiguration().get(""target"").textValue().contains(property)) ||
                                            (plugin.getConfiguration().get(""release"") != null && plugin.getConfiguration().get(""release"").textValue().contains(property)))) {
                                            d = (Xml.Document) new AddPropertyVisitor(property, String.valueOf(version), null)
                                                    .visitNonNull(d, ctx);
                                            maybeUpdateModel();
                                        }
                                    } catch (NumberFormatException ignored) {
                                    }
                                }
                            }
                        }
                    }
                    return d;
                }

                // Otherwise override remote parent's properties locally
                Map<String, String> currentProperties = getResolutionResult().getPom().getProperties();
                boolean foundProperty = false;
                for (String property : JAVA_VERSION_PROPERTIES) {
                    String propertyValue = currentProperties.get(property);
                    if (propertyValue != null) {
                        foundProperty = true;
                        try {
                            if (Float.parseFloat(propertyValue) < version) {
                                d = (Xml.Document) new AddProperty(property, String.valueOf(version), null, false)
                                        .getVisitor()
                                        .visitNonNull(d, ctx);
                                maybeUpdateModel();
                            }
                        } catch (NumberFormatException ex) {
                            // either an expression or something else, don't touch
                        }
                    }
                }

                // When none of the relevant properties are explicitly configured Maven defaults to Java 8
                // The release option was added in 9
                // If no properties have yet been updated then set release explicitly
                if (!foundProperty && version >= 9 && !compilerPluginConfiguredExplicitly) {
                    d = (Xml.Document) new AddProperty(""maven.compiler.release"", String.valueOf(version), null, false)
                            .getVisitor()
                            .visitNonNull(d, ctx);
                    maybeUpdateModel();
                }

                return d;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (isPluginTag(""org.apache.maven.plugins"", ""maven-compiler-plugin"")) {
                    t.getChild(""configuration"").ifPresent(compilerPluginConfig -> {
                        if (compilerPluginConfig.getChildValue(""source"").isPresent() ||
                            compilerPluginConfig.getChildValue(""target"").isPresent() ||
                            compilerPluginConfig.getChildValue(""release"").isPresent()) {
                            compilerPluginConfiguredExplicitly = true;
                        }
                    });
                }
                return t;
            }
        };
    }
}
","{
  ""version"": ""Integer field""
}"
Add Maven plugin dependencies,Adds the specified dependencies to a Maven plugin. Will not add the plugin if it does not already exist in the pom.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.xml.AddToTagVisitor.addToTag;
import static org.openrewrite.xml.MapTagChildrenVisitor.mapTagChildren;
import static org.openrewrite.xml.SemanticallyEqual.areEqual;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddPluginDependency extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build/plugins"");

    @Option(displayName = ""Plugin group"",
            description = ""Group ID of the plugin to which the dependency will be added. "" +
                    ""A group ID is the first part of a dependency coordinate `org.openrewrite.maven:rewrite-maven-plugin:VERSION`."",
            example = ""org.openrewrite.maven"")
    String pluginGroupId;

    @Option(displayName = ""Plugin artifact"",
            description = ""Artifact ID of the plugin to which the dependency will be added."" +
                    ""The second part of a dependency coordinate `org.openrewrite.maven:rewrite-maven-plugin:VERSION`."",
            example = ""rewrite-maven-plugin"")
    String pluginArtifactId;

    @Option(displayName = ""Group"",
            description = ""The group ID of the dependency to add."",
            example = ""org.openrewrite.recipe"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The artifact ID of the dependency to add."",
            example = ""org.openrewrite.recipe"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""The version of the dependency to add."",
            example = ""org.openrewrite.recipe"")
    @Nullable
    String version;

    @Override
    public String getDisplayName() {
        return ""Add Maven plugin dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Adds the specified dependencies to a Maven plugin. Will not add the plugin if it does not already exist in the pom."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag plugin = (Xml.Tag) super.visitTag(tag, ctx);
                if (!isPluginTag(pluginGroupId, pluginArtifactId)) {
                    return plugin;
                }
                Optional<Xml.Tag> maybeDependencies = plugin.getChild(""dependencies"");
                Xml.Tag dependencies;
                boolean formatAllDependencies = false;
                if (maybeDependencies.isPresent()) {
                    dependencies = maybeDependencies.get();
                } else {
                    formatAllDependencies = true;
                    dependencies = Xml.Tag.build(""<dependencies />"").withPrefix(""\n"");
                    plugin = addToTag(plugin, plugin, dependencies, getCursor().getParentOrThrow());
                }
                Xml.Tag newDependencyTag = Xml.Tag.build(""<dependency>\n<groupId>"" + groupId + ""</groupId>\n<artifactId>"" +
                                artifactId + ""</artifactId>"" + ((version == null) ? ""\n"" : ""\n<version>"" + version + ""</version>\n"") + ""</dependency>"")
                        .withPrefix(""\n"");

                // The dependency being added may already exist and may or may not need its version updated
                Optional<Xml.Tag> maybeExistingDependency = dependencies.getChildren()
                        .stream()
                        .filter(it -> groupId.equals(it.getChildValue(""groupId"").orElse(null)) &&
                                artifactId.equals(it.getChildValue(""artifactId"").orElse(null)))
                        .findAny();
                if (maybeExistingDependency.isPresent() && areEqual(newDependencyTag, maybeExistingDependency.get())) {
                    return plugin;
                }
                if (maybeExistingDependency.isPresent()) {
                    plugin = mapTagChildren(plugin, dependencies, it -> {
                        if (it == maybeExistingDependency.get()) {
                            return newDependencyTag;
                        }
                        return it;
                    });
                } else {
                    plugin = addToTag(plugin, dependencies, newDependencyTag, getCursor().getParentOrThrow());
                }
                if (formatAllDependencies) {
                    plugin = autoFormat(plugin, dependencies, ctx, getCursor().getParentOrThrow());
                } else {
                    plugin = autoFormat(plugin, newDependencyTag, ctx, getCursor().getParentOrThrow());
                }
                return plugin;
            }
        };
    }
}
","{
  ""pluginGroupId"": ""String field"",
  ""pluginArtifactId"": ""String field"",
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Add Maven parent,Add a parent pom to a Maven pom.xml. Does nothing if a parent pom is already present.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.MavenMetadata;
import org.openrewrite.maven.tree.MavenRepository;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Collection;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddParentPom extends Recipe {
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group ID"",
            description = ""The group ID of the maven parent pom to be adopted."",
            example = ""org.springframework.boot"")
    String groupId;

    @Option(displayName = ""Artifact ID"",
            description = ""The artifact ID of the maven parent pom to be adopted."",
            example = ""spring-boot-starter-parent"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""29.X"")
    String version;

    @Option(displayName = ""Relative path"",
            description = ""New relative path attribute for parent lookup."",
            example = ""../pom.xml"")
    @Nullable
    String relativePath;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Override
    public String getDisplayName() {
        return ""Add Maven parent"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add a parent pom to a Maven pom.xml. Does nothing if a parent pom is already present."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        //noinspection ConstantConditions
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Tag root = document.getRoot();
                if (!root.getChild(""parent"").isPresent()) {
                    return SearchResult.found(document);
                }
                return document;

            }
        }, new MavenIsoVisitor<ExecutionContext>() {
            @Nullable
            private Collection<String> availableVersions;

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Tag root = document.getRoot();
                assert !root.getChild(""parent"").isPresent();

                try {
                    Optional<String> targetVersion = findAcceptableVersion(groupId, artifactId, ctx);
                    if (targetVersion.isPresent()) {
                        Xml.Tag parentTag = Xml.Tag.build(
                                ""<parent>\n"" +
                                ""<groupId>"" + groupId + ""</groupId>\n"" +
                                ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                                ""<version>"" + targetVersion.get() + ""</version>\n"" +
                                (relativePath == null ? """" : StringUtils.isBlank(relativePath) ?
                                        ""<relativePath/>"" : ""<relativePath>"" + relativePath + ""</relativePath>"") +
                                ""</parent>"");

                        document = (Xml.Document) new AddToTagVisitor<>(root, parentTag, new MavenTagInsertionComparator(root.getChildren()))
                                .visitNonNull(document, ctx, getCursor().getParentOrThrow());

                        maybeUpdateModel();
                        doAfterVisit(new RemoveRedundantDependencyVersions(null, null,
                                RemoveRedundantDependencyVersions.Comparator.GTE, null).getVisitor());
                    }
                } catch (MavenDownloadingException e) {
                    for (Map.Entry<MavenRepository, String> repositoryResponse : e.getRepositoryResponses().entrySet()) {
                        MavenRepository repository = repositoryResponse.getKey();
                        metadataFailures.insertRow(ctx, new MavenMetadataFailures.Row(groupId, artifactId, version,
                                repository.getUri(), repository.getSnapshots(), repository.getReleases(), repositoryResponse.getValue()));
                    }
                    return e.warn(document);
                }

                return super.visitDocument(document, ctx);
            }

            private final VersionComparator versionComparator = Objects.requireNonNull(Semver.validate(version, versionPattern).getValue());

            private Optional<String> findAcceptableVersion(String groupId, String artifactId, ExecutionContext ctx)
                    throws MavenDownloadingException {
                if (availableVersions == null) {
                    MavenMetadata mavenMetadata = metadataFailures.insertRows(ctx, () -> downloadMetadata(groupId, artifactId, ctx));
                    availableVersions = mavenMetadata.getVersioning().getVersions().stream()
                            .filter(v -> versionComparator.isValid(null, v))
                            .collect(toList());
                }
                return availableVersions.stream().max(versionComparator);
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""version"": ""String field""
}"
Change Maven plugin configuration,Apply the specified configuration to a Maven plugin. Will not add the plugin if it does not already exist in the pom.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.xml.AddOrUpdateChild.addOrUpdateChild;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePluginConfiguration extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build/plugins"");

    @Option(displayName = ""Group"",
            description = ""The first part of the coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION' of the plugin to modify."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION' of the plugin to modify."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Language(""xml"")
    @Option(displayName = ""Configuration"",
            description = ""Plugin configuration provided as raw XML overriding any existing configuration. "" +
                          ""Configuration inside `<executions>` blocks will not be altered. "" +
                          ""Supplying `null` will remove any existing configuration."",
            example = ""<foo>bar</foo>"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change Maven plugin configuration"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Apply the specified configuration to a Maven plugin. Will not add the plugin if it does not already exist in the pom."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag plugins = (Xml.Tag) super.visitTag(tag, ctx);
                if (PLUGINS_MATCHER.matches(getCursor())) {
                    Optional<Xml.Tag> maybePlugin = plugins.getChildren().stream()
                            .filter(plugin ->
                                    ""plugin"".equals(plugin.getName()) &&
                                    groupId.equals(plugin.getChildValue(""groupId"").orElse(null)) &&
                                    artifactId.equals(plugin.getChildValue(""artifactId"").orElse(null))
                            )
                            .findAny();
                    if (maybePlugin.isPresent()) {
                        Xml.Tag plugin = maybePlugin.get();
                        if (configuration == null) {
                            plugins = filterChildren(plugins, plugin,
                                    child -> !(child instanceof Xml.Tag && ""configuration"".equals(((Xml.Tag) child).getName())));
                        } else  {
                            plugins = addOrUpdateChild(plugins, plugin,
                                    Xml.Tag.build(""<configuration>\n"" + configuration + ""\n</configuration>""),
                                    getCursor().getParentOrThrow());
                        }
                    }
                }
                return plugins;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Update SCM with Git origin,Updates or adds the Maven `<scm>` tag based on the Git remote origin. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.GitProvenance;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.openrewrite.internal.StringUtils.isNullOrEmpty;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpdateScmFromGitOrigin extends Recipe {

    @Option(displayName = ""Add if missing"",
            description = ""If set to `true`, the recipe will add a `<scm>` section if it is missing. "" +
                          ""If set to `false` (default), the recipe will only update existing `<scm>` sections."",
            required = false)
    @Nullable
    Boolean addIfMissing;

    @Override
    public String getDisplayName() {
        return ""Update SCM with Git origin"";
    }

    @Override
    public String getDescription() {
        return ""Updates or adds the Maven `<scm>` tag based on the Git remote origin. "" +
               ""By default, only existing Source Control Management (SCM) sections are updated. Set `addIfMissing` to `true` to also add missing SCM sections."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {

            @SuppressWarnings(""NotNullFieldNotInitialized"")
            GitOrigin gitOrigin;

            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Optional<GitOrigin> maybeOrigin = document.getMarkers().findFirst(GitProvenance.class)
                        .map(GitProvenance::getOrigin)
                        .map(GitOrigin::parseGitUrl);
                if(!maybeOrigin.isPresent()) {
                    return document;
                }
                gitOrigin = maybeOrigin.get();

                if(!document.getRoot().getChild(""scm"").isPresent()) {
                    if (Boolean.TRUE.equals(addIfMissing)) {
                        // Build the SCM tag with all required elements
                        String httpUrl = ""https://"" + gitOrigin.getHost() + ""/"" + gitOrigin.getPath();
                        String gitPath = gitOrigin.getPath().endsWith("".git"") ?
                                gitOrigin.getPath().substring(0, gitOrigin.getPath().length() - 4) : gitOrigin.getPath();
                        String scmContent = ""<scm>\n"" +
                                ""  <url>"" + httpUrl + ""</url>\n"" +
                                ""  <connection>scm:git:"" + httpUrl + (httpUrl.endsWith("".git"") ? """" : "".git"") + ""</connection>\n"" +
                                ""  <developerConnection>scm:git:git@"" + gitOrigin.getHost() + "":"" + gitPath + "".git</developerConnection>\n"" +
                                ""</scm>"";
                        document = (Xml.Document) new AddToTagVisitor<>(document.getRoot(), Xml.Tag.build(scmContent),
                                new MavenTagInsertionComparator(document.getRoot().getChildren()))
                                .visitNonNull(document, ctx, Objects.requireNonNull(getCursor().getParent()));

                    }
                    return document;
                }

                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (""project"".equals(tag.getName())) {
                    return super.visitTag(tag, ctx);
                } else if (""scm"".equals(tag.getName())) {
                    // Update existing tags, preserving their URL structure
                    tag = updateScmTag(tag, ""url"", ctx);
                    tag = updateScmTag(tag, ""connection"", ctx);
                    tag = updateScmTag(tag, ""developerConnection"", ctx);
                }
                return tag;
            }

            private Xml.Tag updateScmTag(Xml.Tag tag, String tagName, ExecutionContext ctx) {
                Optional<Xml.Tag> maybeChild = tag.getChild(tagName);
                if (maybeChild.isPresent()) {
                    Xml.Tag childTag = maybeChild.get();
                    String originalUrl = childTag.getValue().orElse("""");
                    String updatedUrl = gitOrigin.replaceHostAndPath(originalUrl);
                    if (!originalUrl.equals(updatedUrl)) {
                        tag = (Xml.Tag) new ChangeTagValueVisitor<>(childTag, updatedUrl)
                                .visitNonNull(tag, ctx, getCursor().getParentTreeCursor());
                    }
                }
                return tag;
            }
        };
    }

    @Value
    static class GitOrigin {
        private static final Pattern[] URL_PATTERNS = {
                // SSH format: git@host:path(.git)?
                Pattern.compile(""^git@([^:]+):(.+?)(?:\\.git)?$""),

                // HTTP/HTTPS with optional username and port: http(s)://[username@]host[:port]/path(.git)?
                Pattern.compile(""^https?://(?:[^@]+@)?([^/:]+(?::[0-9]+)?)/(.+?)(?:\\.git)?$""),

                // SSH with protocol and port: ssh://git@host[:port]/path(.git)?
                Pattern.compile(""^ssh://git@([^/:]+(?::[0-9]+)?)/(.+?)(?:\\.git)?$""),

                // Generic protocol://[user@]host[:port]/path(.git)? - catches any other protocols
                Pattern.compile(""^[a-zA-Z][a-zA-Z0-9+.-]*://(?:[^@]+@)?([^/:]+(?::[0-9]+)?)/(.+?)(?:\\.git)?$"")
        };

        String host;
        String path;

        static @Nullable GitOrigin parseGitUrl(String gitUrl) {
            if (!isNullOrEmpty(gitUrl)) {
                for (Pattern pattern : URL_PATTERNS) {
                    Matcher matcher = pattern.matcher(gitUrl);
                    if (matcher.matches()) {
                        return new GitOrigin(matcher.group(1), matcher.group(2));
                    }
                }
            }
            return null;
        }

        String replaceHostAndPath(String originalUrl) {
            if (isNullOrEmpty(originalUrl)) {
                return originalUrl;
            }

            if (originalUrl.startsWith(""scm:git:"")) {
                String actualUrl = originalUrl.substring(""scm:git:"".length());
                return ""scm:git:"" + replaceHostAndPath(actualUrl);
            }

            // Handle git@ format (SSH)
            if (originalUrl.startsWith(""git@"")) {
                // First check if the URL already has the correct host and path
                String expectedPrefix = ""git@"" + host + "":"" + path;
                if (originalUrl.startsWith(expectedPrefix)) {
                    return originalUrl; // Already correct, don't modify
                }

                // Otherwise, replace the host and path
                Matcher gitMatcher = Pattern.compile(""^git@[^:]+:(.+?)$"").matcher(originalUrl);
                if (gitMatcher.matches()) {
                    String originalFullPath = gitMatcher.group(1);
                    // Check if original path ends with .git
                    boolean hasGitExtension = originalFullPath.endsWith("".git"");

                    // Build new URL
                    String newUrl = ""git@"" + host + "":"" + path;
                    if (hasGitExtension && !path.endsWith("".git"")) {
                        newUrl += "".git"";
                    }
                    return newUrl;
                }
            }

            // Handle protocol-based URLs (http, https, ssh, etc.)
            Matcher protocolMatcher = Pattern.compile(""^([a-zA-Z][a-zA-Z0-9+.-]*://)(?:([^@/]+)@)?([^/]+)(/[^?#]*)?(.*)?$"").matcher(originalUrl);
            if (protocolMatcher.find()) {
                String protocol = protocolMatcher.group(1);
                String user = protocolMatcher.group(2);
                String originalHost = protocolMatcher.group(3);
                String originalPath = protocolMatcher.group(4);
                String suffix = protocolMatcher.group(5) != null ? protocolMatcher.group(5) : """";

                String userPrefix = (user != null) ? user + ""@"" : """";

                // Determine if we need to add .git extension
                boolean needsGitExtension = originalPath != null && originalPath.endsWith("".git"") && !path.endsWith("".git"");
                String newPath = ""/"" + path + (needsGitExtension ? "".git"" : """");

                // Check if the base URL already matches (to preserve suffixes)
                String newBaseUrl = protocol + userPrefix + host + newPath;
                if (originalUrl.startsWith(newBaseUrl)) {
                    return originalUrl; // Already correct, preserve any suffix
                }

                return newBaseUrl + suffix;
            }

            // Return the original URL if no patterns matched
            return originalUrl;
        }
    }
}
",{}
Manage dependencies,Make existing dependencies managed by moving their version to be specified in the dependencyManagement section of the POM.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.tree.*;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * Make existing dependencies ""dependency managed"", moving the version to the dependencyManagement
 * section of the POM.
 * <p>
 * All dependencies that match {@link #groupPattern} and {@link #artifactPattern} should be
 * align-able to the same version (either the version provided to this visitor or the maximum matching
 * version if none is provided).
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class ManageDependencies extends ScanningRecipe<Map<GroupArtifactVersion, Collection<ResolvedDependency>>> {
    private static final XPathMatcher MANAGED_DEPENDENCIES_MATCHER = new XPathMatcher(""/project/dependencyManagement/dependencies"");

    @Option(displayName = ""Group"",
            description = ""Group glob expression pattern used to match dependencies that should be managed."" +
                          ""Group is the first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.*"")
    String groupPattern;

    @Option(displayName = ""Artifact"",
            description = ""Artifact glob expression pattern used to match dependencies that should be managed."" +
                          ""Artifact is the second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava*"",
            required = false)
    @Nullable
    String artifactPattern;

    @Option(displayName = ""Add to the root POM"",
            description = ""Add to the root POM where root is the eldest parent of the pom within the source set."",
            required = false)
    @Nullable
    Boolean addToRootPom;

    @Option(displayName = ""Skip model updates"",
            description = ""Optionally skip updating the dependency model after managing dependencies. "" +
                          ""Updating the model does not affect the source code of the POM,"" +
                          ""but will cause the resolved dependency model to reflect the changes made to the POM. "" +
                          ""If this recipe is ran standalone, it is not necessary to update the model."",
            required = false)
    @Nullable
    Boolean skipModelUpdate;

    @Override
    public String getDisplayName() {
        return ""Manage dependencies"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupPattern, artifactPattern);
    }

    @Override
    public String getDescription() {
        return ""Make existing dependencies managed by moving their version to be specified in the dependencyManagement section of the POM."";
    }

    @Override
    public Map<GroupArtifactVersion, Collection<ResolvedDependency>> getInitialValue(ExecutionContext ctx) {
        return new HashMap<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Map<GroupArtifactVersion, Collection<ResolvedDependency>> rootGavToDependencies) {
        return Preconditions.check(Boolean.TRUE.equals(addToRootPom), new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document doc = super.visitDocument(document, ctx);
                Collection<ResolvedDependency> manageableDependencies = findDependencies(groupPattern, artifactPattern != null ? artifactPattern : ""*"");
                ResolvedGroupArtifactVersion root = findRootPom(getResolutionResult()).getPom().getGav();
                rootGavToDependencies.computeIfAbsent(new GroupArtifactVersion(root.getGroupId(), root.getArtifactId(), root.getVersion()), v -> new ArrayList<>()).addAll(manageableDependencies);
                return doc;
            }
        });
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Map<GroupArtifactVersion, Collection<ResolvedDependency>> rootGavToDependencies) {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml maven = super.visitDocument(document, ctx);

                Collection<ResolvedDependency> manageableDependencies;
                if (Boolean.TRUE.equals(addToRootPom)) {
                    ResolvedPom pom = getResolutionResult().getPom();
                    GroupArtifactVersion gav = new GroupArtifactVersion(pom.getGav().getGroupId(), pom.getGav().getArtifactId(), pom.getGav().getVersion());
                    manageableDependencies = rootGavToDependencies.get(gav);
                } else {
                    manageableDependencies = findDependencies(groupPattern, artifactPattern != null ? artifactPattern : ""*"");
                }

                if (manageableDependencies != null) {
                    Map<GroupArtifact, ResolvedDependency> maxVersionByGroupArtifact = new HashMap<>(manageableDependencies.size());

                    for (ResolvedDependency rmd : manageableDependencies) {
                        String alreadyManagedVersion = getResolutionResult().getPom().getManagedVersion(rmd.getGroupId(), rmd.getArtifactId(), rmd.getType(),
                                rmd.getClassifier());
                        if (rmd.getDepth() <= 1 && alreadyManagedVersion == null) {
                            maxVersionByGroupArtifact.compute(new GroupArtifact(rmd.getGroupId(), rmd.getArtifactId()),
                                    (ga, existing) -> existing == null || existing.getVersion().compareTo(rmd.getVersion()) < 0 ?
                                            rmd : existing);
                        }
                    }

                    for (ResolvedDependency rmd : maxVersionByGroupArtifact.values()) {
                        doAfterVisit(new AddManagedDependencyVisitor(rmd.getGroupId(),
                                rmd.getArtifactId(), rmd.getVersion(), null,
                                null, rmd.getRequested().getClassifier()));
                        if (!Boolean.TRUE.equals(skipModelUpdate)) {
                            maybeUpdateModel();
                        }
                    }
                }

                doAfterVisit(new RemoveVersionTagVisitor(groupPattern, artifactPattern != null ? artifactPattern : ""*""));
                return maven;
            }
        };
    }

    private MavenResolutionResult findRootPom(MavenResolutionResult pom) {
        if (pom.getParent() == null) {
            return pom;
        }
        return findRootPom(pom.getParent());
    }

    private static class RemoveVersionTagVisitor extends MavenIsoVisitor<ExecutionContext> {
        private final String groupPattern;
        private final String artifactPattern;

        public RemoveVersionTagVisitor(String groupPattern, String artifactPattern) {
            this.groupPattern = groupPattern;
            this.artifactPattern = artifactPattern;
        }

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isDependencyTag() && isDependencyTag(groupPattern, artifactPattern)) {
                tag.getChild(""version"").ifPresent(versionTag -> doAfterVisit(new RemoveContentVisitor<>(versionTag, false, true)));
                return tag;
            }
            return super.visitTag(tag, ctx);
        }
    }
}
","{
  ""groupPattern"": ""String field""
}"
Change Maven plugin dependencies,Applies the specified dependencies to a Maven plugin. Will not add the plugin if it does not already exist in the pom.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Arrays;
import java.util.Optional;

import static java.util.stream.Collectors.joining;
import static org.openrewrite.xml.AddOrUpdateChild.addOrUpdateChild;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePluginDependencies extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build/plugins"");

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Option(displayName = ""Dependencies"",
            description = ""Plugin dependencies provided as dependency coordinates of format \""groupId:artifactId:version\"". "" +
                          ""When supplying multiple coordinates separate them with \"",\"". "" +
                          ""Supplying `null` will remove any existing plugin dependencies."",
            example = ""org.openrewrite.recipe:rewrite-spring:1.0.0, org.openrewrite.recipe:rewrite-testing-frameworks:1.0.0"",
            required = false)
    @Nullable
    String dependencies;

    @Override
    public String getDisplayName() {
        return ""Change Maven plugin dependencies"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Applies the specified dependencies to a Maven plugin. Will not add the plugin if it does not already exist in the pom."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Xml.Tag dependenciesTag;
        if (dependencies == null) {
            dependenciesTag = null;
        } else {
            dependenciesTag = Xml.Tag.build(
                    ""<dependencies>\n"" +
                    Arrays.stream(dependencies.split("",""))
                            .map(String::trim)
                            .map(gav -> {
                                String[] gavs = gav.split("":"");
                                return ""<dependency>\n<groupId>"" + gavs[0] + ""</groupId>\n<artifactId>"" + gavs[1] +
                                       ""</artifactId>\n<version>"" + gavs[2] + ""</version>\n</dependency>"";
                            }).collect(joining(""\n"")) +
                    ""\n</dependencies>\n"");
        }
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag plugins = (Xml.Tag) super.visitTag(tag, ctx);
                if (PLUGINS_MATCHER.matches(getCursor())) {
                    Optional<Xml.Tag> maybePlugin = plugins.getChildren().stream()
                            .filter(plugin ->
                                    ""plugin"".equals(plugin.getName()) &&
                                    groupId.equals(plugin.getChildValue(""groupId"").orElse(null)) &&
                                    artifactId.equals(plugin.getChildValue(""artifactId"").orElse(null))
                            )
                            .findAny();
                    if (maybePlugin.isPresent()) {
                        Xml.Tag plugin = maybePlugin.get();
                        if (dependencies == null) {
                            plugins = filterChildren(plugins, plugin, child -> !(child instanceof Xml.Tag && ""dependencies"".equals(((Xml.Tag) child).getName())));
                        } else {
                            plugins = addOrUpdateChild(plugins, plugin, dependenciesTag, getCursor().getParentOrThrow());
                        }
                    }
                }
                return plugins;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Remove redundant properties,Remove properties when a parent POM specifies the same property.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.Pom;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Map;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;
import static org.openrewrite.internal.StringUtils.isNullOrEmpty;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveRedundantProperties extends Recipe {
    @Option(displayName = ""Property name"",
            description = ""Property name glob expression pattern used to match properties that should be checked."",
            example = ""*.version"",
            required = false)
    @Nullable
    String namePattern;

    @Option(displayName = ""Only if values match"",
            description = ""Only remove the property if its value exactly matches the property value in the parent pom. "" +
                    ""Default `false`."",
            required = false)
    @Nullable
    Boolean onlyIfValuesMatch;

    @Override
    public String getDisplayName() {
        return ""Remove redundant properties"";
    }

    @Override
    public String getDescription() {
        return ""Remove properties when a parent POM specifies the same property."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (isMatchingPropertyTag(tag) && hasMatchingValue(tag, ctx)) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                    maybeUpdateModel();
                }

                return t;
            }

            private boolean isMatchingPropertyTag(Xml.Tag tag) {
                return isPropertyTag() && (isNullOrEmpty(namePattern) || matchesGlob(tag.getName(), namePattern));
            }

            private boolean hasMatchingValue(Xml.Tag tag, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                Map<String, String> parentProperties;
                if (mrr.getParent() == null) {
                    MavenPomDownloader downloader = new MavenPomDownloader(
                            mrr.getProjectPoms(),
                            ctx,
                            mrr.getMavenSettings(),
                            mrr.getActiveProfiles());
                    try {
                        // Resolve the external parent POM properties
                        parentProperties = mrr
                                .getPom()
                                .getRequested()
                                .withProperties(emptyMap())
                                .withDependencies(emptyList())
                                .withDependencyManagement(emptyList())
                                .withPlugins(emptyList())
                                .withPluginManagement(emptyList())
                                .resolve(mrr.getActiveProfiles(), downloader, ctx)
                                .getProperties();
                    } catch (MavenDownloadingException e) {
                        return false;
                    }
                } else {
                    parentProperties = mrr.getParent().getPom().getProperties();
                }
                String parentPropertyValue = parentProperties.get(tag.getName());
                if (parentPropertyValue == null) {
                    return false;
                }
                if (!Boolean.TRUE.equals(onlyIfValuesMatch)) {
                    return true;
                }
                return tag.getValue()
                        .map(parentPropertyValue::equals)
                        .orElse(false);
            }
        };
    }
}
",{}
Upgrade Maven dependency version,Upgrade the version of a dependency by specifying a group and (optionally) an artifact using Node Semver ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.trait.MavenDependency;
import org.openrewrite.maven.tree.*;
import org.openrewrite.maven.utilities.RetainVersions;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

import java.nio.file.Path;
import java.util.*;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.internal.StringUtils.matchesGlob;

/**
 * Upgrade the version of a dependency by specifying a group or group and artifact using Node Semver
 * <a href=""https://github.com/npm/node-semver#advanced-range-syntax"">advanced range selectors</a>, allowing
 * more precise control over version updates to patch or minor releases.
 * <P><P>
 * NOTES:
 * <li>If a version is defined as a property, this recipe will only change the property value if the property exists within the same pom.</li>
 * <li>This recipe will alter the managed version of the dependency if it exists in the pom.</li>
 * <li>The default behavior for managed dependencies is to leave them unaltered unless the ""overrideManagedVersion"" is set to true.</li>
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVersion.Accumulator> {
    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)"",
            example = ""29.X"")
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'newVersion' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Override managed version"",
            description = ""This flag can be set to explicitly override a managed dependency's version. The default for this flag is `false`."",
            required = false)
    @Nullable
    Boolean overrideManagedVersion;

    @Option(displayName = ""Retain versions"",
            description = ""Accepts a list of GAVs. For each GAV, if it is a project direct dependency, and it is removed "" +
                          ""from dependency management after the changes from this recipe, then it will be retained with an explicit version. "" +
                          ""The version can be omitted from the GAV to use the old value from dependency management"",
            example = ""com.jcraft:jsch"",
            required = false)
    @Nullable
    List<String> retainVersions;

    @SuppressWarnings(""ConstantConditions"")
    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    @Override
    public String getDisplayName() {
        return ""Upgrade Maven dependency version"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, newVersion);
    }

    @Override
    public String getDescription() {
        return ""Upgrade the version of a dependency by specifying a group and (optionally) an artifact using Node Semver "" +
               ""advanced range selectors, allowing more precise control over version updates to patch or minor releases."";
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator accumulator) {
        return new MavenIsoVisitor<ExecutionContext>() {
            private final VersionComparator versionComparator =
                    requireNonNull(Semver.validate(newVersion, versionPattern).getValue());

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                ResolvedPom pom = getResolutionResult().getPom();
                accumulator.projectArtifacts.add(new GroupArtifact(pom.getGroupId(), pom.getArtifactId()));
                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {
                if (isDependencyTag(groupId, artifactId)) {
                    ResolvedDependency d = findDependency(tag);
                    if (d != null && d.getRepository() != null) {
                        // if the resolved dependency exists AND it does not represent an artifact that was parsed
                        // as a source file, attempt to find a new version.
                        try {
                            String newerVersion = MavenDependency.findNewerVersion(d.getGroupId(), d.getArtifactId(), d.getVersion(), getResolutionResult(), metadataFailures,
                                    versionComparator, ctx);
                            if (newerVersion != null) {
                                Optional<Xml.Tag> version = tag.getChild(""version"");
                                if (version.isPresent()) {
                                    String requestedVersion = d.getRequested().getVersion();
                                    if (isProperty(requestedVersion)) {
                                        String propertyName = requestedVersion.substring(2, requestedVersion.length() - 1);
                                        if (!getResolutionResult().getPom().getRequested().getProperties().containsKey(propertyName)) {
                                            storeParentPomProperty(getResolutionResult().getParent(), propertyName, newerVersion);
                                        }
                                    }
                                }
                            }
                        } catch (MavenDownloadingException e) {
                            return e.warn(tag);
                        }
                    }
                }
                return super.visitTag(tag, ctx);
            }

            /**
             * Recursively look for a parent POM that's still part of the sources, which contains the version property.
             * If found, store the property in the accumulator, such that we can update that source file later.
             * @param currentMavenResolutionResult the current Maven resolution result parent to search for the property
             * @param propertyName the name of the property to update, if found in any the parent pom source file
             * @param newerVersion the resolved newer version that any matching parent pom property should be updated to
             */
            private void storeParentPomProperty(@Nullable MavenResolutionResult currentMavenResolutionResult, String propertyName, String newerVersion) {
                if (currentMavenResolutionResult == null) {
                    return; // No parent contained the property; might then be in the same source file, or an import BOM
                }
                Pom pom = currentMavenResolutionResult.getPom().getRequested();
                if (pom.getSourcePath() == null) {
                    return; // Not a source file, so nothing to update
                }
                if (pom.getProperties().containsKey(propertyName)) {
                    accumulator.pomProperties.add(new PomProperty(pom.getSourcePath(), propertyName, newerVersion));
                    return; // Property found, so no further searching is needed
                }
                storeParentPomProperty(currentMavenResolutionResult.getParent(), propertyName, newerVersion);
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator accumulator) {
        return new MavenIsoVisitor<ExecutionContext>() {
            private final VersionComparator versionComparator = requireNonNull(Semver.validate(newVersion, versionPattern).getValue());

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                try {
                    if (isPropertyTag()) {
                        Path pomSourcePath = getResolutionResult().getPom().getRequested().getSourcePath();
                        for (PomProperty pomProperty : accumulator.pomProperties) {
                            if (pomProperty.pomFilePath.equals(pomSourcePath) &&
                                pomProperty.propertyName.equals(tag.getName())) {
                                Optional<String> value = tag.getValue();
                                if (!value.isPresent() || !value.get().equals(pomProperty.propertyValue)) {
                                    doAfterVisit(new ChangeTagValueVisitor<>(tag, pomProperty.propertyValue));
                                    maybeUpdateModel();
                                }
                                break;
                            }
                        }
                    } else if (isDependencyTag(groupId, artifactId)) {
                        t = upgradeDependency(ctx, t);
                    } else if (isManagedDependencyTag(groupId, artifactId)) {
                        if (isManagedDependencyImportTag(groupId, artifactId)) {
                            doAfterVisit(new UpgradeDependencyManagementImportVisitor());
                        } else {
                            TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency = upgradeManagedDependency(tag, ctx, t);
                            if (upgradeManagedDependency != null) {
                                doAfterVisit(upgradeManagedDependency);
                                maybeUpdateModel();
                            }
                        }
                    } else if (isPluginDependencyTag(groupId, artifactId)) {
                        t = upgradePluginDependency(ctx, t);
                    }
                } catch (MavenDownloadingException e) {
                    return e.warn(t);
                }

                if (t != tag && isProjectTag()) {
                    maybeUpdateModel();
                    doAfterVisit(new RemoveRedundantDependencyVersions(groupId, artifactId, null, null).getVisitor());
                }

                return t;
            }

            class UpgradeDependencyManagementImportVisitor extends MavenIsoVisitor<ExecutionContext> {
                @Override
                public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                    Xml.Tag t = super.visitTag(tag, ctx);
                    try {
                        if (isManagedDependencyImportTag(groupId, artifactId)) {
                            TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency = upgradeManagedDependency(tag, ctx, t);
                            if (upgradeManagedDependency != null) {
                                retainVersions();
                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, retainVersions).getVisitor());
                                doAfterVisit(upgradeManagedDependency);
                                maybeUpdateModel();
                                doAfterVisit(new RemoveRedundantDependencyVersions(null, null, null, null).getVisitor());
                            }
                        }
                    } catch (MavenDownloadingException e) {
                        return e.warn(t);
                    }
                    return t;
                }

                private void retainVersions() {
                    RetainVersions.plan(this, retainVersions == null ? emptyList() : retainVersions)
                            .forEach(it -> doAfterVisit(it.getVisitor()));
                }
            }

            private Xml.Tag upgradeDependency(ExecutionContext ctx, Xml.Tag t) throws MavenDownloadingException {
                ResolvedDependency d = findDependency(t);
                if (d != null && d.getRepository() != null) {
                    // if the resolved dependency exists AND it does not represent an artifact that was parsed
                    // as a source file, attempt to find a new version.
                    String newerVersion = findNewerVersion(d.getGroupId(), d.getArtifactId(), d.getVersion(), ctx);
                    if (newerVersion != null) {
                        if (t.getChild(""version"").isPresent()) {
                            t = changeChildTagValue(t, ""version"", newerVersion, overrideManagedVersion, ctx);
                        } else if (Boolean.TRUE.equals(overrideManagedVersion)) {
                            ResolvedManagedDependency dm = findManagedDependency(t);
                            // if a managed dependency is expressed as a property, change the property value
                            // do this only when a requested bom is absent, otherwise changing property has no effect
                            if (dm != null && isProperty(dm.getRequested().getVersion()) && dm.getRequestedBom() == null) {
                                doAfterVisit(new ChangePropertyValue(dm.getRequested().getVersion().substring(2,
                                        dm.getRequested().getVersion().length() - 1),
                                        newerVersion, overrideManagedVersion, false).getVisitor());
                            } else {
                                // if the version is not present and the override managed version is set,
                                // add a new explicit version tag
                                Xml.Tag versionTag = Xml.Tag.build(""<version>"" + newerVersion + ""</version>"");

                                //noinspection ConstantConditions
                                t = (Xml.Tag) new AddToTagVisitor<>(t, versionTag, new MavenTagInsertionComparator(t.getChildren()))
                                        .visitNonNull(t, 0, getCursor().getParent());
                            }
                        }
                    }
                }
                return t;
            }

            private @Nullable TreeVisitor<Xml, ExecutionContext> upgradeManagedDependency(Xml.Tag tag, ExecutionContext ctx, Xml.Tag t) throws MavenDownloadingException {
                ResolvedManagedDependency managedDependency = findManagedDependency(t);
                if (managedDependency != null) {
                    String groupId = managedDependency.getGroupId();
                    String artifactId = managedDependency.getArtifactId();
                    String version = managedDependency.getVersion();
                    if (version != null &&
                        !accumulator.projectArtifacts.contains(new GroupArtifact(groupId, artifactId)) &&
                        matchesGlob(groupId, UpgradeDependencyVersion.this.groupId) &&
                        matchesGlob(artifactId, UpgradeDependencyVersion.this.artifactId)) {
                        return upgradeVersion(ctx, t, managedDependency.getRequested().getVersion(), groupId, artifactId, version);
                    }
                } else {
                    for (ResolvedManagedDependency dm : getResolutionResult().getPom().getDependencyManagement()) {
                        if (dm.getBomGav() != null) {
                            String group = getResolutionResult().getPom().getValue(tag.getChildValue(""groupId"").orElse(getResolutionResult().getPom().getGroupId()));
                            String artifactId = getResolutionResult().getPom().getValue(tag.getChildValue(""artifactId"").orElse(""""));
                            if (!accumulator.projectArtifacts.contains(new GroupArtifact(group, artifactId))) {
                                ResolvedGroupArtifactVersion bom = dm.getBomGav();
                                if (Objects.equals(group, bom.getGroupId()) &&
                                    Objects.equals(artifactId, bom.getArtifactId())) {
                                    return upgradeVersion(ctx, t, requireNonNull(dm.getRequestedBom()).getVersion(), bom.getGroupId(), bom.getArtifactId(), bom.getVersion());
                                }
                            }
                        }
                    }
                }
                return null;
            }

            private Xml.Tag upgradePluginDependency(ExecutionContext ctx, Xml.Tag t) throws MavenDownloadingException {
                String groupId = t.getChildValue(""groupId"").orElse(null);
                String artifactId = t.getChildValue(""artifactId"").orElse(null);
                String version = t.getChildValue(""version"").orElse(null);
                if (groupId != null && artifactId != null && version != null) {
                    String newerVersion = findNewerVersion(groupId, artifactId, resolveVersion(version), ctx);
                    if (newerVersion != null) {
                        t = changeChildTagValue(t, ""version"", newerVersion, overrideManagedVersion, ctx);
                    }
                }
                return t;
            }

            private String resolveVersion(String version) {
                if (isProperty(version)) {
                    Map<String, String> properties = getResolutionResult().getPom().getProperties();
                    String property = version.substring(2, version.length() - 1);
                    return properties.getOrDefault(property, version);
                }
                return version;
            }

            public @Nullable TreeVisitor<Xml, ExecutionContext> upgradeVersion(ExecutionContext ctx, Xml.Tag tag, @Nullable String requestedVersion, String groupId, String artifactId, String version2) throws MavenDownloadingException {
                String newerVersion = findNewerVersion(groupId, artifactId, version2, ctx);
                if (newerVersion == null) {
                    return null;
                } else if (isProperty(requestedVersion)) {
                    //noinspection unchecked
                    return (TreeVisitor<Xml, ExecutionContext>) new ChangePropertyValue(requestedVersion.substring(2, requestedVersion.length() - 1), newerVersion, overrideManagedVersion, false)
                            .getVisitor();
                } else {
                    Xml.Tag childVersionTag = tag.getChild(""version"").orElse(null);
                    if (childVersionTag != null) {
                        return new ChangeTagValueVisitor<>(childVersionTag, newerVersion);
                    }
                }
                return null;
            }

            private @Nullable String findNewerVersion(String groupId, String artifactId, String version, ExecutionContext ctx)
                    throws MavenDownloadingException {
                return MavenDependency.findNewerVersion(groupId, artifactId, version, getResolutionResult(), metadataFailures,
                        versionComparator, ctx);
            }
        };
    }

    @Value
    public static class Accumulator {
        Set<GroupArtifact> projectArtifacts = new HashSet<>();
        Set<PomProperty> pomProperties = new HashSet<>();
    }

    @Value
    public static class PomProperty {
        Path pomFilePath;
        String propertyName;
        String propertyValue;
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Remove unused properties,Detect and remove Maven property declarations which do not have any usage within the project.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextParser;
import org.openrewrite.text.PlainTextVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveUnusedProperties extends ScanningRecipe<RemoveUnusedProperties.Accumulator> {
    @Option(displayName = ""Property pattern"",
            description = ""A pattern to filter properties to remove. Defaults to `.+?` to match anything"",
            required = false,
            example = "".+\\.version"")
    @Nullable
    String propertyPattern;

    @Override
    public String getDisplayName() {
        return ""Remove unused properties"";
    }

    @Override
    public String getDescription() {
        return ""Detect and remove Maven property declarations which do not have any usage within the project."";
    }

    public static class Accumulator {
        public Map<String, Set<MavenResolutionResult>> propertiesToUsingPoms = new HashMap<>();
        public Map<Path, MavenResolutionResult> filteredResourcePathsToDeclaringPoms = new HashMap<>();
        public Map<Path, Set<String>> nonPomPathsToUsages = new HashMap<>();

        public Map<String, Set<MavenResolutionResult>> getFilteredResourceUsages() {
            Map<String, Set<MavenResolutionResult>> result = new HashMap<>();
            filteredResourcePathsToDeclaringPoms.forEach((filteredResourcePath, mrr) ->
                    nonPomPathsToUsages.forEach((usagePath, properties) -> {
                                if (usagePath.startsWith(filteredResourcePath)) {
                                    properties.forEach(property -> {
                                        result.putIfAbsent(property, new HashSet<>());
                                        result.get(property).add(mrr);
                                    });
                                }
                            }
                    ));
            return result;
        }
    }

    @Override
    public RemoveUnusedProperties.Accumulator getInitialValue(ExecutionContext ctx) {
        return new RemoveUnusedProperties.Accumulator();
    }

    private String getPropertyPattern() {
        return propertyPattern != null ? propertyPattern : "".+?"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(RemoveUnusedProperties.Accumulator acc) {
        String patternOrDefault = getPropertyPattern();
        MavenIsoVisitor<ExecutionContext> findPomUsagesVisitor = new FindPomUsagesVisitor(dollarPropertyMatcher(patternOrDefault), acc);
        MavenIsoVisitor<ExecutionContext> findFilteredResourcePathsVisitor = new FindFilteredResourcePathsVisitor(acc);
        PlainTextVisitor<ExecutionContext> findResourceUsagesVisitor = new FindResourceUsagesVisitor(patternOrDefault, acc);

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof Quark || tree instanceof Remote || tree instanceof Binary) {
                    return tree;
                }
                if (tree instanceof SourceFile) {
                    SourceFile sf = (SourceFile) tree;
                    if (findPomUsagesVisitor.isAcceptable(sf, ctx)) { // ie: is a pom
                        findPomUsagesVisitor.visit(sf, ctx);
                        findFilteredResourcePathsVisitor.visit(sf, ctx);
                    } else if (!(tree instanceof JavaSourceFile)) { // optimization: avoid visiting code files which are almost always not filtered resources
                        findResourceUsagesVisitor.visit(PlainTextParser.convert(sf), ctx);
                    }
                }
                return tree;
            }
        };
    }

    private static Pattern dollarPropertyMatcher(String patternOrDefault) {
        return Pattern.compile(""(?<![$\\\\])\\$\\{("" + patternOrDefault + "")}"");
    }

    private static Pattern atPropertyMatcher(String patternOrDefault) {
        return Pattern.compile(""@("" + patternOrDefault + "")@"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(RemoveUnusedProperties.Accumulator acc) {
        Pattern propertyMatcher = Pattern.compile(getPropertyPattern());
        Map<String, Set<MavenResolutionResult>> filteredResourceUsages = acc.getFilteredResourceUsages();
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                String propertyName = t.getName();
                if (isPropertyTag() && propertyMatcher.matcher(propertyName).matches()) {
                    if (isMavenBuiltinProperty(propertyName)) {
                        return t;
                    }

                    if (parentHasProperty(getResolutionResult(), propertyName, ctx)) {
                        return t;
                    }

                    if (acc.propertiesToUsingPoms.containsKey(propertyName)) {
                        for (MavenResolutionResult pomWhereUsed : acc.propertiesToUsingPoms.get(propertyName)) {
                            if (isAncestor(pomWhereUsed, getResolutionResult().getPom().getGav())) {
                                return t;
                            }
                        }
                    }

                    if (filteredResourceUsages.containsKey(propertyName)) {
                        for (MavenResolutionResult pomWhereUsed : filteredResourceUsages.get(propertyName)) {
                            if (isAncestor(pomWhereUsed, getResolutionResult().getPom().getGav())) {
                                return t;
                            }
                        }
                    }

                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                    maybeUpdateModel();
                }
                return t;
            }

            private boolean isMavenBuiltinProperty(String propertyName) {
                return propertyName.startsWith(""project."") || propertyName.startsWith(""maven."");
            }

            private boolean isAncestor(MavenResolutionResult project, ResolvedGroupArtifactVersion possibleAncestorGav) {
                MavenResolutionResult projectAncestor = project;
                while (projectAncestor != null) {
                    if (projectAncestor.getPom().getGav().equals(possibleAncestorGav)) {
                        return true;
                    }
                    projectAncestor = projectAncestor.getParent();
                }
                return false;
            }

            private boolean parentHasProperty(MavenResolutionResult resolutionResult, String propertyName,
                                              ExecutionContext ctx) {
                MavenPomDownloader downloader = new MavenPomDownloader(resolutionResult.getProjectPoms(), ctx,
                        resolutionResult.getMavenSettings(), resolutionResult.getActiveProfiles());
                try {
                    ResolvedPom resolvedBarePom = resolutionResult.getPom().getRequested()
                            .withProperties(emptyMap())
                            .withDependencies(emptyList())
                            .withDependencyManagement(emptyList())
                            .withPlugins(emptyList())
                            .withPluginManagement(emptyList())
                            .resolve(resolutionResult.getActiveProfiles(), downloader, ctx);
                    return resolvedBarePom.getProperties().containsKey(propertyName);
                } catch (MavenDownloadingException e) {
                    // assume parent *does* have property if error to do no harm
                    return true;
                }
            }
        };
    }

    private static class FindPomUsagesVisitor extends MavenIsoVisitor<ExecutionContext> {
        private final Pattern propertyUsageMatcher;
        private final Accumulator acc;

        public FindPomUsagesVisitor(Pattern propertyUsageMatcher, Accumulator acc) {
            this.propertyUsageMatcher = propertyUsageMatcher;
            this.acc = acc;
        }

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag t = super.visitTag(tag, ctx);
            Optional<String> value = t.getValue();
            if (value.isPresent()) {
                Matcher matcher = propertyUsageMatcher.matcher(value.get());
                while (matcher.find()) {
                    acc.propertiesToUsingPoms.putIfAbsent(matcher.group(1), new HashSet<>());
                    acc.propertiesToUsingPoms.get(matcher.group(1)).add(getResolutionResult());
                }
            }
            return t;
        }
    }

    private static class FindFilteredResourcePathsVisitor extends MavenIsoVisitor<ExecutionContext> {
        private final XPathMatcher resourceMatcher = new XPathMatcher(""/project/build/resources/resource"");
        private final Accumulator acc;

        public FindFilteredResourcePathsVisitor(Accumulator acc) {
            this.acc = acc;
        }

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (resourceMatcher.matches(getCursor())) {
                String directory = tag.getChildValue(""directory"").orElse(null);
                if (tag.getChildValue(""filtering"").map(Boolean::valueOf).orElse(false) &&
                        directory != null) {
                    Path path = getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath();
                    try {
                        acc.filteredResourcePathsToDeclaringPoms.put(path.getParent().resolve(directory), getResolutionResult());
                    } catch (InvalidPathException ignored) {
                    } // fail quietly
                }
                return tag;
            } else {
                return super.visitTag(tag, ctx);
            }
        }
    }

    private static class FindResourceUsagesVisitor extends PlainTextVisitor<ExecutionContext> {
        private final Pattern dollarMatcher;
        private final Pattern atMatcher;
        private final Accumulator acc;

        public FindResourceUsagesVisitor(String pattern, Accumulator acc) {
            this.dollarMatcher = dollarPropertyMatcher(pattern);
            this.atMatcher = atPropertyMatcher(pattern);
            this.acc = acc;
        }

        @Override
        public PlainText visitText(PlainText text, ExecutionContext ctx) {
            Matcher matcher = dollarMatcher.matcher(text.getText());
            while (matcher.find()) {
                acc.nonPomPathsToUsages.putIfAbsent(text.getSourcePath(), new HashSet<>());
                acc.nonPomPathsToUsages.get(text.getSourcePath()).add(matcher.group(1));
            }
            matcher = atMatcher.matcher(text.getText());
            while (matcher.find()) {
                acc.nonPomPathsToUsages.putIfAbsent(text.getSourcePath(), new HashSet<>());
                acc.nonPomPathsToUsages.get(text.getSourcePath()).add(matcher.group(1));
            }
            return text;
        }
    }
}
",{}
Remove repository,Removes a matching Maven repository.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.apache.commons.lang3.StringUtils;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveRepository extends Recipe {
    private static final XPathMatcher REPOS_MATCHER = new XPathMatcher(""/project/repositories/repository"");
    private static final XPathMatcher PLUGIN_REPOS_MATCHER = new XPathMatcher(""/project/pluginRepositories/pluginRepository"");

    @Option(example = ""repo-id"", displayName = ""Repository ID"",
            description = ""A unique repository ID."",
            required = false)
    @Nullable
    String id;

    @Option(example = ""http://myrepo.maven.com/repo"", displayName = ""Repository URL"",
            description = ""The URL of the repository."")
    String url;

    @Override
    public String getDisplayName() {
        return ""Remove repository"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s`"", url);
    }

    @Override
    public String getDescription() {
        return ""Removes a matching Maven repository."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {

            @Override
            public  Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag repo = super.visitTag(tag, ctx);

                if (REPOS_MATCHER.matches(getCursor()) || PLUGIN_REPOS_MATCHER.matches(getCursor())) {
                    if (isSameUrlAndID(repo)) {
                        return null;
                    }
                }
                return repo;
            }
        };
    }

    private boolean isSameUrlAndID(Xml.Tag repo) {
        boolean sameURL = StringUtils.isBlank(this.url) || StringUtils.equals(this.url, repo.getChildValue(""url"").orElse(null));
        boolean sameID = StringUtils.isBlank(this.id) || StringUtils.equals(this.id, repo.getChildValue(""id"").orElse(null));

        return sameURL && sameID;
    }
}
","{
  ""url"": ""String field""
}"
Add Maven dependency,Add a Maven dependency to a `pom.xml` file in the correct scope based on where it is used.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.semver.Semver;
import org.openrewrite.xml.tree.Xml;

import java.util.*;
import java.util.regex.Pattern;

import static java.util.Objects.requireNonNull;

/**
 * This recipe will detect the presence of Java types (in Java ASTs) to determine if a dependency should be added
 * to a maven build file. Java Provenance information is used to filter the type search to only those java ASTs that
 * have the same coordinates of that of the pom. Additionally, if a ""scope"" is specified in this recipe, the dependency
 * will only be added if there are types found in a given source set are transitively within that scope.
 * <p>
 * NOTE: IF PROVENANCE INFORMATION IS NOT PRESENT, THIS RECIPE WILL DO NOTHING.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class AddDependency extends ScanningRecipe<AddDependency.Scanned> {
    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""29.X"")
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Scope"",
            description = ""A scope to use when it is not what can be inferred from usage. Most of the time this will be left empty, but "" +
                          ""is used when adding a runtime, provided, or import dependency."",
            example = ""runtime"",
            valid = {""import"", ""runtime"", ""provided"", ""test""},
            required = false)
    @Nullable
    String scope;

    @Option(displayName = ""Releases only"",
            description = ""Whether to exclude snapshots from consideration when using a semver selector"",
            required = false)
    @Nullable
    Boolean releasesOnly;

    @Option(displayName = ""Only if using"",
            description = ""Used to determine if the dependency will be added and in which scope it should be placed."",
            example = ""org.junit.jupiter.api.*"",
            required = false)
    @Nullable
    String onlyIfUsing;

    @Option(displayName = ""Type"",
            description = ""The type of dependency to add. If omitted Maven defaults to assuming the type is \""jar\""."",
            valid = {""jar"", ""pom"", ""war""},
            example = ""jar"",
            required = false)
    @Nullable
    String type;

    @Option(displayName = ""Classifier"",
            description = ""A Maven classifier to add. Most commonly used to select shaded or test variants of a library"",
            example = ""test"",
            required = false)
    @Nullable
    String classifier;

    @Option(displayName = ""Optional"",
            description = ""Set the value of the `<optional>` tag. No `<optional>` tag will be added when this is `null`."",
            required = false)
    @Nullable
    Boolean optional;

    /**
     * A glob expression used to identify other dependencies in the same family as the dependency to be added.
     */
    @Option(displayName = ""Family pattern"",
            description = ""A pattern, applied to groupIds, used to determine which other dependencies should have aligned version numbers. "" +
                          ""Accepts '*' as a wildcard character."",
            example = ""com.fasterxml.jackson*"",
            required = false)
    @Nullable
    @With
    String familyPattern;

    @Option(displayName = ""Accept transitive"",
            description = ""Default false. If enabled, the dependency will not be added if it is already on the classpath as a transitive dependency."",
            example = ""true"",
            required = false)
    @Nullable
    Boolean acceptTransitive;

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        //noinspection ConstantConditions
        if (version != null) {
            validated = validated.or(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    @Override
    public String getDisplayName() {
        return ""Add Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add a Maven dependency to a `pom.xml` file in the correct scope based on where it is used."";
    }

    public static class Scanned {
        boolean usingType;
        Map<JavaProject, String> scopeByProject = new HashMap<>();
        Set<ResolvedGroupArtifactVersion> pomsDefinedInCurrentRepository = new HashSet<>();
    }

    @Override
    public Scanned getInitialValue(ExecutionContext ctx) {
        return new Scanned();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (tree instanceof JavaSourceFile) {
                    if (onlyIfUsing == null || sourceFile != new UsesType<>(onlyIfUsing, true).visit(sourceFile, ctx)) {
                        acc.usingType = true;
                        JavaProject javaProject = sourceFile.getMarkers().findFirst(JavaProject.class).orElse(null);
                        JavaSourceSet javaSourceSet = sourceFile.getMarkers().findFirst(JavaSourceSet.class).orElse(null);
                        if (javaProject != null && javaSourceSet != null) {
                            acc.scopeByProject.compute(javaProject, (jp, scope) -> ""compile"".equals(scope) ?
                                    scope /* a `compile` scope dependency will also be available in test source set */ :
                                    ""test"".equals(javaSourceSet.getName()) ? ""test"" : ""compile""
                            );
                        }
                    }
                } else if (tree instanceof Xml.Document) {
                    Xml.Document doc = (Xml.Document) tree;
                    MavenResolutionResult mrr = doc.getMarkers().findFirst(MavenResolutionResult.class).orElse(null);
                    if (mrr == null) {
                        return sourceFile;
                    }
                    acc.pomsDefinedInCurrentRepository.add(mrr.getPom().getGav());
                }
                return sourceFile;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {
        return Preconditions.check(onlyIfUsing == null || acc.usingType && !acc.scopeByProject.isEmpty(), new MavenVisitor<ExecutionContext>() {
            @Nullable
            final Pattern familyPatternCompiled = familyPattern == null ? null : Pattern.compile(familyPattern.replace(""*"", "".*""));

            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml maven = super.visitDocument(document, ctx);

                JavaProject javaProject = document.getMarkers().findFirst(JavaProject.class).orElse(null);
                String maybeScope = javaProject == null ? null : acc.scopeByProject.get(javaProject);
                if (onlyIfUsing != null && maybeScope == null && !acc.scopeByProject.isEmpty()) {
                    return maven;
                }

                // If the dependency is already in compile scope it will be available everywhere, no need to continue
                Map<Scope, List<ResolvedDependency>> dependencies = getResolutionResult().getDependencies();
                if (dependencies.get(Scope.Compile) != null) {
                    for (ResolvedDependency d : dependencies.get(Scope.Compile)) {
                        if (hasAcceptableTransitivity(d, acc) &&
                            groupId.equals(d.getGroupId()) && artifactId.equals(d.getArtifactId())) {
                            return maven;
                        }
                    }
                }

                String resolvedScope = scope == null ? maybeScope : scope;
                Scope resolvedScopeEnum = Scope.fromName(resolvedScope);
                if ((resolvedScopeEnum == Scope.Provided || resolvedScopeEnum == Scope.Test) && dependencies.get(resolvedScopeEnum) != null) {
                    for (ResolvedDependency d : dependencies.get(resolvedScopeEnum)) {
                        if (hasAcceptableTransitivity(d, acc) &&
                                groupId.equals(d.getGroupId()) && artifactId.equals(d.getArtifactId())) {
                            return maven;
                        }
                    }
                }

                if (onlyIfUsing == null && isSubprojectOfParentInRepository(acc)) {
                    return maven;
                }
                if (isAggregatorNotUsedAsParent()) {
                    return maven;
                }

                return new AddDependencyVisitor(
                        groupId, artifactId, version, versionPattern, resolvedScope, releasesOnly,
                        type, classifier, optional, familyPatternCompiled, metadataFailures).visitNonNull(document, ctx);
            }

            private boolean isSubprojectOfParentInRepository(Scanned acc) {
                return getResolutionResult().getParent() != null &&
                       acc.pomsDefinedInCurrentRepository.contains(getResolutionResult().getParent().getPom().getGav());
            }

            private boolean isAggregatorNotUsedAsParent() {
                List<String> subprojects = getResolutionResult().getPom().getSubprojects();
                if (subprojects == null || subprojects.isEmpty()) {
                    return false;
                }
                List<MavenResolutionResult> modules = getResolutionResult().getModules();
                if (modules.isEmpty()) {
                    return true;
                }
                for (MavenResolutionResult child : modules) {
                    if (subprojects.contains(child.getPom().getGav().getArtifactId())) {
                        return false;
                    }
                }
                return true;
            }

        });
    }

    private boolean hasAcceptableTransitivity(ResolvedDependency d, Scanned acc) {
        return d.isDirect() || Boolean.TRUE.equals(acceptTransitive) && (onlyIfUsing == null || !acc.scopeByProject.isEmpty());
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""version"": ""String field""
}"
Order POM elements,Order POM elements according to the [recommended](https://maven.apache.org/developers/conventions/code.html#pom-code-convention) order.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.time.Duration;
import java.util.*;

import static java.util.Collections.singleton;
import static org.openrewrite.maven.MavenTagInsertionComparator.canonicalOrdering;

public class OrderPomElements extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Order POM elements"";
    }

    @Override
    public String getDescription() {
        return ""Order POM elements according to the [recommended](https://maven.apache.org/developers/conventions/code.html#pom-code-convention) order."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S3423"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(10);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document mvn = super.visitDocument(document, ctx);
                Xml.Tag root = mvn.getRoot();
                if (root.getContent() != null) {
                    Map<String, List<Content>> groupedContents = new HashMap<>(root.getContent().size());

                    // Group comments with the next non-comment content.
                    List<Content> groupedContent = new ArrayList<>();

                    // Collect content that does not exist in `REQUIRED_ORDER`.
                    List<Content> otherContent = new ArrayList<>();

                    // Save the first UUID of grouped content and the size of the grouped content.
                    // The group sizes are used to preserve the original layout of new lines.
                    Map<UUID, Integer> groupSizes = new HashMap<>();

                    for (Content content : root.getContent()) {
                        if (content instanceof Xml.Comment) {
                            groupedContent.add(content);
                        } else if (content instanceof Xml.Tag) {
                            groupedContent.add(content);
                            groupedContents.put(((Xml.Tag) content).getName(), groupedContent);

                            groupSizes.put(groupedContent.get(0).getId(), groupedContent.size());
                            groupedContent = new ArrayList<>();
                        } else {
                            groupedContent.add((content));
                            otherContent.addAll(groupedContent);

                            groupSizes.put(groupedContent.get(0).getId(), groupedContent.size());
                            groupedContent = new ArrayList<>();
                        }
                    }

                    List<Content> updatedOrder = new ArrayList<>(root.getContent().size());
                    // Apply required order.
                    for (String order : canonicalOrdering) {
                        if (groupedContents.containsKey(order)) {
                            updatedOrder.addAll(groupedContents.get(order));
                            groupedContents.remove(order);
                        }
                    }

                    // Add remaining tags that may not have been in the `REQUIRED_ORDER` list.
                    for (List<Content> value : groupedContents.values()) {
                        updatedOrder.addAll(value);
                    }

                    // Add non-tag content.
                    updatedOrder.addAll(otherContent);

                    int beforeIndex = 0;
                    int afterIndex = 0;
                    for (int i = 0; i < root.getContent().size() &&
                                    beforeIndex != root.getContent().size() &&
                                    afterIndex != updatedOrder.size(); i++) {

                        Content original = root.getContent().get(beforeIndex);
                        Content updated = updatedOrder.get(afterIndex);

                        updatedOrder.set(afterIndex, (Content) updated.withPrefix(original.getPrefix()));

                        beforeIndex += groupSizes.get(original.getId());
                        afterIndex += groupSizes.get(updated.getId());
                    }

                    boolean foundChange = false;
                    for (int i = 0; i < root.getContent().size(); i++) {
                        if (root.getContent().get(i) != updatedOrder.get(i)) {
                            foundChange = true;
                            break;
                        }
                    }

                    if (foundChange) {
                        root = root.withContent(updatedOrder);
                        mvn = mvn.withRoot(root);
                        mvn = autoFormat(mvn, ctx);
                    }
                }
                return mvn;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag tg = super.visitTag(tag, ctx);
                if (""dependency"".equals(tg.getName()) ||
                        ""parent"".equals(tg.getName()) ||
                        ""plugin"".equals(tg.getName())) {
                    tg = orderGav(tg);
                }
                return tg;
            }

            private Xml.Tag orderGav(Xml.Tag gavParent) {
                if (gavParent.getContent() != null) {
                    int groupPos = -1;
                    int artifactPos = -1;
                    int versionPos = -1;
                    Map<String, List<Content>> gavGroups = new HashMap<>();
                    List<Content> groupedContent = new ArrayList<>();
                    List<Content> otherContent = new ArrayList<>();
                    for (int i = 0; i < gavParent.getContent().size(); i++) {
                        Content content = gavParent.getContent().get(i);
                        if (content instanceof Xml.Comment) {
                            groupedContent.add(content);
                        } else if (content instanceof Xml.Tag) {
                            Xml.Tag tag = (Xml.Tag) content;
                            if (""groupId"".equals(tag.getName())) {
                                groupPos = i;
                            } else if (""artifactId"".equals(tag.getName())) {
                                artifactPos = i;
                            } else if (""version"".equals(tag.getName())) {
                                versionPos = i;
                            }

                            switch (tag.getName()) {
                                case ""groupId"":
                                case ""artifactId"":
                                case ""version"":
                                    groupedContent.add(tag);
                                    gavGroups.put(tag.getName(), groupedContent);
                                    groupedContent = new ArrayList<>();
                                    break;
                                default:
                                    otherContent.addAll(groupedContent);
                                    otherContent.add(content);
                                    groupedContent = new ArrayList<>();
                                    break;
                            }
                        } else {
                            otherContent.addAll(groupedContent);
                            otherContent.add(content);
                            groupedContent = new ArrayList<>();
                        }
                    }

                    if ((groupPos > artifactPos ||
                         (versionPos > -1 && (artifactPos > versionPos)))) {
                        List<Content> orderedContents = new ArrayList<>();
                        for (String type : new String[]{""groupId"", ""artifactId"", ""version""}) {
                            List<Content> gavContents = gavGroups.get(type);
                            if (gavContents != null) {
                                orderedContents.addAll(gavContents);
                            }
                        }
                        orderedContents.addAll(otherContent);
                        gavParent = gavParent.withContent(orderedContents);
                    }
                }
                return gavParent;
            }
        };
    }
}
",{}
Modernize obsolete Maven poms,Very old Maven poms are no longer supported by current versions of Maven. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

public class ModernizeObsoletePoms extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Modernize obsolete Maven poms"";
    }

    @Override
    public String getDescription() {
        return ""Very old Maven poms are no longer supported by current versions of Maven. "" +
               ""This recipe updates poms with `<pomVersion>3</pomVersion>` to `<modelVersion>4.0.0</modelVersion>` of the Maven pom schema. "" +
               ""This does not attempt to upgrade old dependencies or plugins and is best regarded as the starting point of a migration rather than an end-point."";
    }

    private static final XPathMatcher POM_VERSION = new XPathMatcher(""/project/pomVersion"");
    private static final XPathMatcher CURRENT_VERSION = new XPathMatcher(""/project/currentVersion"");
    private static final XPathMatcher LOGO = new XPathMatcher(""/project/organization/logo"");
    private static final XPathMatcher UNIT_TEST = new XPathMatcher(""/project/build/unitTest"");
    private static final XPathMatcher REPOSITORY = new XPathMatcher(""/project/repository"");
    private static final XPathMatcher ISSUE_TRACKING_URL = new XPathMatcher(""/project/issueTrackingUrl"");
    private static final XPathMatcher PACKAGE = new XPathMatcher(""/project/package"");

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return Preconditions.check(new FindSourceFiles(""**/pom.xml""), new XmlIsoVisitor<ExecutionContext>() {

            @SuppressWarnings({""DataFlowIssue"", ""ConcatenationWithEmptyString""})
            @Override
            public  Xml.@Nullable Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                Cursor c = getCursor();
                if (POM_VERSION.matches(c)) {
                    t = t.withName(""modelVersion"")
                            .withValue(""4.0.0"");
                } else if (CURRENT_VERSION.matches(c)) {
                    t = t.withName(""version"");
                } else if (REPOSITORY.matches(c)) {
                    if (t.getChildValue(""url"").isPresent()) {
                        t = autoFormat(
                                Xml.Tag.build("""" +
                                              ""<repositories>\n"" +
                                              ""    <repository>\n"" +
                                              ""        <id>repo</id>\n"" +
                                              ""        <url>"" + t.getChildValue(""url"").get() + ""</url>\n"" +
                                              ""    </repository>\n"" +
                                              ""</repositories>\n""),
                                ctx, c.getParentTreeCursor());
                    } else {
                        return null;
                    }
                } else if (ISSUE_TRACKING_URL.matches(c)) {
                    if (t.getValue().isPresent()) {
                        t = autoFormat(
                                Xml.Tag.build("""" +
                                              ""<issueManagement>\n"" +
                                              ""    <system>IssueTracker</system>\n"" +
                                              ""    <url>"" + t.getValue().get() + ""</url>\n"" +
                                              ""</issueManagement>\n""),
                                ctx, c.getParentTreeCursor());
                    } else {
                        return null;
                    }
                } else if (LOGO.matches(c) ||
                           UNIT_TEST.matches(c) ||
                           PACKAGE.matches(c)) {
                    return null;
                }
                return t;
            }
        });
    }
}
",{}
Add Maven project property,Add a new property to the Maven project property. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddProperty extends Recipe {

    @Option(displayName = ""Key"",
            description = ""The name of the property key to be added."",
            example = ""junit.version"")
    String key;

    @Option(displayName = ""Value"",
            description = ""The value of property to be added."",
            example = ""4.13"")
    String value;

    @Option(displayName = ""Preserve existing value"",
            description = ""Preserve previous value if the property already exists in the pom file."",
            required = false)
    @Nullable
    Boolean preserveExistingValue;

    @Option(displayName = ""Trust parent POM"",
            description = ""If the parent defines a property with the same key, trust it even if the value isn't the same. "" +
                          ""Useful when you want to wait for the parent to have its value changed first. The parent is not trusted by default."",
            required = false)
    @Nullable
    Boolean trustParent;

    @Override
    public String getDisplayName() {
        return ""Add Maven project property"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s=%s`"", key, value);
    }

    @Override
    public String getDescription() {
        return ""Add a new property to the Maven project property. "" +
               ""Prefers to add the property to the parent if the project has multiple modules."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        final String keyToReplace = key.replace(""${"", """").replace(""}"", """");
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                String parentValue = getResolutionResult().getPom().getRequested().getProperties().get(key);
                if ((Boolean.TRUE.equals(trustParent) && (parentValue == null || value.equals(parentValue))) ||
                        value.equals(getResolutionResult().getPom().getProperties().get(key))) {
                    return document;
                }

                // If there is a parent pom in the same project, update the property there instead
                if (document.getRoot().getChild(""parent"")
                        .flatMap(tag -> tag.getChild(""relativePath""))
                        .flatMap(Xml.Tag::getValue)
                        .flatMap(v -> v.trim().isEmpty() ? Optional.empty() : Optional.of(v))
                        .isPresent()) {
                    if (Boolean.TRUE.equals(preserveExistingValue)) {
                        return document;
                    }
                    // If the property is expected to be in the parent, there's no need for it in the child pom
                    return (Xml.Document) new RemoveProperty(key).getVisitor()
                            .visitNonNull(document, ctx);
                }
                return (Xml.Document) new AddPropertyVisitor(keyToReplace, value, preserveExistingValue)
                        .visitNonNull(document, ctx);
            }
        };
    }
}
","{
  ""key"": ""String field"",
  ""value"": ""String field""
}"
Exclude Maven dependency,Exclude specified dependency from any dependency that transitively includes it.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.Optional;

import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class ExcludeDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. If you specify `compile`, this will NOT match dependencies in `runtime`. "" +
                          ""The purpose of this is to be able to exclude dependencies that should be in a higher scope, e.g. a compile dependency that should be a test dependency."",
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"",
            required = false)
    @Nullable
    String scope;

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""scope"", ""scope is a valid Maven scope"", scope, s -> {
            try {
                if (s != null) {
                    //noinspection ResultOfMethodCallIgnored
                    Scope.fromName(s);
                }
                return true;
            } catch (Throwable t) {
                return false;
            }
        }));
    }

    @Override
    public String getDisplayName() {
        return ""Exclude Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Exclude specified dependency from any dependency that transitively includes it."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Repeat.repeatUntilStable(() -> new MavenVisitor<ExecutionContext>() {
            @Nullable
            private final Scope scope = ExcludeDependency.this.scope == null ? null : Scope.fromName(ExcludeDependency.this.scope);

            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml xml = super.visitDocument(document, ctx);
                if (xml != document) {
                    xml = new UpdateMavenModel<>().visitNonNull(xml, ctx);
                }
                return xml;
            }

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag()) {
                    ResolvedDependency dependency = findDependency(tag, scope);
                    if (dependency != null &&
                        !(matchesGlob(dependency.getGroupId(), groupId) && matchesGlob(dependency.getArtifactId(), artifactId)) &&
                        dependency.findDependency(groupId, artifactId) != null) {
                        Optional<Xml.Tag> maybeExclusions = tag.getChild(""exclusions"");
                        if (maybeExclusions.isPresent()) {
                            Xml.Tag exclusions = maybeExclusions.get();

                            List<Xml.Tag> individualExclusions = exclusions.getChildren(""exclusion"");
                            if (individualExclusions.stream().noneMatch(exclusion ->
                                    groupId.equals(exclusion.getChildValue(""groupId"").orElse(null)) &&
                                    artifactId.equals(exclusion.getChildValue(""artifactId"").orElse(null)))) {
                                Xml.Tag newExclusions = (Xml.Tag) new AddToTagVisitor<>(exclusions, Xml.Tag.build(
                                        ""<exclusion>\n"" +
                                        ""<groupId>"" + groupId + ""</groupId>\n"" +
                                        ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                                        ""</exclusion>""))
                                        .visitNonNull(exclusions, ctx, getCursor());
                                //noinspection unchecked
                                tag = tag.withContent(ListUtils.map((List<Content>) tag.getContent(), t -> t == exclusions ? newExclusions : t));
                            }
                        } else {
                            tag = (Xml.Tag) new AddToTagVisitor<>(tag, Xml.Tag.build(
                                    ""<exclusions>\n"" +
                                    ""<exclusion>\n"" +
                                    ""<groupId>"" + groupId + ""</groupId>\n"" +
                                    ""<artifactId>"" + artifactId + ""</artifactId>\n"" +
                                    ""</exclusion>\n"" +
                                    ""</exclusions>""))
                                    .visitNonNull(tag, ctx, getCursor().getParentOrThrow());
                        }
                    }
                    return tag;
                }
                return super.visitTag(tag, ctx);
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Maven plugin group and artifact ID,Change the groupId and/or the artifactId of a specified Maven plugin. Optionally update the plugin version. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePluginGroupIdAndArtifactId extends Recipe {
    @EqualsAndHashCode.Exclude
    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old group ID"",
            description = ""The old group ID to replace. The group ID is the first part of a plugin coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""org.openrewrite.recipe"")
    String oldGroupId;

    @Option(displayName = ""Old artifact ID"",
            description = ""The old artifactId to replace. The artifact ID is the second part of a plugin coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""my-deprecated-maven-plugin"")
    String oldArtifactId;

    @Option(displayName = ""New group ID"",
            description = ""The new group ID to use."",
            example = ""corp.internal.openrewrite.recipe"",
            required = false)
    @Nullable
    String newGroupId;

    @Option(displayName = ""New artifact ID"",
            description = ""The new artifact ID to use."",
            example = ""my-new-maven-plugin"",
            required = false)
    @Nullable
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Override
    public String getDisplayName() {
        return ""Change Maven plugin group and artifact ID"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", newGroupId, newArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Change the groupId and/or the artifactId of a specified Maven plugin. Optionally update the plugin version. "" +
                ""This recipe does not perform any validation and assumes all values passed are valid."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (isPluginTag(oldGroupId, oldArtifactId)) {
                    if (newGroupId != null) {
                        t = changeChildTagValue(t, ""groupId"", newGroupId, ctx);
                    }
                    if (newArtifactId != null) {
                        t = changeChildTagValue(t, ""artifactId"", newArtifactId, ctx);
                    }
                    if (newVersion != null) {
                        t = changeChildTagValue(t, ""version"", newVersion, ctx);
                    }
                    if (t != tag) {
                        maybeUpdateModel();
                    }
                }
                //noinspection ConstantConditions
                return t;
            }
        };
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field""
}"
Add managed Maven dependency,Add a managed Maven dependency to a `pom.xml` file.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.trait.MavenDependency;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddManagedDependency extends ScanningRecipe<AddManagedDependency.Scanned> {
    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.apache.logging.log4j:ARTIFACT_ID:VERSION'."",
            example = ""org.apache.logging.log4j"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.apache.logging.log4j:log4j-bom:VERSION'."",
            example = ""log4j-bom"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""latest.release"")
    String version;

    @Option(displayName = ""Scope"",
            description = ""An optional scope to use for the dependency management tag."",
            example = ""import"",
            valid = {""import"", ""runtime"", ""provided"", ""test""},
            required = false)
    @Nullable
    String scope;

    @Option(displayName = ""Type"",
            description = ""An optional type to use for the dependency management tag."",
            valid = {""jar"", ""pom"", ""war""},
            example = ""pom"",
            required = false)
    @Nullable
    String type;

    @Option(displayName = ""Classifier"",
            description = ""An optional classifier to use for the dependency management tag"",
            example = ""test"",
            required = false)
    @Nullable
    String classifier;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Releases only"",
            description = ""Whether to exclude snapshots from consideration when using a semver selector"",
            required = false)
    @Nullable
    Boolean releasesOnly;

    @Option(displayName = ""Only if using glob expression for group:artifact"",
            description = ""Only add managed dependencies to projects having a dependency matching the expression."",
            example = ""org.apache.logging.log4j:log4j*"",
            required = false)
    @Nullable
    String onlyIfUsing;

    @Option(displayName = ""Add to the root pom"",
            description = ""Add to the root pom where root is the eldest parent of the pom within the source set."",
            required = false)
    @Nullable
    Boolean addToRootPom;

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        //noinspection ConstantConditions
        if (version != null) {
            validated = validated.or(Semver.validate(version, versionPattern));
        }
        if (!StringUtils.isNullOrEmpty(onlyIfUsing)) {
            validated = validated.and(Validated.test(""onlyIfUsing"", ""invalid group:artifact glob pattern"", onlyIfUsing, s -> {
                try {
                    return onlyIfUsing.matches(""[\\w.-]+\\*?:([\\w-]+\\*?|\\*)"");
                } catch (Throwable t) {
                    return false;
                }
            }));
        }
        return validated;
    }

    @Override
    public String getDisplayName() {
        return ""Add managed Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add a managed Maven dependency to a `pom.xml` file."";
    }

    public static class Scanned {
        boolean usingType;
        List<SourceFile> rootPoms = new ArrayList<>();
    }

    @Override
    public Scanned getInitialValue(ExecutionContext ctx) {
        Scanned scanned = new Scanned();
        scanned.usingType = onlyIfUsing == null;
        return scanned;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {
        return Preconditions.check(acc.usingType || (!StringUtils.isNullOrEmpty(onlyIfUsing) && onlyIfUsing.contains("":"")), new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                document.getMarkers().findFirst(MavenResolutionResult.class).ifPresent(mavenResolutionResult -> {
                    if (mavenResolutionResult.getParent() == null) {
                        acc.rootPoms.add(document);
                    }
                });
                if (acc.usingType) {
                    return document;
                }
                super.visitDocument(document, ctx);
                return document;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (isDependencyTag()) {
                    ResolvedDependency dependency = findDependency(t, null);
                    if (dependency != null) {
                        String[] ga = requireNonNull(onlyIfUsing).split("":"");
                        ResolvedDependency match = dependency.findDependency(ga[0], ga[1]);
                        if (match != null) {
                            acc.usingType = true;
                        }
                    }
                }

                return t;
            }
        });
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {
        return Preconditions.check(acc.usingType, new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml maven = super.visitDocument(document, ctx);

                if (!Boolean.TRUE.equals(addToRootPom) || acc.rootPoms.contains(document)) {
                    ResolvedPom pom = getResolutionResult().getPom();
                    String convertedVersion = pom.getValue(version);
                    if (convertedVersion == null) {
                        return maven;
                    }
                    String convertedGroup = requireNonNull(pom.getValue(groupId));
                    String convertedArtifact = requireNonNull(pom.getValue(artifactId));
                    Validated<VersionComparator> versionValidation = Semver.validate(convertedVersion, versionPattern);
                    if (versionValidation.isValid()) {
                        VersionComparator versionComparator = requireNonNull(versionValidation.getValue());
                        try {
                            // The version of the dependency currently in use (if any) might influence the version comparator
                            // For example, ""latest.patch"" gives very different results depending on the version in use
                            String currentVersion = getResolutionResult().findDependencies(convertedGroup, convertedArtifact, Scope.fromName(scope)).stream()
                                    .map(ResolvedDependency::getVersion)
                                    .findFirst()
                                    .orElse(existingManagedDependencyVersion());
                            String versionToUse = MavenDependency.findNewerVersion(convertedGroup, convertedArtifact, currentVersion, getResolutionResult(), metadataFailures, versionComparator, ctx);

                            // Prevent downgrades
                            if (currentVersion != null && versionToUse != null &&
                                    versionComparator.compare(null, currentVersion, versionToUse) >= 0) {
                                return maven;
                            }

                            if (versionToUse != null && !versionToUse.equals(pom.getValue(existingManagedDependencyVersion()))) {
                                if (ResolvedPom.placeholderHelper.hasPlaceholders(version) && Objects.equals(convertedVersion, versionToUse)) {
                                    // revert back to the original version if the version has a placeholder
                                    versionToUse = version;
                                }
                                doAfterVisit(new AddManagedDependencyVisitor(groupId, artifactId,
                                        versionToUse, scope, type, classifier));
                                maybeUpdateModel();
                            }
                        } catch (MavenDownloadingException e) {
                            return e.warn(document);
                        }
                    }
                }

                return maven;
            }

            private @Nullable String existingManagedDependencyVersion() {
                return getResolutionResult().getPom().getDependencyManagement().stream()
                        .map(resolvedManagedDep -> {
                            if (resolvedManagedDep.matches(groupId, artifactId, type, classifier)) {
                                return resolvedManagedDep.getGav().getVersion();
                            } else if (resolvedManagedDep.getRequestedBom() != null &&
                                       resolvedManagedDep.getRequestedBom().getGroupId().equals(groupId) &&
                                       resolvedManagedDep.getRequestedBom().getArtifactId().equals(artifactId)) {
                                return resolvedManagedDep.getRequestedBom().getVersion();
                            }
                            return null;
                        })
                        .filter(Objects::nonNull)
                        .findFirst().orElse(null);
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""version"": ""String field""
}"
Change Maven plugin executions,Apply the specified executions to a Maven plugin. Will not add the plugin if it does not already exist in the pom.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.xml.AddOrUpdateChild.addOrUpdateChild;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePluginExecutions extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build/plugins"");

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Language(""xml"")
    @Option(displayName = ""Executions"",
            description = ""Plugin goal executions provided as raw XML. Supplying `null` will remove any existing executions."",
            example = ""<execution><phase>validate</phase><goals><goal>dryRun</goal></goals></execution>"",
            required = false)
    @Nullable
    String executions;

    @Override
    public String getDisplayName() {
        return ""Change Maven plugin executions"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Apply the specified executions to a Maven plugin. Will not add the plugin if it does not already exist in the pom."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag plugins = (Xml.Tag) super.visitTag(tag, ctx);
                if (PLUGINS_MATCHER.matches(getCursor())) {
                    Optional<Xml.Tag> maybePlugin = plugins.getChildren().stream()
                            .filter(plugin ->
                                    ""plugin"".equals(plugin.getName()) &&
                                            groupId.equals(plugin.getChildValue(""groupId"").orElse(null)) &&
                                            artifactId.equals(plugin.getChildValue(""artifactId"").orElse(null))
                            )
                            .findAny();
                    if (maybePlugin.isPresent()) {
                        Xml.Tag plugin = maybePlugin.get();
                        if (executions == null) {
                            plugins = filterChildren(plugins, plugin, child -> !(child instanceof Xml.Tag && ""executions"".equals(((Xml.Tag) child).getName())));
                        } else {
                            plugins = addOrUpdateChild(plugins, plugin,
                                    Xml.Tag.build(""<executions>\n"" + executions + ""\n</executions>""),
                                    getCursor().getParentOrThrow());
                        }
                    }
                }
                return plugins;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Remove Maven plugin dependency,Removes a dependency from the <dependencies> section of a plugin in the pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

import static org.openrewrite.internal.StringUtils.matchesGlob;
import static org.openrewrite.xml.FilterTagChildrenVisitor.filterTagChildren;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemovePluginDependency extends Recipe {
    private static final XPathMatcher PLUGINS_MATCHER = new XPathMatcher(""/project/build/plugins"");

    @Option(displayName = ""Plugin group ID"",
            description = ""Group ID of the plugin from which the dependency will be removed. Supports glob."" +
                    ""A Group ID is the first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String pluginGroupId;

    @Option(displayName = ""Plugin artifact ID"",
            description = ""Artifact ID of the plugin from which the dependency will be removed. Supports glob."" +
                    ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String pluginArtifactId;

    @Option(displayName = ""Group"",
            description = ""The first part of a plugin dependency coordinate. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a plugin dependency coordinate. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Override
    public String getDisplayName() {
        return ""Remove Maven plugin dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""from `%s:%s`"", pluginGroupId, pluginArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Removes a dependency from the <dependencies> section of a plugin in the pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveDependencyVisitor();
    }

    private class RemoveDependencyVisitor extends MavenIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            Xml.Tag plugins = super.visitTag(tag, ctx);
            if (!PLUGINS_MATCHER.matches(getCursor())) {
                return plugins;
            }
            Optional<Xml.Tag> maybePlugin = plugins.getChildren().stream()
                    .filter(plugin ->
                            ""plugin"".equals(plugin.getName()) &&
                                    childValueMatches(plugin, ""groupId"", pluginGroupId) &&
                                    childValueMatches(plugin, ""artifactId"", pluginArtifactId)
                    )
                    .findAny();
            if (!maybePlugin.isPresent()) {
                return plugins;
            }
            Xml.Tag plugin = maybePlugin.get();
            Optional<Xml.Tag> maybeDependencies = plugin.getChild(""dependencies"");
            if (!maybeDependencies.isPresent()) {
                return plugins;
            }
            Xml.Tag dependencies = maybeDependencies.get();
            plugins = filterTagChildren(plugins, dependencies, dependencyTag ->
                    !(childValueMatches(dependencyTag, ""groupId"", groupId) &&
                            childValueMatches(dependencyTag, ""artifactId"", artifactId))
            );
            return filterTagChildren(plugins, plugin, pluginChildTag ->
                    !(""dependencies"".equals(pluginChildTag.getName()) && pluginChildTag.getChildren().isEmpty()));
        }

        private boolean childValueMatches(Xml.Tag tag, String childValueName, String globPattern) {
            return tag.getChildValue(childValueName).map(it -> matchesGlob(it, globPattern)).orElse(false);
        }
    }
}
","{
  ""pluginGroupId"": ""String field"",
  ""pluginArtifactId"": ""String field"",
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Maven project property value,Changes the specified Maven project property value leaving the key intact.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePropertyValue extends Recipe {

    @Option(displayName = ""Key"",
            description = ""The name of the property key whose value is to be changed."",
            example = ""junit.version"")
    String key;

    @Option(displayName = ""Value"",
            description = ""Value to apply to the matching property."",
            example = ""4.13"")
    String newValue;

    @Option(displayName = ""Add if missing"",
            description = ""Add the property if it is missing from the pom file."",
            required = false)
    @Nullable
    Boolean addIfMissing;

    @Option(displayName = ""Trust parent POM"",
            description = ""Even if the parent defines a property with the same key, trust it even if the value isn't the same. "" +
                          ""Useful when you want to wait for the parent to have its value changed first. The parent is not trusted by default."",
            required = false)
    @Nullable
    Boolean trustParent;

    @Override
    public String getDisplayName() {
        return ""Change Maven project property value"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s=%s`"", key, newValue);
    }

    @Override
    public String getDescription() {
        return ""Changes the specified Maven project property value leaving the key intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                String currentValue = getResolutionResult().getPom().getProperties().get(key);
                boolean trust = Boolean.TRUE.equals(trustParent);
                if (!trust && !newValue.equals(currentValue)) {
                    return SearchResult.found(document);
                } else if (trust) {
                    String myValue = getResolutionResult().getPom().getRequested().getProperties().get(key);
                    if (myValue != null && !myValue.equals(newValue)) {
                        return SearchResult.found(document);
                    }
                }
                return document;
            }
        }, new MavenIsoVisitor<ExecutionContext>() {
            final String propertyName = key.replace(""${"", """").replace(""}"", """");

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document d = super.visitDocument(document, ctx);
                if (Boolean.TRUE.equals(addIfMissing)) {
                    doAfterVisit(new AddProperty(key, newValue, true, false).getVisitor());
                }
                return d;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isPropertyTag() && propertyName.equals(tag.getName()) &&
                    !newValue.equals(tag.getValue().orElse(null))) {
                    doAfterVisit(new ChangeTagValueVisitor<>(tag, newValue));
                    maybeUpdateModel();
                }
                return super.visitTag(tag, ctx);
            }
        });
    }
}
","{
  ""key"": ""String field"",
  ""newValue"": ""String field""
}"
Add an annotation processor to `maven-compiler-plugin`,Add an annotation processor to the maven compiler plugin. Will not do anything if it already exists. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.maven.trait.MavenPlugin;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddAnnotationProcessor extends Recipe {
    private static final String MAVEN_COMPILER_PLUGIN_GROUP_ID = ""org.apache.maven.plugins"";
    private static final String MAVEN_COMPILER_PLUGIN_ARTIFACT_ID = ""maven-compiler-plugin"";

    @Option(displayName = ""Group"",
            description = ""The first part of the coordinate 'org.projectlombok:lombok-mapstruct-binding:0.2.0' of the processor to add."",
            example = ""org.projectlombok"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a coordinate 'org.projectlombok:lombok-mapstruct-binding:0.2.0' of the processor to add."",
            example = ""lombok-mapstruct-binding"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""The third part of a coordinate 'org.projectlombok:lombok-mapstruct-binding:0.2.0' of the processor to add. "" +
                    ""Note that an exact version is expected"",
            example = ""0.2.0"")
    String version;

    @Override
    public String getDisplayName() {
        return ""Add an annotation processor to `maven-compiler-plugin`"";
    }

    @Override
    public String getDescription() {
        return ""Add an annotation processor to the maven compiler plugin. Will not do anything if it already exists. "" +
                ""Also doesn't add anything when no other annotation processors are defined yet. "" +
                ""(Perhaps `ChangePluginConfiguration` can be used)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag plugins = (Xml.Tag) super.visitTag(tag, ctx);
                plugins = (Xml.Tag) new MavenPlugin.Matcher().asVisitor(plugin -> {
                    if (MAVEN_COMPILER_PLUGIN_GROUP_ID.equals(plugin.getGroupId()) &&
                            MAVEN_COMPILER_PLUGIN_ARTIFACT_ID.equals(plugin.getArtifactId())) {
                        MavenResolutionResult mrr = getResolutionResult();
                        AtomicReference<TreeVisitor<?, ExecutionContext>> afterVisitor = new AtomicReference<>();
                        Xml.Tag modifiedPlugin = new XmlIsoVisitor<ExecutionContext>() {
                            @Override
                            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                                Xml.Tag tg = super.visitTag(tag, ctx);
                                if (""annotationProcessorPaths"".equals(tg.getName())) {
                                    for (int i = 0; i < tg.getChildren().size(); i++) {
                                        Xml.Tag child = tg.getChildren().get(i);
                                        if (groupId.equals(child.getChildValue(""groupId"").orElse(null)) &&
                                                artifactId.equals(child.getChildValue(""artifactId"").orElse(null))) {
                                            if (!version.equals(child.getChildValue(""version"").orElse(null))) {
                                                String oldVersion = child.getChildValue(""version"").orElse("""");
                                                boolean oldVersionUsesProperty = oldVersion.startsWith(""${"");
                                                String lookupVersion = oldVersionUsesProperty ?
                                                        mrr.getPom().getValue(oldVersion.trim()) :
                                                        oldVersion;
                                                VersionComparator comparator = Semver.validate(lookupVersion, null).getValue();
                                                if (comparator.compare(version, lookupVersion) > 0) {
                                                    if (oldVersionUsesProperty) {
                                                        afterVisitor.set(new ChangePropertyValue(oldVersion, version, null, null).getVisitor());
                                                    } else {
                                                        List<Xml.Tag> tags = tg.getChildren();
                                                        tags.set(i, child.withChildValue(""version"", version));
                                                        return tg.withContent(tags);
                                                    }
                                                }
                                            }
                                            return tg;
                                        }
                                    }
                                    return tg.withContent(ListUtils.concat(tg.getChildren(), Xml.Tag.build(String.format(
                                            ""<path>\n<groupId>%s</groupId>\n<artifactId>%s</artifactId>\n<version>%s</version>\n</path>"",
                                            groupId, artifactId, version))));
                                }
                                return tg;
                            }
                        }.visitTag(plugin.getTree(), ctx);
                        if (afterVisitor.get() != null) {
                            doAfterVisit(afterVisitor.get());
                        }
                        return modifiedPlugin;
                    }
                    return plugin.getTree();
                }).visitNonNull(plugins, 0);
                if (plugins != tag) {
                    plugins = autoFormat(plugins, ctx);
                }
                return plugins;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""version"": ""String field""
}"
Remove Maven dependency,Removes a single dependency from the <dependencies> section of the pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Scope"",
            description = ""Only remove dependencies if they are in this scope. If 'runtime', this will"" +
                          ""also remove dependencies in the 'compile' scope because 'compile' dependencies are part of the runtime dependency set"",
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"",
            required = false)
    @Nullable
    String scope;

    @Override
    public String getDisplayName() {
        return ""Remove Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Removes a single dependency from the <dependencies> section of the pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveDependencyVisitor();
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""scope"", ""Scope must be one of compile, runtime, test, or provided"",
                scope, s -> Scope.Invalid != Scope.fromName(s)));
    }

    private class RemoveDependencyVisitor extends MavenIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isDependencyTag(groupId, artifactId)) {
                Scope checkScope = scope != null ? Scope.fromName(scope) : null;
                ResolvedDependency dependency = findDependency(tag, checkScope);
                if (dependency != null) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                    maybeUpdateModel();
                }
            }

            return super.visitTag(tag, ctx);
        }
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Remove Maven project property,Removes the specified Maven project property from the pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveProperty extends Recipe {

    @Option(displayName = ""Property name"",
            description = ""Key name of the property to remove."",
            example = ""junit.version"")
    String propertyName;

    @Override
    public String getDisplayName() {
        return ""Remove Maven project property"";
    }

    @Override
    public String getDescription() {
        return ""Removes the specified Maven project property from the pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemovePropertyVisitor();
    }

    private class RemovePropertyVisitor extends MavenVisitor<ExecutionContext> {
        @Override
        public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isPropertyTag() && propertyName.equals(tag.getName())) {
                doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                maybeUpdateModel();
            }
            return super.visitTag(tag, ctx);
        }
    }
}
","{
  ""propertyName"": ""String field""
}"
Add the Develocity Maven extension,"To integrate the Develocity Maven extension into Maven projects, ensure that the ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.PrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;
import com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.internal.MavenXmlMapper;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.MavenMetadata;
import org.openrewrite.maven.tree.MavenRepository;
import org.openrewrite.semver.LatestRelease;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.style.GeneralFormatStyle;
import org.openrewrite.style.Style;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.XmlParser;
import org.openrewrite.xml.tree.Xml;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.*;


@Value
@EqualsAndHashCode(callSuper = false)
public class AddDevelocityMavenExtension extends ScanningRecipe<AddDevelocityMavenExtension.Accumulator> {
    private static final String GRADLE_ENTERPRISE_MAVEN_EXTENSION_ARTIFACT_ID = ""gradle-enterprise-maven-extension"";
    private static final String DEVELOCITY_MAVEN_EXTENSION_ARTIFACT_ID = ""develocity-maven-extension"";
    private static final String EXTENSIONS_XML_PATH = "".mvn/extensions.xml"";
    private static final String GRADLE_ENTERPRISE_XML_PATH = "".mvn/gradle-enterprise.xml"";
    private static final String DEVELOCITY_XML_PATH = "".mvn/develocity.xml"";

    @Language(""xml"")
    private static final String EXTENSIONS_XML_FORMAT = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
                                                        ""<extensions>\n"" +
                                                        ""</extensions>"";

    @Language(""xml"")
    private static final String EXTENSION_TAG_FORMAT = ""<extension>\n"" +
                                                        ""  <groupId>com.gradle</groupId>\n"" +
                                                        ""  <artifactId>%s</artifactId>\n"" +
                                                        ""  <version>%s</version>\n"" +
                                                        ""</extension>"";

    @Option(displayName = ""Extension version"",
            description = ""A maven-compatible version number to select the gradle-enterprise-maven-extension version."",
            required = false,
            example = ""1.17.4"")
    @Nullable
    String version;

    @Option(displayName = ""Server URL"",
            description = ""The URL of the Develocity server."",
            example = ""https://scans.gradle.com/"")
    String server;

    @Option(displayName = ""Allow untrusted server"",
            description = ""When set to `true` the extension will be configured to allow unencrypted http connections with the server. "" +
                          ""If set to `false` or omitted, the extension will refuse to communicate without transport layer security enabled."",
            required = false,
            example = ""true"")
    @Nullable
    Boolean allowUntrustedServer;

    @Option(displayName = ""Capture file fingerprints"",
            description = ""When set to `true` the extension will capture additional information about the inputs to Maven goals. "" +
                          ""This increases the size of build scans, but is useful for diagnosing issues with goal caching. "",
            required = false,
            example = ""true"")
    @Nullable
    Boolean fileFingerprints;

    @Option(displayName = ""Upload in background"",
            description = ""When set to `false` the extension will not upload build scan in the background. "" +
                          ""By default, build scans are uploaded in the background after the build has finished to avoid blocking the build process."",
            required = false,
            example = ""false"")
    @Nullable
    Boolean uploadInBackground;

    @Option(displayName = ""Publish Criteria"",
            description = ""When set to `Always` the extension will publish build scans of every single build. "" +
                          ""This is the default behavior when omitted."" +
                          ""When set to `Failure` the extension will only publish build scans when the build fails. "" +
                          ""When set to `Demand` the extension will only publish build scans when explicitly requested."",
            required = false,
            valid = {""Always"", ""Failure"", ""Demand""},
            example = ""Always"")
    @Nullable
    PublishCriteria publishCriteria;

    public enum PublishCriteria {
        Always(""ALWAYS""),
        Failure(""ON_FAILURE""),
        Demand(""ON_DEMAND"");

        private final String xmlName;

        PublishCriteria(String xmlName) {
            this.xmlName = xmlName;
        }
    }

    @Override
    public String getDisplayName() {
        return ""Add the Develocity Maven extension"";
    }

    @Override
    public String getDescription() {
        return ""To integrate the Develocity Maven extension into Maven projects, ensure that the "" +
               ""`develocity-maven-extension` is added to the `.mvn/extensions.xml` file if not already present. "" +
               ""Additionally, configure the extension by adding the `.mvn/develocity.xml` configuration file."";
    }

    @Data
    public static class Accumulator {
        boolean mavenProject;
        boolean useCRLFNewLines;
        Path matchingExtensionsXmlFile;
        Path matchingGradleEnterpriseXmlFile;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }

                SourceFile sourceFile = (SourceFile) tree;
                String sourcePath = PathUtils.separatorsToUnix(sourceFile.getSourcePath().toString());
                switch (sourcePath) {
                    case ""pom.xml"":
                        acc.setMavenProject(true);
                        acc.setUseCRLFNewLines(Style.from(GeneralFormatStyle.class, sourceFile, () -> new GeneralFormatStyle(false))
                                .isUseCRLFNewLines());
                        break;
                    case EXTENSIONS_XML_PATH:
                        if (!(sourceFile instanceof Xml.Document)) {
                            throw new RuntimeException(""The extensions.xml is not xml document type"");
                        }
                        acc.setMatchingExtensionsXmlFile(sourceFile.getSourcePath());
                        break;
                    case GRADLE_ENTERPRISE_XML_PATH:
                    case DEVELOCITY_XML_PATH:
                        acc.setMatchingGradleEnterpriseXmlFile(sourceFile.getSourcePath());
                        break;
                    default:
                        break;
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        // This recipe makes change for maven project only, or if the file `.mvn/gradle-enterprise.xml` already exists, do nothing
        if (!acc.isMavenProject() || acc.getMatchingGradleEnterpriseXmlFile() != null) {
            return emptyList();
        }

        VersionComparator versionComparator = Semver.validate(""(,1.21)"", null).getValue();
        if (versionComparator == null) {
            return emptyList();
        }

        String newVersion = version != null ? version : getLatestVersion(ctx);
        List<SourceFile> sources = new ArrayList<>();

        if (versionComparator.compare(null, newVersion, ""1.21"") >= 0) {
            BuildScanConfiguration buildScanConfiguration = buildScanConfiguration(true);
            ServerConfiguration serverConfiguration = new ServerConfiguration(server, allowUntrustedServer);
            DevelocityConfiguration develocityConfiguration = new DevelocityConfiguration(serverConfiguration, buildScanConfiguration);
            sources.add(createNewXml(DEVELOCITY_XML_PATH, writeConfiguration(develocityConfiguration, acc.isUseCRLFNewLines())));
        } else {
            BuildScanConfiguration buildScanConfiguration = buildScanConfiguration(false);
            ServerConfiguration serverConfiguration = new ServerConfiguration(server, allowUntrustedServer);
            GradleEnterpriseConfiguration gradleEnterpriseConfiguration = new GradleEnterpriseConfiguration(serverConfiguration, buildScanConfiguration);
            sources.add(createNewXml(GRADLE_ENTERPRISE_XML_PATH, writeConfiguration(gradleEnterpriseConfiguration, acc.isUseCRLFNewLines())));
        }

        if (acc.getMatchingExtensionsXmlFile() == null) {
            Xml.Document extensionsXml = createNewXml(EXTENSIONS_XML_PATH, EXTENSIONS_XML_FORMAT);
            extensionsXml = addExtension(extensionsXml, ctx);
            sources.add(extensionsXml);
        }

        return sources;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        if (!acc.isMavenProject() || acc.getMatchingExtensionsXmlFile() == null) {
            return TreeVisitor.noop();
        }

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }

                SourceFile sourceFile = (SourceFile) tree;
                if (sourceFile.getSourcePath().equals(acc.getMatchingExtensionsXmlFile())) {
                    Xml.Document extensionsXml = (Xml.Document) sourceFile;

                    // find extension, do nothing if it already exists,
                    boolean hasEnterpriseExtension = findExistingExtension(extensionsXml);
                    if (hasEnterpriseExtension) {
                        return sourceFile;
                    }

                    return addExtension(extensionsXml, ctx);
                }
                return tree;
            }
        };
    }

    @JacksonXmlRootElement(localName = ""gradleEnterprise"")
    @Value
    private static class GradleEnterpriseConfiguration {
        ServerConfiguration server;

        @Nullable
        BuildScanConfiguration buildScan;
    }

    @JacksonXmlRootElement(localName = ""develocity"")
    @Value
    private static class DevelocityConfiguration {
        ServerConfiguration server;

        @Nullable
        BuildScanConfiguration buildScan;
    }

    @Value
    private static class ServerConfiguration {
        String url;

        @Nullable
        Boolean allowUntrusted;
    }

    @Value
    private static class BuildScanConfiguration {
        @Nullable
        Boolean backgroundBuildScanUpload;

        @Nullable
        String publish;

        @Nullable
        PublishingConfiguration publishing;

        @Nullable
        Capture capture;
    }

    @Value
    private static class PublishingConfiguration {
        @Nullable
        String onlyIf;
    }

    @Value
    private static class Capture {
        Boolean goalInputFiles;
        Boolean fileFingerprints;
    }

    private String writeConfiguration(Object config, boolean useCRLFNewLines) {
        try {
            ObjectMapper objectMapper = MavenXmlMapper.writeMapper();
            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
            objectMapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);
            PrettyPrinter pp = new DefaultXmlPrettyPrinter().withCustomNewLine(useCRLFNewLines ? ""\r\n"" : ""\n"");
            return objectMapper.writer(pp).writeValueAsString(config);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private @Nullable BuildScanConfiguration buildScanConfiguration(boolean develocity) {
        if (uploadInBackground != null || publishCriteria != null || fileFingerprints != null) {
            if (develocity) {
                PublishingConfiguration publishing = null;
                if (publishCriteria != null) {
                    String onlyIf;
                    switch (publishCriteria) {
                        case Always:
                            onlyIf = ""true"";
                            break;
                        case Failure:
                            onlyIf = ""!buildResult.failures.empty"";
                            break;
                        case Demand:
                            onlyIf = ""false"";
                            break;
                        default:
                            throw new IllegalStateException(""All options exhausted"");
                    }
                    publishing = new PublishingConfiguration(onlyIf);
                }

                return new BuildScanConfiguration(
                        uploadInBackground,
                        null,
                        publishing,
                        fileFingerprints != null ? new Capture(null, fileFingerprints) : null
                );
            } else {
                return new BuildScanConfiguration(uploadInBackground,
                        publishCriteria != null ? publishCriteria.xmlName : null,
                        null,
                        fileFingerprints != null ? new Capture(fileFingerprints, null) : null);
            }
        }
        return null;
    }

    private static Xml.Document createNewXml(String filePath, @Language(""xml"") String fileContents) {
        XmlParser parser = new XmlParser();
        Xml.Document brandNewFile = parser.parse(fileContents).findFirst()
                .map(Xml.Document.class::cast)
                .orElseThrow(() -> new IllegalArgumentException(""Unable to parse XML contents""));
        return brandNewFile.withSourcePath(Paths.get(filePath));
    }

    /**
     * Return true if the `.mvn/extensions.xml` already includes `gradle-enterprise-maven-extension`
     */
    private boolean findExistingExtension(Xml.Document extensionsXml) {
        XPathMatcher xPathMatcher = new XPathMatcher(""/extensions/extension/artifactId"");
        return new XmlIsoVisitor<AtomicBoolean>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, AtomicBoolean found) {
                if (found.get()) {
                    return tag;
                }
                tag = super.visitTag(tag, found);
                if (xPathMatcher.matches(getCursor())) {
                    Optional<String> maybeArtifactId = tag.getValue();
                    if (maybeArtifactId.isPresent() && (GRADLE_ENTERPRISE_MAVEN_EXTENSION_ARTIFACT_ID.equals(maybeArtifactId.get()) || DEVELOCITY_MAVEN_EXTENSION_ARTIFACT_ID.equals(maybeArtifactId.get()))) {
                        found.set(true);
                    }
                }
                return tag;
            }
        }.reduce(extensionsXml, new AtomicBoolean()).get();
    }

    /**
     * Add `develocity-maven-extension` to the file `.mvn/extensions.xml`,
     * this method assumes that `develocity-maven-extension` does not exist yet, and it should have been checked.
     */
    private Xml.Document addExtension(Xml.Document extensionsXml, ExecutionContext ctx) {
        VersionComparator versionComparator = Semver.validate(""(,1.21)"", null).getValue();
        if (versionComparator == null) {
            return extensionsXml;
        }

        String newVersion = version != null ? version : getLatestVersion(ctx);

        String extension;
        if (versionComparator.compare(null, newVersion, ""1.21"") >= 0) {
            extension = ""develocity-maven-extension"";
        } else {
            extension = ""gradle-enterprise-maven-extension"";
        }
        @Language(""xml"")
        String tagSource = String.format(EXTENSION_TAG_FORMAT, extension, newVersion);
        AddToTagVisitor<ExecutionContext> addToTagVisitor = new AddToTagVisitor<>(
                extensionsXml.getRoot(),
                Xml.Tag.build(tagSource));
        return (Xml.Document) addToTagVisitor.visitNonNull(extensionsXml, ctx);
    }

    private String getLatestVersion(ExecutionContext ctx) {
        MavenExecutionContextView mctx = MavenExecutionContextView.view(ctx);
        MavenPomDownloader pomDownloader = new MavenPomDownloader(emptyMap(), ctx, mctx.getSettings(), mctx.getActiveProfiles());
        VersionComparator versionComparator = new LatestRelease(null);
        GroupArtifact develocityExtension = new GroupArtifact(""com.gradle"", DEVELOCITY_MAVEN_EXTENSION_ARTIFACT_ID);
        try {
            MavenMetadata extensionMetadata = pomDownloader.downloadMetadata(develocityExtension, null, singletonList(MavenRepository.MAVEN_CENTRAL));
            return extensionMetadata.getVersioning()
                    .getVersions()
                    .stream()
                    .filter(v -> versionComparator.isValid(null, v))
                    .max((v1, v2) -> versionComparator.compare(null, v1, v2))
                    .orElseThrow(() -> new IllegalStateException(""Expected to find at least one Gradle Enterprise Maven extension version to select from.""));
        } catch (MavenDownloadingException e) {
            throw new IllegalStateException(""Could not download Maven metadata"", e);
        }
    }
}
","{
  ""server"": ""String field""
}"
Add repository,Adds a new Maven Repository or updates a matching repository.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.util.Objects;
import java.util.Optional;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddRepository extends Recipe {

    @Option(example = ""repo-id"", displayName = ""Repository ID"",
            description = ""A unique name to describe the repository."")
    String id;

    @Option(example = ""http://myrepo.maven.com/repo"", displayName = ""Repository URL"",
            description = ""The URL of the repository."")
    String url;

    @Option(example = ""My Great Repo Name"", required = false,
            displayName = ""Repository name"",
            description = ""A display name for the repository."")
    @Nullable
    String repoName;

    @Option(example = ""default"", required = false,
            displayName = ""Repository layout"",
            description = ""The Maven layout of the repository."")
    @Nullable
    String layout;

    @Option(required = false,
            displayName = ""Enable snapshots"",
            description = ""Snapshots from the repository are available."")
    @Nullable
    Boolean snapshotsEnabled;

    @Option(example = ""warn"", required = false,
            displayName = ""Snapshots checksum policy"",
            description = ""Governs whether snapshots require checksums."")
    @Nullable
    String snapshotsChecksumPolicy;

    @Option(example = ""always"", required = false,
            displayName = ""Snapshots update policy"",
            description = ""The policy governing snapshot updating interval."")
    @Nullable
    String snapshotsUpdatePolicy;

    @Option(required = false,
            displayName = ""Releases enabled"",
            description = ""Releases from the repository are available"")
    @Nullable
    Boolean releasesEnabled;

    @Option(example = ""fail"", required = false,
            displayName = ""Releases checksum policy"",
            description = ""Governs whether releases require checksums."")
    @Nullable
    String releasesChecksumPolicy;

    @Option(example = ""never"", required = false,
            displayName = ""Releases update policy"",
            description = ""The policy governing release updating interval."")
    @Nullable
    String releasesUpdatePolicy;

    @Option(displayName = ""Repository type"",
            description = ""The type of repository to add."",
            example = ""Repository"",
            required = false)
    @Nullable
    Type type;

    @RequiredArgsConstructor
    public enum Type {
        Repository(""repository"", ""repositories""),
        PluginRepository(""pluginRepository"", ""pluginRepositories"");

        final String xmlTagSingle;
        final String xmlTagPlural;
    }

    public Type getType() {
        return type == null ? Type.Repository : type;
    }

    @Override
    public String getDisplayName() {
        return ""Add repository"";
    }

    @Override
    public String getDescription() {
        return ""Adds a new Maven Repository or updates a matching repository."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            private final XPathMatcher REPOS_MATCHER = new XPathMatcher(""/project/"" + getType().xmlTagPlural);

            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Tag root = document.getRoot();
                if (!root.getChild(getType().xmlTagPlural).isPresent()) {
                    document = (Xml.Document) new AddToTagVisitor<>(root, Xml.Tag.build(""<"" + getType().xmlTagPlural + ""/>""))
                            .visitNonNull(document, ctx, getCursor().getParentOrThrow());
                }
                return super.visitDocument(document, ctx);
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag repositories = super.visitTag(tag, ctx);

                if (REPOS_MATCHER.matches(getCursor())) {
                    Optional<Xml.Tag> maybeRepo = repositories.getChildren().stream()
                            .filter(repo ->
                                    getType().xmlTagSingle.equals(repo.getName()) &&
                                    (id.equals(repo.getChildValue(""id"").orElse(null)) || (isReleasesEqual(repo) && isSnapshotsEqual(repo))) &&
                                    url.equals(repo.getChildValue(""url"").orElse(null))
                            )
                            .findAny();

                    if (maybeRepo.isPresent()) {
                        Xml.Tag repo = maybeRepo.get();
                        if (repoName != null && !Objects.equals(repoName, repo.getChildValue(""name"").orElse(null))) {
                            //noinspection OptionalGetWithoutIsPresent
                            repositories = (Xml.Tag) new ChangeTagValueVisitor<>(repo.getChild(""name"").get(), repoName)
                                    .visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                        }
                        if (repoName != null && layout != null && !Objects.equals(layout, repo.getChildValue(""layout"").orElse(null))) {
                            //noinspection OptionalGetWithoutIsPresent
                            repositories = (Xml.Tag) new ChangeTagValueVisitor<>(repo.getChild(""layout"").get(), repoName)
                                    .visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                            maybeUpdateModel();
                        }
                        if (!isReleasesEqual(repo)) {
                            Xml.Tag releases = repo.getChild(""releases"").orElse(null);
                            if (releases == null) {
                                repositories = (Xml.Tag) new AddToTagVisitor<>(repo, Xml.Tag.build(assembleReleases()))
                                        .visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                            } else {
                                repositories = (Xml.Tag) new RemoveContentVisitor<>(releases, true, true)
                                        .visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                                if (!isNoSnapshots()) {
                                    repositories = (Xml.Tag) new AddToTagVisitor<>(repo, Xml.Tag.build(assembleReleases()))
                                            .visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                                }
                            }
                            maybeUpdateModel();
                        }
                        if (!isSnapshotsEqual(repo)) {
                            Xml.Tag snapshots = repo.getChild(""snapshots"").orElse(null);
                            if (snapshots == null) {
                                repositories = (Xml.Tag) new AddToTagVisitor<>(repo, Xml.Tag.build(assembleSnapshots())).visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                            } else {
                                repositories = (Xml.Tag) new RemoveContentVisitor<>(snapshots, true, true).visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                                if (!isNoSnapshots()) {
                                    repositories = (Xml.Tag) new AddToTagVisitor<>(repo, Xml.Tag.build(assembleSnapshots())).visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                                }
                            }
                            maybeUpdateModel();
                        }
                    } else {
                        @Language(""xml"")
                        String sb = ""<"" + getType().xmlTagSingle + "">\n"" +
                                    assembleTagWithValue(""id"", id) +
                                    assembleTagWithValue(""url"", url) +
                                    assembleTagWithValue(""name"", repoName) +
                                    assembleTagWithValue(""layout"", layout) +
                                    assembleReleases() +
                                    assembleSnapshots() +
                                    ""</"" + getType().xmlTagSingle + "">\n"";

                        Xml.Tag repoTag = Xml.Tag.build(sb);
                        repositories = (Xml.Tag) new AddToTagVisitor<>(repositories, repoTag).visitNonNull(repositories, ctx, getCursor().getParentOrThrow());
                        maybeUpdateModel();
                    }
                }
                return repositories;
            }
        };
    }

    private String assembleTagWithValue(String tag, @Nullable String value) {
        StringBuilder sb = new StringBuilder();
        if (value != null) {
            sb.append(""<"");
            sb.append(tag);
            sb.append("">"");
            sb.append(value);
            sb.append(""</"");
            sb.append(tag);
            sb.append("">\n"");
        }
        return sb.toString();
    }

    private String assembleReleases() {
        StringBuilder sb = new StringBuilder();
        if (releasesUpdatePolicy != null || releasesEnabled != null || releasesChecksumPolicy != null) {
            sb.append(""<releases>"");
            if (releasesEnabled != null) {
                sb.append(assembleTagWithValue(""enabled"", String.valueOf(releasesEnabled.booleanValue())));
            }
            if (releasesUpdatePolicy != null) {
                sb.append(assembleTagWithValue(""updatePolicy"", releasesUpdatePolicy));
            }
            if (releasesChecksumPolicy != null) {
                sb.append(assembleTagWithValue(""checksumPolicy"", releasesChecksumPolicy));
            }
            sb.append(""</releases>\n"");
        }
        return sb.toString();
    }

    private String assembleSnapshots() {
        StringBuilder sb = new StringBuilder();
        if (snapshotsEnabled != null || snapshotsChecksumPolicy != null || snapshotsUpdatePolicy != null) {
            sb.append(""<snapshots>"");
            if (snapshotsEnabled != null) {
                sb.append(assembleTagWithValue(""enabled"", String.valueOf(snapshotsEnabled.booleanValue())));
            }
            if (snapshotsUpdatePolicy != null) {
                sb.append(assembleTagWithValue(""updatePolicy"", snapshotsUpdatePolicy));
            }
            if (snapshotsChecksumPolicy != null) {
                sb.append(assembleTagWithValue(""checksumPolicy"", snapshotsChecksumPolicy));
            }
            sb.append(""</snapshots>\n"");
        }
        return sb.toString();
    }

    private boolean isReleasesEqual(Xml.Tag repo) {
        Xml.Tag releases = repo.getChild(""releases"").orElse(null);
        if (releases == null) {
            return isNoReleases();
        } else {
            return Objects.equals(releasesEnabled == null ? null : String.valueOf(releasesEnabled.booleanValue()), releases.getChildValue(""enabled"").orElse(null)) &&
                   Objects.equals(releasesUpdatePolicy, releases.getChildValue(""updatePolicy"").orElse(null)) &&
                   Objects.equals(releasesChecksumPolicy, releases.getChildValue(""checksumPolicy"").orElse(null));
        }
    }

    private boolean isNoReleases() {
        return releasesEnabled == null && releasesUpdatePolicy == null && releasesChecksumPolicy == null;
    }

    private boolean isSnapshotsEqual(Xml.Tag repo) {
        Xml.Tag snapshots = repo.getChild(""snapshots"").orElse(null);
        if (snapshots == null) {
            return isNoSnapshots();
        } else {
            return Objects.equals(snapshotsEnabled == null ? null : String.valueOf(snapshotsEnabled.booleanValue()), snapshots.getChildValue(""enabled"").orElse(null)) &&
                   Objects.equals(snapshotsUpdatePolicy, snapshots.getChildValue(""updatePolicy"").orElse(null)) &&
                   Objects.equals(snapshotsChecksumPolicy, snapshots.getChildValue(""checksumPolicy"").orElse(null));
        }
    }

    private boolean isNoSnapshots() {
        return snapshotsEnabled == null && snapshotsUpdatePolicy == null && snapshotsChecksumPolicy == null;
    }

}
","{
  ""id"": ""String field"",
  ""url"": ""String field""
}"
Use HTTPS for repositories,Use HTTPS for repository URLs.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.security;

import lombok.AllArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.xml.ChangeTagValueVisitor;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class UseHttpsForRepositories extends Recipe {
    private static final XPathMatcher REPOSITORY_URL_MATCHER = new XPathMatcher(""/project/repositories/repository/url"");
    private static final XPathMatcher PLUGIN_REPOSITORY_URL_MATCHER = new XPathMatcher(""/project/pluginRepositories/pluginRepository/url"");
    private static final XPathMatcher DISTRIBUTION_MANAGEMENT_REPOSITORY_URL_MATCHER = new XPathMatcher(""/project/distributionManagement/repository/url"");
    private static final XPathMatcher DISTRIBUTION_MANAGEMENT_SNAPSHOT_REPOSITORY_URL_MATCHER = new XPathMatcher(""/project/distributionManagement/snapshotRepository/url"");

    @Override
    public String getDisplayName() {
        return ""Use HTTPS for repositories"";
    }

    @Override
    public String getDescription() {
        return ""Use HTTPS for repository URLs."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    @Override
    public Set<String> getTags() {
        return new HashSet<>(Arrays.asList(""security"", ""CWE-829""));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isRepositoryUrlTag()) {
                    if (isInsecureTag(tag)) {
                        @SuppressWarnings(""OptionalGetWithoutIsPresent"")
                        String newValue = replaceInsecure(tag.getValue().get());
                        doAfterVisit(new ChangeTagValueVisitor<>(tag, newValue));
                    } else if (tag.getValue().map(v -> v.startsWith(""$"")).orElse(false)) {
                        String repositoryUrlProperty = tag.getValue().get();
                        doAfterVisit(new UpdateMavenPropertyToHttpsVisitor(
                            repositoryUrlProperty.substring(2, repositoryUrlProperty.length() - 1)
                        ));
                    }
                }
                return super.visitTag(tag, ctx);

            }

            private boolean isRepositoryUrlTag() {
                return REPOSITORY_URL_MATCHER.matches(getCursor()) ||
                    PLUGIN_REPOSITORY_URL_MATCHER.matches(getCursor()) ||
                    DISTRIBUTION_MANAGEMENT_REPOSITORY_URL_MATCHER.matches(getCursor()) ||
                    DISTRIBUTION_MANAGEMENT_SNAPSHOT_REPOSITORY_URL_MATCHER.matches(getCursor());
            }
        };
    }

    @AllArgsConstructor
    static class UpdateMavenPropertyToHttpsVisitor extends MavenIsoVisitor<ExecutionContext> {
        final String propertyName;

        @Override
        public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
            if (isPropertyTag() && propertyName.equals(tag.getName()) && isInsecureTag(tag)) {
                @SuppressWarnings(""OptionalGetWithoutIsPresent"")
                String newValue = replaceInsecure(tag.getValue().get());
                doAfterVisit(new ChangeTagValueVisitor<>(tag, newValue));
            }
            return super.visitTag(tag, ctx);
        }
    }

    private static boolean isInsecureTag(Xml.Tag tag) {
        return tag.getValue().map(UseHttpsForRepositories::isInsecure).orElse(false);
    }

    @SuppressWarnings(""HttpUrlsUsage"")
    private static boolean isInsecure(String value) {
        return value.startsWith(""http://"") || value.startsWith(""ftp://"");
    }

    private static String replaceInsecure(String value) {
        return value.replaceAll(""^http://(.*)"", ""https://$1"")
            .replaceAll(""^ftp://(.*)"", ""ftps://$1"");
    }
}
",{}
Migrate to `maven-dependency-plugin` goal `resolve-sources`,Migrate from `sources` to `resolve-sources` for the `maven-dependency-plugin`.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.plugin;

import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.tree.Plugin;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.tree.Xml;

import static java.util.Objects.requireNonNull;

@SuppressWarnings(""ALL"")
public class DependencyPluginGoalResolveSources extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Migrate to `maven-dependency-plugin` goal `resolve-sources`"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from `sources` to `resolve-sources` for the `maven-dependency-plugin`."";
    }

    private static final XPathMatcher xPathMatcher = new XPathMatcher(""//plugin[artifactId='maven-dependency-plugin']/executions/execution/goals[goal='sources']/goal"");
    private static final String minimumVersion = ""3.7.0"";

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        VersionComparator comparator = requireNonNull(Semver.validate(minimumVersion, null).getValue());
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (xPathMatcher.matches(getCursor()) && isPlugInVersionInRange()) {
                    return tag.withValue(""resolve-sources"");
                }
                return t;
            }

            private boolean isPlugInVersionInRange() {
                Cursor pluginCursor = getCursor().dropParentUntil(i -> i instanceof Xml.Tag && ""plugin"".equals(((Xml.Tag) i).getName()));
                Xml.Tag pluginTag = pluginCursor.getValue();
                Plugin plugin = findPlugin(pluginTag);
                if (plugin == null || plugin.getVersion() == null) {
                    plugin = findManagedPlugin(pluginTag);
                    if (plugin == null || plugin.getVersion() == null) {
                        return false;
                    }
                }
                return comparator.compare(null, plugin.getVersion(), minimumVersion) >= 0;
            }
        };
    }
}
",{}
Module has dependency,Searches for Maven modules that have a dependency matching the specified groupId and artifactId. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class ModuleHasDependency extends ScanningRecipe<ModuleHasDependency.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Module has dependency"";
    }

    @Override
    public String getDescription() {
        return ""Searches for Maven modules that have a dependency matching the specified groupId and artifactId. "" +
               ""Places a `SearchResult` marker on all sources within a module with a matching dependency. "" +
               ""This recipe is intended to be used as a precondition for other recipes. "" +
               ""For example this could be used to limit the application of a spring boot migration to only projects "" +
               ""that use spring-boot-starter, limiting unnecessary upgrading. "" +
               ""If the search result you want is instead just the build.gradle(.kts) file applying the plugin, use the `FindDependency` recipe instead."";
    }

    @Option(displayName = ""Group pattern"",
            description = ""Group glob pattern used to match dependencies."",
            example = ""com.fasterxml.jackson.module"")
    String groupIdPattern;

    @Option(displayName = ""Artifact pattern"",
            description = ""Artifact glob pattern used to match dependencies."",
            example = ""jackson-module-*"")
    String artifactIdPattern;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. All scopes are searched by default."",
            valid = {""compile"", ""test"", ""runtime"", ""provided"", ""system""},
            example = ""compile"",
            required = false)
    @Nullable
    String scope;

    @Option(displayName = ""Version"",
            description = ""Match only dependencies with the specified version. "" +
                          ""Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used."" +
                          ""All versions are searched by default."",
            example = ""1.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Only direct"",
            description = ""If enabled, transitive dependencies will not be considered. All dependencies are searched by default."",
            required = false,
            example = ""true"")
    @Nullable
    Boolean onlyDirect;

    @Value
    public static class Accumulator {
        Set<JavaProject> projectsWithDependency;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator(new HashSet<>());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                tree.getMarkers()
                        .findFirst(JavaProject.class)
                        .ifPresent(jp -> {
                            Tree t = new DependencyInsight(groupIdPattern, artifactIdPattern, scope, version, onlyDirect).getVisitor().visit(tree, ctx);
                            if (t != tree) {
                                acc.getProjectsWithDependency().add(jp);
                            }
                        });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                Optional<JavaProject> maybeJp = tree.getMarkers().findFirst(JavaProject.class);
                if (!maybeJp.isPresent()) {
                    return tree;
                }
                JavaProject jp = maybeJp.get();
                if (acc.getProjectsWithDependency().contains(jp)) {
                    return SearchResult.found(tree, ""Module has dependency: "" + groupIdPattern + "":"" + artifactIdPattern + (version == null ? """" : "":"" + version));
                }
                return tree;
            }
        };
    }
}
","{
  ""groupIdPattern"": ""String field"",
  ""artifactIdPattern"": ""String field""
}"
Find Maven dependency,"Finds first-order dependency uses, i.e. dependencies that are defined directly in a project.",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import java.util.HashSet;
import java.util.Set;
import java.util.function.Supplier;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""3.0.0"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    public static Set<Xml.Tag> find(Xml.Document maven, String groupId, String artifactId) {
        return find(maven, groupId, artifactId, null, null);
    }

    public static Set<Xml.Tag> find(Xml.Document maven, String groupId, String artifactId,
                                    @Nullable String version, @Nullable String versionPattern) {
        Set<Xml.Tag> ds = new HashSet<>();
        new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag(groupId, artifactId) &&
                    versionIsValid(version, versionPattern, () -> findDependency(tag))) {
                    ds.add(tag);
                }
                return super.visitTag(tag, ctx);
            }
        }.visit(maven, new InMemoryExecutionContext());
        return ds;
    }

    @Override
    public String getDisplayName() {
        return ""Find Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        String maybeVersionSuffix = version == null ? """" : String.format("":%s%s"", version, versionPattern == null ? """" : versionPattern);
        return String.format(""`%s:%s%s`"", groupId, artifactId, maybeVersionSuffix);
    }

    @Override
    public String getDescription() {
        return ""Finds first-order dependency uses, i.e. dependencies that are defined directly in a project."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isDependencyTag(groupId, artifactId) &&
                    versionIsValid(version, versionPattern, () -> findDependency(tag))) {
                    return SearchResult.found(tag);
                }
                return super.visitTag(tag, ctx);
            }
        };
    }

    private static boolean versionIsValid(@Nullable String desiredVersion, @Nullable String versionPattern,
                                          Supplier<@Nullable ResolvedDependency> resolvedDependencySupplier) {
        if (desiredVersion == null) {
            return true;
        }
        ResolvedDependency resolvedDependency = resolvedDependencySupplier.get();
        if (resolvedDependency == null) {
            // shouldn't happen, but if it does, fail the condition
            return false;
        }
        String actualVersion = resolvedDependency.getVersion();
        Validated<VersionComparator> validate = Semver.validate(desiredVersion, versionPattern);
        if (validate.isInvalid()) {
            return false;
        }
        assert(validate.getValue() != null);
        return validate.getValue().isValid(actualVersion, actualVersion);
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Find effective maven settings,List the effective maven settings file for the current project.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenExecutionContextView;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.MavenSettings;
import org.openrewrite.maven.table.EffectiveMavenSettings;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.tree.Xml;

import java.io.UncheckedIOException;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindMavenSettings extends Recipe {
    @Option(displayName = ""Existence check only"",
            description = ""Only record that a maven settings file exists; do not include its contents."",
            required = false)
    @Nullable
    Boolean existenceCheckOnly;

    transient EffectiveMavenSettings settings = new EffectiveMavenSettings(this);

    @Override
    public String getDisplayName() {
        return ""Find effective maven settings"";
    }

    @Override
    public String getDescription() {
        return ""List the effective maven settings file for the current project."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        XmlMapper mapper = new XmlMapper();

        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                MavenSettings effectiveSettings = MavenExecutionContextView.view(ctx).effectiveSettings(mrr);
                if (effectiveSettings != null) {
                    try {
                        settings.insertRow(ctx, new EffectiveMavenSettings.Row(
                                document.getSourcePath().toString(),
                                Boolean.TRUE.equals(existenceCheckOnly) ?
                                        ""exists"" :
                                        mapper.writerWithDefaultPrettyPrinter().writeValueAsString(mrr.getMavenSettings())
                        ));
                    } catch (JsonProcessingException e) {
                        throw new UncheckedIOException(e);
                    }
                }
                return document;
            }
        };
    }
}
",{}
Module has plugin,Searches for Maven modules that have a plugin matching the specified groupId and artifactId. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class ModuleHasPlugin extends ScanningRecipe<ModuleHasPlugin.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Module has plugin"";
    }

    @Override
    public String getDescription() {
        return ""Searches for Maven modules that have a plugin matching the specified groupId and artifactId. "" +
               ""Places a `SearchResult` marker on all sources within a module with a matching plugin. "" +
               ""This recipe is intended to be used as a precondition for other recipes. "" +
               ""For example this could be used to limit the application of a spring boot migration to only projects "" +
               ""that apply the spring boot plugin, limiting unnecessary upgrading. "" +
               ""If the search result you want is instead just the build.gradle(.kts) file applying the plugin, use the `FindPlugins` recipe instead."";
    }

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    @Value
    public static class Accumulator {
        Set<JavaProject> projectsWithDependency;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator(new HashSet<>());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                tree.getMarkers()
                        .findFirst(JavaProject.class)
                        .ifPresent(jp -> {
                            Tree t = new FindPlugin(groupId, artifactId).getVisitor().visit(tree, ctx);
                            if (t != tree) {
                                acc.getProjectsWithDependency().add(jp);
                            }
                        });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                Optional<JavaProject> maybeJp = tree.getMarkers().findFirst(JavaProject.class);
                if (!maybeJp.isPresent()) {
                    return tree;
                }
                JavaProject jp = maybeJp.get();
                if (acc.getProjectsWithDependency().contains(jp)) {
                    return SearchResult.found(tree, ""Module has plugin: "" + groupId + "":"" + artifactId);
                }
                return tree;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Maven dependency insight,"Find direct and transitive dependencies matching a group, artifact, and scope. ",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.marker.Markup;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.table.DependenciesInUse;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import java.util.Optional;

/**
 * Find direct and transitive dependencies, marking first order dependencies that
 * either match or transitively include a dependency matching {@link #groupIdPattern} and
 * {@link #artifactIdPattern}.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class DependencyInsight extends Recipe {
    transient DependenciesInUse dependenciesInUse = new DependenciesInUse(this);

    @Option(displayName = ""Group pattern"",
            description = ""Group glob pattern used to match dependencies."",
            example = ""com.fasterxml.jackson.module"")
    String groupIdPattern;

    @Option(displayName = ""Artifact pattern"",
            description = ""Artifact glob pattern used to match dependencies."",
            example = ""jackson-module-*"")
    String artifactIdPattern;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. All scopes are searched by default."",
            valid = {""compile"", ""test"", ""runtime"", ""provided"", ""system""},
            example = ""compile"",
            required = false)
    @Nullable
    String scope;

    @Option(displayName = ""Version"",
            description = ""Match only dependencies with the specified version. "" +
                          ""Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used."" +
                          ""All versions are searched by default."",
            example = ""1.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Only direct"",
            description = ""If enabled, transitive dependencies will not be considered. All dependencies are searched by default."",
            required = false,
            example = ""true"")
    @Nullable
    Boolean onlyDirect;

    @Override
    public Validated<Object> validate() {
        Validated<Object> v = super.validate()
                .and(Validated.test(""scope"", ""scope is a valid Maven scope"", scope,
                        s -> Scope.fromName(s) != Scope.Invalid));
        if (version != null) {
            v = v.and(Semver.validate(version, null));
        }
        return v;
    }

    @Override
    public String getDisplayName() {
        return ""Maven dependency insight"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupIdPattern, artifactIdPattern);
    }

    @Override
    public String getDescription() {
        return ""Find direct and transitive dependencies matching a group, artifact, and scope. "" +
               ""Results include dependencies that either directly match or transitively include a matching dependency."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Scope aScope = (scope == null) ? null : Scope.fromName(scope);

        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if(!isDependencyTag()) {
                    return t;
                }
                ResolvedDependency dependency = findDependency(t, aScope);
                if(dependency == null) {
                    return t;
                }
                ResolvedDependency match = dependency.findDependency(groupIdPattern, artifactIdPattern);
                if(match == null) {
                    return t;
                }
                if(version != null) {
                    VersionComparator versionComparator = Semver.validate(version, null).getValue();
                    if(versionComparator == null) {
                        t = Markup.warn(t, new IllegalArgumentException(""Could not construct a valid version comparator from "" + version + "".""));
                    } else {
                        if(!versionComparator.isValid(null, match.getVersion())) {
                            return t;
                        }
                    }
                }
                if (match == dependency) {
                    t = SearchResult.found(t);
                } else if (Boolean.TRUE.equals(onlyDirect)) {
                    return t;
                } else {
                    t = SearchResult.found(t, match.getGav().toString());
                }

                Optional<JavaProject> javaProject = getCursor().firstEnclosingOrThrow(Xml.Document.class).getMarkers()
                        .findFirst(JavaProject.class);
                Optional<JavaSourceSet> javaSourceSet = getCursor().firstEnclosingOrThrow(Xml.Document.class).getMarkers()
                        .findFirst(JavaSourceSet.class);

                dependenciesInUse.insertRow(ctx, new DependenciesInUse.Row(
                        javaProject.map(JavaProject::getProjectName).orElse(""""),
                        javaSourceSet.map(JavaSourceSet::getName).orElse(""main""),
                        match.getGroupId(),
                        match.getArtifactId(),
                        match.getVersion(),
                        match.getDatedSnapshotVersion(),
                        StringUtils.isBlank(match.getRequested().getScope()) ? ""compile"" :
                                match.getRequested().getScope(),
                        match.getDepth()
                ));

                return t;
            }
        };
    }
}
","{
  ""groupIdPattern"": ""String field"",
  ""artifactIdPattern"": ""String field""
}"
Does not include Maven dependency,A precondition which returns false if visiting a Maven pom which includes the specified dependency in the classpath of some scope. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.tree.Scope;

import static org.openrewrite.Validated.notBlank;

@EqualsAndHashCode(callSuper = false)
@Value
public class DoesNotIncludeDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Only direct dependencies"",
            description = ""Default false. If enabled, transitive dependencies will not be considered."",
            required = false,
            example = ""true"")
    @Nullable
    Boolean onlyDirect;

    @Option(displayName = ""Scope"",
            description = ""Default any. If specified, only the requested scope's classpaths will be checked."",
            required = false,
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"")
    @Nullable
    String scope;

    @Override
    public String getDisplayName() {
        return ""Does not include Maven dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""A precondition which returns false if visiting a Maven pom which includes the specified dependency in the classpath of some scope. "" +
                ""For compatibility with multimodule projects, this should most often be applied as a precondition."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate()
                .and(notBlank(""groupId"", groupId).and(notBlank(""artifactId"", artifactId)))
                .and(Validated.test(""scope"", ""scope is a valid Maven scope"", scope,
                        s -> Scope.fromName(s) != Scope.Invalid));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            final TreeVisitor<?, ExecutionContext> di = new DependencyInsight(groupId, artifactId, scope, null, onlyDirect).getVisitor();

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return di.isAcceptable(sourceFile, ctx);
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                Tree t2 = di.visit(tree, ctx);
                // if POM file is unchanged, we found something without the dependency
                if (t2 == tree) {
                    return SearchResult.found(tree);
                }
                return tree;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Find Maven project properties,Finds the specified Maven project properties within a pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.table.MavenProperties;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.util.*;
import java.util.regex.Pattern;

import static org.openrewrite.Tree.randomId;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindProperties extends Recipe {
    transient MavenProperties mavenProperties = new MavenProperties(this);

    @Option(displayName = ""Property pattern"",
            description = ""Regular expression pattern used to match property tag names."",
            example = ""guava.*"")
    String propertyPattern;

    @Option(displayName = ""Value pattern"",
            description = ""Regular expression pattern used to match property values."",
            example = ""28.*"",
            required = false)
    @Nullable
    String valuePattern;

    UUID searchId = randomId();

    @Override
    public String getDisplayName() {
        return ""Find Maven project properties"";
    }

    @Override
    public String getDescription() {
        return ""Finds the specified Maven project properties within a pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Pattern propertyMatcher = Pattern.compile(propertyPattern);
        Pattern propertyUsageMatcher = Pattern.compile("".*\\$\\{"" + propertyMatcher.pattern() + ""}.*"");
        Pattern valueMatcher = valuePattern == null ? null : Pattern.compile(valuePattern);
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (isPropertyTag() && propertyMatcher.matcher(t.getName()).matches()) {
                    if (valueMatcher == null) {
                        t = SearchResult.found(t);
                        mavenProperties.insertRow(ctx, new MavenProperties.Row(t.getName(), t.getValue().orElse(null)));
                    } else {
                        Optional<String> value = t.getValue();
                        if (value.isPresent() && valueMatcher.matcher(value.get()).matches()) {
                            t = SearchResult.found(t);
                            mavenProperties.insertRow(ctx, new MavenProperties.Row(t.getName(), value.get()));
                        }
                    }
                }

                Optional<String> value = t.getValue();
                if (value.isPresent() && propertyUsageMatcher.matcher(value.get()).matches()) {
                    //noinspection unchecked
                    t = t.withContent(ListUtils.mapFirst((List<Content>) t.getContent(), v ->
                            SearchResult.found(v, getResolutionResult().getPom().getValue(value.get()))));
                }
                return t;
            }
        };
    }

    /**
     * @param xml             The xml document of the pom.xml
     * @param propertyPattern Regular expression pattern used to match property tag names
     * @return Set of Maven project property tags that matches the {@code propertyPattern} within a pom.xml
     */
    public static Set<Xml.Tag> find(Xml.Document xml, String propertyPattern) {
        Pattern propertyMatcher = Pattern.compile(propertyPattern);
        Set<Xml.Tag> found = new HashSet<>();
        new MavenVisitor<Set<Xml.Tag>>() {
            @Override
            public Xml visitTag(Xml.Tag tag, Set<Xml.Tag> tags) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, tags);
                if (isPropertyTag() && propertyMatcher.matcher(tag.getName()).matches()) {
                    tags.add(t);
                }
                return t;
            }
        }.visit(xml, found);
        return found;
    }
}
","{
  ""propertyPattern"": ""String field""
}"
Find SCM tag,Finds any `<scm>` tag directly inside the `<project>` root of a Maven pom.xml file.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.xml.tree.Xml;

public class FindScm extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Find SCM tag"";
    }

    @Override
    public String getDescription() {
        return ""Finds any `<scm>` tag directly inside the `<project>` root of a Maven pom.xml file."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (""project"".equals(tag.getName())) {
                    return super.visitTag(tag, ctx);
                } else if (""scm"".equals(tag.getName())) {
                    return SearchResult.found(tag);
                }
                return tag;
            }
        };
    }
}
",{}
Find Maven dependency management entry,"Finds first-order dependency management entries, i.e. dependencies that are defined directly in a project.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import java.util.HashSet;
import java.util.Set;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindManagedDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""3.0.0"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    public static Set<Xml.Tag> find(Xml.Document maven, String groupId, String artifactId) {
        return find(maven, groupId, artifactId, null, null);
    }

    public static Set<Xml.Tag> find(Xml.Document maven, String groupId, String artifactId,
                                    @Nullable String version, @Nullable String versionPattern) {
        Set<Xml.Tag> ds = new HashSet<>();
        new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isManagedDependencyTag(groupId, artifactId) &&
                    versionIsValid(version, tag.getChildValue(""version"").orElse(null), versionPattern)) {
                    ds.add(tag);
                }
                return super.visitTag(tag, ctx);
            }
        }.visit(maven, new InMemoryExecutionContext());
        return ds;
    }

    @Override
    public String getDisplayName() {
        return ""Find Maven dependency management entry"";
    }

    @Override
    public String getInstanceNameSuffix() {
        String maybeVersionSuffix = version == null ? """" : String.format("":%s%s"", version, versionPattern == null ? """" : versionPattern);
        return String.format(""`%s:%s%s`"", groupId, artifactId, maybeVersionSuffix);
    }

    @Override
    public String getDescription() {
        return ""Finds first-order dependency management entries, i.e. dependencies that are defined directly in a project."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isManagedDependencyTag(groupId, artifactId) &&
                    versionIsValid(version, tag.getChildValue(""version"").orElse(null), versionPattern)) {
                    return SearchResult.found(tag);
                }
                return super.visitTag(tag, ctx);
            }
        };
    }

    private static boolean versionIsValid(@Nullable String desiredVersion, @Nullable String actualVersion,
                                          @Nullable String versionPattern) {
        if (desiredVersion == null) {
            return true;
        }
        if (actualVersion == null) {
            // rare but technically valid for a dependencyManagement entry to have no version; bail if so
            return false;
        }
        Validated<VersionComparator> validate = Semver.validate(desiredVersion, versionPattern);
        if (validate.isInvalid()) {
            return false;
        }
        assert validate.getValue() != null;
        return validate.getValue().isValid(actualVersion, actualVersion);
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Maven repository order,Determine the order in which dependencies will be resolved for each `pom.xml` based on its defined repositories and effective `settings.xml`.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenExecutionContextView;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.table.MavenRepositoryOrder;
import org.openrewrite.maven.tree.MavenRepository;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.tree.Xml;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.StreamSupport;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

public class FindRepositoryOrder extends Recipe {
    transient MavenRepositoryOrder repositoryOrder = new MavenRepositoryOrder(this);

    @Override
    public String getDisplayName() {
        return ""Maven repository order"";
    }

    @Override
    public String getDescription() {
        return ""Determine the order in which dependencies will be resolved for each `pom.xml` based on its defined repositories and effective `settings.xml`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();

                Map<String, MavenRepository> repositories = new LinkedHashMap<>();
                for (MavenRepository repository : mrr.getPom().getRepositories()) {
                    repositories.put(repository.getUri(), repository);
                }
                for (MavenRepository repository : MavenExecutionContextView.view(ctx)
                        .getRepositories(
                                mrr.getMavenSettings(),
                                StreamSupport.stream(mrr.getPom().getActiveProfiles().spliterator(), false)
                                        .collect(toList())
                        )) {
                    repositories.put(repository.getUri(), repository);
                }

                int i = 0;
                for (MavenRepository repository : repositories.values()) {
                    repositoryOrder.insertRow(ctx, new MavenRepositoryOrder.Row(
                            repository.getId(),
                            repository.getUri(),
                            repository.isKnownToExist(),
                            i++
                    ));
                }

                return SearchResult.found(document, repositories.values().stream()
                        .map(MavenRepository::getUri)
                        .collect(joining(""\n"")));
            }
        };
    }
}
",{}
Maven parent insight,Find Maven parents matching a `groupId` and `artifactId`.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.table.ParentPomsInUse;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.Parent;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.xml.tree.Xml;

import static java.util.Collections.emptyList;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@EqualsAndHashCode(callSuper = false)
@Value
public class ParentPomInsight extends Recipe {
    transient ParentPomsInUse inUse = new ParentPomsInUse(this);

    @Option(displayName = ""Group pattern"",
            description = ""Group glob pattern used to match dependencies."",
            example = ""org.springframework.boot"")
    String groupIdPattern;

    @Option(displayName = ""Artifact pattern"",
            description = ""Artifact glob pattern used to match dependencies."",
            example = ""spring-boot-starter-*"")
    String artifactIdPattern;

    @Option(displayName = ""Version"",
            description = ""Match only dependencies with the specified version. "" +
                          ""Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used."" +
                          ""All versions are searched by default."",
            example = ""1.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Recursive"",
            description = ""Whether to search recursively through the parents. True by default."",
            required = false)
    @Nullable
    Boolean recursive;

    @Override
    public String getDisplayName() {
        return ""Maven parent insight"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""for `%s:%s`"", groupIdPattern, artifactIdPattern);
    }

    @Override
    public String getDescription() {
        return ""Find Maven parents matching a `groupId` and `artifactId`."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> v = super.validate();
        if (version != null) {
            v = v.and(Semver.validate(version, null));
        }
        return v;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Nullable
            final VersionComparator versionComparator = version == null ? null : Semver.validate(version, null).getValue();

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (!isParentTag()) {
                    return t;
                }

                MavenResolutionResult mrr = getResolutionResult();
                MavenPomDownloader mpd = new MavenPomDownloader(mrr.getProjectPoms(), ctx, mrr.getMavenSettings(), mrr.getActiveProfiles());

                Parent ancestor = mrr.getPom().getRequested().getParent();
                String relativePath = tag.getChildValue(""relativePath"").orElse(null);
                while (ancestor != null) {
                    String groupId = ancestor.getGroupId();
                    String artifactId = ancestor.getArtifactId();
                    if (matchesGlob(groupId, groupIdPattern) && matchesGlob(artifactId, artifactIdPattern)) {
                        String parentVersion = ancestor.getVersion();
                        if (versionComparator == null || versionComparator.isValid(null, parentVersion)) {
                            // Found a parent pom that matches the criteria
                            inUse.insertRow(ctx, new ParentPomsInUse.Row(
                                    mrr.getPom().getArtifactId(), groupId, artifactId, parentVersion, relativePath));
                            return SearchResult.found(t);
                        }
                    }
                    if (Boolean.FALSE.equals(recursive)) {
                        return t;
                    }
                    try {
                        ResolvedPom ancestorPom = mpd.download(ancestor.getGav(), null, null, mrr.getPom().getRepositories())
                                .resolve(emptyList(), mpd, ctx);
                        ancestor = ancestorPom.getRequested().getParent();
                        relativePath = null;
                    } catch (MavenDownloadingException e) {
                        return e.warn(t);
                    }
                }
                return t;
            }
        };
    }
}
","{
  ""groupIdPattern"": ""String field"",
  ""artifactIdPattern"": ""String field""
}"
Find Maven projects,Maven projects are `pom.xml` files with a `MavenResolutionResult` marker.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

public class FindMavenProject extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find Maven projects"";
    }

    @Override
    public String getDescription() {
        return ""Maven projects are `pom.xml` files with a `MavenResolutionResult` marker."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                if (document.getMarkers().findFirst(MavenResolutionResult.class).isPresent()) {
                    return SearchResult.found(document);
                }
                return super.visitDocument(document, ctx);
            }
        };
    }
}
",{}
Effective dependencies,Emit the data of binary dependency relationships.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.table.DependencyGraph;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.tree.Xml;

import java.util.List;
import java.util.Map;

@Value
@EqualsAndHashCode(callSuper = false)
public class EffectiveDependencies extends Recipe {
    transient DependencyGraph dependencyGraph = new DependencyGraph(this);

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope"",
            valid = {""compile"", ""test"", ""runtime"", ""provided""},
            example = ""compile"")
    String scope;

    @Override
    public String getDisplayName() {
        return ""Effective dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Emit the data of binary dependency relationships."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""scope"", ""scope is a valid Maven scope"", scope,
                s -> Scope.fromName(s) != Scope.Invalid));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Scope aScope = Scope.fromName(scope);

        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                String javaProject = getCursor().firstEnclosingOrThrow(Xml.Document.class).getMarkers()
                        .findFirst(JavaProject.class).map(JavaProject::getProjectName).orElse("""");
                String javaSourceSet = getCursor().firstEnclosingOrThrow(Xml.Document.class).getMarkers()
                        .findFirst(JavaSourceSet.class).map(JavaSourceSet::getName).orElse(""main"");

                for (Map.Entry<Scope, List<ResolvedDependency>> scopedDependencies : mrr.getDependencies().entrySet()) {
                    if (!scopedDependencies.getKey().isInClasspathOf(aScope)) {
                        continue;
                    }
                    emitDependency(mrr.getPom().getGav(), scopedDependencies.getValue(), ctx, javaProject, javaSourceSet);
                }
                return document;
            }
        };
    }

    private void emitDependency(ResolvedGroupArtifactVersion gav, List<ResolvedDependency> dependencies,
                                ExecutionContext ctx, String javaProject, String javaSourceSet) {
        for (ResolvedDependency d : dependencies) {
            dependencyGraph.insertRow(ctx, new DependencyGraph.Row(
                    javaProject,
                    javaSourceSet,
                    String.format(""%s:%s:%s"", gav.getGroupId(), gav.getArtifactId(), gav.getVersion()),
                    String.format(""%s:%s:%s"", d.getGav().getGroupId(), d.getGav().getArtifactId(), d.getGav().getVersion())
            ));
            emitDependency(d.getGav(), d.getDependencies(), ctx, javaProject, javaSourceSet);
        }
    }
}
","{
  ""scope"": ""String field""
}"
List effective Maven repositories,"Lists the Maven repositories that would be used for dependency resolution, in order of precedence. ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenExecutionContextView;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.MavenSettings;
import org.openrewrite.maven.tree.MavenRepository;
import org.openrewrite.maven.tree.MavenRepositoryMirror;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.xml.tree.Xml;

import java.util.Collection;
import java.util.List;
import java.util.StringJoiner;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.PathUtils.separatorsToUnix;

@Value
@EqualsAndHashCode(callSuper = false)
public class EffectiveMavenRepositories extends Recipe {

    @Override
    public String getDisplayName() {
        return ""List effective Maven repositories"";
    }

    @Override
    public String getDescription() {
        return ""Lists the Maven repositories that would be used for dependency resolution, in order of precedence. "" +
               ""This includes Maven repositories defined in the Maven settings file (and those contributed by active profiles) as "" +
               ""determined when the LST was produced."";
    }

    @Option(displayName = ""Use markers"",
            description = ""Whether to add markers for each effective Maven repository to the POM. Default `false`."",
            required = false)
    @Nullable
    Boolean useMarkers;

    transient EffectiveMavenRepositoriesTable table = new EffectiveMavenRepositoriesTable(this);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                MavenExecutionContextView mctx = MavenExecutionContextView.view(ctx);
                MavenSettings settings = mctx.effectiveSettings(mrr);

                StringJoiner repositories = new StringJoiner(""\n"");
                if (settings == null) {
                    for (MavenRepository repository : mrr.getPom().getRepositories()) {
                        repositories.add(repository.getUri());
                        table.insertRow(ctx, new EffectiveMavenRepositoriesTable.Row(
                                separatorsToUnix(document.getSourcePath().toString()),
                                repository.getUri()));
                    }
                    repositories.add(MavenRepository.MAVEN_CENTRAL.getUri());
                    table.insertRow(ctx, new EffectiveMavenRepositoriesTable.Row(
                            separatorsToUnix(document.getSourcePath().toString()),
                            MavenRepository.MAVEN_CENTRAL.getUri()));
                } else {
                    Collection<MavenRepositoryMirror> mirrors = mctx.getMirrors(settings);
                    List<MavenRepository> effectiveRepositories = Stream.concat(
                                    settings.getActiveRepositories(settings.getActiveProfiles() == null ? emptyList() : settings.getActiveProfiles().getActiveProfiles())
                                            .stream()
                                            .map(rawRepo -> MavenRepository.builder().uri(rawRepo.getUrl()).build()),
                                    Stream.concat(mrr.getPom().getRepositories().stream(), Stream.of(MavenRepository.MAVEN_CENTRAL)))
                            .map(repository -> MavenRepositoryMirror.apply(mirrors, repository))
                            .collect(toList());

                    for (MavenRepository repository : effectiveRepositories) {
                        repositories.add(repository.getUri());
                        table.insertRow(ctx, new EffectiveMavenRepositoriesTable.Row(
                                separatorsToUnix(document.getSourcePath().toString()),
                                repository.getUri()));
                    }
                }

                if (Boolean.TRUE.equals(useMarkers)) {
                    return SearchResult.found(document, repositories.toString());
                }

                return document;
            }
        };
    }
}
",{}
Effective managed dependencies,Emit the data of binary dependency relationships.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.table.ManagedDependencyGraph;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedManagedDependency;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class EffectiveManagedDependencies extends Recipe {
    transient ManagedDependencyGraph dependencyGraph = new ManagedDependencyGraph(this);

    @Override
    public String getDisplayName() {
        return ""Effective managed dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Emit the data of binary dependency relationships."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                emitParent(mrr, ctx);
                return document;
            }
        };
    }

    private void emitParent(MavenResolutionResult mrr, ExecutionContext ctx) {
        if (mrr.getParent() != null) {
            dependencyGraph.insertRow(ctx, new ManagedDependencyGraph.Row(
                    String.format(""%s:%s:%s"", mrr.getPom().getGroupId(), mrr.getPom().getArtifactId(), mrr.getPom().getVersion()),
                    String.format(""%s:%s:%s"", mrr.getParent().getPom().getGroupId(),
                            mrr.getParent().getPom().getArtifactId(), mrr.getParent().getPom().getVersion())
            ));

            for (ResolvedManagedDependency managed : mrr.getPom().getDependencyManagement()) {
                dependencyGraph.insertRow(ctx, new ManagedDependencyGraph.Row(
                        String.format(""%s:%s:%s"", mrr.getPom().getGroupId(), mrr.getPom().getArtifactId(), mrr.getPom().getVersion()),
                        String.format(""%s:%s:%s"", managed.getGroupId(), managed.getArtifactId(), managed.getVersion())
                ));
            }
        }
    }
}
",{}
Find Maven plugin,Finds a Maven plugin within a pom.xml.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.HashSet;
import java.util.Set;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindPlugin extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""org.openrewrite.maven"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'org.openrewrite.maven:rewrite-maven-plugin:VERSION'."",
            example = ""rewrite-maven-plugin"")
    String artifactId;

    public static Set<Xml.Tag> find(Xml.Document maven, String groupId, String artifactId) {
        Set<Xml.Tag> ds = new HashSet<>();
        new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isPluginTag(groupId, artifactId)) {
                    ds.add(tag);
                }
                return super.visitTag(tag, ctx);
            }
        }.visit(maven, new InMemoryExecutionContext());
        return ds;
    }

    @Override
    public String getDisplayName() {
        return ""Find Maven plugin"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Finds a Maven plugin within a pom.xml."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isPluginTag(groupId, artifactId)) {
                    return SearchResult.found(tag);
                }
                return super.visitTag(tag, ctx);
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Print Maven dependency hierarchy in DOT format,The DOT language format is specified [here](https://graphviz.org/doc/info/lang.html).,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.utilities;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.maven.tree.MavenResolutionResult;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.maven.tree.Scope;
import org.openrewrite.xml.tree.Xml;

import java.util.*;

import static java.util.Collections.newSetFromMap;
import static java.util.stream.Collectors.toList;

public class PrintMavenAsDot extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Print Maven dependency hierarchy in DOT format"";
    }

    @Override
    public String getDescription() {
        return ""The DOT language format is specified [here](https://graphviz.org/doc/info/lang.html)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                MavenResolutionResult mrr = getResolutionResult();
                if (!document.getMarkers().findFirst(SearchResult.class).isPresent()) {
                    return document.withMarkers(document.getMarkers().add(new SearchResult(Tree.randomId(), dot(mrr))));
                }
                return super.visitDocument(document, ctx);
            }

            private String dot(MavenResolutionResult mrr) {
                StringBuilder dot = new StringBuilder(""digraph main {\n"");

                Map<ResolvedGroupArtifactVersion, Integer> index = new HashMap<>();

                // for convenience, we construct a ResolvedDependency out of the POM's GAV.
                ResolvedGroupArtifactVersion root =
                        new ResolvedGroupArtifactVersion(
                                null,
                                mrr.getPom().getGroupId(),
                                mrr.getPom().getArtifactId(),
                                mrr.getPom().getVersion(),
                                null);
                dotLabel(dot, 0, root);
                index.put(root, 0);

                // Build up index of all dependencies, so we can reference them by index in the DOT output
                for (Scope scope : Scope.values()) {
                    if (scope.ordinal() < Scope.Compile.ordinal() || Scope.Test.ordinal() < scope.ordinal()) {
                        continue;
                    }
                    List<ResolvedDependency> resolvedDependencies = mrr.getDependencies().get(scope);
                    if (resolvedDependencies == null) {
                        continue;
                    }
                    for (ResolvedDependency dep : resolvedDependencies) {
                        if (!index.containsKey(dep.getGav())) {
                            dotLabel(dot, index.size(), dep.getGav());
                            index.put(dep.getGav(), index.size());
                        }
                    }
                }

                Set<ResolvedGroupArtifactVersion> seen = newSetFromMap(new IdentityHashMap<>());
                for (Scope scope : Scope.values()) {
                    if (scope.ordinal() < Scope.Compile.ordinal() || Scope.Test.ordinal() < scope.ordinal()) {
                        continue;
                    }
                    dotEdges(
                            dot, root, scope,
                            mrr.getDependencies().get(scope).stream()
                                    .filter(dep -> dep.isDirect() && seen.add(dep.getGav()))
                                    .collect(toList()),
                            index
                    );
                }

                dot.append(""}"");
                return dot.toString();
            }

            private void dotLabel(StringBuilder dot, int index, ResolvedGroupArtifactVersion gav) {
                dot.append(index)
                        .append("" [label=\"""")
                        .append(gav.getGroupId())
                        .append("":"")
                        .append(gav.getArtifactId())
                        .append("":"")
                        .append(gav.getVersion())
                        .append(""\""];\n"");
            }

            private void dotEdges(StringBuilder dot,
                                  ResolvedGroupArtifactVersion head,
                                  Scope scope,
                                  List<ResolvedDependency> resolvedDependencies,
                                  Map<ResolvedGroupArtifactVersion, Integer> index) {
                int headIndex = index.get(head);
                for (ResolvedDependency dep : resolvedDependencies) {
                    dot.append(headIndex)
                            .append("" -> "")
                            .append(index.get(dep.getGav()))
                            .append("" [taillabel=\"""")
                            .append(scope)
                            .append(""\""];\n"");
                    dotEdges(dot, dep.getGav(), scope, dep.getDependencies(), index);
                }
            }
        };
    }
}
",{}
Add explicit plugin versions,"Add explicit plugin versions to POMs for reproducibility, as [MNG-4173](https://issues.apache.org/jira/browse/MNG-4173) removes automatic version resolution for POM plugins.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.maven.UpgradePluginVersion;
import org.openrewrite.maven.tree.ResolvedPom;
import org.openrewrite.xml.tree.Xml;

public class ExplicitPluginVersion extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add explicit plugin versions"";
    }

    @Override
    public String getDescription() {
        return ""Add explicit plugin versions to POMs for reproducibility, as [MNG-4173](https://issues.apache.org/jira/browse/MNG-4173) removes automatic version resolution for POM plugins."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (isPluginTag() && !t.getChild(""version"").isPresent()) {
                    ResolvedPom resolvedPom = getResolutionResult().getPom();
                    String groupId = resolvedPom.getValue(tag.getChildValue(""groupId"").orElse(""org.apache.maven.plugins""));
                    String artifactId = resolvedPom.getValue(tag.getChildValue(""artifactId"").orElse(""*""));
                    // Do not override parent plugin versions
                    if (resolvedPom.getPluginManagement().stream()
                            .noneMatch(p -> groupId.equals(p.getGroupId()) && StringUtils.matchesGlob(p.getArtifactId(), artifactId))) {
                        doAfterVisit(new UpgradePluginVersion(groupId, artifactId, ""latest.release"", null, true, true).getVisitor());
                    }
                }
                return t;
            }
        };
    }
}
",{}
Add explicit `groupId` to Maven plugins,Add the default `<groupId>org.apache.maven.plugins</groupId>` to plugins for clarity.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenTagInsertionComparator;
import org.openrewrite.maven.MavenVisitor;
import org.openrewrite.xml.AddToTagVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class ExplicitPluginGroupId extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add explicit `groupId` to Maven plugins"";
    }

    @Override
    public String getDescription() {
        return ""Add the default `<groupId>org.apache.maven.plugins</groupId>` to plugins for clarity."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (isPluginTag() && !t.getChild(""groupId"").isPresent() && t.getChild(""artifactId"").isPresent()) {
                    Xml.Tag groupIdTag = Xml.Tag.build(""<groupId>org.apache.maven.plugins</groupId>"");
                    t = (Xml.Tag) new AddToTagVisitor<>(t, groupIdTag, new MavenTagInsertionComparator(t.getChildren()))
                            .visitNonNull(t, ctx, getCursor().getParentOrThrow());
                    maybeUpdateModel();
                }
                return t;
            }
        };
    }
}
",{}
Dependency management dependencies should have a version,"If they don't have a version, they can't possibly affect dependency resolution anywhere, and can be safely removed.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.maven.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.maven.MavenIsoVisitor;
import org.openrewrite.xml.RemoveContentVisitor;
import org.openrewrite.xml.tree.Xml;

public class DependencyManagementDependencyRequiresVersion extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Dependency management dependencies should have a version"";
    }

    @Override
    public String getDescription() {
        return ""If they don't have a version, they can't possibly affect dependency resolution anywhere, and can be safely removed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MavenIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (isManagedDependencyTag() && tag.getChildValue(""version"").orElse(null) == null) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                }
                return super.visitTag(tag, ctx);
            }
        };
    }
}
",{}
Add value to JSON Object,"Adds a `value` at the specified `keyPath` with the specified `key`, if the key doesn't already exist.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.json.tree.*;
import org.openrewrite.marker.Markers;

import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddKeyValue extends Recipe {

    @Option(displayName = ""Key path"",
            description = ""A JsonPath expression to locate the *parent* JSON entry."",
            example = ""'$.subjects.*' or '$.' or '$.x[1].y.*' etc."")
    String keyPath;

    @Option(displayName = ""Key"",
            description = ""The key to create."",
            example = ""myKey"")
    String key;

    @Option(displayName = ""Value"",
            description = ""The value to add to the document at the specified key. Can be of any type representing JSON value."" +
                          "" String values should be quoted to be inserted as Strings."",
            example = ""`\""myValue\""` or `{\""a\"": 1}` or `[ 123 ]`"")
    @Language(""Json"")
    String value;

    @Option(displayName = ""Prepend"",
            required = false,
            description = ""If set to `true` the value will be added to the beginning of the object"")
    boolean prepend;

    @Override
    public String getDisplayName() {
        return ""Add value to JSON Object"";
    }

    @Override
    public String getDescription() {
        return ""Adds a `value` at the specified `keyPath` with the specified `key`, if the key doesn't already exist."";
    }


    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JsonIsoVisitor<ExecutionContext>() {
            private final JsonPathMatcher pathMatcher = new JsonPathMatcher(keyPath);

            @Override
            public Json.JsonObject visitObject(Json.JsonObject obj, ExecutionContext ctx) {
                obj = super.visitObject(obj, ctx);

                if (pathMatcher.matches(getCursor()) && objectDoesNotContainKey(obj, key)) {
                    List<Json> originalMembers = obj.getMembers();
                    boolean jsonIsEmpty = originalMembers.isEmpty() || originalMembers.get(0) instanceof Json.Empty;
                    Space space = jsonIsEmpty || prepend ? originalMembers.get(0).getPrefix() : Space.build(""\n"", emptyList());

                    Json newMember = new Json.Member(randomId(), space, Markers.EMPTY, rightPaddedKey(), parsedValue());

                    if (jsonIsEmpty) {
                        return autoFormat(obj.withMembers(singletonList(newMember)), ctx, getCursor().getParent());
                    }

                    List<Json> newMembers = prepend ?
                            ListUtils.concat(newMember, originalMembers) :
                            ListUtils.concat(originalMembers, newMember);
                    return autoFormat(obj.withMembers(newMembers), ctx, getCursor().getParent());
                }
                return obj;
            }

            private JsonValue parsedValue() {
                Json.Document parsedDoc = (Json.Document) JsonParser.builder().build()
                        .parse(value.trim()).findFirst().get();
                JsonValue value = parsedDoc.getValue();
                return value.withPrefix(value.getPrefix().withWhitespace("" ""));
            }

            private JsonRightPadded<JsonKey> rightPaddedKey() {
                return new JsonRightPadded<>(
                        new Json.Literal(randomId(), Space.EMPTY, Markers.EMPTY, ""\"""" + key + ""\"""", key),
                        Space.EMPTY, Markers.EMPTY
                );
            }

            private boolean objectDoesNotContainKey(Json.JsonObject obj, String key) {
                for (Json member : obj.getMembers()) {
                    if (member instanceof Json.Member) {
                        if (keyMatches(((Json.Member) member).getKey(), key)) {
                            return false;
                        }
                    }
                }
                return true;
            }

            private boolean keyMatches(JsonKey jsonKey, String key) {
                if (jsonKey instanceof Json.Literal) {
                    return key.equals(((Json.Literal) jsonKey).getValue());
                } else if (jsonKey instanceof Json.Identifier) {
                    return key.equals(((Json.Identifier) jsonKey).getName());
                }
                return false;
            }
        };
    }
}
","{
  ""keyPath"": ""String field"",
  ""key"": ""String field"",
  ""prepend"": ""boolean field""
}"
Change key,"Change a JSON mapping entry key, while leaving the value intact.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.json.tree.Json;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeKey extends Recipe {
    @Option(displayName = ""Old key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a JSON entry."",
            example = ""$.subjects.kind"")
    String oldKeyPath;

    @Option(displayName = ""New key"",
            description = ""The new name for the key selected by oldKeyPath."",
            example = ""kind"")
    String newKey;

    @Override
    public String getDisplayName() {
        return ""Change key"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldKeyPath, newKey);
    }

    @Override
    public String getDescription() {
        return ""Change a JSON mapping entry key, while leaving the value intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(oldKeyPath);
        return new JsonIsoVisitor<ExecutionContext>() {
            @Override
            public Json.Member visitMember(Json.Member member, ExecutionContext ctx) {
                Json.Member m = super.visitMember(member, ctx);
                if (matcher.matches(getCursor())) {
                    String value = ChangeKey.this.newKey;
                    if (value.startsWith(""'"") || value.startsWith(""\"""")) {
                        value = value.substring(1, value.length() - 1);
                    }
                    m = m.withKey(
                            m.getKey() instanceof Json.Literal ?
                                    ((Json.Literal) m.getKey())
                                            .withSource(newKey)
                                            .withValue(value) :
                                    new Json.Literal(Tree.randomId(), m.getKey().getPrefix(), m.getKey().getMarkers(),
                                            newKey, value)
                    );
                }
                return m;
            }
        };
    }
}
","{
  ""newKey"": ""String field""
}"
Delete key,Delete a JSON mapping entry key.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.json.tree.Json;
import org.openrewrite.json.tree.Space;

import java.util.concurrent.atomic.AtomicReference;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteKey extends Recipe {

    @Option(displayName = ""Key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a JSON entry."",
            example = ""$.subjects.kind"")
    String keyPath;

    @Override
    public String getDisplayName() {
        return ""Delete key"";
    }

    @Override
    public String getDescription() {
        return ""Delete a JSON mapping entry key."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(keyPath);
        return new JsonIsoVisitor<ExecutionContext>() {
            @Override
            public Json.JsonObject visitObject(Json.JsonObject obj, ExecutionContext ctx) {
                Json.JsonObject o = super.visitObject(obj, ctx);
                AtomicReference<Space> copyFirstPrefix = new AtomicReference<>();
                o = o.withMembers(ListUtils.map(o.getMembers(), (i, e) -> {
                    if (matcher.matches(new Cursor(getCursor(), e))) {
                        if (i == 0 && getCursor().getParentOrThrow().getValue() instanceof Json.Array) {
                            copyFirstPrefix.set(e.getPrefix());
                        }
                        return null;
                    }
                    return e;
                }));

                if (!o.getMembers().isEmpty() && copyFirstPrefix.get() != null) {
                    o = o.withMembers(ListUtils.mapFirst(o.getMembers(), e -> e.withPrefix(copyFirstPrefix.get())));
                }

                return o;
            }
        };
    }
}
",{}
Change value,Change a JSON mapping entry value leaving the key intact.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.json.tree.Json;
import org.openrewrite.marker.Markers;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeValue extends Recipe {
    @Option(displayName = ""Key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a JSON entry."",
            example = ""$.subjects.kind"")
    String oldKeyPath;

    @Option(displayName = ""New value"",
            description = ""The new value to set for the key identified by oldKeyPath."",
            example = ""'Deployment'"")
    String value;

    @Override
    public String getDisplayName() {
        return ""Change value"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldKeyPath, value);
    }

    @Override
    public String getDescription() {
        return ""Change a JSON mapping entry value leaving the key intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(oldKeyPath);
        return new JsonIsoVisitor<ExecutionContext>() {
            @Override
            public Json.Member visitMember(Json.Member member, ExecutionContext ctx) {
                Json.Member m = super.visitMember(member, ctx);
                if (matcher.matches(getCursor()) && (!(m.getValue() instanceof Json.Literal) || !((Json.Literal) m.getValue()).getValue().equals(value))) {
                    String source = ChangeValue.this.value;
                    if (source.startsWith(""'"") || source.startsWith(""\"""")) {
                        source = source.substring(1, source.length() - 1);
                    }
                    if (!(m.getValue() instanceof Json.Literal) || !((Json.Literal) m.getValue()).getSource().equals(ChangeValue.this.value)) {
                        m = m.withValue(new Json.Literal(randomId(), m.getValue().getPrefix(), Markers.EMPTY, ChangeValue.this.value, source));
                    }
                }
                return m;
            }
        };
    }
}
","{
  ""value"": ""String field""
}"
Find JSON object members,Find JSON object members by JsonPath expression.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.json.JsonIsoVisitor;
import org.openrewrite.json.JsonPathMatcher;
import org.openrewrite.json.tree.Json;
import org.openrewrite.json.tree.JsonKey;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindKey extends Recipe {
    @Option(displayName = ""Key path"",
            description = ""A JsonPath expression used to find matching keys."",
            example = ""$.subjects.kind"")
    String key;

    @Override
    public String getDisplayName() {
        return ""Find JSON object members"";
    }

    @Override
    public String getDescription() {
        return ""Find JSON object members by JsonPath expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(key);
        return new JsonIsoVisitor<ExecutionContext>() {
            @Override
            public Json.Member visitMember(Json.Member member, ExecutionContext ctx) {
                Json.Member m = super.visitMember(member, ctx);
                if (matcher.matches(getCursor())) {
                    return m.withKey(SearchResult.found(m.getKey()));
                }
                return m;
            }
        };
    }

    public static Set<JsonKey> find(Json j, String key) {
        JsonPathMatcher matcher = new JsonPathMatcher(key);
        Set<JsonKey> ks = new HashSet<>();
        new JsonIsoVisitor<Set<JsonKey>>() {
            @Override
            public Json.Member visitMember(Json.Member member, Set<JsonKey> ks) {
                Json.Member m = super.visitMember(member, ks);
                if (matcher.matches(getCursor())) {
                    ks.add(m.getKey());
                }
                return m;
            }
        }.visit(j, ks);
        return ks;
    }
}
","{
  ""key"": ""String field""
}"
JSON new lines,Split members into separate lines in JSON.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.json.style.TabsAndIndentsStyle;
import org.openrewrite.json.style.WrappingAndBracesStyle;
import org.openrewrite.style.GeneralFormatStyle;

public class WrappingAndBraces extends Recipe {
    private final WrappingAndBracesStyle wrappingAndBracesStyle;
    private final TabsAndIndentsStyle tabsAndIndentsStyle;
    private final GeneralFormatStyle generalFormatStyle;

    public WrappingAndBraces() {
        this.wrappingAndBracesStyle = WrappingAndBracesStyle.DEFAULT;
        this.tabsAndIndentsStyle = TabsAndIndentsStyle.DEFAULT;
        this.generalFormatStyle = GeneralFormatStyle.DEFAULT;
    }

    public WrappingAndBraces(WrappingAndBracesStyle wrappingAndBracesStyle, TabsAndIndentsStyle tabsAndIndentsStyle, GeneralFormatStyle generalFormatStyle) {
        this.wrappingAndBracesStyle = wrappingAndBracesStyle;
        this.tabsAndIndentsStyle = tabsAndIndentsStyle;
        this.generalFormatStyle = generalFormatStyle;
    }

    @Override
    public String getDisplayName() {
        return ""JSON new lines"";
    }

    @Override
    public String getDescription() {
        return ""Split members into separate lines in JSON."";
    }

    @Override
    public WrappingAndBracesVisitor<ExecutionContext> getVisitor() {
        return new WrappingAndBracesVisitor<>(wrappingAndBracesStyle, tabsAndIndentsStyle, generalFormatStyle, null);
    }
}
",{}
Format JSON,Format JSON code using a standard comprehensive set of JSON formatting recipes.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;

public class AutoFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Format JSON"";
    }

    @Override
    public String getDescription() {
        return ""Format JSON code using a standard comprehensive set of JSON formatting recipes."";
    }

    @Override
    public AutoFormatVisitor<ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>();
    }
}
",{}
JSON indent,Format tabs and indents in JSON.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.json.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.json.JsonIsoVisitor;
import org.openrewrite.json.style.Autodetect;
import org.openrewrite.json.style.TabsAndIndentsStyle;
import org.openrewrite.json.style.WrappingAndBracesStyle;
import org.openrewrite.json.tree.Json;
import org.openrewrite.style.GeneralFormatStyle;
import org.openrewrite.style.Style;

public class Indents extends Recipe {
    @Override
    public String getDisplayName() {
        return ""JSON indent"";
    }

    @Override
    public String getDescription() {
        return ""Format tabs and indents in JSON."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends JsonIsoVisitor<ExecutionContext> {
        @Override
        public Json. Document visitDocument(Json.Document docs, ExecutionContext ctx) {
            Autodetect autodetected = Autodetect.detector().sample(docs).build();
            TabsAndIndentsStyle tabsAndIndentsStyle = Style.from(TabsAndIndentsStyle.class, docs, () -> autodetected.getStyle(TabsAndIndentsStyle.class));
            WrappingAndBracesStyle wrappingAndBracesStyle = Style.from(WrappingAndBracesStyle.class, docs, () -> autodetected.getStyle(WrappingAndBracesStyle.class));
            GeneralFormatStyle generalFormatStyle = Style.from(GeneralFormatStyle.class, docs, () -> autodetected.getStyle(GeneralFormatStyle.class));
            doAfterVisit(new TabsAndIndentsVisitor<>(wrappingAndBracesStyle, tabsAndIndentsStyle, generalFormatStyle,null));
            return docs;
        }
    }
}
",{}
Write the AST model,"Expand the model into an AST with Lombok annotations, Padding classes, etc.",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package generate;

import lombok.RequiredArgsConstructor;
import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.StringJoiner;

@RequiredArgsConstructor
public class WriteModel extends Recipe {
    final List<J.ClassDeclaration> modelClasses;

    @Override
    public String getDisplayName() {
        return ""Write the AST model"";
    }

    @Override
    public String getDescription() {
        return ""Expand the model into an AST with Lombok annotations, Padding classes, etc."";
    }

    JavaParser.Builder<? extends JavaParser, ?> parser = JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath());

    JavaVisitor<ExecutionContext> writeModelClass = new JavaIsoVisitor<ExecutionContext>() {
        final JavaTemplate valueModel = JavaTemplate.builder(
                """"""
                        @Value
                        @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)
                        @With
                        """"""
        ).javaParser(parser).build();

        final JavaTemplate paddedModel = JavaTemplate.builder(
                """"""
                        @ToString
                        @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
                        @EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)
                        @RequiredArgsConstructor
                        @AllArgsConstructor(access = AccessLevel.PRIVATE)
                        """"""
        ).javaParser(parser).build();

        final JavaTemplate idField = JavaTemplate.builder(""@EqualsAndHashCode.Include UUID id;"").imports(""java.util.UUID"").javaParser(parser).build();
        final JavaTemplate prefixField = JavaTemplate.builder(""Space prefix;"").javaParser(parser).build();
        final JavaTemplate markersField = JavaTemplate.builder(""Markers markers;"").imports(""org.openrewrite.marker.Markers"").javaParser(parser).build();
        final JavaTemplate paddingField = JavaTemplate.builder(""@Nullable @NonFinal transient WeakReference<Padding> padding;"").javaParser(parser).build();
        final JavaTemplate implementsTree = JavaTemplate.builder(""Toml"").javaParser(parser).build();

        final JavaTemplate getPadding = JavaTemplate.builder(
                """"""
                        public Padding getPadding() {
                            Padding p;
                            if (this.padding == null) {
                                p = new Padding(this);
                                this.padding = new WeakReference<>(p);
                            } else {
                                p = this.padding.get();
                                if (p == null || p.t != this) {
                                    p = new Padding(this);
                                    this.padding = new WeakReference<>(p);
                                }
                            }
                            return p;
                        }
                        """"""
        ).build();

        final JavaTemplate paddingClass = JavaTemplate.builder(
                """"""
                        @RequiredArgsConstructor
                        public static class Padding {
                            private final #{} t;
                        }
                        """"""
        ).build();

        final JavaTemplate acceptMethod = JavaTemplate.builder(
                """"""
                        @Override public <P> Toml acceptToml(TomlVisitor<P> v, P p) {
                          return v.visit#{}(this, p);
                        }
                        """"""
        ).javaParser(parser).build();

        /**
         * The accessors in the model class that skips the padding and return the contained element.
         */
        final JavaTemplate unwrappedPaddedGetterWither = JavaTemplate.builder(
                """"""
                        public #{} get#{}() {
                            return #{}.getElement();
                        }

                        public #{} with#{}(#{} #{}) {
                            //noinspection ConstantConditions
                            return getPadding().with#{}(Toml#{}Padded.withElement(this.#{}, #{}));
                        }
                        """"""
        ).javaParser(parser).build();

        final JavaTemplate nullableUnwrappedPaddedGetterWither = JavaTemplate.builder(
                """"""
                        @Nullable
                        public #{} get#{}() {
                            return #{} == null ? null : #{}.getElement();
                        }

                        public #{} with#{}(@Nullable #{} #{}) {
                            if (#{} == null) {
                                return this.#{} == null ? this : new #{}(#{});
                            }
                            return getPadding().with#{}(Toml#{}Padded.withElement(this.#{}, #{}));
                        }
                        """"""
        ).javaParser(parser).build();

        /**
         * The accessors in the model class that skips the padding and return the contained elements.
         */
        final JavaTemplate unwrappedContainerGetterWither = JavaTemplate.builder(
                """"""
                        public List<#{}> get#{}() {
                            return #{}.getElements();
                        }

                        public #{} with#{}(List<#{}> #{}) {
                            return getPadding().with#{}(this.#{}.getPadding().withElements(TomlRightPadded.withElements(
                                this.#{}.getPadding().getElements(), #{}));
                        }
                        """"""
        ).javaParser(parser).build();

        final JavaTemplate withGetterAnnotations = JavaTemplate.builder(""@With @Getter"")
                .javaParser(parser).build();

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = classDecl;
            if (!FindAnnotations.find(c, ""@generate.Skip"").isEmpty()) {
                //noinspection ConstantConditions
                return null;
            }

            boolean padded = c.getBody().getStatements().stream().anyMatch(this::isPadded);

            if (c.getImplements() == null) {
                c = implementsTree.apply(updateCursor(c), c.getCoordinates().addImplementsClause());
            }


            c = markersField.apply(updateCursor(c), c.getBody().getCoordinates().firstStatement());
            c = prefixField.apply(updateCursor(c), c.getBody().getCoordinates().firstStatement());
            c = idField.apply(updateCursor(c), c.getBody().getCoordinates().firstStatement());
            c = acceptMethod.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(), classDecl.getSimpleName());

            for (Statement statement : c.getBody().getStatements()) {
                if (statement instanceof J.VariableDeclarations varDec) {
                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(varDec.getType());

                    JavaType.FullyQualified elementType = null;
                    if (varDec.getTypeExpression() instanceof J.ParameterizedType typeExpression) {
                        if (typeExpression.getTypeParameters() != null) {
                            elementType = TypeUtils.asFullyQualified(typeExpression.getTypeParameters().get(0).getType());
                        }
                    }

                    if (fqn != null) {
                        if (elementType != null) {
                            c = switch (fqn.getClassName()) {
                                case ""TomlContainer"" -> writeContainerGetterWithers(c, varDec, elementType);
                                case ""TomlLeftPadded"" -> writePaddedGetterWithers(c, varDec, elementType, ""Left"");
                                case ""TomlRightPadded"" -> writePaddedGetterWithers(c, varDec, elementType, ""Right"");
                                default -> writeModelGetterWithers(c, varDec);
                            };
                        } else if (padded) {
                            c = writeModelGetterWithers(c, varDec);
                        }
                    } else if (padded) {
                        c = writeModelGetterWithers(c, varDec);
                    }
                }
            }

            if (padded) {
                c = paddedModel.apply(updateCursor(c), c.getCoordinates().replaceAnnotations());
                c = paddingField.apply(updateCursor(c), c.getBody().getCoordinates().firstStatement());
                c = getPadding.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement());
                c = paddingClass.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(), c.getSimpleName());
            } else {
                c = valueModel.apply(updateCursor(c), c.getCoordinates().replaceAnnotations());
            }

            List<Statement> statements = c.getBody().getStatements();
            c = c.withBody(c.getBody().withStatements(ListUtils.map(statements, (i, statement) -> {
                if (statement instanceof J.VariableDeclarations && i > 0) {
                    Statement previous = statements.get(i - 1);
                    if (!((J.VariableDeclarations) statement).getLeadingAnnotations().isEmpty() ||
                        (previous instanceof J.VariableDeclarations) && !((J.VariableDeclarations) previous).getLeadingAnnotations().isEmpty()) {
                        return statement.withPrefix(Space.format(""\n\n""));
                    }
                }
                return statement;
            })));

            return c;
        }

        private J.ClassDeclaration writeModelGetterWithers(J.ClassDeclaration c, J.VariableDeclarations varDec) {
            return c.withBody(c.getBody().withStatements(ListUtils.map(c.getBody().getStatements(), statement -> {
                if (statement == varDec) {
                    Cursor cursor = new Cursor(new Cursor(updateCursor(c), c.getBody()), varDec);
                    statement = withGetterAnnotations.apply(cursor, varDec.getCoordinates().addAnnotation(Comparator.comparing(J.Annotation::getSimpleName)));
                }
                return statement;
            })));
        }

        private J.ClassDeclaration writeContainerGetterWithers(J.ClassDeclaration c, J.VariableDeclarations varDec, JavaType.FullyQualified elementType) {
            String name = varDec.getVariables().get(0).getSimpleName();
            String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
            String elementTypeName = elementType.getClassName();
            String modelTypeName = c.getSimpleName();

            J.Block body = unwrappedContainerGetterWither.apply(new Cursor(updateCursor(c), c.getBody()), c.getBody().getCoordinates().lastStatement(),
                    elementTypeName, capitalizedName,
                    name,
                    modelTypeName, capitalizedName, elementTypeName, name,
                    capitalizedName, name,
                    name, name);

            return c.withBody(body);
        }

        private J.ClassDeclaration writePaddedGetterWithers(J.ClassDeclaration c, J.VariableDeclarations varDec, JavaType.FullyQualified elementType,
                                                            String leftOrRight) {
            boolean nullable = !FindAnnotations.find(varDec, ""@org.openrewrite.internal.lang.Nullable"").isEmpty();
            String name = varDec.getVariables().get(0).getSimpleName();
            String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
            String elementTypeName = elementType.getClassName();
            String modelTypeName = c.getSimpleName();

            J.Block body = c.getBody();
            if (nullable) {
                StringJoiner newModelArguments = new StringJoiner("", "");
                for (Statement statement : body.getStatements()) {
                    if (statement instanceof J.VariableDeclarations) {
                        newModelArguments.add(statement == varDec ? ""null"" : ((J.VariableDeclarations) statement).getVariables()
                                .get(0).getSimpleName());
                    }
                }
                body = nullableUnwrappedPaddedGetterWither.apply(new Cursor(getCursor(), body), body.getCoordinates().lastStatement(),
                        elementTypeName, capitalizedName, name, name, modelTypeName, capitalizedName,
                        elementTypeName, name, name, name, modelTypeName, newModelArguments.toString(),
                        capitalizedName, leftOrRight, name, name);
            } else {
                body = unwrappedPaddedGetterWither.apply(new Cursor(getCursor(), body), body.getCoordinates().lastStatement(),
                        elementTypeName, capitalizedName, name,
                        modelTypeName, capitalizedName, elementTypeName, name,
                        capitalizedName, leftOrRight, name, name);
            }

            return c.withBody(body);
        }

        boolean isPadded(Statement statement) {
            if (!(statement instanceof J.VariableDeclarations)) {
                return false;
            }
            JavaType.FullyQualified type = TypeUtils.asFullyQualified(((J.VariableDeclarations) statement).getType());
            assert type != null;
            return type.getClassName().contains(""Padded"") || type.getClassName().equals(""TomlContainer"");
        }
    };

    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<>() {
            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                Object parent = getCursor().getParentOrThrow().getValue();
                if (!(parent instanceof J.ClassDeclaration) || !((J.ClassDeclaration) parent).getSimpleName().equals(""Toml"")) {
                    return block;
                }

                J.Block b = block.withStatements(ListUtils.map(block.getStatements(), s -> s instanceof J.ClassDeclaration &&
                                                                                           !(((J.ClassDeclaration) s).getSimpleName().equals(""CompilationUnit"")) ? null : s));
                List<Statement> statements = new ArrayList<>(b.getStatements());
                statements.addAll(ListUtils.map(modelClasses,
                        mc -> (J.ClassDeclaration) writeModelClass.visitNonNull(mc, ctx, getCursor().getParentOrThrow())));
                b = b.withStatements(statements);

                return b;
            }
        };
    }
}
",{}
Write the boilerplate for `TomlPrinter`,Every print method starts with `visitSpace` then `visitMarkers`. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package generate;

import lombok.RequiredArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;
import java.util.StringJoiner;

import static java.util.Objects.requireNonNull;

@RequiredArgsConstructor
public class WritePrinter extends Recipe {
    final List<J.ClassDeclaration> modelClasses;

    @Override
    public String getDisplayName() {
        return ""Write the boilerplate for `TomlPrinter`"";
    }

    @Override
    public String getDescription() {
        return ""Every print method starts with `visitSpace` then `visitMarkers`. "" +
               ""Every model element is visited. An engineer must fill in the places "" +
               ""where keywords are grammatically required."";
    }

    JavaParser.Builder<? extends JavaParser, ?> parser = JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath());

    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration c = classDecl;

                for (J.ClassDeclaration modelClass : missingVisitorMethods(c)) {
                    String modelTypeName = modelClass.getSimpleName();
                    String paramName = modelTypeName.substring(0, 1).toLowerCase() + modelTypeName.substring(1);

                    StringJoiner fields = new StringJoiner(""\n    "");
                    for (Statement statement : modelClass.getBody().getStatements()) {
                        if (statement instanceof J.VariableDeclarations varDec) {
                            J.VariableDeclarations.NamedVariable namedVariable = varDec.getVariables().get(0);
                            String name = namedVariable.getSimpleName();
                            String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);

                            JavaType.FullyQualified elemType = requireNonNull(TypeUtils.asFullyQualified(varDec.getType()));
                            switch (elemType.getClassName()) {
                                case ""TomlLeftPadded"":
                                    fields.add(""visitLeftPadded(\""\"","" + paramName + "".getPadding().get"" + capitalizedName + ""(), p);"");
                                    break;
                                case ""TomlRightPadded"":
                                    fields.add(""visitRightPadded("" + paramName + "".getPadding().get"" + capitalizedName + ""(), \""\"", p);"");
                                    break;
                                case ""TomlContainer"":
                                    fields.add(""visitContainer(\""\"", "" + paramName + "".getPadding().get"" + capitalizedName + ""(), \""\"", \""\"", p);"");
                                    break;
                                case ""List"":
                                    String loopVar = paramName.substring(0, 1);
                                    if (loopVar.equals(""p"")) {
                                        loopVar = ""pp"";
                                    }
                                    String typeParam = ((J.Identifier) requireNonNull(((J.ParameterizedType) varDec.getTypeExpression()).getTypeParameters()).get(0)).getSimpleName();
                                    fields.add(""for(Toml."" + typeParam + "" "" + loopVar + "" : "" + paramName + "".get"" + capitalizedName + ""()) {\n"" +
                                               ""    // TODO print each element\n"" +
                                               ""}"");
                                    break;
                                case ""String"":
                                    fields.add(""p.append("" + paramName + "".get"" + capitalizedName + ""());"");
                                    break;
                                case ""Integer"":
                                    fields.add(""p.append("" + paramName + "".get"" + capitalizedName + ""().toString());"");
                                    break;
                                default:
                                    if (elemType.getClassName().startsWith(""Toml"")) {
                                        fields.add(""visit("" + paramName + "".get"" + capitalizedName + ""(), p);"");
                                    }
                            }
                        }
                    }

                    StringBuilder template = new StringBuilder();

                    JavaTemplate visitMethod = JavaTemplate.builder(
                                    ""public Toml visit#{}(Toml.#{} #{}, PrintOutputCapture<P> p) {"" +
                                    ""    visitSpace(#{}.getPrefix(), p);"" +
                                    ""    visitMarkers(#{}.getMarkers(), p);"" +
                                    ""    #{}"" +
                                    ""    return #{};"" +
                                    ""}""
                            )
                            .javaParser(parser)
//                            .doAfterVariableSubstitution(System.out::println)
                            .doBeforeParseTemplate(template::append)
                            .build();

                    try {
                        c = visitMethod.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(),
                                modelTypeName, modelTypeName, paramName,
                                paramName,
                                paramName,
                                fields,
                                paramName);
                    } catch (Throwable t) {
                        System.out.println(template);
                        throw t;
                    }
                }

                return c;
            }

            private List<J.ClassDeclaration> missingVisitorMethods(J.ClassDeclaration visitorClass) {
                return ListUtils.map(modelClasses, modelClass -> {
                    for (Statement statement : visitorClass.getBody().getStatements()) {
                        if (statement instanceof J.MethodDeclaration m) {
                            if (m.getSimpleName().endsWith(modelClass.getSimpleName())) {
                                return null;
                            }
                        }
                    }
                    return modelClass;
                });
            }
        };
    }
}
",{}
Write TOML boilerplate,Write the boilerplate for `TomlVisitor` and `TomlIsoVisitor`.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package generate;

import lombok.RequiredArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.List;
import java.util.StringJoiner;

import static java.util.Objects.requireNonNull;

@RequiredArgsConstructor
public class WriteVisitorMethods extends Recipe {
    final List<J.ClassDeclaration> modelClasses;

    @Override
    public String getDisplayName() {
        return ""Write TOML boilerplate"";
    }

    @Override
    public String getDescription() {
        return ""Write the boilerplate for `TomlVisitor` and `TomlIsoVisitor`."";
    }

    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        return new JavaVisitor<>() {
            @Override
            public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                return switch (classDecl.getSimpleName()) {
                    case ""TomlVisitor"" ->
                            writeVisitorMethods.visitNonNull(classDecl, ctx, getCursor().getParentOrThrow());
                    case ""TomlIsoVisitor"" ->
                            writeIsoVisitorMethods.visitNonNull(classDecl, ctx, getCursor().getParentOrThrow());
                    default -> classDecl;
                };

            }
        };
    }

    JavaParser.Builder<? extends JavaParser, ?> parser = JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath());

    private final JavaVisitor<ExecutionContext> writeVisitorMethods = new JavaIsoVisitor<>() {

        final JavaTemplate visitMethod = JavaTemplate.builder(
                """"""
                public Toml visit#{}(Toml.#{} #{}, P p) {
                    Toml.#{} #{} = #{};
                    #{} = #{}.withPrefix(visitSpace(#{}.getPrefix(), p));
                    #{} = #{}.withMarkers(visitMarkers(#{}.getMarkers(), p));
                    #{}
                    return #{};
                }
                """"""
        ).javaParser(parser).build();

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = classDecl;

            for (J.ClassDeclaration modelClass : missingVisitorMethods(c)) {
                String modelTypeName = modelClass.getSimpleName();
                String paramName = modelTypeName.substring(0, 1).toLowerCase() + modelTypeName.substring(1);
                String varName = paramName.substring(0, 1);
                if (varName.equals(""p"")) {
                    varName = ""pp"";
                }

                StringJoiner fields = new StringJoiner(""\n    "");
                for (Statement statement : modelClass.getBody().getStatements()) {
                    if (statement instanceof J.VariableDeclarations varDec) {
                        boolean nullable = !FindAnnotations.find(varDec, ""@org.openrewrite.internal.lang.Nullable"").isEmpty();
                        String name = varDec.getVariables().get(0).getSimpleName();
                        String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);

                        JavaType.FullyQualified elemType = requireNonNull(TypeUtils.asFullyQualified(varDec.getType()));
                        switch (elemType.getClassName()) {
                            case ""TomlLeftPadded"":
                                if (nullable) {
                                    fields.add(""if("" + varName + "".getPadding().get"" + capitalizedName + ""() != null) {"");
                                }
                                fields.add(varName + "" = "" + varName + "".getPadding().with"" + capitalizedName + ""(visitLeftPadded("" +
                                           varName + "".getPadding().get"" + capitalizedName + ""(), p));"");
                                if (nullable) {
                                    fields.add(""}"");
                                }
                                break;
                            case ""TomlRightPadded"":
                                if (nullable) {
                                    fields.add(""if("" + varName + "".getPadding().get"" + capitalizedName + ""() != null) {"");
                                }
                                fields.add(varName + "" = "" + varName + "".getPadding().with"" + capitalizedName + ""(visitRightPadded("" +
                                           varName + "".getPadding().get"" + capitalizedName + ""(), p));"");
                                if (nullable) {
                                    fields.add(""}"");
                                }
                                break;
                            case ""TomlContainer"":
                                fields.add(varName + "" = "" + varName + "".getPadding().with"" + capitalizedName + ""(visitContainer("" + varName + "".getPadding().get"" + capitalizedName + ""(), p));"");
                                break;
                            case ""List"":
                                J.ParameterizedType parameterizedType = requireNonNull((J.ParameterizedType) varDec.getTypeExpression());
                                String elemListType = requireNonNull(TypeUtils.asFullyQualified(requireNonNull(parameterizedType.getTypeParameters()).get(0).getType()))
                                        .getClassName();
                                fields.add(varName + "" = "" + varName + "".with"" + capitalizedName + ""(ListUtils.map("" +
                                           varName + "".get"" + capitalizedName + ""(), t -> ("" + elemListType +
                                           "") visit(t, p)));"");
                                break;
                            default:
                                if (elemType.getClassName().startsWith(""Toml"")) {
                                    fields.add(varName + "" = "" + varName + "".with"" + capitalizedName + ""(("" +
                                               elemType.getClassName() + "") visit("" + varName + "".get"" + capitalizedName + ""(), p));"");
                                }
                        }
                    }
                }
                c = visitMethod.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(),
                        modelTypeName, modelTypeName, paramName,
                        modelTypeName, varName, paramName,
                        varName, varName, varName,
                        varName, varName, varName,
                        fields,
                        varName);
            }

            return c;
        }
    };

    private final JavaVisitor<ExecutionContext> writeIsoVisitorMethods = new JavaIsoVisitor<>() {
        final JavaTemplate isoVisitMethod = JavaTemplate.builder(
                """"""
                @Override
                public Toml.#{} visit#{}(Toml.#{} #{}, P p) {
                    return (Toml.#{}) super.visit#{}(#{}, p);
                }
                """"""
        ).javaParser(parser).build();

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = classDecl;

            for (J.ClassDeclaration modelClass : missingVisitorMethods(c)) {
                String modelTypeName = modelClass.getSimpleName();
                String paramName = modelTypeName.substring(0, 1).toLowerCase() + modelTypeName.substring(1);
                c = isoVisitMethod.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(),
                        modelTypeName, modelTypeName, modelTypeName, paramName,
                        modelTypeName, modelTypeName, paramName);
            }

            return c;
        }
    };

    private List<J.ClassDeclaration> missingVisitorMethods(J.ClassDeclaration visitorClass) {
        return ListUtils.map(modelClasses, modelClass -> {
            for (Statement statement : visitorClass.getBody().getStatements()) {
                if (statement instanceof J.MethodDeclaration m) {
                    if (m.getSimpleName().endsWith(modelClass.getSimpleName())) {
                        return null;
                    }
                }
            }
            return modelClass;
        });
    }
}
",{}
Write accessors for padded parts of the model,Write accessors for padded parts of the model.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package generate;

import lombok.RequiredArgsConstructor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.search.FindAnnotations;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;

import java.util.StringJoiner;

/**
 * TODO Unable to add accessors in the first phase due to some bug in JavaTemplate.
 */
@RequiredArgsConstructor
public class WritePaddingAccessors extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Write accessors for padded parts of the model"";
    }

    @Override
    public String getDescription() {
        return ""Write accessors for padded parts of the model."";
    }

    JavaParser.Builder<? extends JavaParser, ?> parser = JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath());

    @RequiredArgsConstructor
    class WritePaddingAccessorsVisitor extends JavaIsoVisitor<ExecutionContext> {
        final J.ClassDeclaration modelClassDeclaration;

        /**
         * The accessors in the Padding class that return the padding wrapped element.
         */
        final JavaTemplate paddedGetterWither = JavaTemplate.builder(
                """"""
                        #{}
                        public Toml#{}<#{}> get#{}() {
                            return t.#{};
                        }

                        public #{} with#{}(#{}Toml#{}<#{}> #{}) {
                            return t.#{} == #{} ? t : new #{}(#{});
                        }
                        """"""
        ).javaParser(parser).build();

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration c = classDecl;

            if (c.getSimpleName().equals(""Padding"")) {
                for (Statement statement : modelClassDeclaration.getBody().getStatements()) {
                    if (statement instanceof J.VariableDeclarations varDec) {
                        JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(varDec.getType());

                        JavaType.FullyQualified elementType = null;
                        if (varDec.getTypeExpression() instanceof J.ParameterizedType typeExpression) {
                            if (typeExpression.getTypeParameters() != null) {
                                elementType = TypeUtils.asFullyQualified(typeExpression.getTypeParameters().get(0).getType());
                            }
                        }

                        if (fqn != null && elementType != null) {
                            c = switch (fqn.getClassName()) {
                                case ""TomlContainer"" -> writePaddedGetterWithers(c, varDec, elementType, ""Container"");
                                case ""TomlLeftPadded"" -> writePaddedGetterWithers(c, varDec, elementType, ""LeftPadded"");
                                case ""TomlRightPadded"" -> writePaddedGetterWithers(c, varDec, elementType, ""RightPadded"");
                                default -> c;
                            };
                        }
                    }
                }

                return c;
            }

            return super.visitClassDeclaration(classDecl, ctx);
        }

        private J.ClassDeclaration writePaddedGetterWithers(J.ClassDeclaration c, J.VariableDeclarations varDec, JavaType.FullyQualified elementType,
                                                            String leftOrRight) {
            boolean nullable = !FindAnnotations.find(varDec, ""@org.openrewrite.internal.lang.Nullable"").isEmpty();
            String name = varDec.getVariables().get(0).getSimpleName();
            String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);
            String elementTypeName = elementType.getClassName();
            String modelTypeName = modelClassDeclaration.getSimpleName();

            StringJoiner newModelArguments = new StringJoiner("", "");
            for (Statement paddingStatement : modelClassDeclaration.getBody().getStatements()) {
                if (paddingStatement instanceof J.VariableDeclarations) {
                    newModelArguments.add(paddingStatement == varDec ? name : ""t."" + ((J.VariableDeclarations) paddingStatement).getVariables()
                            .get(0).getSimpleName());
                }
            }

            c = paddedGetterWither.apply(updateCursor(c), c.getBody().getCoordinates().lastStatement(),
                    nullable ? ""@Nullable "" : """", leftOrRight, elementTypeName, capitalizedName,
                    name, modelTypeName, capitalizedName,
                    nullable ? ""@Nullable "" : """", leftOrRight,
                    elementTypeName, name, name, name, modelTypeName, newModelArguments);

            return c;
        }
    }

    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<>() {
            @Override
            public J.Block visitBlock(J.Block block, ExecutionContext ctx) {
                Object parent = getCursor().getParentOrThrow().getValue();
                if (!(parent instanceof J.ClassDeclaration) || !((J.ClassDeclaration) parent).getSimpleName().equals(""Toml"")) {
                    return block;
                }

                J.Block b = block;

                b = b.withStatements(ListUtils.map(b.getStatements(),
                        mc -> mc instanceof J.ClassDeclaration ?
                                (Statement) new WritePaddingAccessorsVisitor((J.ClassDeclaration) mc)
                                        .visitNonNull(mc, ctx, getCursor().getParentOrThrow()) :
                                mc)
                );

                return b;
            }
        };
    }
}
",{}
Append to sequence,Append item to YAML sequence.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class AppendToSequence extends Recipe {
    @Option(displayName = ""Sequence path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a YAML sequence."",
            example = ""$.universe.planets"")
    String sequencePath;

    @Option(displayName = ""New value"",
            description = ""The new value to be appended to the sequence."",
            example = ""earth"")
    String value;

    @Option(displayName = ""Optional: match existing sequence values"",
            description = ""If specified, the item will only be appended if the existing sequence matches these values."",
            example = ""existingValue1"",
            required = false)
    @Nullable
    List<String> existingSequenceValues;

    @Option(displayName = ""Optional: match existing sequence values in any order"",
            description = ""If specified in combination with the above parameter, the item will only be appended if the existing sequence has the specified values in any order."",
            example = ""true"",
            required = false)
    @Nullable
    Boolean matchExistingSequenceValuesInAnyOrder;

    @Override
    public String getDisplayName() {
        return ""Append to sequence"";
    }

    @Override
    public String getInstanceName() {
        return String.format(""Append %s to sequence `%s`"",
                value, sequencePath);
    }

    @Override
    public String getDescription() {
        return ""Append item to YAML sequence."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(sequencePath);
        return new AppendToSequenceVisitor(matcher, value, existingSequenceValues,
                Boolean.TRUE.equals(matchExistingSequenceValuesInAnyOrder));
    }
}
","{
  ""value"": ""String field""
}"
Change key,Change a YAML mapping entry key while leaving the value intact.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.yaml.tree.Yaml;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeKey extends Recipe {
    @Option(displayName = ""Old key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a YAML entry."",
            example = ""$.subjects.kind"")
    String oldKeyPath;

    @Option(displayName = ""New key"",
            description = ""The new name for the key selected by the `oldKeyPath`."",
            example = ""kind"")
    String newKey;

    @Override
    public String getDisplayName() {
        return ""Change key"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldKeyPath, newKey);
    }

    @Override
    public String getDescription() {
        return ""Change a YAML mapping entry key while leaving the value intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(oldKeyPath);
        return new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);
                if (matcher.matches(getCursor())) {
                    if (e.getKey() instanceof Yaml.Scalar) {
                        e = e.withKey(((Yaml.Scalar) e.getKey()).withValue(newKey));
                    }
                }
                return e;
            }
        };
    }
}
","{
  ""newKey"": ""String field""
}"
Unfold YAML properties,"Transforms dot-separated property keys in YAML files into nested map hierarchies to enhance clarity and readability, or for compatibility with tools expecting structured YAML.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.yaml.tree.Yaml;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.internal.StringUtils.countOccurrences;
import static org.openrewrite.internal.StringUtils.hasLineBreak;
import static org.openrewrite.marker.Markers.EMPTY;
import static org.openrewrite.yaml.tree.Yaml.Scalar.Style.PLAIN;

@Value
@EqualsAndHashCode(callSuper = false)
public class UnfoldProperties extends Recipe {
    private static final Pattern LINE_BREAK = Pattern.compile(""\\R"");

    @Option(displayName = ""Exclusions"",
            description = ""An optional list of [JsonPath Plus](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expressions to specify keys that should not be unfolded."",
            example = ""$..[org.springframework.security]"")
    List<String> exclusions;

    @Option(displayName = ""Apply to"",
            description = ""An optional list of [JsonPath Plus](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expressions that specify which keys the recipe should target only. "" +
                    ""Only the properties matching these expressions will be unfolded."",
            example = ""$..[org.springframework.security]"")
    List<String> applyTo;

    public UnfoldProperties(@Nullable final List<String> exclusions, @Nullable final List<String> applyTo) {
        this.exclusions = exclusions == null ? emptyList() : exclusions;
        this.applyTo = applyTo == null ? emptyList() : applyTo;
    }

    @Override
    public String getDisplayName() {
        return ""Unfold YAML properties"";
    }

    @Override
    public String getDescription() {
        return ""Transforms dot-separated property keys in YAML files into nested map hierarchies to enhance clarity and readability, or for compatibility with tools expecting structured YAML."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        List<JsonPathMatcher> exclusionMatchers = exclusions.stream().map(JsonPathMatcher::new).collect(toList());
        return new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {
                Yaml.Document doc = super.visitDocument(document, ctx);
                doAfterVisit(new MergeDuplicateSectionsVisitor<>(doc));
                return doc;
            }

            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry e, ExecutionContext ctx) {
                Yaml.Mapping.Entry entry = super.visitMappingEntry(e, ctx);

                String key = entry.getKey().getValue();
                if (key.contains(""."")) {
                    boolean foundMatch = false;
                    Cursor c = getCursor();
                    while (!foundMatch && !c.isRoot()) {
                        Cursor current = c;
                        foundMatch = exclusionMatchers.stream().anyMatch(it -> it.matches(current));
                        if (foundMatch) {
                            break;
                        } else {
                            c = c.getParent();
                        }
                    }
                    if (!foundMatch) {
                        List<String> parts = getParts(key);
                        if (parts.size() > 1) {
                            Yaml.Mapping.Entry nestedEntry = createNestedEntry(parts, 0, entry.getValue()).withPrefix(entry.getPrefix());
                            Yaml.Mapping.Entry newEntry = maybeAutoFormat(entry, nestedEntry, entry.getValue(), ctx, getCursor());

                            if (shouldShift()) {
                                int identLevel = Math.abs(getIndentLevel(entry) - getIndentLevel(newEntry));
                                if (!hasLineBreak(entry.getPrefix()) && hasLineBreak(newEntry.getPrefix())) {
                                    newEntry = newEntry.withPrefix(substringOfAfterFirstLineBreak(entry.getPrefix()));
                                } else if (identLevel == 0 && hasLineBreak(newEntry.getPrefix())) {
                                    identLevel = 2; // autFormat indents the entire block by 2 spaces though it is a root level entry -> shift by 2 later
                                }
                                doAfterVisit(new ShiftFormatLeftVisitor<>(newEntry, identLevel));
                            }

                            return newEntry;
                        }
                    }
                }

                return entry;
            }

            /**
             * Splits a key into parts while respecting certain exclusion rules.
             * The method ensures certain segments of the key are kept together as defined in the exclusion list.
             * It also considers the applyTo list during the split process.
             *
             * @param key the full key to be split into parts
             * @return a list of strings representing the split parts of the key
             */
            private List<String> getParts(String key) {
                String parentKey = getParentKey();
                List<String> keepTogether = new ArrayList<>();
                for (String ex : exclusions) {
                    keepTogether.addAll(matches(key, ex, parentKey));
                }

                List<String> result = new ArrayList<>();
                List<String> parts = Arrays.asList(key.split(""\\.""));
                outer:
                for (int i = 0; i < parts.size(); ) {
                    for (String group : keepTogether) {
                        List<String> groupParts = Arrays.asList(group.split(""\\.""));
                        if (i + groupParts.size() <= parts.size()) {
                            List<String> subList = parts.subList(i, i + groupParts.size());
                            if (subList.equals(groupParts)) {
                                result.add(String.join(""."", groupParts));
                                i += groupParts.size();
                                continue outer;
                            }
                        }
                    }
                    result.add(parts.get(i));
                    i++;
                }

                if (!applyTo.isEmpty()) {
                    if (applyTo.stream().allMatch(it -> matches(key, it, parentKey).isEmpty())) {
                        return emptyList();
                    }
                }

                return result;
            }

            private String getParentKey() {
                StringBuilder parentKey = new StringBuilder();
                Cursor c = getCursor().getParent();
                while (c != null) {
                    if (c.getValue() instanceof Yaml.Mapping.Entry) {
                        parentKey.insert(0, ((Yaml.Mapping.Entry) c.getValue()).getKey().getValue() + ""."");
                    }
                    c = c.getParent();
                }
                return parentKey.length() == 0 ? """" : parentKey.substring(0, parentKey.length() - 1);
            }

            /**
             * Matches a key against a JsonPath pattern.
             * It uses a custom JsonPathParser to parse keys with dots, like `logging.level`, and support the @property.match operator.
             *
             * @return found group or empty if no match was found
             */
            private List<String> matches(String key, String pattern, String parentKey) {
                // Recursive descent
                List<String> result = new ArrayList<>();
                if (pattern.startsWith(""$.."")) {
                    pattern = pattern.substring(3);
                }

                // Starts from root
                if (pattern.startsWith(""$."")) {
                    pattern = pattern.replace(""$."" + parentKey, """");
                    if (pattern.startsWith(""."")) {
                        pattern = pattern.substring(1);
                    }
                }

                // Handle parent-child conditions like: `$..[logging.level][?(<condition>)]` and `$..logging.level[?(<condition>)]`
                if (pattern.startsWith(""["") && pattern.contains(""]["")) {
                    int secondBracketStart = pattern.indexOf('[', 1);
                    String secondBracket = pattern.substring(secondBracketStart);
                    String valueOfFirstBracket = pattern.substring(1, secondBracketStart - 1);
                    List<String> firstBracketMatches = matches(key, valueOfFirstBracket, parentKey);
                    for (String firstBracketMatch : firstBracketMatches) {
                        if (key.startsWith(firstBracketMatch) && key.length() > firstBracketMatch.length()) {
                            result.addAll(matches(key.substring(firstBracketMatch.length() + 1), secondBracket, (!parentKey.isEmpty() ? parentKey + ""."" : parentKey) + valueOfFirstBracket));
                        }
                    }
                    pattern = pattern.substring(1, secondBracketStart - 1) + secondBracket;
                }
                if (!pattern.startsWith(""["") && pattern.contains(""["") && parentKey.contains(pattern.split(""\\["")[0])) {
                    pattern = ""["" + pattern.split(""\\["")[1];
                }

                // property in brackets
                if (pattern.startsWith(""["") && pattern.endsWith(""]"")) {
                    pattern = pattern.substring(1, pattern.length() - 1);
                }

                // properties can be wrapped in quotes
                if (pattern.startsWith(""\"""") && pattern.endsWith(""\"""")) {
                    pattern = pattern.substring(1, pattern.length() - 1);
                } else if (pattern.startsWith(""'"") && pattern.endsWith(""'"")) {
                    pattern = pattern.substring(1, pattern.length() - 1);
                }

                if (key.contains(pattern)) {
                    result.add(pattern);
                } else if (pattern.startsWith(""?(@property.match(/"") && pattern.endsWith(""/))"")) {
                    pattern = pattern.substring(19, pattern.length() - 3);
                    Matcher m = Pattern.compile("".*("" + pattern + "").*"").matcher(key);
                    if (m.matches()) {
                        String match = m.group(1).isEmpty() ? m.group(0) : m.group(1);
                        if (match.endsWith(""."")) {
                            match = match.substring(0, match.length() - 1);
                        }
                        result.add(match);
                    }
                }
                return result;
            }

            private Yaml.Mapping.Entry createNestedEntry(List<String> keys, int index, Yaml.Block value) {
                if (index != keys.size() - 1) {
                    Yaml.Mapping.Entry entry = createNestedEntry(keys, index + 1, value);
                    value = new Yaml.Mapping(randomId(), EMPTY, null, singletonList(entry), null, null, null);
                }

                Yaml.Scalar key = new Yaml.Scalar(randomId(), """", EMPTY, PLAIN, null, null, keys.get(index));
                return new Yaml.Mapping.Entry(randomId(), """", EMPTY, key, """", value);
            }

            private int getIndentLevel(Yaml.Mapping.Entry entry) {
                String[] parts = entry.getPrefix().split(""\\R"");
                return parts.length > 1 ? countOccurrences(parts[1], "" "") : 0;
            }

            /**
             * MaybeAutoFormat cannot determine the proper indenting.
             * So shift when the first key with dots is targeted:
             *
             * <pre>
             * {@code
             * a.b:           # <-- shift
             *   b.c:
             * a2.b2: true    # <-- shift
             * a3:
             *  b3:
             *   c3.d4:       # <-- shift
             *    e4.f5.g6:
             *     h3: true
             * }
             * </pre>
             */
            private boolean shouldShift() {
                try {
                    getCursor().dropParentUntil(it -> it instanceof Yaml.Mapping.Entry && ((Yaml.Mapping.Entry) it).getKey().getValue().contains("".""));
                    return false;
                } catch (IllegalStateException ignored) {
                    // `IllegalStateException(""Expected to find a matching parent"")` means no parent with dot in key can be found
                    return true;
                }
            }

            private String substringOfAfterFirstLineBreak(String s) {
                String[] lines = LINE_BREAK.split(s, -1);
                return lines.length > 1 ? String.join(""\n"", Arrays.copyOfRange(lines, 1, lines.length)) : """";
            }
        };
    }
}
",{}
Change property key,"Change a YAML property key while leaving the value intact. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.yaml.search.FindProperty;
import org.openrewrite.yaml.tree.Yaml;

import java.util.*;
import java.util.regex.Pattern;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Spliterators.spliteratorUnknownSize;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toCollection;
import static java.util.stream.StreamSupport.stream;
import static org.openrewrite.Tree.randomId;

/**
 * Nested YAML mappings are interpreted as dot
 * separated property names, e.g. as Spring Boot
 * interprets application.yml files.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePropertyKey extends Recipe {

    @Option(displayName = ""Old property key"",
            description = ""The property key to rename. Supports glob patterns."",
            example = ""management.metrics.binders.*.enabled"")
    String oldPropertyKey;

    @Option(displayName = ""New property key"",
            description = ""The new name for the property key."",
            example = ""management.metrics.enable.process.files"")
    String newPropertyKey;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `oldPropertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Defaults to `true`. If you want to use exact matching in your search, set this to `false`."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Option(example = ""List.of(\""group\"")"", displayName = ""Except"",
            description = ""If any of these property keys exist as direct children of `oldPropertyKey`, then they will not be moved to `newPropertyKey`."",
            required = false)
    @Nullable
    List<String> except;


    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Change property key"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldPropertyKey, newPropertyKey);
    }

    @Override
    public String getDescription() {
        return ""Change a YAML property key while leaving the value intact. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles(filePattern), new ChangePropertyKeyVisitor<>());
    }

    private class ChangePropertyKeyVisitor<P> extends YamlIsoVisitor<P> {
        @Override
        public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, P p) {
            Yaml.Mapping.Entry e = super.visitMappingEntry(entry, p);
            if (getCursor().firstEnclosing(Yaml.Sequence.class) != null) {
                return e;
            }
            Deque<Yaml.Mapping.Entry> propertyEntries = getCursor().getPathAsStream()
                    .filter(Yaml.Mapping.Entry.class::isInstance)
                    .map(Yaml.Mapping.Entry.class::cast)
                    .collect(toCollection(ArrayDeque::new));

            String prop = stream(spliteratorUnknownSize(propertyEntries.descendingIterator(), 0), false)
                    .map(e2 -> e2.getKey().getValue())
                    .collect(joining("".""));

            if (newPropertyKey.startsWith(oldPropertyKey) &&
                    (matches(prop, newPropertyKey) || matches(prop, newPropertyKey + "".*"") || childMatchesNewPropertyKey(entry, prop))) {
                return e;
            }

            String propertyToTest = newPropertyKey;
            if (matches(prop, oldPropertyKey)) {
                Iterator<Yaml.Mapping.Entry> propertyEntriesLeftToRight = propertyEntries.descendingIterator();
                while (propertyEntriesLeftToRight.hasNext()) {
                    Yaml.Mapping.Entry propertyEntry = propertyEntriesLeftToRight.next();
                    String value = propertyEntry.getKey().getValue() + ""."";

                    if ((!propertyToTest.startsWith(value ) || (propertyToTest.startsWith(value) && !propertyEntriesLeftToRight.hasNext())) &&
                        hasNonExcludedValues(propertyEntry)) {
                        doAfterVisit(new InsertSubpropertyVisitor<>(
                                propertyEntry,
                                propertyToTest,
                                entry
                        ));
                        break;
                    }
                    propertyToTest = propertyToTest.substring(value.length());
                }
            } else {
                String parentProp = prop.substring(0, prop.length() - e.getKey().getValue().length()).replaceAll("".$"", """");
                if (matches(prop, oldPropertyKey + "".*"") &&
                        !(matches(parentProp, oldPropertyKey + "".*"") || matches(parentProp, oldPropertyKey)) &&
                        noneMatch(prop, oldPropertyKey, excludedSubKeys())) {
                    Iterator<Yaml.Mapping.Entry> propertyEntriesLeftToRight = propertyEntries.descendingIterator();
                    while (propertyEntriesLeftToRight.hasNext()) {
                        Yaml.Mapping.Entry propertyEntry = propertyEntriesLeftToRight.next();
                        String value = propertyEntry.getKey().getValue() + ""."";

                        if (!propertyToTest.startsWith(value ) || (propertyToTest.startsWith(value) && !propertyEntriesLeftToRight.hasNext())) {
                            doAfterVisit(new InsertSubpropertyVisitor<>(
                                    propertyEntry,
                                    propertyToTest + prop.substring(oldPropertyKey.length()),
                                    entry
                            ));
                            break;
                        }
                        propertyToTest = propertyToTest.substring(value.length());
                    }
                }
            }

            return e;
        }

        private boolean childMatchesNewPropertyKey(Yaml.Mapping.Entry entry, String cursorPropertyKey) {
            String rescopedNewPropertyKey = newPropertyKey.replaceFirst(
                    Pattern.quote(cursorPropertyKey),
                    entry.getKey().getValue());
            return !FindProperty.find(entry, rescopedNewPropertyKey, relaxedBinding).isEmpty();
        }
    }

    private boolean hasNonExcludedValues(Yaml.Mapping.Entry propertyEntry) {
        if (!(propertyEntry.getValue() instanceof Yaml.Mapping)) {
            return true;
        } else {
            for (Yaml.Mapping.Entry entry : ((Yaml.Mapping) propertyEntry.getValue()).getEntries()) {
                if (noneMatch(entry, excludedSubKeys())) {
                    return true;
                }
            }
            return false;
        }
    }

    private boolean hasExcludedValues(Yaml.Mapping.Entry propertyEntry) {
        if (propertyEntry.getValue() instanceof Yaml.Mapping) {
            for (Yaml.Mapping.Entry entry : ((Yaml.Mapping) propertyEntry.getValue()).getEntries()) {
                if (anyMatch(entry, excludedSubKeys())) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean anyMatch(Yaml.Mapping.Entry entry, List<String> subKeys) {
        for (String subKey : subKeys) {
            if (entry.getKey().getValue().equals(subKey) ||
                    entry.getKey().getValue().startsWith(subKey + ""."")) {
                return true;
            }
        }
        return false;
    }

    private static boolean noneMatch(Yaml.Mapping.Entry entry, List<String> subKeys) {
        for (String subKey : subKeys) {
            if (entry.getKey().getValue().equals(subKey) ||
                    entry.getKey().getValue().startsWith(subKey + ""."")) {
                return false;
            }
        }
        return true;
    }

    private boolean noneMatch(String key, String basePattern, List<String> excludedSubKeys) {
        for (String subkey : excludedSubKeys) {
            String subKeyPattern = basePattern + ""."" + subkey;
            if (matches(key, subKeyPattern) || matches(key, subKeyPattern + "".*"")) {
                return false;
            }
        }
        return true;
    }

    private boolean matches(String string, String pattern) {
        return !Boolean.FALSE.equals(relaxedBinding) ?
                NameCaseConvention.matchesGlobRelaxedBinding(string, pattern) :
                StringUtils.matchesGlob(string, pattern);
    }

    private List<String> excludedSubKeys() {
        return except != null ? except : emptyList();
    }

    private class InsertSubpropertyVisitor<P> extends YamlIsoVisitor<P> {
        private final Yaml.Mapping.Entry scope;
        private final String subproperty;
        private final Yaml.Mapping.Entry entryToReplace;

        private InsertSubpropertyVisitor(Yaml.Mapping.Entry scope, String subproperty, Yaml.Mapping.Entry entryToReplace) {
            this.scope = scope;
            this.subproperty = subproperty;
            this.entryToReplace = entryToReplace;
        }

        @Override
        public Yaml.Mapping visitMapping(Yaml.Mapping mapping, P p) {
            Yaml.Mapping m = super.visitMapping(mapping, p);
            if (m.getEntries().contains(scope)) {
                String newEntryPrefix = scope.getPrefix();
                Yaml.Mapping.Entry newEntry = new Yaml.Mapping.Entry(randomId(),
                        newEntryPrefix,
                        Markers.EMPTY,
                        new Yaml.Scalar(randomId(), """", Markers.EMPTY,
                                Yaml.Scalar.Style.PLAIN, null, null, subproperty),
                        scope.getBeforeMappingValueIndicator(),
                        removeExclusions(entryToReplace.getValue().copyPaste()));

                if (hasExcludedValues(entryToReplace)) {
                    m = m.withEntries(ListUtils.concat(m.getEntries(), newEntry));
                } else {
                    if (m.getEntries().contains(entryToReplace)) {
                        m = m.withEntries(ListUtils.map(m.getEntries(), e -> {
                            if (e.equals(entryToReplace)) {
                                return newEntry.withPrefix(e.getPrefix());
                            }
                            return e;
                        }));
                    } else {
                        m = (Yaml.Mapping) new DeletePropertyVisitor<>(entryToReplace).visitNonNull(m, p);
                        Yaml.Mapping newMapping = m.withEntries(singletonList(newEntry));
                        Yaml.Mapping mergedMapping = (Yaml.Mapping) new MergeYamlVisitor<>(m, newMapping, true, null, false, null, null).visitMapping(m, p);
                        m = maybeAutoFormat(m, mergedMapping, p, getCursor().getParentOrThrow());
                    }
                }
            }

            return m;
        }

        @Override
        public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry originalEntry, P p) {
            final Yaml.Mapping.Entry e = super.visitMappingEntry(originalEntry, p);
            if (e == entryToReplace && hasNonExcludedValues(entryToReplace) && e.getValue() instanceof Yaml.Mapping) {
                return e.withValue(onlyExclusions((Yaml.Mapping) e.getValue()));
            }
            return e;
        }

        private Yaml.Mapping onlyExclusions(final Yaml.Mapping mapping) {
            List<Yaml.Mapping.Entry> list = new ArrayList<>();
            for (Yaml.Mapping.Entry entry : mapping.getEntries()) {
                if (!noneMatch(entry, excludedSubKeys())) {
                    list.add(entry);
                }
            }
            return mapping.withEntries(list);
        }

        private Yaml.Block removeExclusions(Yaml.Block block) {
            if (!(block instanceof Yaml.Mapping)) {
                return block;
            } else {
                Yaml.Mapping mapping = (Yaml.Mapping) block;
                List<Yaml.Mapping.Entry> list = new ArrayList<>();
                for (Yaml.Mapping.Entry entry : mapping.getEntries()) {
                    if (noneMatch(entry, excludedSubKeys())) {
                        list.add(entry);
                    }
                }
                return mapping.withEntries(list);
            }
        }
    }

    private static class DeletePropertyVisitor<P> extends YamlIsoVisitor<P> {
        private final Yaml.Mapping.Entry scope;

        private DeletePropertyVisitor(Yaml.Mapping.Entry scope) {
            this.scope = scope;
        }

        @Override
        public Yaml.Mapping visitMapping(Yaml.Mapping mapping, P p) {
            Yaml.Mapping m = super.visitMapping(mapping, p);

            boolean changed = false;
            List<Yaml.Mapping.Entry> entries = new ArrayList<>();
            for (Yaml.Mapping.Entry entry : m.getEntries()) {
                if (entry == scope || (entry.getValue() instanceof Yaml.Mapping && ((Yaml.Mapping) entry.getValue()).getEntries().isEmpty())) {
                    changed = true;
                } else {
                    entries.add(entry);
                }
            }

            if (entries.size() == 1) {
                entries = ListUtils.map(entries, e -> e.withPrefix(""""));
            }

            if (changed) {
                m = m.withEntries(entries);

                if (getCursor().getParentOrThrow().getValue() instanceof Yaml.Document) {
                    Yaml.Document document = getCursor().getParentOrThrow().getValue();
                    if (!document.isExplicit()) {
                        m = m.withEntries(m.getEntries());
                    }
                }
            }
            return m;
        }
    }
}
","{
  ""oldPropertyKey"": ""String field"",
  ""newPropertyKey"": ""String field""
}"
Create YAML file,Create a new YAML file.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.remote.Remote;
import org.openrewrite.yaml.tree.Yaml;

import java.net.URI;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CreateYamlFile extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""Relative file path"",
            description = ""File path of new file."",
            example = ""foo/bar/baz.yaml"")
    String relativeFileName;

    @Language(""yml"")
    @Option(displayName = ""File contents"",
            description = ""Multiline text content for the file."",
            example = ""a:\n"" +
                      ""  property: value\n"" +
                      ""another:\n"" +
                      ""  property: value"",
            required = false)
    @Nullable
    String fileContents;

    @Option(displayName = ""File contents URL"",
            description = ""URL to file containing text content for the file. Use either `fileContents` or `fileContentsUrl` option."",
            example = ""http://foo.bar/baz.yaml"",
            required = false)
    @Nullable
    String fileContentsUrl;

    @Option(displayName = ""Overwrite existing file"",
            description = ""If there is an existing file, should it be overwritten."",
            required = false)
    @Nullable
    Boolean overwriteExisting;

    @Override
    public String getDisplayName() {
        return ""Create YAML file"";
    }

    @Override
    public String getDescription() {
        return ""Create a new YAML file."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        return new CreateFileVisitor(Paths.get(relativeFileName), shouldCreate);
    }

    @Override
    public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            return YamlParser.builder().build().parse(getYamlContents(ctx))
                    .map(brandNewFile -> (SourceFile) brandNewFile.withSourcePath(Paths.get(relativeFileName)))
                    .collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
        Path path = Paths.get(relativeFileName);
        return new YamlVisitor<ExecutionContext>() {

            @Override
            public Yaml visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                if (Boolean.TRUE.equals(overwriteExisting) && path.equals(documents.getSourcePath())) {
                    @Language(""yml"")
                    String yamlContents = getYamlContents(ctx);
                    if (StringUtils.isBlank(yamlContents)) {
                        return documents.withDocuments(emptyList());
                    }
                    if (documents.printAll().equals(yamlContents)) {
                        return documents;
                    }
                    Optional<SourceFile> sourceFiles = YamlParser.builder().build()
                            .parse(yamlContents)
                            .findFirst();
                    if (sourceFiles.isPresent()) {
                        SourceFile sourceFile = sourceFiles.get();
                        if (sourceFile instanceof Yaml.Documents) {
                            return documents.withDocuments(((Yaml.Documents) sourceFile).getDocuments());
                        }
                    }
                }
                return documents;
            }
        };
    }

    @Language(""yml"")
    private String getYamlContents(ExecutionContext ctx) {
        @Language(""yml"") String yamlContents = fileContents;
        if (yamlContents == null && fileContentsUrl != null) {
            yamlContents = Remote.builder(Paths.get(relativeFileName))
                    .build(URI.create(fileContentsUrl))
                    .printAll(ctx);
        }
        return yamlContents == null ? """" : yamlContents;
    }
}
","{
  ""relativeFileName"": ""String field""
}"
Copy YAML value,Copies a YAML value from one key to another. ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.yaml.tree.Yaml;

import java.nio.file.Path;

@SuppressWarnings(""LanguageMismatch"")
@Value
@EqualsAndHashCode(callSuper = false)
public class CopyValue extends ScanningRecipe<CopyValue.Accumulator> {
    @Option(displayName = ""Old key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a YAML key/value pair to copy."",
            example = ""$.source.kind"")
    String oldKeyPath;

    @Option(displayName = ""Old file path"",
            description = ""The file path to the YAML file to copy the value from. "" +
                          ""If `null` then the value will be copied from any yaml file it appears within."",
            example = ""src/main/resources/application.yaml"",
            required = false)
    @Nullable
    String oldFilePath;

    @Option(displayName = ""New key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression defining where the value should be written."",
            example = ""$.dest.kind"")
    String newKey;

    @Option(displayName = ""New file path"",
            description = ""The file path to the YAML file to copy the value to. "" +
                          ""If `null` then the value will be copied only into the same file it was found in."",
            example = ""src/main/resources/application.yaml"",
            required = false)
    @Nullable
    String newFilePath;

    @Override
    public String getDisplayName() {
        return ""Copy YAML value"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""%s`%s` to %s`%s`"",
                (oldFilePath == null) ? """" : oldFilePath + "":"",
                oldKeyPath,
                (newFilePath == null) ? """" : newFilePath + "":"",
                newKey);
    }

    @Override
    public String getDescription() {
        return ""Copies a YAML value from one key to another. "" +
               ""The existing key/value pair remains unaffected by this change. "" +
               ""Attempts to merge the copied value into the new key if it already exists. "" +
               ""Attempts to create the new key if it does not exist."";
    }

    @Data
    public static class Accumulator {
        @Nullable
        String snippet;

        Path path;
    }


    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        TreeVisitor<?, ExecutionContext> visitor = new YamlIsoVisitor<ExecutionContext>() {
            final JsonPathMatcher oldPathMatcher = new JsonPathMatcher(oldKeyPath);

            @Override
            public Yaml.Documents visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                if (acc.snippet == null) {
                    return super.visitDocuments(documents, ctx);
                }
                return documents;
            }

            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry source = super.visitMappingEntry(entry, ctx);
                if (oldPathMatcher.matches(getCursor())) {
                    acc.snippet = entry.getValue().print(getCursor());
                    acc.path = getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath();
                }
                return source;
            }
        };
        if (oldFilePath != null) {
            visitor = Preconditions.check(new FindSourceFiles(oldFilePath), visitor);
        }

        return visitor;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        if (acc.snippet == null) {
            return TreeVisitor.noop();
        }
        return Preconditions.check(new FindSourceFiles(newFilePath == null ? acc.path.toString() : newFilePath),
                new MergeYaml(newKey, acc.snippet, false, null, null, null, null, null).getVisitor());
    }
}
",{}
Comment out property,Comment out a YAML property and add a comment in front.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.yaml.tree.Yaml;

import java.util.ArrayDeque;
import java.util.Deque;

import static java.util.Spliterators.spliteratorUnknownSize;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toCollection;
import static java.util.stream.StreamSupport.stream;

@Value
@EqualsAndHashCode(callSuper = false)
public class CommentOutProperty extends Recipe {
    @Option(displayName = ""Property key"",
            description = ""The key to be commented out."",
            example = ""applicability.singleSource"")
    String propertyKey;

    @Option(displayName = ""Comment text"",
            description = ""The comment text to be added before the specified key."",
            example = ""The `foo` property is deprecated, please migrate"")
    String commentText;

    @Option(example = ""true"", displayName = ""Comment out property"",
            description = ""If false, property wouldn't be commented out, only comment will be added. By default, set to true"",
            required = false)
    @Nullable
    Boolean commentOutProperty;

    @Override
    public String getDisplayName() {
        return ""Comment out property"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s`"", propertyKey);
    }

    @Override
    public String getDescription() {
        return ""Comment out a YAML property and add a comment in front."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new YamlIsoVisitor<ExecutionContext>() {
            private boolean nextDocNeedsNewline;
            private String comment = """";
            private String indentation = """";
            private boolean isBlockCommentExists;

            @Override
            public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {
                Yaml.Document doc = super.visitDocument(document, ctx);

                if (nextDocNeedsNewline) {
                    nextDocNeedsNewline = false;
                    doc = doc.withPrefix(""\n"" + doc.getPrefix());
                }

                // Add any leftover comment to the end of document
                if (!comment.isEmpty() && !Boolean.FALSE.equals(commentOutProperty)) {
                    String newPrefix = String.format(""%s# %s%s%s"",
                            indentation,
                            commentText,
                            indentation.contains(""\n"") ? """" : ""\n"",
                            indentation.contains(""\n"") ? comment : comment.replace(""#"", ""# ""));
                    nextDocNeedsNewline = !newPrefix.endsWith(""\n"");
                    comment = """";
                    return document.withEnd(doc.getEnd().withPrefix(newPrefix));
                }
                return doc;
            }

            @Override
            public Yaml.Sequence.Entry visitSequenceEntry(Yaml.Sequence.Entry entry,
                                                          ExecutionContext ctx) {
                indentation = entry.getPrefix();
                if (Boolean.FALSE.equals(commentOutProperty)) {
                    return addBockCommentIfNecessary(entry, ctx);
                } else if (!comment.isEmpty()) {
                    // add comment and return
                    String newPrefix = entry.getPrefix() + ""# "" + commentText + comment + entry.getPrefix();
                    comment = """";
                    return entry.withPrefix(newPrefix);
                }
                return super.visitSequenceEntry(entry, ctx);
            }

            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                String lastIndentation = indentation;
                indentation = entry.getPrefix();

                if (!comment.isEmpty() && !Boolean.FALSE.equals(commentOutProperty)) {
                    String newPrefix = entry.getPrefix() + ""# "" + commentText + comment + entry.getPrefix();
                    comment = """";
                    return entry.withPrefix(newPrefix);
                }

                String prop = calculateCurrentKeyPath();

                if (prop.equals(propertyKey)) {
                    String prefix = entry.getPrefix();

                    if (prefix.contains(""\n"")) {
                        comment = entry.print(getCursor().getParentTreeCursor()).replace(prefix, prefix + ""# "");
                    } else {
                        // getCursor().getParent().getValue()
                        comment = lastIndentation + ""#"" + entry.print(getCursor().getParentTreeCursor());
                    }

                    if (Boolean.FALSE.equals(commentOutProperty)) {
                        if (!entry.getPrefix().contains(commentText) && !isBlockCommentExists) {
                            return entry.withPrefix(entry.getPrefix() + ""# "" + commentText + (entry.getPrefix().contains(""\n"") ? entry.getPrefix() : ""\n"" + entry.getPrefix()));
                        }
                    } else {
                        doAfterVisit(new DeleteProperty(propertyKey, null, null, null).getVisitor());
                    }
                    return entry;
                }

                return super.visitMappingEntry(entry, ctx);
            }

            private Yaml.Sequence.Entry addBockCommentIfNecessary(Yaml.Sequence.Entry entry, ExecutionContext ctx) {
                boolean propertyExistsInSequence = isPropertyExistsInSequence(entry);
                if (propertyExistsInSequence) {
                    isBlockCommentExists = true;
                    if (!entry.getPrefix().contains(commentText)) {
                        return entry.withPrefix(entry.getPrefix() + ""# "" + commentText + (entry.getPrefix().contains(""\n"") ? entry.getPrefix() : ""\n"" + entry.getPrefix()));
                    }
                }
                return super.visitSequenceEntry(entry, ctx);
            }

            private boolean isPropertyExistsInSequence(Yaml.Sequence.Entry entry) {
                if (!(entry.getBlock() instanceof Yaml.Mapping)) {
                    return false;
                }
                Yaml.Mapping mapping = (Yaml.Mapping) entry.getBlock();
                String prop = calculateCurrentKeyPath();
                return mapping.getEntries().stream()
                        .anyMatch(e -> propertyKey.equals(prop + ""."" + e.getKey().getValue()));
            }

            private String calculateCurrentKeyPath() {
                Deque<Yaml.Mapping.Entry> propertyEntries = getCursor().getPathAsStream()
                        .filter(Yaml.Mapping.Entry.class::isInstance)
                        .map(Yaml.Mapping.Entry.class::cast)
                        .collect(toCollection(ArrayDeque::new));

                return stream(spliteratorUnknownSize(propertyEntries.descendingIterator(), 0), false)
                        .map(e2 -> e2.getKey().getValue())
                        .collect(joining("".""));
            }
        };
    }
}
","{
  ""propertyKey"": ""String field"",
  ""commentText"": ""String field""
}"
Coalesce YAML properties,"Simplify nested map hierarchies into their simplest dot separated property form, similar to how Spring Boot interprets `application.yml` files.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

import java.util.List;

import static java.util.Collections.emptyList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CoalesceProperties extends Recipe {
    @Option(displayName = ""Exclusions"",
            description = ""An optional list of [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expressions to specify keys that should not be unfolded."",
            example = ""$..[org.springframework.security]"",
            required = false)
    @Nullable List<String> exclusions;

    @Option(displayName = ""Apply to"",
            description = ""An optional list of [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expressions that specify which keys the recipe should target only. "" +
                    ""Only the properties matching these expressions will be unfolded."",
            example = ""$..[org.springframework.security]"",
            required = false)
    @Nullable List<String> applyTo;

    @Deprecated
    public CoalesceProperties() {
        this(null, null);
    }

    @JsonCreator
    public CoalesceProperties(@Nullable final List<String> exclusions, @Nullable final List<String> applyTo) {
        this.exclusions = exclusions == null ? emptyList() : exclusions;
        this.applyTo = applyTo == null ? emptyList() : applyTo;
    }

    @Override
    public String getDisplayName() {
        return ""Coalesce YAML properties"";
    }

    @Override
    public String getDescription() {
        return ""Simplify nested map hierarchies into their simplest dot separated property form, similar to how Spring Boot interprets `application.yml` files."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new CoalescePropertiesVisitor<>(exclusions, applyTo);
    }
}
",{}
Delete key,Delete a YAML mapping entry key.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.yaml.tree.Yaml;

import java.util.concurrent.atomic.AtomicReference;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteKey extends Recipe {
    @Option(displayName = ""Key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a YAML entry."",
            example = ""$.source.kind"")
    String keyPath;


    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Delete key"";
    }

    @Override
    public String getDescription() {
        return ""Delete a YAML mapping entry key."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(keyPath);
        return Preconditions.check(new FindSourceFiles(filePattern), new YamlIsoVisitor<ExecutionContext>() {

            @Override
            public  Yaml.Sequence.@Nullable Entry visitSequenceEntry(Yaml.Sequence.Entry entry, ExecutionContext ctx) {
                if (matcher.matches(getCursor()) || matcher.matches(new Cursor(getCursor(), entry.getBlock()))) {
                    removeUnused(getCursor().getParent());
                    return null;
                }
                return super.visitSequenceEntry(entry, ctx);
            }

            @Override
            public Yaml.Mapping visitMapping(Yaml.Mapping mapping, ExecutionContext ctx) {
                Yaml.Mapping m = super.visitMapping(mapping, ctx);
                AtomicReference<String> copyFirstPrefix = new AtomicReference<>();
                m = m.withEntries(ListUtils.map(m.getEntries(), (i, e) -> {
                    if (matcher.matches(new Cursor(getCursor(), e))) {
                        if (i == 0 && getCursor().getParentOrThrow().getValue() instanceof Yaml.Sequence.Entry) {
                            copyFirstPrefix.set(e.getPrefix());
                        }
                        removeUnused(getCursor().getParent());
                        return null;
                    }
                    return e;
                }));

                if (!m.getEntries().isEmpty() && copyFirstPrefix.get() != null) {
                    m = m.withEntries(ListUtils.mapFirst(m.getEntries(), e -> e.withPrefix(copyFirstPrefix.get())));
                }

                return m;
            }
        });
    }
}
",{}
Change YAML property,"Change a YAML property. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.yaml.tree.Yaml;

import java.util.Iterator;
import java.util.Objects;
import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePropertyValue extends Recipe {
    @Option(displayName = ""Property key"",
            description = ""The key to look for. Supports glob patterns."",
            example = ""management.metrics.binders.*.enabled"")
    String propertyKey;

    @Option(example = ""newValue"", displayName = ""New value"",
            description = ""The new value to be used for key specified by `propertyKey`."")
    String newValue;

    @Option(example = ""oldValue"", displayName = ""Old value"",
            required = false,
            description = ""Only change the property value if it matches the configured `oldValue`."")
    @Nullable
    String oldValue;

    @Option(displayName = ""Regex"",
            description = ""Default `false`. If enabled, `oldValue` will be interpreted as a Regular Expression, "" +
                          ""to replace only all parts that match the regex. Capturing group can be used in `newValue`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                          ""rules. Default is `true`. Set to `false`  to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;


    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Change YAML property"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", propertyKey, newValue);
    }

    @Override
    public String getDescription() {
        return ""Change a YAML property. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(
                Validated.test(""oldValue"", ""is required if `regex` is enabled"", oldValue,
                        value -> !(Boolean.TRUE.equals(regex) && StringUtils.isNullOrEmpty(value))));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles(filePattern), new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);
                String prop = getProperty(getCursor());
                if (matchesPropertyKey(prop) && matchesOldValue(e.getValue())) {
                    Yaml.Block updatedValue = updateValue(e.getValue());
                    if (updatedValue != null) {
                        e = e.withValue(updatedValue);
                    }
                }
                return e;
            }
        });
    }

    // returns null if value should not change
    private Yaml.@Nullable Block updateValue(Yaml.Block value) {
        if (value instanceof Yaml.Scalar) {
            Yaml.Scalar scalar = (Yaml.Scalar) value;
            Yaml.Scalar newScalar = scalar.withValue(Boolean.TRUE.equals(regex) ?
                    scalar.getValue().replaceAll(Objects.requireNonNull(oldValue), newValue) :
                    newValue);
            return scalar.getValue().equals(newScalar.getValue()) ? null : newScalar;
        }
        if (value instanceof Yaml.Sequence) {
            Yaml.Sequence sequence = (Yaml.Sequence) value;
            return sequence.withEntries(ListUtils.map(sequence.getEntries(), entry -> {
                if (matchesOldValue(entry.getBlock())) {
                    Yaml.Block updatedValue = updateValue(entry.getBlock());
                    if (updatedValue != null) {
                        return entry.withBlock(updatedValue);
                    }
                }
                return entry;
            }));
        }
        return null;
    }

    private boolean matchesPropertyKey(String prop) {
        return !Boolean.FALSE.equals(relaxedBinding) ?
                NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey) :
                StringUtils.matchesGlob(prop, propertyKey);
    }

    private boolean matchesOldValue(Yaml.Block value) {
        if (value instanceof Yaml.Scalar) {
            Yaml.Scalar scalar = (Yaml.Scalar) value;
            return StringUtils.isNullOrEmpty(oldValue) ||
                   (Boolean.TRUE.equals(regex) ?
                           Pattern.compile(oldValue).matcher(scalar.getValue()).find() :
                           scalar.getValue().equals(oldValue));
        } else if (value instanceof Yaml.Sequence) {
            for (Yaml.Sequence.Entry entry : ((Yaml.Sequence) value).getEntries()) {
                if (matchesOldValue(entry.getBlock())) {
                    return true;
                }
            }
        }
        return false;
    }

    private static String getProperty(Cursor cursor) {
        StringBuilder asProperty = new StringBuilder();
        Iterator<Object> path = cursor.getPath();
        int i = 0;
        while (path.hasNext()) {
            Object next = path.next();
            if (next instanceof Yaml.Mapping.Entry) {
                Yaml.Mapping.Entry entry = (Yaml.Mapping.Entry) next;
                if (i++ > 0) {
                    asProperty.insert(0, '.');
                }
                asProperty.insert(0, entry.getKey().getValue());
            }
        }
        return asProperty.toString();
    }
}
","{
  ""propertyKey"": ""String field"",
  ""newValue"": ""String field""
}"
Delete property,"Delete a YAML property. Nested YAML mappings are interpreted as dot separated property names, i.e. ",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.marker.Marker;
import org.openrewrite.yaml.tree.Yaml;

import java.util.*;

import static java.util.Spliterators.spliteratorUnknownSize;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toCollection;
import static java.util.stream.StreamSupport.stream;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteProperty extends Recipe {
    @Option(displayName = ""Property key"",
            description = ""The key to be deleted."",
            example = ""management.metrics.binders.files.enabled"")
    String propertyKey;

    @Deprecated
    @Option(displayName = ""Coalesce"",
            description = ""(Deprecated: in a future version, this recipe will always use the `false` behavior)"" +
                    "" Simplify nested map hierarchies into their simplest dot separated property form."",
            required = false)
    @Nullable
    Boolean coalesce;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Defaults to `true`. If you want to use exact matching in your search, set this to `false`."",
            required = false)
    @Nullable
    Boolean relaxedBinding;


    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Delete property"";
    }

    @Override
    public String getDescription() {
        return ""Delete a YAML property. Nested YAML mappings are interpreted as dot separated property names, i.e. "" +
                ""as Spring Boot interprets application.yml files like `a.b.c.d` or `a.b.c:d`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles(filePattern), new YamlIsoVisitor<ExecutionContext>() {

            @Override
            public Yaml.Documents visitDocuments(Yaml.Documents documents, ExecutionContext ctx) {
                // TODO: Update DeleteProperty to support documents having Anchor / Alias Pairs
                if (documents != new ReplaceAliasWithAnchorValueVisitor<ExecutionContext>().visit(documents, ctx)) {
                    return documents;
                }
                return super.visitDocuments(documents, ctx);
            }

            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);

                Deque<Yaml.Mapping.Entry> propertyEntries = getCursor().getPathAsStream()
                        .filter(Yaml.Mapping.Entry.class::isInstance)
                        .map(Yaml.Mapping.Entry.class::cast)
                        .collect(toCollection(ArrayDeque::new));

                String prop = stream(spliteratorUnknownSize(propertyEntries.descendingIterator(), 0), false)
                        .map(e2 -> e2.getKey().getValue())
                        .collect(joining("".""));

                if (!Boolean.FALSE.equals(relaxedBinding) ? NameCaseConvention.equalsRelaxedBinding(prop, propertyKey) : prop.equals(propertyKey)) {
                    doAfterVisit(new DeletePropertyVisitor<>(entry));
                    if (Boolean.TRUE.equals(coalesce)) {
                        maybeCoalesceProperties();
                    }
                }

                return e;
            }
        });
    }

    private static class DeletePropertyVisitor<P> extends YamlVisitor<P> {
        private final Yaml.Mapping.Entry scope;

        private DeletePropertyVisitor(Yaml.Mapping.Entry scope) {
            this.scope = scope;
        }

        @Override
        public Yaml visitSequence(Yaml.Sequence sequence, P p) {
            sequence = (Yaml.Sequence) super.visitSequence(sequence, p);
            List<Yaml.Sequence.Entry> entries = sequence.getEntries();
            if (entries.isEmpty()) {
                return sequence;
            }

            entries = ListUtils.map(entries, entry -> ToBeRemoved.hasMarker(entry) ? null : entry);
            return entries.isEmpty() ? ToBeRemoved.withMarker(sequence) : sequence.withEntries(entries);
        }

        @Override
        public Yaml visitSequenceEntry(Yaml.Sequence.Entry entry, P p) {
            entry = (Yaml.Sequence.Entry) super.visitSequenceEntry(entry, p);
            if (entry.getBlock() instanceof Yaml.Mapping) {
                Yaml.Mapping m = (Yaml.Mapping) entry.getBlock();
                if (ToBeRemoved.hasMarker(m)) {
                    return ToBeRemoved.withMarker(entry);
                }
            }
            return entry;
        }

        @Override
        public Yaml visitMapping(Yaml.Mapping mapping, P p) {
            Yaml.Mapping m = (Yaml.Mapping) super.visitMapping(mapping, p);

            boolean changed = false;
            List<Yaml.Mapping.Entry> entries = new ArrayList<>();
            String deletedPrefix = null;
            int count = 0;
            for (Yaml.Mapping.Entry entry : m.getEntries()) {
                if (ToBeRemoved.hasMarker(entry.getValue())) {
                    changed = true;
                    continue;
                }

                if (entry == scope || (entry.getValue() instanceof Yaml.Mapping && ((Yaml.Mapping) entry.getValue()).getEntries().isEmpty())) {
                    deletedPrefix = entry.getPrefix();
                    changed = true;
                } else {
                    if (deletedPrefix != null) {
                        if (count == 0 && containsOnlyWhitespace(entry.getPrefix())) {
                            // do this only if the entry will be the first element
                            entry = entry.withPrefix(deletedPrefix);
                        }
                        deletedPrefix = null;
                    }
                    entries.add(entry);
                    count++;
                }
            }

            if (changed) {
                m = m.withEntries(entries);
                if (entries.isEmpty()) {
                    m = ToBeRemoved.withMarker(m);
                }

                if (getCursor().getParentOrThrow().getValue() instanceof Yaml.Document) {
                    Yaml.Document document = getCursor().getParentOrThrow().getValue();
                    if (!document.isExplicit()) {
                        m = m.withEntries(m.getEntries());
                    }
                }
            }
            return m;
        }
    }

    private static boolean containsOnlyWhitespace(@Nullable String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }

        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (!Character.isWhitespace(c)) {
                return false;
            }
        }

        return true;
    }

    @Value
    @With
    private static class ToBeRemoved implements Marker {
        UUID id;
        static <Y2 extends Yaml> Y2 withMarker(Y2 y) {
            return y.withMarkers(y.getMarkers().addIfAbsent(new ToBeRemoved(randomId())));
        }
        static boolean hasMarker(Yaml y) {
            return y.getMarkers().findFirst(ToBeRemoved.class).isPresent();
        }
    }
}
","{
  ""propertyKey"": ""String field""
}"
Merge YAML snippet,Merge a YAML snippet with an existing YAML document.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.Value;
import lombok.experimental.NonFinal;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.yaml.tree.Yaml;

import java.util.Optional;

import static org.openrewrite.internal.StringUtils.isBlank;
import static org.openrewrite.yaml.MergeYaml.InsertMode.*;

@Value
@EqualsAndHashCode(callSuper = false)
@NoArgsConstructor(force = true) // TODO: remove with @deprecated constructor
public class MergeYaml extends Recipe {
    @Option(displayName = ""Key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression used to find matching keys."",
            example = ""$.metadata"")
    String key;

    @Option(displayName = ""YAML snippet"",
            description = ""The YAML snippet to insert. The snippet will be indented to match the style of its surroundings."",
            example = ""labels:\n  label-one: \""value-one\"""")
    @Language(""yml"")
    String yaml;

    @Option(displayName = ""Accept theirs"",
            description = ""When the YAML snippet to insert conflicts with an existing key value pair and an existing key has a different value, prefer the original value."",
            required = false)
    @Nullable
    Boolean acceptTheirs;

    @Incubating(since = ""7.30.0"")
    @Option(displayName = ""Object identifying property"",
            description = ""Name of a property which will be used to identify objects (mapping). This serves as the key to match on when merging entries of a sequence."",
            required = false,
            example = ""name"")
    @Nullable
    String objectIdentifyingProperty;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Option(displayName = ""Insert mode"",
            description = ""Choose an insertion point when multiple mappings exist. Default is `Last`."",
            valid = {""Before"", ""After"", ""Last""},
            required = false)
    @Nullable
    InsertMode insertMode;

    @Option(displayName = ""Insert property"",
            description = ""Define the key for the insertion mode. Takes the `key` JsonPath into account. Only useful when `insert mode` is either `Before` or `After`."",
            required = false,
            example = ""some-key"")
    @Nullable
    String insertProperty;

    @Option(displayName = ""Create new keys"",
            description = ""When the key path does _not_ match any keys, create new keys on the spot. Default is `true`."",
            required = false)
    @Nullable
    Boolean createNewKeys;

    public MergeYaml(String key, @Language(""yml"") String yaml, @Nullable Boolean acceptTheirs, @Nullable String objectIdentifyingProperty, @Nullable String filePattern, @Nullable InsertMode insertMode, @Nullable String insertProperty, @Nullable Boolean createNewKeys) {
        this.key = key;
        this.yaml = yaml;
        this.acceptTheirs = acceptTheirs;
        this.objectIdentifyingProperty = objectIdentifyingProperty;
        this.filePattern = filePattern;
        this.insertMode = insertMode;
        this.insertProperty = insertProperty;
        this.createNewKeys = createNewKeys;
    }

    public enum InsertMode { Before, After, Last }

    @Nullable
    @NonFinal
    transient Yaml incoming = null;

    @Override
    public Validated<Object> validate() {
        return super.validate()
                .and(Validated.test(""yaml"", ""Must be valid YAML"",
                        yaml, y -> {
                            if (yaml == null) {
                                return false;
                            }
                            MergeYaml.maybeParse(yaml).ifPresent(it -> incoming = it);
                            return incoming != null;
                        }))
                .and(Validated.required(""key"", key))
                .and(Validated.test(""insertProperty"", ""Insert property must be filed when `insert mode` is either `BeforeProperty` or `AfterProperty`."", insertProperty,
                        s -> insertMode == null || insertMode == Last || !isBlank(s)));
    }
    @Override
    public String getDisplayName() {
        return ""Merge YAML snippet"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""at `%s`"", key);
    }

    @Override
    public String getDescription() {
        return ""Merge a YAML snippet with an existing YAML document."";
    }

    final static String FOUND_MATCHING_ELEMENT = ""FOUND_MATCHING_ELEMENT"";
    final static String REMOVE_PREFIX = ""REMOVE_PREFIX"";

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        // When `new MergeYaml(..).getVisitor() is used directly in another recipe, the `validate` function will not be called, thus `incoming` is null
        if (incoming == null) {
            incoming = MergeYaml.parse(yaml);
        }
        return Preconditions.check(new FindSourceFiles(filePattern), new YamlIsoVisitor<ExecutionContext>() {
            private final boolean accptTheirs = Boolean.TRUE.equals(acceptTheirs);
            private final JsonPathMatcher matcher = new JsonPathMatcher(key);

            @Override
            public Yaml.Document visitDocument(Yaml.Document document, ExecutionContext ctx) {
                if (""$"".equals(key)) {
                    Yaml.Document d = document.withBlock((Yaml.Block)
                            new MergeYamlVisitor<>(document.getBlock(), incoming, accptTheirs, objectIdentifyingProperty, insertMode, insertProperty)
                                    .visitNonNull(document.getBlock(), ctx, getCursor())
                    );
                    if (getCursor().getMessage(REMOVE_PREFIX, false)) {
                        d = insertMode == Before ? d.withPrefix("""") : d.withEnd(d.getEnd().withPrefix(""""));
                    }
                    return d;
                }
                Yaml.Document d = super.visitDocument(document, ctx);
                if ((createNewKeys == null || Boolean.TRUE.equals(createNewKeys)) && d == document && !getCursor().getMessage(FOUND_MATCHING_ELEMENT, false)) {
                    // No matching element found, but check if the key maybe exists in the json path.
                    String valueKey = maybeKeyFromJsonPath(key);
                    if (valueKey == null) {
                        return d;
                    }
                    // No matching element already exists, so it must be constructed.
                    @Language(""yml"") String snippet;
                    if (incoming instanceof Yaml.Mapping) {
                        // Use two spaces as indent, the `MergeYamlVisitor` recipe will take care for proper indenting by calling `autoformat`,
                        snippet = valueKey + "":\n  "" + yaml.replaceAll(""\n"", ""\n  "");
                    } else {
                        // If there is no space between the colon and the value it will not be interpreted as a mapping
                        snippet = valueKey + "":"" + (yaml.startsWith("" "") ? yaml : "" "" + yaml);
                    }
                    return d.withBlock((Yaml.Block)
                            new MergeYamlVisitor<>(d.getBlock(), MergeYaml.parse(snippet), accptTheirs, objectIdentifyingProperty, insertMode, insertProperty)
                                    .visitNonNull(d.getBlock(), ctx, getCursor()));
                }
                if (getCursor().getMessage(REMOVE_PREFIX, false)) {
                    d = d.withEnd(d.getEnd().withPrefix(""""));
                }
                return d;
            }

            private @Nullable String maybeKeyFromJsonPath(String jsonPath) {
                if (!jsonPath.startsWith(""$."")) {
                    return null;
                }
                // if the key contains a jsonpath filter we cannot infer a valid key
                if (jsonPath.matches("".*\\[\\s?\\?\\s?\\(\\s?@\\..*\\)\\s?].*"")) {
                    return null;
                }
                // remove keys that contain wildcard or deep search
                if (jsonPath.matches("".*\\*.*"") || jsonPath.matches("".*\\.\\..*"")) {
                    return null;
                }
                return jsonPath.substring(2);
            }

            @Override
            public Yaml.Mapping visitMapping(Yaml.Mapping mapping, ExecutionContext ctx) {
                Yaml.Mapping m = super.visitMapping(mapping, ctx);
                if (matcher.matches(getCursor())) {
                    getCursor().putMessageOnFirstEnclosing(Yaml.Document.class, FOUND_MATCHING_ELEMENT, true);
                    m = (Yaml.Mapping) new MergeYamlVisitor<>(mapping, incoming, accptTheirs,
                            objectIdentifyingProperty, insertMode, insertProperty).visitNonNull(mapping, ctx, getCursor().getParentOrThrow());
                }
                return m;
            }

            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                if (matcher.matches(getCursor())) {
                    getCursor().putMessageOnFirstEnclosing(Yaml.Document.class, FOUND_MATCHING_ELEMENT, true);
                    Yaml.Block value = (Yaml.Block) new MergeYamlVisitor<>(entry.getValue(), incoming,
                            accptTheirs, objectIdentifyingProperty, insertMode, insertProperty).visitNonNull(entry.getValue(),
                            ctx, getCursor());
                    if (value instanceof Yaml.Scalar && value.getPrefix().isEmpty()) {
                        value = value.withPrefix("" "");
                    }
                    return entry.withValue(value);
                }
                return super.visitMappingEntry(entry, ctx);
            }

            @Override
            public Yaml.Sequence visitSequence(Yaml.Sequence sequence, ExecutionContext ctx) {
                if (matcher.matches(getCursor().getParentOrThrow())) {
                    getCursor().putMessageOnFirstEnclosing(Yaml.Document.class, FOUND_MATCHING_ELEMENT, true);
                    return sequence.withEntries(ListUtils.map(sequence.getEntries(),
                            entry -> entry.withBlock((Yaml.Block) new MergeYamlVisitor<>(entry.getBlock(), incoming,
                                    accptTheirs, objectIdentifyingProperty, insertMode, insertProperty)
                                    .visitNonNull(entry.getBlock(), ctx, new Cursor(getCursor(), entry)))));
                }
                return super.visitSequence(sequence, ctx);
            }
        });
    }

    private static Optional<Yaml.Block> maybeParse(@Language(""yml"") String yaml) {
        return new YamlParser().parse(yaml)
                .findFirst()
                .filter(Yaml.Documents.class::isInstance)
                .map(Yaml.Documents.class::cast)
                .map(docs -> {
                    // Any comments will have been put on the parent Document node, preserve by copying to the mapping
                    Yaml.Document doc = docs.getDocuments().get(0);
                    if (doc.getBlock() instanceof Yaml.Mapping) {
                        Yaml.Mapping m = (Yaml.Mapping) doc.getBlock();
                        return m.withEntries(ListUtils.mapFirst(m.getEntries(), entry -> entry.withPrefix(doc.getPrefix())));
                    } else if (doc.getBlock() instanceof Yaml.Sequence) {
                        Yaml.Sequence s = (Yaml.Sequence) doc.getBlock();
                        return s.withEntries(ListUtils.mapFirst(s.getEntries(), entry -> entry.withPrefix(doc.getPrefix())));
                    }
                    return doc.getBlock().withPrefix(doc.getPrefix());
                });
    }

    static Yaml parse(@Language(""yml"") String yaml) {
        return maybeParse(yaml)
                .orElseThrow(() -> new IllegalArgumentException(""Could not parse as YAML""));
    }
}
",{}
Change value,Change a YAML mapping entry value while leaving the key intact.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.yaml.tree.Yaml;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeValue extends Recipe {
    @Option(displayName = ""Key path"",
            description = ""A [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression to locate a YAML entry."",
            example = ""$.subjects.kind"")
    String keyPath;

    @Option(displayName = ""New value"",
            description = ""The new value to set for the key identified by the `oldKeyPath`."",
            example = ""Deployment"")
    String value;


    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Change value"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", keyPath, value);
    }

    @Override
    public String getDescription() {
        return ""Change a YAML mapping entry value while leaving the key intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(keyPath);
        return Preconditions.check(new FindSourceFiles(filePattern), new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);
                if (matcher.matches(getCursor()) && (!(e.getValue() instanceof Yaml.Scalar) || !((Yaml.Scalar) e.getValue()).getValue().equals(value))) {
                    Yaml.Anchor anchor = (e.getValue() instanceof Yaml.Scalar) ? ((Yaml.Scalar) e.getValue()).getAnchor() : null;
                    Yaml.Tag tag = (e.getValue() instanceof Yaml.Scalar) ? ((Yaml.Scalar) e.getValue()).getTag() : null;
                    String prefix = e.getValue() instanceof Yaml.Sequence ? ((Yaml.Sequence) e.getValue()).getOpeningBracketPrefix() : e.getValue().getPrefix();
                    e = e.withValue(
                            new Yaml.Scalar(randomId(), prefix, Markers.EMPTY,
                                    Yaml.Scalar.Style.PLAIN, anchor, tag, value)
                    );
                }
                return e;
            }

            @Override
            public Yaml.Scalar visitScalar(Yaml.Scalar scalar, ExecutionContext ctx) {
                Yaml.Scalar s = super.visitScalar(scalar, ctx);
                if (matcher.matches(getCursor())) {
                    s = s.withValue(value);
                }
                return s;
            }
        });
    }


}
","{
  ""value"": ""String field""
}"
Find YAML entries,Find YAML entries that match the specified [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.yaml.JsonPathMatcher;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.tree.Yaml;

import java.util.HashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindKey extends Recipe {
    @Option(displayName = ""Path"",
            description = ""A JsonPath expression used to find matching keys."",
            example = ""$.subjects.kind"")
    String key;

    @Override
    public String getDisplayName() {
        return ""Find YAML entries"";
    }

    @Override
    public String getDescription() {
        return ""Find YAML entries that match the specified [JsonPath](https://docs.openrewrite.org/reference/jsonpath-and-jsonpathmatcher-reference) expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher matcher = new JsonPathMatcher(key);
        return new YamlVisitor<ExecutionContext>() {
            @Override
            public Yaml visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = (Yaml.Mapping.Entry) super.visitMappingEntry(entry, ctx);
                if (matcher.matches(getCursor())) {
                    e = SearchResult.found(e);
                }
                return e;
            }

            @Override
            public Yaml visitMapping(Yaml.Mapping mapping, ExecutionContext ctx) {
                Yaml.Mapping m = (Yaml.Mapping) super.visitMapping(mapping, ctx);
                if (matcher.matches(getCursor())) {
                    m = SearchResult.found(m);
                }
                return m;
            }
        };
    }

    public static Set<Yaml> find(Yaml y, String jsonPath) {
        JsonPathMatcher matcher = new JsonPathMatcher(jsonPath);
        YamlVisitor<Set<Yaml>> findVisitor = new YamlVisitor<Set<Yaml>>() {
            @Override
            public Yaml visitMappingEntry(Yaml.Mapping.Entry entry, Set<Yaml> es) {
                Yaml.Mapping.Entry e = (Yaml.Mapping.Entry) super.visitMappingEntry(entry, es);
                if (matcher.matches(getCursor())) {
                    es.add(e);
                }
                return e;
            }

            @Override
            public Yaml visitMapping(Yaml.Mapping mapping, Set<Yaml> es) {
                Yaml.Mapping m = (Yaml.Mapping) super.visitMapping(mapping, es);
                if (matcher.matches(getCursor())) {
                    es.add(m);
                }
                return m;
            }
        };

        Set<Yaml> es = new HashSet<>();
        findVisitor.visit(y, es);
        return es;
    }
}
","{
  ""key"": ""String field""
}"
Find YAML properties,"Find YAML properties that match the specified `propertyKey`. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.YamlVisitor;
import org.openrewrite.yaml.tree.Yaml;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindProperty extends Recipe {

    @Option(displayName = ""Property key"",
            description = ""The key to look for. Glob is supported."",
            example = ""management.metrics.binders.*.enabled"")
    String propertyKey;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Defaults to `true`. If you want to use exact matching in your search, set this to `false`."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Option(displayName = ""Property value"",
            example = ""false"",
            description = ""If provided, only properties specified in propertyKey having this value will be found. Works only for scalar values"",
            required = false)
    @Nullable
    String propertyValue;

    @Override
    public String getDisplayName() {
        return ""Find YAML properties"";
    }

    @Override
    public String getDescription() {
        return ""Find YAML properties that match the specified `propertyKey`. Expects dot notation for nested YAML mappings, similar to how Spring Boot interprets `application.yml` files."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new YamlIsoVisitor<ExecutionContext>() {
            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, ExecutionContext ctx) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, ctx);
                String prop = getProperty(getCursor());
                if (!Boolean.FALSE.equals(relaxedBinding) ?
                        NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey) :
                        StringUtils.matchesGlob(prop, propertyKey)) {
                    if (!Objects.isNull(propertyValue)) {
                        if (entry.getValue() instanceof Yaml.Scalar) {
                            Yaml.Scalar scalar = (Yaml.Scalar) entry.getValue();
                            if (scalar.getValue().equals(propertyValue)) {
                                e = e.withValue(SearchResult.found(e.getValue()));
                            }
                        }
                    } else {
                        e = e.withValue(SearchResult.found(e.getValue()));
                    }
                }
                return e;
            }
        };
    }

    public static Set<Yaml.Block> find(Yaml y, String propertyKey, @Nullable Boolean relaxedBinding) {
        YamlVisitor<Set<Yaml.Block>> findVisitor = new YamlIsoVisitor<Set<Yaml.Block>>() {
            @Override
            public Yaml.Mapping.Entry visitMappingEntry(Yaml.Mapping.Entry entry, Set<Yaml.Block> values) {
                Yaml.Mapping.Entry e = super.visitMappingEntry(entry, values);
                String prop = getProperty(getCursor());
                if (!Boolean.FALSE.equals(relaxedBinding) ?
                        NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey) :
                        StringUtils.matchesGlob(prop, propertyKey)) {
                    values.add(entry.getValue());
                }
                return e;
            }
        };

        Set<Yaml.Block> values = new HashSet<>();
        findVisitor.visit(y, values);
        return values;
    }

    public static boolean matches(Cursor cursor, String propertyKey, @Nullable Boolean relaxedBinding) {
        String prop = getProperty(cursor);
        return !Boolean.FALSE.equals(relaxedBinding) ?
                NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey) :
                StringUtils.matchesGlob(prop, propertyKey);
    }

    private static String getProperty(Cursor cursor) {
        StringBuilder asProperty = new StringBuilder();
        Iterator<Object> path = cursor.getPath();
        int i = 0;
        while (path.hasNext()) {
            Object next = path.next();
            if (next instanceof Yaml.Mapping.Entry) {
                Yaml.Mapping.Entry entry = (Yaml.Mapping.Entry) next;
                if (i++ > 0) {
                    asProperty.insert(0, '.');
                }
                asProperty.insert(0, entry.getKey().getValue());
            }
        }
        return asProperty.toString();
    }
}
","{
  ""propertyKey"": ""String field""
}"
Remove unused YAML,Remove YAML mappings and sequence keys that have no value.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class RemoveUnused extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove unused YAML"";
    }

    @Override
    public String getDescription() {
        return ""Remove YAML mappings and sequence keys that have no value."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveUnusedVisitor<>(null);
    }
}
",{}
YAML indent,Format tabs and indents in YAML.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.yaml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.style.Style;
import org.openrewrite.yaml.YamlIsoVisitor;
import org.openrewrite.yaml.style.Autodetect;
import org.openrewrite.yaml.style.IndentsStyle;
import org.openrewrite.yaml.style.YamlDefaultStyles;
import org.openrewrite.yaml.tree.Yaml;

public class Indents extends Recipe {
    @Override
    public String getDisplayName() {
        return ""YAML indent"";
    }

    @Override
    public String getDescription() {
        return ""Format tabs and indents in YAML."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends YamlIsoVisitor<ExecutionContext> {
        @Override
        public Yaml.Documents visitDocuments(Yaml.Documents docs, ExecutionContext ctx) {
            IndentsStyle style = Style.from(IndentsStyle.class, docs, () -> Autodetect.tabsAndIndents(docs, YamlDefaultStyles.indents()));
            doAfterVisit(new IndentsVisitor<>(style, null));
            return docs;
        }
    }
}
",{}
Groovy GString curly braces,"In Groovy [GStrings](https://docs.groovy-lang.org/latest/html/api/groovy/lang/GString.html), curly braces are optional for single variable expressions. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.groovy.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.groovy.GroovyVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.tree.J;

public class GStringCurlyBraces extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Groovy GString curly braces"";
    }

    @Override
    public String getDescription() {
        return ""In Groovy [GStrings](https://docs.groovy-lang.org/latest/html/api/groovy/lang/GString.html), curly braces are optional for single variable expressions. "" +
               ""This recipe adds them, so that the expression is always surrounded by curly braces."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new GroovyVisitor<ExecutionContext>() {
            @Override
            public J visitGStringValue(G.GString.Value value, ExecutionContext ctx) {
                return value.withEnclosedInBraces(true);
            }
        };
    }
}
",{}
Move a closure which is the last argument of a method invocation out of parentheses,Groovy allows a shorthand syntax that allows a closure to be placed outside of parentheses.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.groovy.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class OmitParenthesesForLastArgumentLambda extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Move a closure which is the last argument of a method invocation out of parentheses"";
    }

    @Override
    public String getDescription() {
        return ""Groovy allows a shorthand syntax that allows a closure to be placed outside of parentheses."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new OmitParenthesesForLastArgumentLambdaVisitor<>(null);
    }
}
",{}
Format Groovy code,Format Groovy code using a standard comprehensive set of Groovy formatting recipes.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.groovy.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class AutoFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Format Groovy code"";
    }

    @Override
    public String getDescription() {
        return ""Format Groovy code using a standard comprehensive set of Groovy formatting recipes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>(null);
    }
}
",{}
Stylize Groovy code to omit parentheses,Omit parentheses for last argument lambdas in Groovy code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.groovy.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.groovy.style.OmitParenthesesStyle;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import java.util.Optional;

import static java.util.Objects.requireNonNull;

public class OmitParenthesesFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Stylize Groovy code to omit parentheses"";
    }

    @Override
    public String getDescription() {
        return ""Omit parentheses for last argument lambdas in Groovy code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new OmitParenthesesFromCompilationUnitStyle();
    }

    private static class OmitParenthesesFromCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                SourceFile cu = (SourceFile) requireNonNull(tree);
                OmitParenthesesStyle style = Optional.ofNullable(cu.getStyle(OmitParenthesesStyle.class)).orElse(OmitParenthesesStyle.DEFAULT);
                if (style.getLastArgumentLambda()) {
                    doAfterVisit(new OmitParenthesesForLastArgumentLambda().getVisitor());
                }
            }
            return super.visit(tree, ctx);
        }
    }
}
",{}
Replace legacy attribute index syntax,Replace legacy attribute index syntax (`.0`) with the new syntax (`[0]`).,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.hcl.tree.Hcl;
import org.openrewrite.hcl.tree.HclRightPadded;
import org.openrewrite.hcl.tree.Space;
import org.openrewrite.marker.Markers;

public class ReplaceLegacyAttributeIndexSyntax extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Replace legacy attribute index syntax"";
    }

    @Override
    public String getDescription() {
        return ""Replace legacy attribute index syntax (`.0`) with the new syntax (`[0]`)."";
    }

    @Override
    public HclVisitor<ExecutionContext> getVisitor() {
        return new HclVisitor<ExecutionContext>() {
            @Override
            public Hcl.Index visitLegacyIndexAttribute(Hcl.LegacyIndexAttributeAccess legacy, ExecutionContext ctx) {
                Hcl.LegacyIndexAttributeAccess ret = (Hcl.LegacyIndexAttributeAccess) super.visitLegacyIndexAttribute(legacy, ctx);
                Hcl.Index.Position position = new Hcl.Index.Position(Tree.randomId(), Space.EMPTY, ret.getIndex().getMarkers(), new HclRightPadded<>(ret.getIndex(), Space.EMPTY, Markers.EMPTY));
                return new Hcl.Index(Tree.randomId(), ret.getPrefix(), ret.getMarkers(), ret.getBase().getElement(), position);
            }
        };
    }
}
",{}
Move content to another file,"Move content to another HCL file, deleting it in the original file.",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.hcl.tree.BodyContent;
import org.openrewrite.hcl.tree.Hcl;
import org.openrewrite.hcl.tree.Space;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class MoveContentToFile extends ScanningRecipe<MoveContentToFile.Scanned> {
    @Option(displayName = ""Content path"",
            description = ""A JSONPath expression specifying the block to move."",
            example = ""$.provider"")
    String contentPath;

    @Option(displayName = ""From path"",
            description = ""The source path of the file from which content is being moved."",
            example = ""from.tf"")
    String fromPath;

    @Option(displayName = ""To path"",
            description = ""The source path of the file to move the content to."",
            example = ""to.tf"")
    String destinationPath;

    @Override
    public String getDisplayName() {
        return ""Move content to another file"";
    }

    @Override
    public String getDescription() {
        return ""Move content to another HCL file, deleting it in the original file."";
    }

    static class Scanned {
        @Nullable
        BodyContent toMove;

        boolean destinationExists;
    }

    @Override
    public Scanned getInitialValue(ExecutionContext ctx) {
        return new Scanned();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {
        JsonPathMatcher pathMatcher = new JsonPathMatcher(contentPath);
        Path from = Paths.get(fromPath);
        Path dest = Paths.get(destinationPath);

        return new HclIsoVisitor<ExecutionContext>() {
            @Override
            public Hcl.ConfigFile visitConfigFile(Hcl.ConfigFile configFile, ExecutionContext ctx) {
                if (configFile.getSourcePath().equals(from)) {
                    return super.visitConfigFile(configFile, ctx);
                } else if (configFile.getSourcePath().equals(dest)) {
                    acc.destinationExists = true;
                }
                return configFile;
            }

            @Override
            public BodyContent visitBodyContent(BodyContent bodyContent, ExecutionContext ctx) {
                BodyContent b = super.visitBodyContent(bodyContent, ctx);
                if (pathMatcher.matches(getCursor())) {
                    acc.toMove = bodyContent;
                    //noinspection ConstantConditions
                }
                return b;
            }
        };
    }

    @Override
    public Collection<Hcl.ConfigFile> generate(Scanned acc, ExecutionContext ctx) {
        if (acc.destinationExists || acc.toMove == null) {
            return emptyList();
        }
        Hcl.ConfigFile configFile = HclParser.builder().build().parse("""")
                .findFirst()
                .map(Hcl.ConfigFile.class::cast)
                .orElseThrow(() -> new IllegalArgumentException(""Could not parse as HCL""));
        configFile = configFile.withBody(singletonList(acc.toMove.withPrefix(Space.EMPTY)))
                .withSourcePath(Paths.get(destinationPath));
        return singletonList(configFile);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {
        JsonPathMatcher pathMatcher = new JsonPathMatcher(contentPath);
        Path from = Paths.get(fromPath);
        Path dest = Paths.get(destinationPath);

        return Preconditions.check(acc.toMove != null, new HclIsoVisitor<ExecutionContext>() {

            @Override
            public @Nullable BodyContent visitBodyContent(BodyContent bodyContent, ExecutionContext ctx) {
                BodyContent b = super.visitBodyContent(bodyContent, ctx);
                Path sourcePath = getCursor().firstEnclosingOrThrow(Hcl.ConfigFile.class).getSourcePath();
                if (sourcePath.equals(from) && pathMatcher.matches(getCursor())) {
                    // delete the block from the original file
                    //noinspection ConstantConditions
                    return null;
                } else if (sourcePath.equals(dest) && pathMatcher.matches(getCursor())) {
                    return acc.toMove;
                }
                return b;
            }
        });
    }
}
","{
  ""contentPath"": ""String field"",
  ""fromPath"": ""String field"",
  ""destinationPath"": ""String field""
}"
Delete content,Delete HCL content by path.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.hcl.tree.BodyContent;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteContent extends Recipe {
    @Option(
            displayName = ""Content path"",
            description = ""A JSONPath expression specifying the block to delete."",
            example = ""$.provider""
    )
    String contentPath;

    @Override
    public String getDisplayName() {
        return ""Delete content"";
    }

    @Override
    public String getDescription() {
        return ""Delete HCL content by path."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher pathMatcher = new JsonPathMatcher(contentPath);
        return new HclIsoVisitor<ExecutionContext>() {

            @Override
            public @Nullable BodyContent visitBodyContent(BodyContent bodyContent, ExecutionContext ctx) {
                BodyContent b = super.visitBodyContent(bodyContent, ctx);
                if (pathMatcher.matches(getCursor())) {
                    //noinspection ConstantConditions
                    return null;
                }
                return b;
            }
        };
    }
}
","{
  ""contentPath"": ""String field""
}"
Find and replace literals in HCL files,"Find and replace literal values in HCL files. This recipe parses the source files on which it runs as HCL, ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.hcl.HclIsoVisitor;
import org.openrewrite.hcl.tree.Hcl;
import org.openrewrite.marker.AlreadyReplaced;

import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindAndReplaceLiteral extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find and replace literals in HCL files"";
    }

    @Override
    public String getDescription() {
        return ""Find and replace literal values in HCL files. This recipe parses the source files on which it runs as HCL, "" +
               ""meaning you can execute HCL language-specific recipes before and after this recipe in a single recipe run."";
    }

    @Option(displayName = ""Find"", description = ""The literal to find (and replace)"", example = ""blacklist"")
    String find;

    @Option(displayName = ""Replace"",
            description = ""The replacement literal for `find`. This snippet can be multiline."",
            example = ""denylist"",
            required = false)
    @Nullable
    String replace;

    @Option(displayName = ""Regex"",
            description = ""Default false. If true, `find` will be interpreted as a Regular Expression, and capture group contents will be available in `replace`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Case sensitive"",
            description = ""If `true` the search will be sensitive to case. Default `false`."",
            required = false)
    @Nullable
    Boolean caseSensitive;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new HclIsoVisitor<ExecutionContext>() {
            @Override
            public Hcl.Literal visitLiteral(final Hcl.Literal literal, final ExecutionContext ctx) {
                for (AlreadyReplaced alreadyReplaced : literal.getMarkers().findAll(AlreadyReplaced.class)) {
                    if (Objects.equals(find, alreadyReplaced.getFind()) &&
                        Objects.equals(replace, alreadyReplaced.getReplace())) {
                        return literal;
                    }
                }
                String searchStr = find;
                if (!Boolean.TRUE.equals(regex)) {
                    searchStr = Pattern.quote(searchStr);
                }
                int patternOptions = 0;
                if (!Boolean.TRUE.equals(caseSensitive)) {
                    patternOptions |= Pattern.CASE_INSENSITIVE;
                }
                Pattern pattern = Pattern.compile(searchStr, patternOptions);
                if (literal.getValue() == null) {
                    return literal;
                }
                Matcher matcher = pattern.matcher(literal.getValue().toString());
                if (!matcher.find()) {
                    return literal;
                }
                String replacement = replace == null ? """" : replace;
                if (!Boolean.TRUE.equals(regex)) {
                    replacement = replacement.replace(""$"", ""\\$"");
                }
                String newLiteral = matcher.replaceAll(replacement);
                return literal.withValue(newLiteral).withValueSource(newLiteral)
                        .withMarkers(literal.getMarkers().add(new AlreadyReplaced(randomId(), find, replace)));
            }
        };
    }
}
",{}
Find content,Find HCL content by path.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.hcl.HclIsoVisitor;
import org.openrewrite.hcl.JsonPathMatcher;
import org.openrewrite.hcl.tree.BodyContent;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindContent extends Recipe {
    @Option(
            displayName = ""Content path"",
            description = ""A JSONPath expression specifying the block to find."",
            example = ""$.provider""
    )
    String contentPath;

    @Override
    public String getDisplayName() {
        return ""Find content"";
    }

    @Override
    public String getDescription() {
        return ""Find HCL content by path."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JsonPathMatcher pathMatcher = new JsonPathMatcher(contentPath);
        return new HclIsoVisitor<ExecutionContext>() {
            @Override
            public BodyContent visitBodyContent(BodyContent bodyContent, ExecutionContext ctx) {
                BodyContent b = super.visitBodyContent(bodyContent, ctx);
                if (pathMatcher.matches(getCursor())) {
                    return SearchResult.found(b);
                }
                return b;
            }
        };
    }
}
","{
  ""contentPath"": ""String field""
}"
Remove trailing whitespace,Remove any extra trailing whitespace from the end of each line.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class RemoveTrailingWhitespace extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove trailing whitespace"";
    }

    @Override
    public String getDescription() {
        return ""Remove any extra trailing whitespace from the end of each line."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveTrailingWhitespaceVisitor<>();
    }
}
",{}
Normalize format,Move whitespace to the outermost LST element possible.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

/**
 * Ensures that whitespace is on the outermost AST element possible.
 */
public class NormalizeFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Normalize format"";
    }

    @Override
    public String getDescription() {
        return ""Move whitespace to the outermost LST element possible."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new NormalizeFormatVisitor<>();
    }
}
",{}
Tabs and indents,Format tabs and indents in HCL code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.hcl.HclIsoVisitor;
import org.openrewrite.hcl.style.TabsAndIndentsStyle;
import org.openrewrite.hcl.tree.Hcl;

public class TabsAndIndents extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Tabs and indents"";
    }

    @Override
    public String getDescription() {
        return ""Format tabs and indents in HCL code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends HclIsoVisitor<ExecutionContext> {
        @Override
        public Hcl.ConfigFile visitConfigFile(Hcl.ConfigFile cf, ExecutionContext ctx) {
            TabsAndIndentsStyle style = cf.getStyle(TabsAndIndentsStyle.class);
            if (style == null) {
                style = TabsAndIndentsStyle.DEFAULT;
            }
            return (Hcl.ConfigFile) new TabsAndIndentsVisitor<>(style).visitNonNull(cf, ctx);
        }
    }
}
",{}
Blank lines,Add and/or remove blank lines.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.*;
import org.openrewrite.hcl.HclIsoVisitor;
import org.openrewrite.hcl.tree.Hcl;

public class BlankLines extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Blank lines"";
    }

    @Override
    public String getDescription() {
        return ""Add and/or remove blank lines."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new BlankLinesFromCompilationUnitStyle();
    }

    private static class BlankLinesFromCompilationUnitStyle extends HclIsoVisitor<ExecutionContext> {
        @Override
        public Hcl.ConfigFile visitConfigFile(Hcl.ConfigFile configFile, ExecutionContext ctx) {
            BlankLinesStyle style = configFile.getStyle(BlankLinesStyle.class);
            if (style == null) {
                style = BlankLinesStyle.DEFAULT;
            }
            return (Hcl.ConfigFile) new BlankLinesVisitor<>(style).visitNonNull(configFile, ctx);
        }
    }

    public static <H extends Hcl> H formatBlankLines(Hcl j, Cursor cursor) {
        BlankLinesStyle style = cursor.firstEnclosingOrThrow(SourceFile.class)
                .getStyle(BlankLinesStyle.class);
        //noinspection unchecked
        return (H) new BlankLinesVisitor<>(style == null ? BlankLinesStyle.DEFAULT : style)
                .visitNonNull(j, 0, cursor);
    }
}
",{}
Format HCL code,Format HCL code using a standard comprehensive set of HCL formatting recipes.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class AutoFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Format HCL code"";
    }

    @Override
    public String getDescription() {
        return ""Format HCL code using a standard comprehensive set of HCL formatting recipes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>();
    }
}
",{}
Spaces,Format whitespace in HCL code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.hcl.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.hcl.HclIsoVisitor;
import org.openrewrite.hcl.style.SpacesStyle;
import org.openrewrite.hcl.tree.Hcl;

public class Spaces extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Spaces"";
    }

    @Override
    public String getDescription() {
        return ""Format whitespace in HCL code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new SpacesFromCompilationUnitStyle();
    }

    private static class SpacesFromCompilationUnitStyle extends HclIsoVisitor<ExecutionContext> {
        @Override
        public Hcl.ConfigFile visitConfigFile(Hcl.ConfigFile cf, ExecutionContext ctx) {
            SpacesStyle style = cf.getStyle(SpacesStyle.class);
            if (style == null) {
                style = SpacesStyle.DEFAULT;
            }
            return (Hcl.ConfigFile) new SpacesVisitor<>(style).visitNonNull(cf, ctx);
        }
    }
}
",{}
Accumulation-scanned recipe,Some recipes hava loop to determine all updates and add them to the scanner. This cycle/recipe only can update for the provided dependency.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.openrewrite.*;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;

import java.util.List;

import static org.openrewrite.gradle.Assertions.*;
import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;
import static org.openrewrite.properties.Assertions.properties;
import static org.openrewrite.test.RewriteTest.toRecipe;

class UpgradeTransitiveDependencyVersionTest implements RewriteTest {

    @Override
    public void defaults(RecipeSpec spec) {
        spec
          .beforeRecipe(withToolingApi())
          .recipe(new UpgradeTransitiveDependencyVersion(
            ""com.fasterxml*"", ""jackson-core"", ""2.12.5"", null, ""CVE-2024-BAD"", null));
    }

    @DocumentExample
    @Test
    void addConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintForDependenciesDeclaredInMultipleConfigurationsThatExtendFromDifferentResolvableConfigurations() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  compileOnly 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      runtimeOnly('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                      compileOnly('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  compileOnly 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @ParameterizedTest
    @ValueSource(strings = {""compileOnly"", ""implementation"", ""runtimeOnly"", ""testCompileOnly"", ""testImplementation"", ""testRuntimeOnly""})
    void updatesExistingConstraints(String configurationName) {
        rewriteRun(spec ->
            spec.recipe(new UpgradeTransitiveDependencyVersion(
              ""com.thoughtworks.xstream"", ""xstream"", ""1.4.21"", null, null, null)),
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      %1$s 'com.thoughtworks.xstream:xstream:1.4.17'
                  }
              }

              dependencies {
                  %1$s 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:4.2.0'
              }
              """""".formatted(configurationName),
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      %1$s 'com.thoughtworks.xstream:xstream:1.4.21'
                  }
              }

              dependencies {
                  %1$s 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client:4.2.0'
              }
              """""".formatted(configurationName)
          )
        );
    }

    @Test
    void includedDefaultConfigurationsReceiveRuntimeConstraints() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(
              ""org.apache.commons"", ""commons-lang3"", ""3.14.0"", null, null, List.of(""compileOnly"", ""runtimeOnly""))),
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  compileOnly 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """""",
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  constraints {
                      compileOnly('org.apache.commons:commons-lang3:3.14.0')
                  }

                  compileOnly 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """"""
          )
        );
    }

    @Test
    void customConfiguration() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              configurations.create(""foo"")
              repositories { mavenCentral() }

              dependencies {
                  foo 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              configurations.create(""foo"")
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      foo('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  foo 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void customNonTransitiveConfigurationCannotAddConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              configurations {
                  foo {
                      transitive = false
                  }
              }
              repositories { mavenCentral() }

              dependencies {
                  foo 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintAddsSameArtifactsInSameConfigurationAsSingleConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintAddsSameArtifactsInDifferentConfigurationAsSingleConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintAddsUnrelatedConfigurationsForSameArtifact() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
                id 'ear'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
                  earlib 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """""",
            """"""
              plugins {
                id 'java'
                id 'ear'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      earlib('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  runtimeOnly 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
                  earlib 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.8.9'
              }
              """"""
          )
        );
    }

    @Test
    void updateConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.0') {
                          because 'some reason'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Disabled(""String interpolation with inline properties is not yet supported"")
    @Test
    void updateConstraintGStringInterpolation() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              def jacksonVersion = ""2.12.0""

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because 'some reason'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              def jacksonVersion = ""2.12.5""

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void updateConstraintInPropertiesFile() {
        rewriteRun(
          properties(
            """"""
              jacksonVersion=2.12.0
              """""",
            """"""
              jacksonVersion=2.12.5
              """""",
            spec -> spec.path(""gradle.properties"")
          ),
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because 'some reason'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void updateConstraintInPropertiesFileMapNotation() {
        rewriteRun(
          properties(
            """"""
              jacksonVersion=2.12.0
              """""",
            """"""
              jacksonVersion=2.12.5
              """""",
            spec -> spec.path(""gradle.properties"")
          ),
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation group: ""com.fasterxml.jackson.core"", name: ""jackson-core"", version: jacksonVersion, {
                          because 'some reason'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation group: ""com.fasterxml.jackson.core"", name: ""jackson-core"", version: jacksonVersion, {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void kotlinDslUpdateConstraintInPropertiesFile() {
        rewriteRun(
          properties(
            """"""
              jacksonVersion=2.12.0
              """""",
            """"""
              jacksonVersion=2.12.5
              """""",
            spec -> spec.path(""gradle.properties"")
          ),
          buildGradleKts(
            """"""
              plugins {
                `java-library`
              }
              repositories { mavenCentral() }

              val jacksonVersion: String by project
              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because(""some reason"")
                      }
                  }

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """""",
            """"""
              plugins {
                `java-library`
              }
              repositories { mavenCentral() }

              val jacksonVersion: String by project
              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:$jacksonVersion"") {
                          because(""CVE-2024-BAD"")
                      }
                  }

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """"""
          )
        );
    }

    @Test
    void updateConstraintAddingBecause() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""org.openrewrite:rewrite-core:7.0.0"")
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')
                      implementation(""org.openrewrite:rewrite-xml:7.0.0"")
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""org.openrewrite:rewrite-core:7.0.0"")
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                      implementation(""org.openrewrite:rewrite-xml:7.0.0"")
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintToExistingConstraintsBlock() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                  }
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintToConfigurationNotExtendingAnything() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'ear' }
              repositories { mavenCentral() }

              dependencies {
                  earlib 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                  }
              }
              """""",
            """"""
              plugins { id 'ear' }
              repositories { mavenCentral() }

              dependencies {
                  earlib 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      earlib('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }
              }
              """"""
          )
        );
    }

    @Test
    void removeOtherVersionConstraint() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core') {
                          because 'security'
                          version {
                              strictly('2.12.0')
                          }
                      }
                  }
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }
              }
              """"""
          )
        );
    }

    @Test
    void addConstraintToNonTransitiveExtendingTransitiveConfiguration() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'ear' }
              repositories { mavenCentral() }
              configurations.earlib.extendsFrom configurations.deploy
              dependencies {
                  earlib 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                  }
              }
              """""",
            """"""
              plugins { id 'ear' }
              repositories { mavenCentral() }
              configurations.earlib.extendsFrom configurations.deploy
              dependencies {
                  earlib 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      earlib('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }
              }
              """"""
          )
        );
    }

    @Test
    void constraintDoesNotGetAddedToNonTransitiveNonExtendingConfiguration() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'ear' }
              repositories { mavenCentral() }
              dependencies {
                  deploy 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                  }
              }
              """"""
          )
        );
    }

    @Issue(""https://github.com/openrewrite/rewrite/issues/4228"")
    @Test
    void constraintDoesNotGetAddedInsideConstraint() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(""com.fasterxml.jackson.core"", ""jackson-core"", ""2.12.5"", null, ""CVE-2024-BAD"", null)),
          //language=groovy
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      implementation(""org.apache.logging.log4j:log4j-core"") {
                          version {
                              strictly(""2.17.0"")
                          }
                          because 'security'
                      }
                  }
              }
              """""",
            """"""
              plugins {
                  id 'java'
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'

                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                      implementation(""org.apache.logging.log4j:log4j-core"") {
                          version {
                              strictly(""2.17.0"")
                          }
                          because 'security'
                      }
                  }
              }
              """"""
          )
        );
    }

    @Test
    void includedConfigurationsReceiveOnlyConfiguredConstraints() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(
              ""org.apache.commons"", ""commons-lang3"", ""3.14.0"", null, null, List.of(""pitest""))),
          buildGradle(
            """"""
              plugins {
                  id 'info.solidsoft.pitest' version '1.15.0'
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  testImplementation 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """""",
            """"""
              plugins {
                  id 'info.solidsoft.pitest' version '1.15.0'
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  constraints {
                      pitest('org.apache.commons:commons-lang3:3.14.0')
                  }

                  testImplementation 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """"""
          )
        );
    }

    @Test
    void noIncludedConfigurationsReceiveAllConstraints() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(
              ""org.apache.commons"", ""commons-lang3"", ""3.14.0"", null, null, null)),
          buildGradle(
            """"""
              plugins {
                  id 'info.solidsoft.pitest' version '1.15.0'
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  testImplementation 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """""",
            """"""
              plugins {
                  id 'info.solidsoft.pitest' version '1.15.0'
                  id 'java'
              }
              repositories { mavenCentral() }
              dependencies {
                  constraints {
                      pitest('org.apache.commons:commons-lang3:3.14.0')
                      testImplementation('org.apache.commons:commons-lang3:3.14.0')
                  }

                  testImplementation 'org.apache.activemq:artemis-jakarta-server:2.28.0'
              }
              """"""
          )
        );
    }

    @Test
    void useResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                  id 'java'
                  id 'io.spring.dependency-management' version '1.1.5'
              }
              repositories { mavenCentral() }

              dependencies {

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                  id 'java'
                  id 'io.spring.dependency-management' version '1.1.5'
              }
              repositories { mavenCentral() }
              configurations.all {
                  resolutionStrategy.eachDependency { details ->
                      if (details.requested.group == 'com.fasterxml.jackson.core' && details.requested.name == 'jackson-core') {
                          details.useVersion('2.12.5')
                          details.because('CVE-2024-BAD')
                      }
                  }
              }

              dependencies {

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void noChangesIfDependencyIsAlsoPresentOnProject() {
        rewriteRun(
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation('com.fasterxml.jackson.core:jackson-core:2.12.0')
                  implementation('com.fasterxml.jackson.core:jackson-databind:2.12.0')
              }
              """"""
          )
        );
    }

    @Test
    void kotlinDslAddConstraint() {
        rewriteRun(
          buildGradleKts(
            """"""
              plugins {
                `java-library`
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """""",
            """"""
              plugins {
                `java-library`
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:2.12.5"") {
                          because(""CVE-2024-BAD"")
                      }
                  }

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """"""
          )
        );
    }

    @Test
    void kotlinDslUpdateConstraint() {
        rewriteRun(
          buildGradleKts(
            """"""
              plugins { id(""java"") }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:2.12.0"") {
                          because(""some reason"")
                      }
                  }

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """""",
            """"""
              plugins { id(""java"") }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:2.12.5"") {
                          because(""CVE-2024-BAD"")
                      }
                  }

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """"""
          )
        );
    }

    @Test
    void kotlinDslUseResolutionStrategyWhenSpringDependencyManagementPluginIsPresent() {
        rewriteRun(
          buildGradleKts(
            """"""
              plugins {
                  `java-library`
                  id(""io.spring.dependency-management"") version ""1.1.5""
              }
              repositories { mavenCentral() }

              dependencies {

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """""",
            """"""
              plugins {
                  `java-library`
                  id(""io.spring.dependency-management"") version ""1.1.5""
              }
              repositories { mavenCentral() }
              configurations.all {
                  resolutionStrategy.eachDependency { details ->
                      if (details.requested.group == ""com.fasterxml.jackson.core"" && details.requested.name == ""jackson-core"") {
                          details.useVersion(""2.12.5"")
                          details.because(""CVE-2024-BAD"")
                      }
                  }
              }

              dependencies {

                  implementation(""org.openrewrite:rewrite-java:7.0.0"")
              }
              """"""
          )
        );
    }

    @Test
    void canHandleNullScannedAccumulator() {
        UpgradeTransitiveDependencyVersion updateClassgraph = new UpgradeTransitiveDependencyVersion(""io.github.classgraph"", ""classgraph"", ""4.8.112"", null, null, null);
        UpgradeTransitiveDependencyVersion updateJackson = new UpgradeTransitiveDependencyVersion(""com.fasterxml*"", ""jackson-core"", ""2.12.5"", null, ""CVE-2024-BAD"", null);
        rewriteRun(
          spec -> spec.recipe(new ScanningAccumulatedUpgradeRecipe(updateClassgraph, updateJackson)),
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-core:2.12.5') {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          )
        );
    }

    @Test
    void canUseAnyWildcardForMultipleMatchingArtifactIds() {
        rewriteRun(spec ->
            spec.recipe(new UpgradeTransitiveDependencyVersion(""org.apache.tomcat.embed"", ""*"", ""10.1.42"", null, null, null)),
          buildGradle(
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  implementation 'org.springframework.boot:spring-boot-starter-tomcat:3.3.12'
              }
              """""",
            """"""
              plugins {
                id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('org.apache.tomcat.embed:tomcat-embed-core:10.1.42')
                      implementation('org.apache.tomcat.embed:tomcat-embed-el:10.1.42')
                      implementation('org.apache.tomcat.embed:tomcat-embed-websocket:10.1.42')
                  }

                  implementation 'org.springframework.boot:spring-boot-starter-tomcat:3.3.12'
              }
              """"""
          )
        );
    }

    @Test
    void doesNotAddRedundantConstraintWhenImplementationAlreadyHasIt() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(
              ""com.fasterxml.jackson.core"", ""jackson-databind"", ""2.12.5"", null, null, List.of(""testImplementation""))),
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation 'com.fasterxml.jackson.core:jackson-databind:2.12.5'
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0'
              }
              """"""
          )
        );
    }

    @Test
    void replacesTestImplementationConstraintWithImplementation() {
        rewriteRun(
          spec -> spec
            .recipe(new UpgradeTransitiveDependencyVersion(
              ""com.fasterxml.jackson.core"", ""jackson-databind"", ""2.12.5"", null, null, null)),
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.12.5'
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0'
              }
              """""",
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation('com.fasterxml.jackson.core:jackson-databind:2.12.5')
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
                  testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0'
              }
              """"""
          )
        );
    }

    @Test
    void updateConstraintForVersionInSettings() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:${gradle.jacksonVersion}"") {
                          because 'some reason'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-core:${gradle.jacksonVersion}"") {
                          because 'CVE-2024-BAD'
                      }
                  }

                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """"""
          ),
          settingsGradle(
            """"""
              gradle.ext {
                  jacksonVersion = '2.12.0'
              }
              """""",
            """"""
              gradle.ext {
                  jacksonVersion = '2.12.5'
              }
              """"""
          )
        );
    }

    @Test
    void noChangesIfDependencyIsAlsoPresentOnProjectForVersionInSettings() {
        rewriteRun(
          buildGradle(
            """"""
              plugins { id 'java' }
              repositories { mavenCentral() }

              dependencies {
                  implementation ""com.fasterxml.jackson.core:jackson-core:${gradle.jacksonVersion}""
                  implementation ""com.fasterxml.jackson.core:jackson-databind:${gradle.jacksonVersion}""
              }
              """"""
          ),
          settingsGradle(
            """"""
              gradle.ext {
                  jacksonVersion = '2.12.0'
              }
              """"""
          )
        );
    }

    @Test
    void upgradeDependencyVersionBeforeApplyingTheUpgradeTransitiveDependencyVersion() {
        rewriteRun(
          // We use an imperative recipe rather than a declarative recipeList, because in a declarative recipeList, all recipes perform their scanning phase first and only then perform their editing phase.
          // In this test case, we want the UpgradeTransitiveDependencyVersion recipe to scan and edit based on the output of the first recipeâ€™s changes,
          // to reflect a recipe downstream that uses this kind of setup.
          spec -> spec.recipe(toRecipe(() -> new JavaIsoVisitor<>() {
              @Override
              public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                  if (tree instanceof G.CompilationUnit) {
                      // A recipe that updates an existing dependency in the Gradle build file.
                      // That dependency itself declares the one targeted by UpgradeTransitiveDependencyVersion as a transitive dependency.
                      // In this case, ""org.openrewrite:rewrite-java"" has ""com.fasterxml.jackson.core:jackson-databind"" as a transitive dependency.
                      UpgradeDependencyVersion upgrade = new UpgradeDependencyVersion(""org.openrewrite"", ""rewrite-java"", ""8.0.0"", null);
                      UpgradeDependencyVersion.DependencyVersionState acc = upgrade.getInitialValue(ctx);
                      upgrade.getScanner(acc).visit(tree, ctx);
                      tree = upgrade.getVisitor(acc).visit(tree, ctx);

                      // Use the changed tree as input for a UpgradeTransitiveDependencyVersion run
                      UpgradeTransitiveDependencyVersion upgradeTransitive = new UpgradeTransitiveDependencyVersion(""com.fasterxml.jackson.core"", ""jackson-databind"", ""2.15.1"", null, null, null);
                      UpgradeTransitiveDependencyVersion.DependencyVersionState accTransitive2 = upgradeTransitive.getInitialValue(ctx);
                      upgradeTransitive.getScanner(accTransitive2).visit(tree, ctx);
                      tree = upgradeTransitive.getVisitor(accTransitive2).visit(tree, ctx);
                  }
                  return super.visit(tree, ctx);
              }
          })),
          buildGradle(
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation 'com.fasterxml.jackson.core:jackson-databind:2.12.0'
                  }
                  implementation 'org.openrewrite:rewrite-java:7.0.0'
              }
              """""",
            """"""
              plugins {
                  id 'java'
              }
              repositories { mavenCentral() }

              dependencies {
                  constraints {
                      implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.1'
                  }
                  implementation 'org.openrewrite:rewrite-java:8.0.0'
              }
              """"""
          )
        );
    }

    /**
     * This test verifies that the recipe correctly prevents downgrading transitive dependencies.
     * <ul>
     * <li>jackson-dataformat-xml:2.18.0 brings in jackson-databind:2.18.0 transitively.</li>
     * <li>jackson-datatype-jsr310:2.15.3 brings in jackson-databind:2.15.3 transitively.</li>
     * </ul>
     *  When trying to ""upgrade"" to 2.15.0 (which would be a downgrade), the recipe should
     *  make no changes to avoid downgrading the transitive dependency.
     */
    @Test
    void doesNotDowngradeTransitiveDependencyVersion() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeTransitiveDependencyVersion(
            ""com.fasterxml.jackson.core"", ""jackson-databind"", ""2.15.0"", null, null, null)),
          buildGradle(
            """"""
            plugins {
                id 'java'
            }
            repositories { mavenCentral() }
            
            dependencies {
                implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.18.0'
                implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.3'
            }
            """"""
          )
        );
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    public static class ScanningAccumulatedUpgradeRecipe extends ScanningRecipe<UpgradeTransitiveDependencyVersion.DependencyVersionState> {
        @Override
        public String getDisplayName() {
            return ""Accumulation-scanned recipe"";
        }

        @Override
        public String getDescription() {
            return ""Some recipes hava loop to determine all updates and add them to the scanner. This cycle/recipe only can update for the provided dependency."";
        }

        private final UpgradeTransitiveDependencyVersion scanAlsoFor;
        private final UpgradeTransitiveDependencyVersion upgradeDependency;

        @Override
        public UpgradeTransitiveDependencyVersion.DependencyVersionState getInitialValue(ExecutionContext ctx) {
            return new UpgradeTransitiveDependencyVersion.DependencyVersionState();
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getScanner(UpgradeTransitiveDependencyVersion.DependencyVersionState acc) {
            return new TreeVisitor<>() {
                @Override
                public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                    if (tree instanceof SourceFile) {
                        tree = scanAlsoFor.getScanner(acc).visit(tree, ctx);
                        tree = upgradeDependency.getScanner(acc).visit(tree, ctx);
                    }
                    return tree;
                }
            };
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor(UpgradeTransitiveDependencyVersion.DependencyVersionState acc) {
            return upgradeDependency.getVisitor(acc);
        }
    }
}
",{}
Upgrade a version within the GradleProject marker,Upgrade a version within the GradleProject marker. Makes no changes to the source file itself,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.marker;

import lombok.EqualsAndHashCode;
import lombok.SneakyThrows;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.maven.tree.Dependency;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.test.SourceSpec;

import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Fail.fail;
import static org.openrewrite.gradle.Assertions.buildGradle;
import static org.openrewrite.gradle.Assertions.settingsGradle;
import static org.openrewrite.gradle.toolingapi.Assertions.withToolingApi;
import static org.openrewrite.java.Assertions.mavenProject;

class GradleProjectTest implements RewriteTest {

    @Override
    public void defaults(RecipeSpec spec) {
        spec.beforeRecipe(withToolingApi())
          .validateRecipeSerialization(false);
    }

    @Test
    void noopUpgrade() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""org.openrewrite"", ""rewrite-java"", ""8.56.0""),
            ""implementation"",
            (original, updated) -> assertThat(updated).isSameAs(original)
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(""org.openrewrite:rewrite-java:8.56.0"")
              }
              """"""
          )
        );
    }

    @Test
    void multiProject() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""org.openrewrite"", ""rewrite-java"", ""8.57.0""),
            ""implementation"",
            (original, updated) -> {
                // mostly interested that a ProjectDependency does not cause an exception
            }
          )),
          mavenProject(""root"",
            settingsGradle(
              """"""
                include(""a"")
                include(""b"")
                """""",
              SourceSpec::skip
            ),
            mavenProject(""a"",
              buildGradle(
                """"""
                  plugins {
                      id(""java"")
                  }
                  repositories {
                      mavenCentral()
                  }
                  dependencies {
                      implementation(""org.openrewrite:rewrite-java:8.56.0"")
                  }
                  """""",
                SourceSpec::skip
              )
            ),
            mavenProject(""b"",
              buildGradle(
                """"""
                  plugins {
                      id(""java"")
                  }
                  repositories {
                      mavenCentral()
                  }
                  dependencies {
                      implementation(project("":a""))
                      implementation(""org.openrewrite:rewrite-java:8.56.0"")
                  }
                  """"""
              )
            )
          )
        );
    }

    @Test
    void plusVersion() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""org.openrewrite"", ""rewrite-java"", ""8.57.0""),
            ""implementation"",
            (original, updated) -> {
                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();
                List<GradleDependencyConfiguration> updatedConfigurations = ListUtils.concat(implementation, updated.configurationsExtendingFrom(implementation, true));
                for (GradleDependencyConfiguration updatedConfiguration : updatedConfigurations) {
                    Dependency requested = updatedConfiguration.findRequestedDependency(""org.openrewrite"", ""rewrite-java"");
                    assertThat(requested).isNotNull()
                      .extracting(Dependency::getVersion)
                      .as(updatedConfiguration.getName() + "" expected to have requested version upgrade"")
                      .isEqualTo(""8.57.0"");
                    if (updatedConfiguration.isCanBeResolved()) {
                        ResolvedDependency resolved = updatedConfiguration.findResolvedDependency(""org.openrewrite"", ""rewrite-java"");
                        assertThat(resolved).isNotNull()
                          .extracting(ResolvedDependency::getVersion)
                          .as(updatedConfiguration.getName() + "" expected to have resolved version upgrade"")
                          .isEqualTo(""8.57.0"");
                    }
                }
            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(""org.openrewrite:rewrite-java:8.56.+"")
              }
              """"""
          )
        );
    }

    @Test
    void simpleUpgrade() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""org.openrewrite"", ""rewrite-java"", ""8.57.0""),
            ""implementation"",
            (original, updated) -> {
                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();
                List<GradleDependencyConfiguration> updatedConfigurations = ListUtils.concat(implementation, updated.configurationsExtendingFrom(implementation, true));
                for (GradleDependencyConfiguration updatedConfiguration : updatedConfigurations) {
                    Dependency requested = updatedConfiguration.findRequestedDependency(""org.openrewrite"", ""rewrite-java"");
                    assertThat(requested).isNotNull()
                      .extracting(Dependency::getVersion)
                      .as(updatedConfiguration.getName() + "" expected to have requested version upgrade"")
                      .isEqualTo(""8.57.0"");
                    if (updatedConfiguration.isCanBeResolved()) {
                        ResolvedDependency resolved = updatedConfiguration.findResolvedDependency(""org.openrewrite"", ""rewrite-java"");
                        assertThat(resolved).isNotNull()
                          .extracting(ResolvedDependency::getVersion)
                          .as(updatedConfiguration.getName() + "" expected to have resolved version upgrade"")
                          .isEqualTo(""8.57.0"");
                    }
                }

            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(""org.openrewrite:rewrite-java:8.56.0"")
              }
              """"""
          )
        );
    }

    @Test
    void bomUpgrade() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""org.openrewrite"", ""rewrite-bom"", ""8.57.0""),
            ""implementation"",
            (original, updated) -> {
                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();
                List<GradleDependencyConfiguration> updatedConfigurations = ListUtils.concat(implementation, updated.configurationsExtendingFrom(implementation, true));
                for (GradleDependencyConfiguration updatedConfiguration : updatedConfigurations) {
                    Dependency requested = updatedConfiguration.findRequestedDependency(""org.openrewrite"", ""rewrite-java"");
                    assertThat(requested).isNotNull()
                      .extracting(Dependency::getVersion)
                      .as(updatedConfiguration.getName() + "" expected to have requested version upgrade"")
                      .isNull();
                    if (updatedConfiguration.isCanBeResolved()) {
                        ResolvedDependency resolved = updatedConfiguration.findResolvedDependency(""org.openrewrite"", ""rewrite-java"");
                        assertThat(resolved).isNotNull()
                          .extracting(ResolvedDependency::getVersion)
                          .as(updatedConfiguration.getName() + "" expected to have resolved version upgrade"")
                          .isEqualTo(""8.57.0"");
                    }
                }

            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(platform(""org.openrewrite:rewrite-bom:8.56.0""))
                  implementation(""org.openrewrite:rewrite-java"")
              }
              """"""
          )
        );
    }

    @Test
    void removesDefunctTransitives() {
        rewriteRun(
          spec -> spec.recipe(new UpgradeDependencyInMarker(
            new GroupArtifactVersion(""io.vertx"", ""vertx-core"", ""5.0.1""),
            ""implementation"",
            (original, updated) -> {
                assertThat(updated).isNotSameAs(original);

                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();

                Dependency requested = implementation.findRequestedDependency(""io.vertx"", ""vertx-core"");
                assertThat(requested).isNotNull()
                  .extracting(Dependency::getVersion)
                  .isEqualTo(""5.0.1"");

                List<GradleDependencyConfiguration> resolvableConfigurations = ListUtils.concat(implementation, updated.configurationsExtendingFrom(implementation, true));
                for (GradleDependencyConfiguration config : resolvableConfigurations) {
                    if (config.isCanBeResolved()) {
                        ResolvedDependency vertxCore = config.findResolvedDependency(""io.vertx"", ""vertx-core"");
                        if (vertxCore != null) {
                            assertThat(vertxCore.getVersion())
                              .as(config.getName() + "" should have vertx-core 5.0.1"")
                              .isEqualTo(""5.0.1"");
                        }

                        // Check that netty-codec is NOT listed amongst the dependencies as it is not a dependency of vertx-core 5.0.1
                        assertThat(config.getResolved())
                          .as(config.getName() + "" should NOT contain netty-codec after upgrade to vertx-core 5.0.1"")
                          .noneMatch(dep -> ""io.netty"".equals(dep.getGroupId()) && ""netty-codec"".equals(dep.getArtifactId()));
                    }
                }
            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java-library"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(""io.vertx:vertx-core:3.9.8"")
              }
              """"""
          )
        );
    }

    @Test
    void removeDependency() {
        rewriteRun(
          spec -> spec.recipe(new RemoveDependency(
            List.of(new GroupArtifact(""org.openrewrite"", ""rewrite-core"")),
            (original, updated) -> {
                assertThat(updated).isNotSameAs(original);

                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();

                Dependency rewriteCore = implementation.findRequestedDependency(""org.openrewrite"", ""rewrite-core"");
                assertThat(rewriteCore)
                  .as(""rewrite-core should have been removed"")
                  .isNull();

            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  implementation(""org.openrewrite:rewrite-core:8.56.0"")
                  implementation(""org.openrewrite:rewrite-java:8.56.0"")
              }
              """"""
          )
        );
    }

    @Test
    void changeConstraint() {
        rewriteRun(
          spec -> spec.recipe(new ChangeConstraint(
            Map.of(""implementation"", List.of(new GroupArtifactVersion(""com.fasterxml.jackson.core"", ""jackson-databind"", ""2.19.2""))),
            (original, updated) -> {
                GradleDependencyConfiguration implementation = updated.getConfiguration(""implementation"");
                assertThat(implementation).isNotNull();

                Dependency rewriteCore = implementation.findRequestedDependency(""org.openrewrite"", ""rewrite-core"");
                assertThat(rewriteCore).isNotNull()
                  .extracting(Dependency::getVersion)
                  .as(""rewrite-core version should not have changed"")
                  .isEqualTo(""8.56.0"");

                // Verify the constraint was updated
                List<GradleDependencyConstraint> constraints = implementation.getConstraints();
                assertThat(constraints).isNotNull();

                GradleDependencyConstraint jacksonConstraint = constraints.stream()
                  .filter(c -> ""com.fasterxml.jackson.core"".equals(c.getGroupId()) &&
                               ""jackson-databind"".equals(c.getArtifactId()))
                  .findFirst()
                  .orElse(null);

                assertThat(jacksonConstraint).isNotNull()
                  .extracting(GradleDependencyConstraint::getRequiredVersion)
                  .isEqualTo(""2.19.2"");

                // Verify the runtimeClasspath has the updated resolved version
                GradleDependencyConfiguration runtimeClasspath = updated.getConfiguration(""runtimeClasspath"");
                assertThat(runtimeClasspath).isNotNull();
                ResolvedDependency resolvedJackson = runtimeClasspath.findResolvedDependency(""com.fasterxml.jackson.core"", ""jackson-databind"");
                assertThat(resolvedJackson).isNotNull()
                  .extracting(ResolvedDependency::getVersion)
                  .as(""jackson-databind should be resolved to the constrained version"")
                  .isEqualTo(""2.19.2"");
            }
          )),
          buildGradle(
            """"""
              plugins {
                  id(""java"")
              }
              repositories {
                  mavenCentral()
              }
              dependencies {
                  constraints {
                      implementation(""com.fasterxml.jackson.core:jackson-databind:2.15.0"")
                  }
                  implementation(""org.openrewrite:rewrite-core:8.56.0"")
              }
              """"""
          )
        );
    }
}

@EqualsAndHashCode(callSuper = false)
@Value
class UpgradeDependencyInMarker extends Recipe {

    GroupArtifactVersion newGav;
    String configuration;
    BiConsumer<GradleProject, GradleProject> testAssertion;

    @Override
    public String getDisplayName() {
        return ""Upgrade a version within the GradleProject marker"";
    }

    @Override
    public String getDescription() {
        return ""Upgrade a version within the GradleProject marker. Makes no changes to the source file itself"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        //noinspection NullableProblems
        return new TreeVisitor<>() {
            @Override
            @SneakyThrows
            public Tree visit(Tree tree, ExecutionContext ctx) {
                GradleProject original = tree.getMarkers().findFirst(GradleProject.class).orElseThrow(() -> fail(""Missing GradleProject""));
                GradleProject updated = original.upgradeDirectDependencyVersion(configuration, newGav, ctx);
                testAssertion.accept(original, updated);
                return tree;
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@Value
class RemoveDependency extends Recipe {

    List<GroupArtifact> gas;

    @Nullable
    String configuration;

    BiConsumer<GradleProject, GradleProject> testAssertion;

    public RemoveDependency(List<GroupArtifact> gas, BiConsumer<GradleProject, GradleProject> testAssertion) {
        this.gas = gas;
        this.configuration = null;
        this.testAssertion = testAssertion;
    }

    @Override
    public String getDisplayName() {
        return ""Remove a dependency within the GradleProject marker"";
    }

    @Override
    public String getDescription() {
        return ""Remove a dependency within the GradleProject marker. Makes no changes to the source file itself"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        //noinspection NullableProblems
        return new TreeVisitor<>() {
            @Override
            @SneakyThrows
            public Tree visit(Tree tree, ExecutionContext ctx) {
                GradleProject original = tree.getMarkers().findFirst(GradleProject.class).orElseThrow(() -> fail(""Missing GradleProject""));
                GradleProject updated = original.removeDirectDependencies(gas, ctx);
                testAssertion.accept(original, updated);
                return tree;
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@Value
class ChangeConstraint extends Recipe {

    Map<String, List<GroupArtifactVersion>> configToConstraint;
    BiConsumer<GradleProject, GradleProject> testAssertion;

    @Override
    public String getDisplayName() {
        return ""Remove a dependency within the GradleProject marker"";
    }

    @Override
    public String getDescription() {
        return ""Remove a dependency within the GradleProject marker. Makes no changes to the source file itself"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        //noinspection NullableProblems
        return new TreeVisitor<>() {
            @Override
            @SneakyThrows
            public Tree visit(Tree tree, ExecutionContext ctx) {
                GradleProject original = tree.getMarkers().findFirst(GradleProject.class).orElseThrow(() -> fail(""Missing GradleProject""));
                GradleProject updated = original.addOrUpdateConstraints(configToConstraint, ctx);
                testAssertion.accept(original, updated);
                return tree;
            }
        };
    }
}
",{}
Remove redundant explicit dependencies and versions,Remove explicitly-specified dependencies and dependency versions that are managed by a Gradle `platform`/`enforcedPlatform`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.Markup;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.MavenDownloadingExceptions;
import org.openrewrite.maven.internal.MavenPomDownloader;
import org.openrewrite.maven.tree.*;
import org.openrewrite.semver.ExactVersion;
import org.openrewrite.semver.LatestIntegration;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.*;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.gradle.RemoveRedundantDependencyVersions.Comparator.*;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveRedundantDependencyVersions extends Recipe {
    @Option(displayName = ""Group"",
            description = ""Group glob expression pattern used to match dependencies that should be managed."" +
                          ""Group is the first part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""com.google.*"",
            required = false)
    @Nullable
    String groupPattern;

    @Option(displayName = ""Artifact"",
            description = ""Artifact glob expression pattern used to match dependencies that should be managed."" +
                          ""Artifact is the second part of a dependency coordinate `com.google.guava:guava:VERSION`."",
            example = ""guava*"",
            required = false)
    @Nullable
    String artifactPattern;

    @Option(displayName = ""Only if managed version is ..."",
            description = ""Only remove the explicit version if the managed version has the specified comparative relationship to the explicit version. "" +
                          ""For example, `gte` will only remove the explicit version if the managed version is the same or newer. "" +
                          ""Default `eq`."",
            valid = {""ANY"", ""EQ"", ""LT"", ""LTE"", ""GT"", ""GTE""},
            required = false)
    @Nullable
    Comparator onlyIfManagedVersionIs;

    public enum Comparator {ANY, EQ, LT, LTE, GT, GTE}

    @Override
    public String getDisplayName() {
        return ""Remove redundant explicit dependencies and versions"";
    }

    @Override
    public String getDescription() {
        return ""Remove explicitly-specified dependencies and dependency versions that are managed by a Gradle `platform`/`enforcedPlatform`."";
    }

    private static final List<String> DEPENDENCY_MANAGEMENT_METHODS = Arrays.asList(
            ""api"",
            ""implementation"",
            ""compileOnly"",
            ""runtimeOnly"",
            ""testImplementation"",
            ""testCompileOnly"",
            ""testRuntimeOnly"",
            ""debugImplementation"",
            ""releaseImplementation"",
            ""androidTestImplementation"",
            ""featureImplementation"",
            ""annotationProcessor"",
            ""kapt"",
            ""ksp"",
            ""compile"", // deprecated
            ""runtime"", // deprecated
            ""testCompile"", // deprecated
            ""testRuntime"" // deprecated
    );
    private static final VersionComparator VERSION_COMPARATOR = requireNonNull(Semver.validate(""latest.release"", null).getValue());

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
                    GradleProject gp;
                    final Map<String, List<ResolvedPom>> platforms = new HashMap<>();
                    final Map<String, List<ResolvedDependency>> directDependencies = new HashMap<>();


                    @Override
                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                        if (tree instanceof JavaSourceFile) {
                            Optional<GradleProject> maybeGp = tree.getMarkers().findFirst(GradleProject.class);
                            if (!maybeGp.isPresent()) {
                                return (J) tree;
                            }

                            gp = maybeGp.get();
                            new JavaIsoVisitor<ExecutionContext>() {
                                @Override
                                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                    J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                                    new GradleDependency.Matcher()
                                            .groupId(groupPattern)
                                            .artifactId(artifactPattern)
                                            .get(getCursor())
                                            .ifPresent(it ->
                                                    directDependencies.computeIfAbsent(m.getSimpleName(), k -> new ArrayList<>()).add(it.getResolvedDependency()));

                                    if (!""platform"".equals(m.getSimpleName()) && !""enforcedPlatform"".equals(m.getSimpleName())) {
                                        return m;
                                    }

                                    GroupArtifactVersion gav = null;
                                    if (m.getArguments().get(0) instanceof J.Literal) {
                                        J.Literal l = (J.Literal) m.getArguments().get(0);
                                        if (l.getType() == JavaType.Primitive.String) {
                                            Dependency dependency = DependencyStringNotationConverter.parse((String) l.getValue());
                                            gav = new GroupArtifactVersion(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());
                                        }
                                    } else if (m.getArguments().get(0) instanceof G.MapEntry) {
                                        String groupId = null;
                                        String artifactId = null;
                                        String version = null;

                                        for (Expression arg : m.getArguments()) {
                                            if (!(arg instanceof G.MapEntry &&
                                                  ((G.MapEntry) arg).getKey().getType() == JavaType.Primitive.String &&
                                                  ((G.MapEntry) arg).getValue().getType() == JavaType.Primitive.String)) {
                                                continue;
                                            }

                                            Object key = ((J.Literal) ((G.MapEntry) arg).getKey()).getValue();
                                            if (""group"".equals(key)) {
                                                groupId = (String) ((J.Literal) ((G.MapEntry) arg).getValue()).getValue();
                                            } else if (""name"".equals(key)) {
                                                artifactId = (String) ((J.Literal) ((G.MapEntry) arg).getValue()).getValue();
                                            } else if (""version"".equals(key)) {
                                                version = (String) ((J.Literal) ((G.MapEntry) arg).getValue()).getValue();
                                            }
                                        }

                                        if (groupId != null && artifactId != null && version != null) {
                                            gav = new GroupArtifactVersion(groupId, artifactId, version);
                                        }
                                    }
                                    if (gav != null) {
                                        MavenPomDownloader mpd = new MavenPomDownloader(ctx);
                                        try {
                                            ResolvedPom platformPom = mpd.download(gav, null, null, gp.getMavenRepositories())
                                                    .resolve(emptyList(), mpd, ctx);
                                            platforms.computeIfAbsent(getCursor().getParentOrThrow(1).firstEnclosingOrThrow(J.MethodInvocation.class).getSimpleName(), k -> new ArrayList<>()).add(platformPom);
                                        } catch (MavenDownloadingException ignored) {
                                        }
                                    }
                                    return m;
                                }
                            }.visit(tree, ctx);
                            tree = new JavaIsoVisitor<ExecutionContext>() {

                                @Override
                                public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                    J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                                    if (""dependencies"".equals(m.getSimpleName())) {
                                        // Gradle tolerates multiple declarations of the same dependency, but only the one with the newest version is used
                                        // Filter out duplicates
                                        Map<GroupArtifactVersion, J.MethodInvocation> requestedToDeclaration = new HashMap<>();
                                        Map<GroupArtifact, List<String>> gaToRequested = new HashMap<>();
                                        new JavaIsoVisitor<ExecutionContext>() {
                                            @Override
                                            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext executionContext) {
                                                J.MethodInvocation m1 = super.visitMethodInvocation(method, executionContext);
                                                new GradleDependency.Matcher().get(getCursor()).ifPresent(it -> {
                                                    if (it.getResolvedDependency().getRequested().getVersion() != null) {
                                                        requestedToDeclaration.put(it.getResolvedDependency().getRequested().getGav(), m1);
                                                        gaToRequested.computeIfAbsent(it.getResolvedDependency().getGav().asGroupArtifact(), (groupArtifact -> new ArrayList<>()))
                                                                .add(it.getResolvedDependency().getRequested().getVersion());
                                                    }
                                                });
                                                return m1;
                                            }
                                        }.visit(m.getArguments().get(0), ctx, getCursor());

                                        Set<J.MethodInvocation> toBeRemoved = new HashSet<>();
                                        for (Map.Entry<GroupArtifact, List<String>> gaToRequestedVersions : gaToRequested.entrySet()) {
                                            GroupArtifact ga = gaToRequestedVersions.getKey();
                                            List<String> requested = gaToRequestedVersions.getValue();
                                            if (requested.size() < 2) {
                                                continue;
                                            }
                                            // The newest version number is relevant, others are redundant and can be removed
                                            requested.stream()
                                                    .sorted(VERSION_COMPARATOR.reversed())
                                                    .skip(1)
                                                    .forEach(redundant -> toBeRemoved.add(requestedToDeclaration.get(new GroupArtifactVersion(ga.getGroupId(), ga.getArtifactId(), redundant))));
                                        }

                                        // With the list of redundant declarations in-hand, remove them from the dependencies block
                                        //noinspection NullableProblems
                                        m = (J.MethodInvocation) new JavaIsoVisitor<ExecutionContext>() {
                                            @Override
                                            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext executionContext) {
                                                J.MethodInvocation m1 = super.visitMethodInvocation(method, executionContext);
                                                if (toBeRemoved.contains(m1)) {
                                                    //noinspection DataFlowIssue
                                                    return null;
                                                }
                                                return m1;
                                            }

                                            @Override
                                            public J.@Nullable Return visitReturn(J.Return _return, ExecutionContext ctx) {
                                                J.Return r = super.visitReturn(_return, ctx);
                                                if (r.getExpression() == null) {
                                                    return null;
                                                }
                                                return r;
                                            }
                                        }.visit(m, ctx, getCursor().getParentTreeCursor());
                                    } else if (""constraints"".equals(m.getSimpleName())) {
                                        if (m.getArguments().isEmpty() ||
                                            !(m.getArguments().get(0) instanceof J.Lambda) ||
                                            !(((J.Lambda) m.getArguments().get(0)).getBody() instanceof J.Block)) {
                                            return m;
                                        }
                                        if (((J.Block) ((J.Lambda) m.getArguments().get(0)).getBody()).getStatements().isEmpty()) {
                                            return null;
                                        }
                                        return m;
                                    } else {
                                        if (!isDependencyManagmentMethod(m.getSimpleName()) ||
                                            m.getArguments().isEmpty() ||
                                            m.getArguments().get(0).getType() != JavaType.Primitive.String) {
                                            return m;
                                        }
                                        String value = (String) ((J.Literal) m.getArguments().get(0)).getValue();
                                        Dependency dependency = DependencyStringNotationConverter.parse(value);
                                        try {
                                            getCursor().dropParentUntil(obj -> obj instanceof J.MethodInvocation && ""constraints"".equals(((J.MethodInvocation) obj).getSimpleName())).getValue();
                                            if (shouldRemoveRedundantConstraint(dependency, gp.getConfiguration(m.getSimpleName()))) {
                                                return null;
                                            }
                                            return m;
                                        } catch (Exception ignore) {
                                        }

                                        try {
                                            if (shouldRemoveRedundantDependency(dependency, m.getSimpleName(), gp.getMavenRepositories(), ctx)) {
                                                return null;
                                            }
                                        } catch (MavenDownloadingException e) {
                                            return Markup.error(m, e);
                                        }
                                    }
                                    return m;
                                }

                                @Override
                                public J.@Nullable Return visitReturn(J.Return _return, ExecutionContext ctx) {
                                    J.Return r = super.visitReturn(_return, ctx);
                                    if (r.getExpression() == null) {
                                        return null;
                                    }
                                    return r;
                                }

                                private boolean isDependencyManagmentMethod(String methodName) {
                                    return DEPENDENCY_MANAGEMENT_METHODS.contains(methodName);
                                }

                                private boolean shouldRemoveRedundantDependency(@Nullable Dependency dependency, String configurationName, List<MavenRepository> repositories, ExecutionContext ctx) throws MavenDownloadingException {
                                    if (dependency == null || ((groupPattern != null && !matchesGlob(dependency.getGroupId(), groupPattern)) ||
                                                               (artifactPattern != null && !matchesGlob(dependency.getArtifactId(), artifactPattern)))) {
                                        return false;
                                    }

                                    for (Map.Entry<String, List<ResolvedDependency>> entry : directDependencies.entrySet()) {
                                        for (ResolvedDependency d : entry.getValue()) {
                                            // ignore self
                                            if (d.getGroupId().equals(dependency.getGroupId()) && d.getArtifactId().equals(dependency.getArtifactId())) {
                                                continue;
                                            }

                                            // noinspection ConstantConditions
                                            if (d.getDependencies() == null) {
                                                continue;
                                            }
                                            if (matchesConfiguration(configurationName, entry.getKey()) &&
                                                d.findDependency(dependency.getGroupId(), dependency.getArtifactId()) != null &&
                                                dependsOnNewerVersion(dependency.getGav(), d.getGav().asGroupArtifactVersion(), repositories, ctx)) {
                                                return true;
                                            }
                                        }
                                    }
                                    return false;
                                }

                                private boolean dependsOnNewerVersion(GroupArtifactVersion searchGav, GroupArtifactVersion toSearch, List<MavenRepository> repositories, ExecutionContext ctx) throws MavenDownloadingException {
                                    if (toSearch.getVersion() == null) {
                                        return false;
                                    }
                                    if (searchGav.asGroupArtifact().equals(toSearch.asGroupArtifact())) {
                                        return searchGav.getVersion() == null || matchesComparator(toSearch.getVersion(), searchGav.getVersion());
                                    }
                                    MavenPomDownloader mpd = new MavenPomDownloader(ctx);
                                    try {
                                        List<ResolvedDependency> resolved = mpd.download(toSearch, null, null, repositories)
                                                .resolve(emptyList(), mpd, repositories, ctx)
                                                .resolveDependencies(Scope.Runtime, mpd, ctx);
                                        for (ResolvedDependency r : resolved) {
                                            if (Objects.equals(searchGav.getGroupId(), r.getGroupId()) && Objects.equals(searchGav.getArtifactId(), r.getArtifactId())) {
                                                return searchGav.getVersion() == null || matchesComparator(r.getVersion(), searchGav.getVersion());
                                            }
                                        }
                                    } catch (MavenDownloadingExceptions e) {
                                        throw e.getExceptions().get(0);
                                    }
                                    return false;
                                }

                                boolean matchesConfiguration(String configA, String configB) {
                                    if (""runtimeOnly"".equals(configA) && ""implementation"".equals(configB)) {
                                        return true;
                                    }
                                    if (""testRuntimeOnly"".equals(configA)) {
                                        if (""testImplementation"".equals(configB) || ""implementation"".equals(configB)) {
                                            return true;
                                        }
                                    }
                                    return configA.equals(configB);
                                }

                                boolean shouldRemoveRedundantConstraint(@Nullable Dependency constraint, @Nullable GradleDependencyConfiguration c) {
                                    if (c == null || constraint == null || constraint.getVersion() == null) {
                                        return false;
                                    }
                                    if (constraint.getVersion().contains(""["") || constraint.getVersion().contains(""!!"")) {
                                        // https://docs.gradle.org/current/userguide/dependency_versions.html#sec:strict-version
                                        return false;
                                    }
                                    if ((groupPattern != null && !matchesGlob(constraint.getGroupId(), groupPattern)) ||
                                        (artifactPattern != null && !matchesGlob(constraint.getArtifactId(), artifactPattern))) {
                                        return false;
                                    }

                                    return Stream.concat(
                                                    Stream.of(c),
                                                    gp.configurationsExtendingFrom(c, true).stream()
                                            )
                                            .filter(GradleDependencyConfiguration::isCanBeResolved)
                                            .distinct()
                                            .map(conf -> conf.findResolvedDependency(requireNonNull(constraint.getGroupId()), constraint.getArtifactId()))
                                            .filter(Objects::nonNull)
                                            .anyMatch(resolvedDependency -> VERSION_COMPARATOR.compare(null, resolvedDependency.getVersion(), constraint.getVersion()) > 0);
                                }
                            }.visitNonNull(tree, ctx);
                        }
                        return super.visit(tree, ctx);
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                        Optional<GradleDependency> maybeGradleDependency = new GradleDependency.Matcher()
                                .groupId(groupPattern)
                                .artifactId(artifactPattern)
                                .get(getCursor());
                        if (!maybeGradleDependency.isPresent()) {
                            return m;
                        }

                        GradleDependency gradleDependency = maybeGradleDependency.get();
                        ResolvedDependency dep = gradleDependency.getResolvedDependency();
                        if (StringUtils.isBlank(dep.getVersion())) {
                            return m;
                        }

                        if (platforms.containsKey(m.getSimpleName())) {
                            for (ResolvedPom platform : platforms.get(m.getSimpleName())) {
                                String managedVersion = platform.getManagedVersion(dep.getGroupId(), dep.getArtifactId(), null, dep.getRequested().getClassifier());
                                if (matchesComparator(managedVersion, dep.getVersion())) {
                                    return maybeRemoveVersion(m);
                                }
                            }
                        }
                        GradleDependencyConfiguration gdc = gp.getConfiguration(m.getSimpleName());
                        if (gdc != null) {
                            for (GradleDependencyConfiguration configuration : gdc.allExtendsFrom()) {
                                if (platforms.containsKey(configuration.getName())) {
                                    for (ResolvedPom platform : platforms.get(configuration.getName())) {
                                        String managedVersion = platform.getManagedVersion(dep.getGroupId(), dep.getArtifactId(), null, dep.getRequested().getClassifier());
                                        if (matchesComparator(managedVersion, dep.getVersion())) {
                                            return maybeRemoveVersion(m);
                                        }
                                    }
                                }
                            }
                        }

                        return m;
                    }

                    private J.MethodInvocation maybeRemoveVersion(J.MethodInvocation m) {
                        if (m.getArguments().get(0) instanceof J.Literal) {
                            J.Literal l = (J.Literal) m.getArguments().get(0);
                            if (l.getType() == JavaType.Primitive.String) {
                                Dependency dep = DependencyStringNotationConverter.parse((String) l.getValue());
                                if (dep == null || dep.getClassifier() != null || dep.getExt() != null) {
                                    return m;
                                }
                                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg ->
                                        ChangeStringLiteral.withStringValue(l, dep.withVersion(null).toStringNotation()))
                                );
                            }
                        } else if (m.getArguments().get(0) instanceof G.MapLiteral) {
                            return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                                G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                                return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), entry -> {
                                    if (entry.getKey() instanceof J.Literal && ""version"".equals(((J.Literal) entry.getKey()).getValue())) {
                                        return null;
                                    }
                                    return entry;
                                }));
                            }));
                        } else if (m.getArguments().get(0) instanceof G.MapEntry) {
                            return m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                                G.MapEntry entry = (G.MapEntry) arg;
                                if (entry.getKey() instanceof J.Literal && ""version"".equals(((J.Literal) entry.getKey()).getValue())) {
                                    return null;
                                }
                                return entry;
                            }));
                        }
                        return m;
                    }
                }
        );
    }

    private Comparator determineComparator() {
        if (onlyIfManagedVersionIs != null) {
            return onlyIfManagedVersionIs;
        }
        return EQ;
    }

    private boolean matchesComparator(@Nullable String managedVersion, String requestedVersion) {
        Comparator comparator = determineComparator();
        if (managedVersion == null) {
            return false;
        }
        if (comparator == ANY) {
            return true;
        }
        if (!isExact(managedVersion)) {
            return false;
        }
        int comparison = new LatestIntegration(null).compare(null, managedVersion, requestedVersion);
        if (comparison < 0) {
            return comparator == LT || comparator == LTE;
        } else if (comparison > 0) {
            return comparator == GT || comparator == GTE;
        } else {
            return comparator == EQ || comparator == LTE || comparator == GTE;
        }
    }

    private boolean isExact(String managedVersion) {
        Validated<VersionComparator> maybeVersionComparator = Semver.validate(managedVersion, null);
        return maybeVersionComparator.isValid() && maybeVersionComparator.getValue() instanceof ExactVersion;
    }
}
",{}
Upgrade transitive Gradle dependencies,Upgrades the version of a transitive dependency in a Gradle build file. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.format.BlankLinesVisitor;
import org.openrewrite.java.search.FindMethods;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.kotlin.KotlinIsoVisitor;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.Markup;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.Dependency;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.semver.Semver;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Preconditions.not;
import static org.openrewrite.gradle.UpgradeDependencyVersion.getGradleProjectKey;

@SuppressWarnings(""GroovyAssignabilityCheck"")
@Incubating(since = ""8.18.0"")
@Value
@EqualsAndHashCode(callSuper = false)
@RequiredArgsConstructor
public class UpgradeTransitiveDependencyVersion extends ScanningRecipe<UpgradeTransitiveDependencyVersion.DependencyVersionState> {
    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(""RewriteGradleProject dependencies(..)"");
    private static final MethodMatcher CONSTRAINTS_MATCHER = new MethodMatcher(""org.gradle.api.artifacts.dsl.DependencyHandler constraints(..)"", true);
    private static final String CONSTRAINT_MATCHER = ""org.gradle.api.artifacts.dsl.DependencyHandler *(..)"";

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""29.X"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'newVersion' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Because"",
            description = ""The reason for upgrading the transitive dependency. For example, we could be responding to a vulnerability."",
            required = false,
            example = ""CVE-2021-1234"")
    @Nullable
    String because;

    @Option(displayName = ""Include configurations"",
            description = ""A list of configurations to consider during the upgrade. For example, For example using `implementation, runtimeOnly`, we could be responding to a deployable asset vulnerability only (ignoring test scoped vulnerabilities)."",
            required = false,
            example = ""implementation, runtimeOnly"")
    @Nullable
    List<String> onlyForConfigurations;

    /**
     * This recipe needs to generate LST elements representing ""constraints"" and ""because"" method invocations.
     * Aside from their parameterization with different arguments they are otherwise identical.
     * GradleParser isn't particularly fast, so in a recipe run which involves more than one UpgradeTransitiveDependencyVersion
     * it is much faster to produce these LST elements only once then manipulate their arguments.
     * This largely mimics how caching works in JavaTemplate. If we create a Gradle/GroovyTemplate this could be refactored.
     */
    private static Map<String, Optional<JavaSourceFile>> snippetCache(ExecutionContext ctx) {
        //noinspection unchecked
        return (Map<String, Optional<JavaSourceFile>>) ctx.getMessages()
                .computeIfAbsent(UpgradeTransitiveDependencyVersion.class.getName() + "".snippetCache"", k -> new HashMap<String, Optional<G.CompilationUnit>>());
    }

    private static Optional<JavaSourceFile> parseAsGradle(String snippet, boolean isKotlinDsl, ExecutionContext ctx) {
        return snippetCache(ctx)
                .computeIfAbsent(snippet, s -> GradleParser.builder().build().parseInputs(singleton(
                                new Parser.Input(
                                        Paths.get(""build.gradle"" + (isKotlinDsl ? "".kts"" : """")),
                                        () -> new ByteArrayInputStream(snippet.getBytes(StandardCharsets.UTF_8))
                                )), null, ctx)
                        .findFirst()
                        .map(maybeCu -> {
                            maybeCu.getMarkers()
                                    .findFirst(ParseExceptionResult.class)
                                    .ifPresent(per -> {
                                        throw new IllegalStateException(""Encountered exception "" + per.getExceptionType() + "" with message "" + per.getMessage() + "" on snippet:\n"" + snippet);
                                    });
                            return (JavaSourceFile) maybeCu;
                        }));
    }

    @Override
    public String getDisplayName() {
        return ""Upgrade transitive Gradle dependencies"";
    }

    @Override
    public String getDescription() {
        return ""Upgrades the version of a transitive dependency in a Gradle build file. "" +
               ""There are many ways to do this in Gradle, so the mechanism for upgrading a "" +
               ""transitive dependency must be considered carefully depending on your style "" +
               ""of dependency management."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    public static class DependencyVersionState {
        Map<String, Map<GroupArtifact, Map<GradleDependencyConfiguration, String>>> updatesPerProject = new LinkedHashMap<>();
        Map<String, GroupArtifact> versionPropNameToGA = new HashMap<>();
        private boolean dependenciesToUpdateCalculated = false;
        private final Map<GroupArtifact, String> dependenciesToUpdate = new HashMap<>();

        /**
         * Collects a map of dependencies that require an update, regardless of which project they belong to.
         * <p>
         * Only dependencies that match the configured {@code dependencyMatcher} are included.
         *
         * @return a map of {@link GroupArtifact} to target version string, representing dependencies that need updating
         */
        private Map<GroupArtifact, String> dependenciesToUpdate(DependencyMatcher dependencyMatcher) {
            if (!dependenciesToUpdateCalculated) {
                for (Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> entry : updatesPerProject.values()) {
                    for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : entry.entrySet()) {
                        if (!dependencyMatcher.matches(update.getKey().getGroupId(), update.getKey().getArtifactId())) {
                            continue;
                        }
                        Map<GradleDependencyConfiguration, String> configs = update.getValue();
                        for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {
                            dependenciesToUpdate.put(new GroupArtifact(update.getKey().getGroupId(), update.getKey().getArtifactId()), config.getValue());
                        }
                    }
                }
                dependenciesToUpdateCalculated = true;
            }
            return dependenciesToUpdate;
        }
    }

    @Override
    public DependencyVersionState getInitialValue(ExecutionContext ctx) {
        return new DependencyVersionState();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(DependencyVersionState acc) {
        return Preconditions.check(new IsBuildGradle<>(), new JavaVisitor<ExecutionContext>() {
            @SuppressWarnings(""NotNullFieldNotInitialized"")
            GradleProject gradleProject;

            final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    gradleProject = tree.getMarkers().findFirst(GradleProject.class)
                            .orElseThrow(() -> new IllegalStateException(""Unable to find GradleProject marker.""));
                    acc.updatesPerProject.putIfAbsent(getGradleProjectKey(gradleProject), new HashMap<>());

                    DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);

                    // Determine the configurations used to declare dependencies that requested dependencies in the build
                    List<GradleDependencyConfiguration> declaredConfigurations = gradleProject.getConfigurations().stream()
                            .filter(c -> c.isCanBeDeclared() && !c.getRequested().isEmpty())
                            .collect(toList());

                    configurations:
                    for (GradleDependencyConfiguration configuration : gradleProject.getConfigurations()) {
                        // Skip when there's a direct dependency, as per openrewrite/rewrite#5355
                        for (Dependency dependency : configuration.getRequested()) {
                            if (dependencyMatcher.matches(dependency.getGroupId(), dependency.getArtifactId())) {
                                continue configurations;
                            }
                        }
                        for (ResolvedDependency resolved : configuration.getResolved()) {
                            if (resolved.isTransitive() && dependencyMatcher.matches(resolved.getGroupId(), resolved.getArtifactId(), resolved.getVersion())) {
                                try {
                                    String selected = versionSelector.select(resolved.getGav(), configuration.getName(), version, versionPattern, ctx);
                                    if (selected == null || resolved.getVersion().equals(selected)) {
                                        continue;
                                    }

                                    GradleDependencyConfiguration constraintConfig = constraintConfiguration(configuration, declaredConfigurations);
                                    if (constraintConfig == null) {
                                        continue;
                                    }

                                    acc.updatesPerProject.get(getGradleProjectKey(gradleProject)).merge(
                                            new GroupArtifact(resolved.getGroupId(), resolved.getArtifactId()),
                                            singletonMap(constraintConfig, selected),
                                            (existing, update) -> {
                                                Map<GradleDependencyConfiguration, String> all = new LinkedHashMap<>(existing);
                                                all.putAll(update);
                                                all.keySet().removeIf(c -> {
                                                    if (c == null) {
                                                        return true; // TODO ?? how does this happen
                                                    }

                                                    for (GradleDependencyConfiguration config : all.keySet()) {
                                                        for (GradleDependencyConfiguration gc : c.allExtendsFrom()) {
                                                            if (gc.getName().equals(config.getName())) {
                                                                return true;
                                                            }
                                                        }

                                                        // TODO there has to be a better way!
                                                        if (""runtimeOnly"".equals(c.getName())) {
                                                            if (""implementation"".equals(config.getName())) {
                                                                return true;
                                                            }
                                                        } else if (""testRuntimeOnly"".equals(c.getName())) {
                                                            if (""testImplementation"".equals(config.getName()) || ""implementation"".equals(config.getName())) {
                                                                return true;
                                                            }
                                                        }
                                                    }
                                                    return false;
                                                });
                                                return all;
                                            }
                                    );
                                } catch (MavenDownloadingException e) {
                                    return Markup.warn((JavaSourceFile) tree, e);
                                }
                            }
                        }
                    }
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);

                // If a dependency uses a version property, map the property name to its group:artifact in versionPropNameToGA
                if (m.getArguments().get(0) instanceof G.MapEntry) {
                    String declaredGroupId = null;
                    String declaredArtifactId = null;
                    String declaredVersion = null;

                    for (Expression e : m.getArguments()) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(((J.Literal) arg.getKey()).getValue() instanceof String)) {
                            continue;
                        }

                        String keyValue = (String) ((J.Literal) arg.getKey()).getValue();
                        String valueValue = null;
                        if (arg.getValue() instanceof J.Literal) {
                            J.Literal value = (J.Literal) arg.getValue();
                            if (value.getValue() instanceof String) {
                                valueValue = (String) value.getValue();
                            }
                        } else if (arg.getValue() instanceof J.Identifier) {
                            valueValue = ((J.Identifier) arg.getValue()).getSimpleName();
                        } else if (arg.getValue() instanceof G.GString) {
                            List<J> strings = ((G.GString) arg.getValue()).getStrings();
                            if (!strings.isEmpty() && strings.get(0) instanceof G.GString.Value) {
                                G.GString.Value versionGStringValue = (G.GString.Value) strings.get(0);
                                if (versionGStringValue.getTree() instanceof J.Identifier) {
                                    valueValue = ((J.Identifier) versionGStringValue.getTree()).getSimpleName();
                                }
                            }
                        }

                        switch (keyValue) {
                            case ""group"":
                                declaredGroupId = valueValue;
                                break;
                            case ""name"":
                                declaredArtifactId = valueValue;
                                break;
                            case ""version"":
                                if (arg.getValue() instanceof J.Literal) {
                                    return m;
                                }
                                declaredVersion = valueValue;
                                break;
                        }
                    }
                    if (declaredGroupId == null || declaredArtifactId == null || declaredVersion == null) {
                        return m;
                    }
                    acc.versionPropNameToGA.put(declaredVersion, new GroupArtifact(declaredGroupId, declaredArtifactId));
                } else {
                    for (Expression depArg : m.getArguments()) {
                        if (depArg instanceof G.GString) {
                            List<J> strings = ((G.GString) depArg).getStrings();
                            if (strings.size() == 2 && strings.get(0) instanceof J.Literal && (((J.Literal) strings.get(0)).getValue() instanceof String) && strings.get(1) instanceof G.GString.Value) {
                                org.openrewrite.gradle.internal.Dependency dep = DependencyStringNotationConverter.parse((String) ((J.Literal) strings.get(0)).getValue());
                                if (dep != null) {
                                    G.GString.Value versionValue = (G.GString.Value) strings.get(1);
                                    acc.versionPropNameToGA.put(versionValue.getTree().toString(), new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));
                                }
                            }
                        } else if (depArg instanceof K.StringTemplate) {
                            List<J> strings = ((K.StringTemplate) depArg).getStrings();
                            if (strings.size() == 2 && strings.get(0) instanceof J.Literal && (((J.Literal) strings.get(0)).getValue() instanceof String) && strings.get(1) instanceof K.StringTemplate.Expression) {
                                org.openrewrite.gradle.internal.Dependency dep = DependencyStringNotationConverter.parse((String) ((J.Literal) strings.get(0)).getValue());
                                if (dep != null) {
                                    K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);
                                    acc.versionPropNameToGA.put(versionValue.getTree().toString(), new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));
                                }
                            }
                        }
                    }
                }
                return m;
            }

            /*
             * It is typical in Gradle for there to be a number of unresolvable configurations that developers put
             * dependencies into in their build files, like implementation. Other configurations like compileClasspath
             * and runtimeClasspath are resolvable and will directly or transitively extend from those unresolvable
             * configurations.
             *
             * It isn't impossible to manage the version of the dependency directly in the child configuration, but you
             * might end up with the same dependency managed multiple times, something like this:
             *
             * constraints {
             *     runtimeClasspath(""g:a:v"") { }
             *     compileClasspath(""g:a:v"") { }
             *     testRuntimeClasspath(""g:a:v"") { }
             *     testCompileClasspath(""g:a:v"") { }
             * }
             *
             * whereas if we find a common root configuration, the above can be simplified to:
             *
             * constraints {
             *     implementation(""g:a:v"") { }
             * }
             */
            private @Nullable GradleDependencyConfiguration constraintConfiguration(GradleDependencyConfiguration config, List<GradleDependencyConfiguration> declaredConfigurations) {
                // Check if the resolved configuration e.g. compileClasspath extends from a declared configuration
                // defined in the build e.g. implementation. Constraints should only use the configuration name of the
                // dependency declared in the build.
                Optional<GradleDependencyConfiguration> declaredConfig = config.getExtendsFrom().stream()
                        .filter(declaredConfigurations::contains)
                        .findFirst();

                // The configuration name for the used constraint should be the name of the declared configuration if it exists,
                // otherwise the name of the current configuration
                String constraintConfigName = declaredConfig.map(GradleDependencyConfiguration::getName)
                        .orElseGet(config::getName);

                if (onlyForConfigurations != null && !onlyForConfigurations.isEmpty()) {
                    if (!onlyForConfigurations.contains(constraintConfigName)) {
                        return null;
                    }
                } else {
                    for (GradleDependencyConfiguration extended : config.getExtendsFrom()) {
                        if (extended.getName().equals(constraintConfigName)) {
                            return extended;
                        }
                    }
                }

                GradleDependencyConfiguration configuration = gradleProject.getConfiguration(constraintConfigName);
                if (configuration != null && configuration.isTransitive()) {
                    return configuration;
                }

                return null;
            }
        });
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {
        final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);
        return new TreeVisitor<Tree, ExecutionContext>() {
            private final UpdateGradle updateGradle = new UpdateGradle(acc);
            private final UpdateProperties updateProperties = new UpdateProperties(acc);

            @Override
            public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {
                return updateProperties.isAcceptable(sf, ctx) || updateGradle.isAcceptable(sf, ctx);
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                Tree t = tree;
                if (t instanceof SourceFile) {
                    SourceFile sf = (SourceFile) t;
                    if (updateProperties.isAcceptable(sf, ctx)) {
                        t = updateProperties.visitNonNull(t, ctx);
                    } else if (updateGradle.isAcceptable(sf, ctx)) {
                        t = updateGradle.visitNonNull(t, ctx);
                    }
                    Optional<GradleProject> projectMarker = t.getMarkers().findFirst(GradleProject.class);
                    if (tree != t && projectMarker.isPresent()) {
                        GradleProject gradleProject = projectMarker.get();
                        gradleProject = updatedModel(projectMarker.get(), acc.updatesPerProject.get(getGradleProjectKey(gradleProject)), ctx);
                        if (projectMarker.get() != gradleProject) {
                            t = t.withMarkers(t.getMarkers().setByType(gradleProject));
                        }
                    }
                }
                return t;
            }

            private GradleProject updatedModel(GradleProject gp, Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> toUpdate, ExecutionContext ctx) {
                Map<String, Set<GroupArtifactVersion>> configsToUpdate = new HashMap<>();
                for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : toUpdate.entrySet()) {
                    Map<GradleDependencyConfiguration, String> configs = update.getValue();
                    String groupId = update.getKey().getGroupId();
                    String artifactId = update.getKey().getArtifactId();
                    for (Map.Entry<GradleDependencyConfiguration, String> configToVersion : configs.entrySet()) {
                        String configName = configToVersion.getKey().getName();
                        String newVersion = configToVersion.getValue();
                        configsToUpdate.computeIfAbsent(configName, it -> new HashSet<>())
                                .add(new GroupArtifactVersion(groupId, artifactId, newVersion));
                    }
                }
                return gp.addOrUpdateConstraints(configsToUpdate, ctx);
            }
        };
    }

    @RequiredArgsConstructor
    private class UpdateGradle extends JavaVisitor<ExecutionContext> {
        final DependencyVersionState acc;
        final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);

        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) tree;
                GradleProject gradleProject = cu.getMarkers().findFirst(GradleProject.class).orElse(null);
                Map<GroupArtifact, Map<GradleDependencyConfiguration, String>> projectRequiredUpdates = gradleProject != null ? acc.updatesPerProject.getOrDefault(getGradleProjectKey(gradleProject), emptyMap()) : emptyMap();
                if (projectRequiredUpdates.keySet().stream().anyMatch(ga -> dependencyMatcher.matches(ga.getGroupId(), ga.getArtifactId()))) {
                    cu = (JavaSourceFile) Preconditions.check(
                            not(new JavaIsoVisitor<ExecutionContext>() {
                                @Override
                                public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                                    if (tree instanceof G.CompilationUnit) {
                                        return new UsesMethod<>(CONSTRAINTS_MATCHER).visit(tree, ctx);
                                    }
                                    // Kotlin is not type attributed, so do things more manually
                                    return super.visit(tree, ctx);
                                }

                                @Override
                                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                    J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                                    if (""constraints"".equals(m.getSimpleName()) && withinBlock(getCursor(), ""dependencies"")) {
                                        return SearchResult.found(m);
                                    }
                                    return m;
                                }
                            }),
                            new AddConstraintsBlock(cu instanceof K.CompilationUnit)
                    ).visitNonNull(cu, ctx);

                    for (Map.Entry<GroupArtifact, Map<GradleDependencyConfiguration, String>> update : projectRequiredUpdates.entrySet()) {
                        if (!dependencyMatcher.matches(update.getKey().getGroupId(), update.getKey().getArtifactId())) {
                            continue;
                        }
                        Map<GradleDependencyConfiguration, String> configs = update.getValue();
                        for (Map.Entry<GradleDependencyConfiguration, String> config : configs.entrySet()) {
                            cu = (JavaSourceFile) new AddConstraint(cu instanceof K.CompilationUnit, config.getKey().getName(), new GroupArtifactVersion(update.getKey().getGroupId(),
                                    update.getKey().getArtifactId(), config.getValue()), gradleProject, because).visitNonNull(cu, ctx);
                        }
                    }

                    // Spring dependency management plugin stomps on constraints. Use an alternative mechanism it does not override
                    if (gradleProject.getPlugins().stream().anyMatch(plugin -> ""io.spring.dependency-management"".equals(plugin.getId()))) {
                        cu = (JavaSourceFile) new DependencyConstraintToRule().getVisitor().visitNonNull(cu, ctx);
                    }
                }
                if (cu != tree) {
                    return cu;
                }
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
            // rare case that gradle versions are set via settings.gradle ext block (only possible for Groovy DSL)
            if (""ext"".equals(method.getSimpleName()) && getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().endsWith(""settings.gradle"")) {
                m = (J.MethodInvocation) new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext executionContext) {
                        J.Assignment a = super.visitAssignment(assignment, executionContext);
                        if (!(a.getVariable() instanceof J.Identifier)) {
                            return a;
                        }
                        GroupArtifact ga = acc.versionPropNameToGA.get(""gradle."" + a.getVariable());
                        if (acc.dependenciesToUpdate(dependencyMatcher).containsKey(ga)) {
                            if (!(a.getAssignment() instanceof J.Literal)) {
                                return a;
                            }
                            J.Literal l = (J.Literal) a.getAssignment();
                            String newVersion = acc.dependenciesToUpdate(dependencyMatcher).get(ga);
                            String quote = l.getValueSource() == null ? ""\"""" : l.getValueSource().substring(0, 1);
                            a = a.withAssignment(l.withValue(newVersion).withValueSource(quote + newVersion + quote));
                        }
                        return a;
                    }
                }.visitNonNull(m, ctx, getCursor().getParentTreeCursor());
            }
            return m;
        }
    }

    @RequiredArgsConstructor
    private class UpdateProperties extends PropertiesVisitor<ExecutionContext> {
        final DependencyVersionState acc;
        final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);

        @Override
        public Properties visitFile(Properties.File file, ExecutionContext ctx) {
            return file.getSourcePath().endsWith(""gradle.properties"") ? super.visitFile(file, ctx) : file;
        }

        @Override
        public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
            GroupArtifact ga = acc.versionPropNameToGA.get(entry.getKey());
            if (acc.dependenciesToUpdate(dependencyMatcher).containsKey(ga)) {
                return entry.withValue(entry.getValue().withText(acc.dependenciesToUpdate(dependencyMatcher).get(ga)));
            }
            return entry;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class AddConstraintsBlock extends JavaIsoVisitor<ExecutionContext> {
        boolean isKotlinDsl;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

            if (DEPENDENCIES_DSL_MATCHER.matches(method)) {
                G.CompilationUnit withConstraints = (G.CompilationUnit) parseAsGradle(
                        //language=groovy
                        ""plugins { id 'java' }\n"" +
                        ""dependencies {\n"" +
                        ""    constraints {\n"" +
                        ""    }\n"" +
                        ""}\n"", false, ctx)
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse constraints block""));

                Statement constraints = FindMethods.find(withConstraints, ""org.gradle.api.artifacts.dsl.DependencyHandler constraints(..)"", true)
                        .stream()
                        .filter(J.MethodInvocation.class::isInstance)
                        .map(J.MethodInvocation.class::cast)
                        .filter(m2 -> ""constraints"".equals(m2.getSimpleName()))
                        .findFirst()
                        .orElseThrow(() -> new IllegalStateException(""Unable to find constraints block""))
                        .withMarkers(Markers.EMPTY);

                return autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                    if (!(arg instanceof J.Lambda)) {
                        return arg;
                    }
                    J.Lambda dependencies = (J.Lambda) arg;
                    if (!(dependencies.getBody() instanceof J.Block)) {
                        return m;
                    }
                    J.Block body = (J.Block) dependencies.getBody();

                    List<Statement> statements = ListUtils.mapFirst(body.getStatements(), stat -> stat.withPrefix(stat.getPrefix().withWhitespace(
                            BlankLinesVisitor.minimumLines(stat.getPrefix().getWhitespace(), 1))));
                    return dependencies.withBody(body.withStatements(
                            ListUtils.concat(constraints, statements)));
                })), constraints, ctx, getCursor().getParentOrThrow());
            } else if (isKotlinDsl && ""dependencies"".equals(m.getSimpleName()) && getCursor().getParentTreeCursor().firstEnclosing(J.MethodInvocation.class) == null) {
                K.CompilationUnit withConstraints = (K.CompilationUnit) parseAsGradle(
                        //language=kotlin
                        ""plugins { id(\""java\"") }\n"" +
                        ""dependencies {\n"" +
                        ""    constraints {}\n"" +
                        ""}\n"", true, ctx)
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse constraints block""));

                J.MethodInvocation constraints = withConstraints.getStatements()
                        .stream()
                        .map(J.Block.class::cast)
                        .flatMap(block -> block.getStatements().stream())
                        .filter(J.MethodInvocation.class::isInstance)
                        .map(J.MethodInvocation.class::cast)
                        .filter(m2 -> ""dependencies"".equals(m2.getSimpleName()))
                        .flatMap(dependencies -> ((J.Block) ((J.Lambda) dependencies.getArguments().get(0)).getBody()).getStatements().stream())
                        .filter(J.MethodInvocation.class::isInstance)
                        .map(J.MethodInvocation.class::cast)
                        .filter(m2 -> ""constraints"".equals(m2.getSimpleName()))
                        .findFirst()
                        .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {
                            J.Lambda lambda = (J.Lambda) arg;
                            return lambda.withBody(((J.Block) lambda.getBody()).withEnd(Space.format(""\n"")));
                        })))
                        .orElseThrow(() -> new IllegalStateException(""Unable to find constraints block""))
                        .withMarkers(Markers.EMPTY);

                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                    if (!(arg instanceof J.Lambda)) {
                        return arg;
                    }
                    J.Lambda dependencies = (J.Lambda) arg;
                    if (!(dependencies.getBody() instanceof J.Block)) {
                        return m;
                    }
                    J.Block body = (J.Block) dependencies.getBody();

                    List<Statement> statements = ListUtils.mapFirst(body.getStatements(), stat -> stat.withPrefix(stat.getPrefix().withWhitespace(
                            BlankLinesVisitor.minimumLines(stat.getPrefix().getWhitespace(), 1))));
                    return dependencies.withBody(body.withStatements(
                            ListUtils.concat(autoFormat(constraints, ctx, getCursor().getParentOrThrow()), statements)));
                }));
            }

            return m;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class AddConstraint extends JavaIsoVisitor<ExecutionContext> {
        boolean isKotlinDsl;
        String config;
        GroupArtifactVersion gav;
        GradleProject gradleProject;

        @Nullable
        String because;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (!CONSTRAINTS_MATCHER.matches(m) && !(isKotlinDsl && ""constraints"".equals(m.getSimpleName()) && withinBlock(getCursor(), ""dependencies""))) {
                return m;
            }
            String ga = gav.getGroupId() + "":"" + gav.getArtifactId();
            String existingConstraintVersion = null;
            J.MethodInvocation existingConstraint = null;
            List<J.MethodInvocation> constraintsToRemove = new ArrayList<>();
            MethodMatcher constraintMatcher = new MethodMatcher(CONSTRAINT_MATCHER, true);

            // Find the configuration being added
            GradleDependencyConfiguration targetConfig = gradleProject.getConfiguration(config);

            // Check all constraints
            if (!(m.getArguments().get(0) instanceof J.Lambda) || !(((J.Lambda) m.getArguments().get(0)).getBody() instanceof J.Block)) {
                return m;
            }
            for (Statement statement : ((J.Block) ((J.Lambda) m.getArguments().get(0)).getBody()).getStatements()) {
                if (statement instanceof J.MethodInvocation || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation)) {
                    J.MethodInvocation m2 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() : statement);
                    if ((!isKotlinDsl && constraintMatcher.matches(m2)) || (isKotlinDsl && ""constraints"".equals(m.getSimpleName()))) {
                        if (matchesConstraint(m2, ga)) {
                            if (m2.getSimpleName().equals(config)) {
                                existingConstraint = m2;
                                if (m2.getArguments().get(0) instanceof J.Literal) {
                                    org.openrewrite.gradle.internal.Dependency notation = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) m2.getArguments().get(0)).getValue()));
                                    if (notation == null) {
                                        continue;
                                    }
                                    existingConstraintVersion = notation.getVersion();
                                }
                            } else if (targetConfig != null) {
                                // Check if this constraint is on a configuration that extends from our target
                                GradleDependencyConfiguration constraintConfig = gradleProject.getConfiguration(m2.getSimpleName());
                                if (constraintConfig != null && constraintConfig.allExtendsFrom().contains(targetConfig)) {
                                    constraintsToRemove.add(m2);
                                }
                            }
                        }
                    }
                }
            }

            if (Objects.equals(gav.getVersion(), existingConstraintVersion)) {
                return m;
            }

            // Remove constraints from child configurations
            if (!constraintsToRemove.isEmpty()) {
                m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                    if (!(arg instanceof J.Lambda)) {
                        return arg;
                    }
                    J.Lambda lambda = (J.Lambda) arg;
                    if (!(lambda.getBody() instanceof J.Block)) {
                        return arg;
                    }
                    J.Block body = (J.Block) lambda.getBody();
                    List<Statement> statements = new ArrayList<>(body.getStatements());
                    statements.removeIf(statement -> {
                        if (statement instanceof J.MethodInvocation) {
                            return constraintsToRemove.contains(statement);
                        } else if (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation) {
                            return constraintsToRemove.contains(((J.Return) statement).getExpression());
                        }
                        return false;
                    });
                    return lambda.withBody(body.withStatements(statements));
                }));
            }

            if (existingConstraint == null) {
                m = (J.MethodInvocation) new CreateConstraintVisitor(config, gav, because, isKotlinDsl)
                        .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));
            } else {
                m = (J.MethodInvocation) new UpdateConstraintVersionVisitor(gav, existingConstraint, because, isKotlinDsl)
                        .visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));
            }
            return m;
        }

        private boolean matchesConstraint(J.MethodInvocation m, String ga) {
            Expression arg = m.getArguments().get(0);

            if (arg instanceof G.MapEntry) {
                String declaredGroupId = null;
                String declaredArtifactId = null;

                for (Expression e : m.getArguments()) {
                    if (!(e instanceof G.MapEntry)) {
                        continue;
                    }
                    G.MapEntry entry = (G.MapEntry) e;
                    if (!(entry.getKey() instanceof J.Literal) || !(((J.Literal) entry.getKey()).getValue() instanceof String)) {
                        continue;
                    }
                    String keyValue = (String) ((J.Literal) entry.getKey()).getValue();
                    if (entry.getValue() instanceof J.Literal) {
                        J.Literal value = (J.Literal) entry.getValue();
                        if (value.getValue() instanceof String) {
                            if (""group"".equals(keyValue)) {
                                declaredGroupId = (String) value.getValue();
                            } else if (""name"".equals(keyValue)) {
                                declaredArtifactId = (String) value.getValue();
                            }
                        }
                    }
                }
                return (declaredGroupId + "":"" + declaredArtifactId).equals(ga);
            } else if (arg instanceof G.GString || arg instanceof K.StringTemplate) {
                List<J> strings = arg instanceof G.GString ? ((G.GString) arg).getStrings() : ((K.StringTemplate) arg).getStrings();
                for (J j : strings) {
                    if (j instanceof J.Literal && ((J.Literal) j).getValue() != null && ((J.Literal) j).getValue().toString().startsWith(ga)) {
                        return true;
                    }
                }
                return false;
            }  else if (arg instanceof J.Literal && ((J.Literal) arg).getValue() != null) {
                return ((J.Literal) arg).getValue().toString().startsWith(ga);
            }
            return false;
        }
    }

    //language=groovy
    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY =
            ""plugins {\n"" +
            ""    id 'java'\n"" +
            ""}\n"" +
            ""dependencies {\n"" +
            ""    constraints {\n"" +
            ""        implementation('foobar')\n"" +
            ""    }\n"" +
            ""}"";
    //language=kotlin
    private static final String INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN =
            ""plugins {\n"" +
            ""    id(\""java\"")\n"" +
            ""}\n"" +
            ""dependencies {\n"" +
            ""    constraints {\n"" +
            ""        implementation(\""foobar\"")\n"" +
            ""    }\n"" +
            ""}"";
    //language=groovy
    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY =
            ""plugins {\n"" +
            ""    id 'java'\n"" +
            ""}\n"" +
            ""dependencies {\n"" +
            ""    constraints {\n"" +
            ""        implementation('foobar') {\n"" +
            ""            because 'because'\n"" +
            ""        }\n"" +
            ""    }\n"" +
            ""}"";
    //language=kotlin
    private static final String INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN =
            ""plugins {\n"" +
            ""    id(\""java\"")\n"" +
            ""}\n"" +
            ""dependencies {\n"" +
            ""    constraints {\n"" +
            ""        implementation(\""foobar\"") {\n"" +
            ""            because(\""because\"")\n"" +
            ""        }\n"" +
            ""    }\n"" +
            ""}"";

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class CreateConstraintVisitor extends JavaIsoVisitor<ExecutionContext> {

        String config;
        GroupArtifactVersion gav;

        @Nullable
        String because;

        boolean isKotlinDsl;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (""version"".equals(method.getSimpleName())) {
                return method;
            }
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

            J.MethodInvocation constraint;
            if (!isKotlinDsl) {
                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_GROOVY : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)
                        .map(G.CompilationUnit.class::cast)
                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))
                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))
                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())
                        .map(dependenciesBody -> (J.Return) dependenciesBody.getStatements().get(0))
                        .map(returnConstraints -> (J.MethodInvocation) returnConstraints.getExpression())
                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))
                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())
                        .map(constraintsBlock -> (J.Return) constraintsBlock.getStatements().get(0))
                        .map(returnConfiguration -> (J.MethodInvocation) returnConfiguration.getExpression())
                        .map(it -> it.withName(it.getName().withSimpleName(config))
                                .withArguments(ListUtils.map(it.getArguments(), arg -> {
                                    if (arg instanceof J.Literal) {
                                        return ((J.Literal) requireNonNull(arg))
                                                .withValue(gav.toString())
                                                .withValueSource(""'"" + gav + ""'"");
                                    } else if (arg instanceof J.Lambda && because != null) {
                                        return (Expression) new GroovyIsoVisitor<Integer>() {
                                            @Override
                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {
                                                return literal.withValue(because)
                                                        .withValueSource(""'"" + because + ""'"");
                                            }
                                        }.visitNonNull(arg, 0);
                                    }
                                    return arg;
                                })))
                        // Assign a unique ID so multiple constraints can be added
                        .map(it -> it.withId(Tree.randomId()))
                        .orElseThrow(() -> new IllegalStateException(""Unable to find constraint""));
            } else {
                constraint = parseAsGradle(because == null ? INDIVIDUAL_CONSTRAINT_SNIPPET_KOTLIN : INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN, true, ctx)
                        .map(K.CompilationUnit.class::cast)
                        .map(it -> (J.Block) it.getStatements().get(0))
                        .map(it -> (J.MethodInvocation) it.getStatements().get(1))
                        .map(dependenciesMethod -> (J.Lambda) dependenciesMethod.getArguments().get(0))
                        .map(dependenciesClosure -> (J.Block) dependenciesClosure.getBody())
                        .map(dependenciesBody -> (J.MethodInvocation) dependenciesBody.getStatements().get(0))
                        .map(constraintsInvocation -> (J.Lambda) constraintsInvocation.getArguments().get(0))
                        .map(constraintsLambda -> (J.Block) constraintsLambda.getBody())
                        .map(constraintsBlock -> (J.MethodInvocation) constraintsBlock.getStatements().get(0))
                        .map(it -> it.withName(it.getName().withSimpleName(config))
                                .withArguments(ListUtils.map(it.getArguments(), arg -> {
                                    if (arg instanceof J.Literal) {
                                        return ChangeStringLiteral.withStringValue((J.Literal) requireNonNull(arg), gav.toString());
                                    } else if (arg instanceof J.Lambda && because != null) {
                                        return (Expression) new KotlinIsoVisitor<Integer>() {
                                            @Override
                                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {
                                                return ChangeStringLiteral.withStringValue(literal, because);
                                            }
                                        }.visitNonNull(arg, 0);
                                    }
                                    return arg;
                                })))
                        // Assign a unique ID so multiple constraints can be added
                        .map(it -> it.withId(Tree.randomId()))
                        .orElseThrow(() -> new IllegalStateException(""Unable to find constraint""));
            }

            return autoFormat(m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                if (!(arg instanceof J.Lambda)) {
                    return arg;
                }
                J.Lambda dependencies = (J.Lambda) arg;
                if (!(dependencies.getBody() instanceof J.Block)) {
                    return arg;
                }
                J.Block body = (J.Block) dependencies.getBody();

                return dependencies.withBody(body.withStatements(
                        ListUtils.concat(constraint, body.getStatements())));
            })), ctx, getCursor().getParentOrThrow());
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class UpdateConstraintVersionVisitor extends JavaIsoVisitor<ExecutionContext> {
        GroupArtifactVersion gav;
        J.MethodInvocation existingConstraint;

        @Nullable
        String because;

        boolean isKotlinDsl;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (""version"".equals(method.getSimpleName())) {
                return method;
            }
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (existingConstraint.isScope(m)) {
                AtomicBoolean updatedBecause = new AtomicBoolean(false);
                m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                    if (arg instanceof J.Literal) {
                        String valueSource = ((J.Literal) arg).getValueSource();
                        char quote;
                        if (valueSource == null) {
                            quote = '\'';
                        } else {
                            quote = valueSource.charAt(0);
                        }
                        return ((J.Literal) arg).withValue(gav.toString())
                                .withValueSource(quote + gav.toString() + quote);
                    } else if (arg instanceof J.Lambda) {
                        arg = (Expression) new RemoveVersionVisitor().visitNonNull(arg, ctx);
                    }
                    if (because != null) {
                        Expression arg2 = (Expression) new UpdateBecauseTextVisitor(because)
                                .visitNonNull(arg, ctx, getCursor());
                        if (arg2 != arg) {
                            updatedBecause.set(true);
                        }
                        return arg2;
                    }
                    return arg;
                }));
                if (because != null && !updatedBecause.get()) {
                    m = (J.MethodInvocation) new CreateBecauseVisitor(because, isKotlinDsl).visitNonNull(m, ctx, requireNonNull(getCursor().getParent()));
                }
            }
            return m;
        }
    }

    @SuppressWarnings(""NullableProblems"")
    private static class RemoveVersionVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.@Nullable Return visitReturn(J.Return _return, ExecutionContext ctx) {
            J.Return r = super.visitReturn(_return, ctx);
            if (r.getExpression() == null) {
                return null;
            }
            return r;
        }

        @Override
        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (""version"".equals(m.getSimpleName()) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda) {
                return null;
            }
            return m;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class UpdateBecauseTextVisitor extends JavaIsoVisitor<ExecutionContext> {
        String because;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (!""because"".equals(m.getSimpleName())) {
                return m;
            }
            return m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                if (arg instanceof J.Literal) {
                    char quote;
                    if (((J.Literal) arg).getValueSource() == null) {
                        quote = '""';
                    } else {
                        quote = ((J.Literal) arg).getValueSource().charAt(0);
                    }
                    return ((J.Literal) arg).withValue(because)
                            .withValueSource(quote + because + quote);
                }
                return arg;
            }));
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class CreateBecauseVisitor extends JavaIsoVisitor<ExecutionContext> {
        String because;
        boolean isKotlinDsl;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            J.Lambda becauseArg;
            if (!isKotlinDsl) {
                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_GROOVY, false, ctx)
                        .map(G.CompilationUnit.class::cast)
                        .map(cu -> (J.MethodInvocation) cu.getStatements().get(1))
                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))
                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))
                        .map(J.Return.class::cast)
                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))
                        .map(J.Lambda.class::cast)
                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))
                        .map(J.Return.class::cast)
                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))
                        .map(J.Lambda.class::cast)
                        .map(it -> (J.Lambda) new GroovyIsoVisitor<Integer>() {
                            @Override
                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {
                                return literal.withValue(because)
                                        .withValueSource(""'"" + because + ""'"");
                            }
                        }.visitNonNull(it, 0))
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse because text""));
            } else {
                becauseArg = parseAsGradle(INDIVIDUAL_CONSTRAINT_BECAUSE_SNIPPET_KOTLIN, true, ctx)
                        .map(K.CompilationUnit.class::cast)
                        .map(cu -> (J.Block) cu.getStatements().get(0))
                        .map(block -> (J.MethodInvocation) block.getStatements().get(1))
                        .map(dependencies -> (J.Lambda) dependencies.getArguments().get(0))
                        .map(dependenciesClosure -> ((J.Block) dependenciesClosure.getBody()).getStatements().get(0))
                        .map(J.Return.class::cast)
                        .map(returnConstraints -> ((J.MethodInvocation) requireNonNull(returnConstraints.getExpression())).getArguments().get(0))
                        .map(J.Lambda.class::cast)
                        .map(constraintsClosure -> ((J.Block) constraintsClosure.getBody()).getStatements().get(0))
                        .map(J.Return.class::cast)
                        .map(returnImplementation -> ((J.MethodInvocation) requireNonNull(returnImplementation.getExpression())).getArguments().get(1))
                        .map(J.Lambda.class::cast)
                        .map(it -> (J.Lambda) new KotlinIsoVisitor<Integer>() {
                            @Override
                            public J.Literal visitLiteral(J.Literal literal, Integer integer) {
                                return literal.withValue(because)
                                        .withValueSource(""\"""" + because + ""\"""");
                            }
                        }.visitNonNull(it, 0))
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse because text""));
            }
            m = m.withArguments(ListUtils.concat(m.getArguments().subList(0, 1), becauseArg));
            return autoFormat(m, ctx, getCursor().getParentOrThrow());
        }
    }

    private static boolean withinBlock(Cursor cursor, String name) {
        Cursor parentCursor = cursor.getParent();
        while (parentCursor != null) {
            if (parentCursor.getValue() instanceof J.MethodInvocation) {
                J.MethodInvocation m = parentCursor.getValue();
                if (m.getSimpleName().equals(name)) {
                    return true;
                }
            }
            parentCursor = parentCursor.getParent();
        }

        return false;
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change a Gradle dependency classifier,Changes classifier of an existing dependency declared in `build.gradle` files.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.semver.DependencyMatcher;

import java.util.*;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyClassifier extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New classifier"",
            description = ""A qualification classifier for the dependency."",
            example = ""sources"",
            required = false)
    @Nullable
    String newClassifier;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change a Gradle dependency classifier"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s` to `%s`"", groupId, artifactId, newClassifier);
    }

    @Override
    public String getDescription() {
        return ""Changes classifier of an existing dependency declared in `build.gradle` files."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(DependencyMatcher.build(groupId + "":"" + artifactId));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(groupId + "":"" + artifactId).getValue());

            GradleProject gradleProject;

            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);
                if (!maybeGp.isPresent()) {
                    return cu;
                }

                gradleProject = maybeGp.get();

                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);
                if (g != cu) {
                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));
                }
                return g;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .configuration(configuration)
                        .groupId(groupId)
                        .artifactId(artifactId);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal) {
                    String gav = (String) ((J.Literal) depArgs.get(0)).getValue();
                    if (gav != null) {
                        Dependency dependency = DependencyStringNotationConverter.parse(gav);
                        if (dependency != null && dependency.getVersion() != null && !Objects.equals(newClassifier, dependency.getClassifier())) {
                            Dependency newDependency = dependency.withClassifier(newClassifier);
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, newDependency.toStringNotation())));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.MapEntry) {
                    G.MapEntry classifierEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String version = null;
                    String classifier = null;

                    String groupDelimiter = ""'"";
                    G.MapEntry mapEntry = null;
                    String classifierStringDelimiter = null;
                    int index = 0;
                    for (Expression e : depArgs) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                            if (value.getValueSource() != null) {
                                groupDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                        } else if (""name"".equals(keyValue)) {
                            if (index > 0 && mapEntry == null) {
                                mapEntry = arg;
                            }
                            artifactId = valueValue;
                        } else if (""version"".equals(keyValue)) {
                            version = valueValue;
                        } else if (""classifier"".equals(keyValue)) {
                            if (value.getValueSource() != null) {
                                classifierStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            classifierEntry = arg;
                            classifier = valueValue;
                        }
                        index++;
                    }
                    if (groupId == null || artifactId == null || Objects.equals(newClassifier, classifier)) {
                        return m;
                    }

                    if (classifier == null) {
                        String delimiter = groupDelimiter;
                        List<Expression> args = m.getArguments();
                        J.Literal keyLiteral = new J.Literal(Tree.randomId(), mapEntry == null ? Space.EMPTY : mapEntry.getKey().getPrefix(), Markers.EMPTY, ""classifier"", ""classifier"", null, JavaType.Primitive.String);
                        J.Literal valueLiteral = new J.Literal(Tree.randomId(), mapEntry == null ? Space.EMPTY : mapEntry.getValue().getPrefix(), Markers.EMPTY, newClassifier, delimiter + newClassifier + delimiter, null, JavaType.Primitive.String);
                        args.add(new G.MapEntry(Tree.randomId(), mapEntry == null ? Space.EMPTY : mapEntry.getPrefix(), Markers.EMPTY, JRightPadded.build(keyLiteral), valueLiteral, null));
                        m = m.withArguments(args);
                    } else {
                        G.MapEntry finalClassifier = classifierEntry;
                        if (newClassifier == null) {
                            m = m.withArguments(ListUtils.map(m.getArguments(), arg -> arg == finalClassifier ? null : arg));
                        } else {
                            String delimiter = classifierStringDelimiter; // `classifierStringDelimiter` cannot be null
                            m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                                if (arg == finalClassifier) {
                                    return finalClassifier.withValue(((J.Literal) finalClassifier.getValue())
                                            .withValue(newClassifier)
                                            .withValueSource(delimiter + newClassifier + delimiter));
                                }
                                return arg;
                            }));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.MapLiteral) {
                    G.MapLiteral map = (G.MapLiteral) depArgs.get(0);
                    G.MapEntry classifierEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String classifier = null;

                    String groupDelimiter = ""'"";
                    G.MapEntry mapEntry = null;
                    String classifierStringDelimiter = null;
                    int index = 0;
                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                            if (value.getValueSource() != null) {
                                groupDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                        } else if (""name"".equals(keyValue)) {
                            if (index > 0 && mapEntry == null) {
                                mapEntry = arg;
                            }
                            artifactId = valueValue;
                        } else if (""classifier"".equals(keyValue)) {
                            if (value.getValueSource() != null) {
                                classifierStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            classifierEntry = arg;
                            classifier = valueValue;
                        }
                        index++;
                    }
                    if (groupId == null || artifactId == null || Objects.equals(newClassifier, classifier)) {
                        return m;
                    }

                    if (classifier == null) {
                        String delimiter = groupDelimiter;
                        G.MapEntry finalMapEntry = mapEntry;
                        J.Literal keyLiteral = new J.Literal(Tree.randomId(), mapEntry == null ? Space.EMPTY : mapEntry.getKey().getPrefix(), Markers.EMPTY, ""classifier"", ""classifier"", null, JavaType.Primitive.String);
                        J.Literal valueLiteral = new J.Literal(Tree.randomId(), mapEntry == null ? Space.EMPTY : mapEntry.getValue().getPrefix(), Markers.EMPTY, newClassifier, delimiter + newClassifier + delimiter, null, JavaType.Primitive.String);
                        m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                            G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                            return mapLiteral.withElements(ListUtils.concat(mapLiteral.getElements(), new G.MapEntry(Tree.randomId(), finalMapEntry == null ? Space.EMPTY : finalMapEntry.getPrefix(), Markers.EMPTY, JRightPadded.build(keyLiteral), valueLiteral, null)));
                        }));
                    } else {
                        G.MapEntry finalClassifier = classifierEntry;
                        if (newClassifier == null) {
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                                G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                                return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> e == finalClassifier ? null : e));
                            }));
                        } else {
                            String delimiter = classifierStringDelimiter; // `classifierStringDelimiter` cannot be null
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                                G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                                return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> {
                                    if (e == finalClassifier) {
                                        return finalClassifier.withValue(((J.Literal) finalClassifier.getValue())
                                                .withValue(newClassifier)
                                                .withValueSource(delimiter + newClassifier + delimiter));
                                    }
                                    return e;
                                }));
                            }));
                        }
                    }
                }

                return m;
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    if (!StringUtils.isBlank(configuration) && !configuration.equals(gdc.getName())) {
                        newNameToConfiguration.put(gdc.getName(), gdc);
                        continue;
                    }

                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId()) && !Objects.equals(requested.getClassifier(), newClassifier)) {
                            return requested.withClassifier(newClassifier);
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId()) && !Objects.equals(resolved.getClassifier(), newClassifier)) {
                            return resolved.withClassifier(newClassifier);
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Add Gradle platform dependency,Add a gradle platform dependency to a `build.gradle` file in the correct configuration based on where it is used.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.search.FindJVMTestSuites;
import org.openrewrite.gradle.trait.JvmTestSuite;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.semver.Semver;

import java.util.*;

import static java.lang.Boolean.TRUE;
import static java.util.Collections.singletonList;
import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.ENFORCED_PLATFORM;
import static org.openrewrite.gradle.AddDependencyVisitor.DependencyModifier.PLATFORM;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddPlatformDependency extends ScanningRecipe<AddPlatformDependency.Scanned> {

    @EqualsAndHashCode.Exclude
    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'com.google.guava:guava:VERSION'."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'com.google.guava:guava:VERSION'"",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                    ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                    ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                    ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""29.X"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example, "" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Configuration"",
            description = ""A configuration to use when it is not what can be inferred from usage. Most of the time this will be left empty, but "" +
                    ""is used when adding a new, as yet unused, dependency."",
            example = ""implementation"",
            required = false)
    @Nullable
    String configuration;

    @Option(displayName = ""Enforced"",
            description = ""Used to determine whether the platform dependency should be enforcedPlatform."",
            example = ""true"",
            required = false)
    @Nullable
    Boolean enforced;

    @Override
    public String getDisplayName() {
        return ""Add Gradle platform dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add a gradle platform dependency to a `build.gradle` file in the correct configuration based on where it is used."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    public static class Scanned {
        Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();
    }

    @Override
    public Scanned getInitialValue(ExecutionContext ctx) {
        return new Scanned();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile sourceFile = (SourceFile) tree;
                sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {
                    Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());
                    sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->
                            configurations.add(""main"".equals(sourceSet.getName()) ? ""implementation"" : sourceSet.getName() + ""Implementation""));
                });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {
        return Preconditions.check(!acc.configurationsByProject.isEmpty(),
                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                        if (!(tree instanceof JavaSourceFile)) {
                            return (J) tree;
                        }
                        JavaSourceFile s = (JavaSourceFile) tree;
                        Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);
                        Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);
                        if (!maybeJp.isPresent() || !acc.configurationsByProject.containsKey(maybeJp.get()) || !maybeGp.isPresent()) {
                            return s;
                        }

                        JavaProject jp = maybeJp.get();
                        GradleProject gp = maybeGp.get();

                        Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?
                                acc.configurationsByProject.getOrDefault(jp, new HashSet<>()) :
                                new HashSet<>(singletonList(configuration));
                        if (resolvedConfigurations.isEmpty()) {
                            resolvedConfigurations.add(""implementation"");
                        }

                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);
                        gradleConfigurationFilter.removeTransitiveConfigurations();
                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));
                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();

                        if (resolvedConfigurations.isEmpty()) {
                            return s;
                        }

                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);
                        AddDependencyVisitor.DependencyModifier modifier = TRUE.equals(enforced) ? ENFORCED_PLATFORM : PLATFORM;
                        for (String resolvedConfiguration : resolvedConfigurations) {
                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);
                            if (jvmTestSuite != null) {
                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern,
                                                null, null, metadataFailures, modifier, ctx).visitNonNull(s, ctx);
                            } else {
                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,
                                        null, null, metadataFailures, this::isTopLevel, modifier).visitNonNull(s, ctx);
                            }
                        }

                        return s;
                    }

                    private boolean isTopLevel(Cursor cursor) {
                        return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;
                    }

                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {
                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {
                            if (jvmTestSuite.isAcceptable(configuration)) {
                                return jvmTestSuite;
                            }
                        }
                        return null;
                    }
                }));
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Enable Develocity build cache,Adds `buildCache` configuration to `develocity` where not yet present.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.tree.J;

import java.util.concurrent.atomic.AtomicBoolean;

@Value
@EqualsAndHashCode(callSuper = false)
public class EnableDevelocityBuildCache extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Enable Develocity build cache"";
    }

    @Override
    public String getDescription() {
        return ""Adds `buildCache` configuration to `develocity` where not yet present."";
    }

    @Option(displayName = ""Enable remote build cache"",
            description = ""Value for `//develocity/buildCache/remote/enabled`."",
            example = ""true"",
            required = false)
    @Nullable
    String remoteEnabled;

    @Option(displayName = ""Enable remote build cache push"",
            description = ""Value for `//develocity/buildCache/remote/storeEnabled`."",
            example = ""System.getenv(\""CI\"") != null"",
            required = false)
    @Nullable
    String remotePushEnabled;

    @Override
    public Validated<Object> validate(ExecutionContext ctx) {
        return super.validate(ctx)
                .and(Validated.notBlank(""remoteEnabled"", remoteEnabled)
                        .or(Validated.notBlank(""remotePushEnabled"", remotePushEnabled)));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsSettingsGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (""develocity"".equals(method.getSimpleName()) && !hasBuildCache(method)) {
                    J.MethodInvocation buildCache = createBuildCache(ctx);
                    return maybeAutoFormat(method, method.withArguments(ListUtils.mapFirst(method.getArguments(), arg -> {
                        if (arg instanceof J.Lambda) {
                            J.Lambda lambda = (J.Lambda) arg;
                            J.Block block = (J.Block) lambda.getBody();
                            return lambda.withBody(block.withStatements(ListUtils.concat(block.getStatements(), buildCache)));
                        }
                        return arg;
                    })), ctx);
                }
                return method;
            }

            private boolean hasBuildCache(J.MethodInvocation m) {
                return new GroovyIsoVisitor<AtomicBoolean>() {
                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean atomicBoolean) {
                        if (""buildCache"".equals(method.getSimpleName())) {
                            atomicBoolean.set(true);
                            return method;
                        }
                        return super.visitMethodInvocation(method, atomicBoolean);
                    }
                }.reduce(m, new AtomicBoolean(false), getCursor().getParentTreeCursor()).get();
            }
        });
    }

    private J.MethodInvocation createBuildCache(ExecutionContext ctx) {
        String conf = ""buildCache {\n"" +
                ""    remote(develocity.buildCache) {\n"";
        if (!StringUtils.isBlank(remoteEnabled)) {
            conf += ""        enabled = "" + remoteEnabled + ""\n"";
        }
        if (!StringUtils.isBlank(remotePushEnabled)) {
            conf += ""        push = "" + remotePushEnabled + ""\n"";
        }
        conf += ""    }"" +
                ""}"";
        return (J.MethodInvocation) GradleParser.builder().build()
                .parse(ctx, conf)
                .map(G.CompilationUnit.class::cast)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException(""Could not parse as Gradle""))
                .getStatements()
                .get(0);
    }
}
",{}
Remove an enabled Gradle preview feature,Remove an enabled Gradle preview feature from `settings.gradle`.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveEnableFeaturePreview extends Recipe {

    @Option(displayName = ""The feature preview name"",
            description = ""The name of the feature preview to remove."",
            example = ""ONE_LOCKFILE_PER_PROJECT"")
    String previewFeatureName;

    @Override
    public String getDisplayName() {
        return ""Remove an enabled Gradle preview feature"";
    }

    @Override
    public String getDescription() {
        return ""Remove an enabled Gradle preview feature from `settings.gradle`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsSettingsGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {

            @Override
            public  J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (""enableFeaturePreview"".equals(method.getSimpleName()) &&
                    method.getArguments().size() == 1 &&
                    J.Literal.isLiteralValue(method.getArguments().get(0), previewFeatureName)) {
                    return null;
                }
                return method;
            }
        });
    }
}
","{
  ""previewFeatureName"": ""String field""
}"
Use `Map` notation for Gradle dependency declarations,"In Gradle, dependencies can be expressed as a `String` like `\",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import org.openrewrite.*;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.*;
import org.openrewrite.kotlin.KotlinVisitor;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

public class DependencyUseMapNotation extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use `Map` notation for Gradle dependency declarations"";
    }

    @Override
    public String getDescription() {
        return ""In Gradle, dependencies can be expressed as a `String` like `\""groupId:artifactId:version\""`, "" +
                ""or equivalently as a `Map` like `group: 'groupId', name: 'artifactId', version: 'version'` (groovy) "" +
                ""or `group = \""groupId\"", name = \""artifactId\"", version = \""version\""` (kotlin). "" +
                ""This recipe replaces dependencies represented as `Strings` with an equivalent dependency represented as a `Map`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), Preconditions.or(new GroovyScriptVisitor(), new KotlinScriptVisitor()));
    }

    private static class KotlinScriptVisitor extends KotlinVisitor<ExecutionContext> {
        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);

            GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher();

            if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                return m;
            }
            m = forBasicString(m, this::mapEntry, J.Assignment::withPrefix, Function.identity());
            return forStringTemplate(m, K.StringTemplate.class, K.StringTemplate::getStrings, K.StringTemplate.Expression.class, K.StringTemplate.Expression::getTree, this::mapEntry, this::mapEntry, J.Assignment::withPrefix, Function.identity());
        }

        private J.Assignment mapEntry(String key, String value) {
            return mapEntry(key,
                    new J.Literal(randomId(), Space.build("" "", emptyList()), Markers.EMPTY, value, ""\"""" + value + ""\"""", null, JavaType.Primitive.String));
        }

        private J.Assignment mapEntry(String key, Expression e) {
            return new J.Assignment(
                    randomId(),
                    Space.format("" ""),
                    Markers.EMPTY,
                    new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), key, null, null),
                    JLeftPadded.build(e).withBefore(Space.SINGLE_SPACE),
                    null
            );
        }
    }

    private static class GroovyScriptVisitor extends GroovyVisitor<ExecutionContext> {
        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);

            GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher();

            if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                return m;
            }
            m = forBasicString(m, this::mapEntry, G.MapEntry::withPrefix, this::updateTypeForMapArgument);
            return forStringTemplate(m, G.GString.class, G.GString::getStrings, G.GString.Value.class, G.GString.Value::getTree, this::mapEntry, this::mapEntry, G.MapEntry::withPrefix, this::updateTypeForMapArgument);
        }

        private J.MethodInvocation updateTypeForMapArgument(J.MethodInvocation m) {
            JavaType.Method mtype = m.getMethodType();
            if (mtype == null) {
                return m;
            }
            mtype = mtype.withParameterTypes(singletonList(JavaType.ShallowClass.build(""java.util.Map"")));
            if (m.getName().getType() != null) {
                m = m.withName(m.getName().withType(mtype));
            }
            return m.withMethodType(mtype);
        }

        private G.MapEntry mapEntry(String key, String value) {
            return mapEntry(key,
                    new J.Literal(randomId(), Space.build("" "", emptyList()), Markers.EMPTY, value, ""'"" + value + ""'"", null, JavaType.Primitive.String));
        }

        private G.MapEntry mapEntry(String key, Expression e) {
            return new G.MapEntry(
                    randomId(),
                    Space.format("" ""),
                    Markers.EMPTY,
                    JRightPadded.build(new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), key, null, null)),
                    e,
                    null
            );
        }
    }

    private static <T extends Expression> J.MethodInvocation forBasicString(J.MethodInvocation m,
                                                                            BiFunction<String, String, T> mapper,
                                                                            BiFunction<T, Space, T> firstItemPrefixer,
                                                                            Function<J.MethodInvocation, J.MethodInvocation> typeAddition) {
        Expression e = m.getArguments().get(0);
        if (!(e instanceof J.Literal)) {
            return m;
        }
        J.Literal arg = (J.Literal) e;
        if (arg.getType() != JavaType.Primitive.String) {
            return m;
        }
        String dependencyString = (String) arg.getValue();
        if (dependencyString == null) {
            return m;
        }
        Dependency dependency = DependencyStringNotationConverter.parse(dependencyString);
        if (dependency == null) {
            return m;
        }
        List<Expression> arguments = new ArrayList<>();
        arguments.add(firstItemPrefixer.apply(mapper.apply(""group"", dependency.getGroupId())
                .withMarkers(arg.getMarkers()), arg.getPrefix()));
        arguments.add(mapper.apply(""name"", dependency.getArtifactId())
                .withMarkers(arg.getMarkers()));
        if (dependency.getVersion() != null) {
            arguments.add(mapper.apply(""version"", dependency.getVersion())
                    .withMarkers(arg.getMarkers()));
        }
        if (dependency.getClassifier() != null) {
            arguments.add(mapper.apply(""classifier"", dependency.getClassifier())
                    .withMarkers(arg.getMarkers()));
        }
        if (dependency.getExt() != null) {
            arguments.add(mapper.apply(""ext"", dependency.getExt())
                    .withMarkers(arg.getMarkers()));
        }

        Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);
        if (lastArg instanceof J.Lambda) {
            m = m.withArguments(ListUtils.concat(arguments, lastArg));
        } else {
            m = m.withArguments(arguments);
        }

        return typeAddition.apply(m);
    }

    private static <T extends Expression, P extends J, R extends Expression> J.MethodInvocation forStringTemplate(J.MethodInvocation m,
                                                                                                     Class<T> type,
                                                                                                     Function<T, List<J>> partsExtractor,
                                                                                                     Class<P> partsType,
                                                                                                     Function<P, Tree> getTreeFromTemplatePart,
                                                                                                     BiFunction<String, String, R> mapper,
                                                                                                     BiFunction<String, Expression, R> expressionMapper,
                                                                                                     BiFunction<R, Space, R> firstItemPrefixer,
                                                                                                     Function<J.MethodInvocation, J.MethodInvocation> typeAddition) {
        Expression e = m.getArguments().get(0);
        if (!(type.isInstance(e))) {
            return m;
        }
        T template = type.cast(e);
        // Supporting all possible interpolations is impossible
        // Supporting all probable interpolations is difficult
        // This focuses on the most common case: When only the version number is interpolated
        List<J> parts = partsExtractor.apply(template);
        if (parts.size() != 2 || !(parts.get(0) instanceof J.Literal) || !(partsType.isInstance(parts.get(1)))) {
            return m;
        }
        J.Literal arg1 = (J.Literal) parts.get(0);
        if (arg1.getType() != JavaType.Primitive.String || arg1.getValue() == null) {
            return m;
        }
        String[] ga = ((String) arg1.getValue()).split("":"");
        if (ga.length != 2) {
            return m;
        }
        P arg2 = partsType.cast(parts.get(1));
        Tree tree = getTreeFromTemplatePart.apply(arg2);
        if (!(tree instanceof Expression)) {
            return m;
        }
        R groupEntry = firstItemPrefixer.apply(mapper.apply(""group"", ga[0]).withMarkers(e.getMarkers()), e.getPrefix());
        R artifactEntry = mapper.apply(""name"", ga[1]).withMarkers(e.getMarkers());
        R versionEntry = expressionMapper.apply(""version"", ((Expression) tree).withPrefix(Space.SINGLE_SPACE)).withMarkers(e.getMarkers());

        Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);
        if (lastArg instanceof J.Lambda) {
            m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry, lastArg));
        } else {
            m = m.withArguments(Arrays.asList(groupEntry, artifactEntry, versionEntry));
        }

        return typeAddition.apply(m);
    }
}
",{}
Change a Gradle dependency extension,Changes extension of an existing dependency declared in `build.gradle` files.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.semver.DependencyMatcher;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyExtension extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New extension"",
            description = ""An artifact extension."",
            example = ""jar"")
    String newExtension;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change a Gradle dependency extension"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s` to `%s`"", groupId, artifactId, newExtension);
    }

    @Override
    public String getDescription() {
        return ""Changes extension of an existing dependency declared in `build.gradle` files."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(DependencyMatcher.build(groupId + "":"" + artifactId));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .configuration(configuration)
                        .groupId(groupId)
                        .artifactId(artifactId);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal) {
                    String gav = (String) ((J.Literal) depArgs.get(0)).getValue();
                    if (gav != null) {
                        Dependency dependency = DependencyStringNotationConverter.parse(gav);
                        if (dependency != null && !newExtension.equals(dependency.getExt())) {
                            Dependency newDependency = dependency.withExt(newExtension);
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, newDependency.toStringNotation())));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.MapEntry) {
                    G.MapEntry extensionEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String extension = null;

                    String extensionStringDelimiter = ""'"";
                    for (Expression e : depArgs) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        } else if (""ext"".equals(keyValue) && !newExtension.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                extensionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            extensionEntry = arg;
                            extension = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null || extension == null) {
                        return m;
                    }
                    String delimiter = extensionStringDelimiter;
                    G.MapEntry finalExtension = extensionEntry;
                    m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                        if (arg == finalExtension) {
                            return finalExtension.withValue(((J.Literal) finalExtension.getValue())
                                    .withValue(newExtension)
                                    .withValueSource(delimiter + newExtension + delimiter));
                        }
                        return arg;
                    }));
                } else if (depArgs.get(0) instanceof G.MapLiteral) {
                    G.MapLiteral map = (G.MapLiteral) depArgs.get(0);
                    G.MapEntry extensionEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String extension = null;

                    String extensionStringDelimiter = ""'"";
                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        } else if (""ext"".equals(keyValue) && !newExtension.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                extensionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            extensionEntry = arg;
                            extension = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null || extension == null) {
                        return m;
                    }
                    String delimiter = extensionStringDelimiter;
                    G.MapEntry finalExtension = extensionEntry;
                    m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                        G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                        return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> {
                            if (e == finalExtension) {
                                return finalExtension.withValue(((J.Literal) finalExtension.getValue())
                                        .withValue(newExtension)
                                        .withValueSource(delimiter + newExtension + delimiter));
                            }
                            return e;
                        }));
                    }));
                }

                return m;
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newExtension"": ""String field""
}"
Change a Gradle dependency configuration,A common example is the need to change `compile` to `api`/`implementation` as ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.semver.DependencyMatcher;

import java.time.Duration;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependencyConfiguration extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New configuration"",
            description = ""A dependency configuration container."",
            example = ""api"")
    String newConfiguration;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change a Gradle dependency configuration"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s` to `%s`"", groupId, artifactId, newConfiguration);
    }

    @Override
    public String getDescription() {
        return ""A common example is the need to change `compile` to `api`/`implementation` as "" +
               ""[part of the move](https://docs.gradle.org/current/userguide/upgrading_version_6.html) to Gradle 7.x and later."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(DependencyMatcher.build(groupId + "":"" + artifactId));
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            // Still need to be able to change the configuration for project dependencies which are not yet supported by the `GradleDependency.Matcher`
            final MethodMatcher dependencyDsl = new MethodMatcher(""DependencyHandlerSpec *(..)"");

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .configuration(configuration);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent() && !matchesOtherDependency(m)) {
                    return m;
                }


                DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);
                List<Expression> args = m.getArguments();
                if (args.get(0) instanceof J.Literal) {
                    J.Literal arg = (J.Literal) args.get(0);
                    if (!(arg.getValue() instanceof String)) {
                        return m;
                    }

                    Dependency dependency = DependencyStringNotationConverter.parse((String) arg.getValue());
                    if (dependency == null || !dependencyMatcher.matches(dependency.getGroupId(), dependency.getArtifactId())) {
                        return m;
                    }
                } else if (args.get(0) instanceof G.GString) {
                    G.GString gString = (G.GString) args.get(0);
                    List<J> strings = gString.getStrings();
                    if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof G.GString.Value)) {
                        return m;
                    }
                    J.Literal groupArtifact = (J.Literal) strings.get(0);
                    if (!(groupArtifact.getValue() instanceof String)) {
                        return m;
                    }

                    Dependency dependency = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                    if (dependency == null || !dependencyMatcher.matches(dependency.getGroupId(), dependency.getArtifactId())) {
                        return m;
                    }
                } else if (args.get(0) instanceof G.MapEntry) {
                    if (args.size() < 2) {
                        return m;
                    }

                    String groupId = null;
                    String artifactId = null;
                    for (Expression e : args) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        }
                    }

                    if (artifactId == null || !dependencyMatcher.matches(groupId, artifactId)) {
                        return m;
                    }
                } else if (args.get(0) instanceof G.MapLiteral) {
                    if (args.size() < 2) {
                        return m;
                    }

                    G.MapLiteral map = (G.MapLiteral) args.get(0);
                    String groupId = null;
                    String artifactId = null;
                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        }
                    }

                    if (artifactId == null || !dependencyMatcher.matches(groupId, artifactId)) {
                        return m;
                    }
                } else if (args.get(0) instanceof J.MethodInvocation) {
                    J.MethodInvocation inner = (J.MethodInvocation) args.get(0);
                    if (!(""project"".equals(inner.getSimpleName()) || ""platform"".equals(inner.getSimpleName()) || ""enforcedPlatform"".equals(inner.getSimpleName()))) {
                        return m;
                    }
                    List<Expression> innerArgs = inner.getArguments();
                    if (!(innerArgs.get(0) instanceof J.Literal)) {
                        return m;
                    }
                    J.Literal value = (J.Literal) innerArgs.get(0);
                    if (!(value.getValue() instanceof String)) {
                        return m;
                    }

                    Dependency dependency;
                    if (""project"".equals(inner.getSimpleName())) {
                        dependency = new Dependency("""", ((String) value.getValue()).substring(1), null, null, null);
                    } else {
                        dependency = DependencyStringNotationConverter.parse((String) value.getValue());
                    }

                    if (dependency == null || !dependencyMatcher.matches(dependency.getGroupId(), dependency.getArtifactId())) {
                        return m;
                    }
                } else {
                    return m;
                }

                if (newConfiguration.equals(m.getSimpleName())) {
                    return m;
                }

                return m.withName(m.getName().withSimpleName(newConfiguration));
            }

            private boolean matchesOtherDependency(J.MethodInvocation m) {
                if (!dependencyDsl.matches(m)) {
                    return false;
                }

                if (m.getArguments().isEmpty() || !(m.getArguments().get(0) instanceof J.MethodInvocation)) {
                    return false;
                }

                J.MethodInvocation inner = (J.MethodInvocation) m.getArguments().get(0);
                if (!(""project"".equals(inner.getSimpleName()) || ""platform"".equals(inner.getSimpleName()) || ""enforcedPlatform"".equals(inner.getSimpleName()))) {
                    return false;
                }

                return StringUtils.isBlank(configuration) || configuration.equals(m.getSimpleName());
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newConfiguration"": ""String field""
}"
Change Gradle managed dependency,Change a Gradle managed dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before.\n,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.search.FindGradleProject;
import org.openrewrite.gradle.trait.SpringDependencyManagementPluginEntry;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.semver.Semver;
import org.openrewrite.trait.Trait;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
@RequiredArgsConstructor
public class ChangeManagedDependency extends Recipe {

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old groupId"",
            description = ""The old groupId to replace. The groupId is the first part of a dependency coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""org.openrewrite.recipe"")
    String oldGroupId;

    @Option(displayName = ""Old artifactId"",
            description = ""The old artifactId to replace. The artifactId is the second part of a dependency coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""rewrite-testing-frameworks"")
    String oldArtifactId;

    @Option(displayName = ""New groupId"",
            description = ""The new groupId to use. Defaults to the existing group id."",
            example = ""corp.internal.openrewrite.recipe"",
            required = false)
    @Nullable
    String newGroupId;

    @Option(displayName = ""New artifactId"",
            description = ""The new artifactId to use. Defaults to the existing artifact id."",
            example = ""rewrite-testing-frameworks"",
            required = false)
    @Nullable
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                    ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                    ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                    ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    // Individual dependencies tend to appear in several places within a given dependency graph.
    // Minimize the number of allocations by caching the updated dependencies.
    transient Map<org.openrewrite.maven.tree.Dependency, org.openrewrite.maven.tree.Dependency> updatedRequested = new HashMap<>();
    transient Map<org.openrewrite.maven.tree.ResolvedDependency, org.openrewrite.maven.tree.ResolvedDependency> updatedResolved = new HashMap<>();

    @Override
    public String getDisplayName() {
        return ""Change Gradle managed dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", oldGroupId, oldArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Change a Gradle managed dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before.\n"" +
                ""For now, only Spring Dependency Management Plugin entries are supported and no other forms of managed dependencies (yet)."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        validated = validated.and(Validated.required(""newGroupId"", newGroupId).or(Validated.required(""newArtifactId"", newArtifactId)));
        return validated.and(Validated.test(
                ""coordinates"",
                ""newGroupId OR newArtifactId must be different from before"",
                this,
                r -> {
                    boolean sameGroupId = StringUtils.isBlank(r.newGroupId) || Objects.equals(r.oldGroupId, r.newGroupId);
                    boolean sameArtifactId = StringUtils.isBlank(r.newArtifactId) || Objects.equals(r.oldArtifactId, r.newArtifactId);
                    return !(sameGroupId && sameArtifactId);
                }
        ));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new JavaIsoVisitor<ExecutionContext>() {

            private final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(oldGroupId + "":"" + oldArtifactId).getValue());

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                J t = super.visit(tree, ctx);
                if (t instanceof JavaSourceFile && t != tree) {
                    Optional<GradleProject> maybeGp = tree.getMarkers().findFirst(GradleProject.class);
                    if (maybeGp.isPresent()) {
                        GradleProject gp = maybeGp.get();
                        t = t.withMarkers(t.getMarkers().setByType(updateGradleModel(gp)));
                    }
                }
                return t;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                return new SpringDependencyManagementPluginEntry.Matcher().groupId(oldGroupId).artifactId(oldArtifactId)
                        .get(getCursor())
                        .map(dep -> dep.withGroupArtifactVersion(depMatcher, newGroupId, newArtifactId, newVersion, versionPattern, metadataFailures, ctx))
                        .map(Trait::getTree)
                        .orElse(m);
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        assert requested != null;
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId())) {
                            requested = updatedRequested.computeIfAbsent(requested, r -> {
                                GroupArtifactVersion gav = r.getGav();
                                if (newGroupId != null) {
                                    gav = gav.withGroupId(newGroupId);
                                }
                                if (newArtifactId != null) {
                                    gav = gav.withArtifactId(newArtifactId);
                                }
                                if (gav != r.getGav()) {
                                    r = r.withGav(gav);
                                }
                                return r;
                            });
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        assert resolved != null;
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId())) {
                            resolved = updatedResolved.computeIfAbsent(resolved, r -> {
                                ResolvedGroupArtifactVersion gav = r.getGav();
                                if (newGroupId != null) {
                                    gav = gav.withGroupId(newGroupId);
                                }
                                if (newArtifactId != null) {
                                    gav = gav.withArtifactId(newArtifactId);
                                }
                                if (gav != r.getGav()) {
                                    r = r.withGav(gav);
                                }
                                return r;
                            });
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field""
}"
Change Extra Property,Gradle's [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.gradle.search.FindGradleProject;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.java.tree.J;

import java.util.Objects;


@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeExtraProperty extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Change Extra Property"";
    }

    @Override
    public String getDescription() {
        return ""Gradle's [ExtraPropertiesExtension](https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html) "" +
               ""is a commonly used mechanism for setting arbitrary key/value pairs on a project. "" +
               ""This recipe will change the value of a property with the given key name if that key can be found. "" +
               ""It assumes that the value being set is a String literal. "" +
               ""Does not add the value if it does not already exist."";
    }

    @Option(displayName = ""Key"",
            description = ""The key of the property to change."",
            example = ""foo"")
    String key;

    @Option(displayName = ""Value"",
            description = ""The new value to set. The value will be treated the contents of a string literal."",
            example = ""bar"")
    String value;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.File).getVisitor(), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public J.Assignment visitAssignment(J.Assignment as, ExecutionContext ctx) {
                if(!(as.getAssignment() instanceof J.Literal)) {
                    return as;
                }
                if(as.getVariable() instanceof J.Identifier) {
                    if(!Objects.equals(key, ((J.Identifier) as.getVariable()).getSimpleName())) {
                        return as;
                    }
                    J.MethodInvocation m = getCursor().firstEnclosing(J.MethodInvocation.class);
                    if(m == null || !""ext"".equals(m.getSimpleName())) {
                        return as;
                    }
                    as = updateAssignment(as);
                } else if(as.getVariable() instanceof J.FieldAccess) {
                    J.FieldAccess var = (J.FieldAccess) as.getVariable();
                    if(!Objects.equals(key, var.getSimpleName())) {
                        return as;
                    }
                    if((var.getTarget() instanceof J.Identifier && ""ext"".equals(((J.Identifier) var.getTarget()).getSimpleName())) ||
                       (var.getTarget() instanceof J.FieldAccess && ""ext"".equals(((J.FieldAccess) var.getTarget()).getSimpleName())) ) {
                        as = updateAssignment(as);
                    }
                }

                return as;
            }
        });
    }

    private J.Assignment updateAssignment(J.Assignment as) {
        if(!(as.getAssignment() instanceof J.Literal)) {
            return as;
        }
        J.Literal asVal = (J.Literal) as.getAssignment();
        if(Objects.equals(value, asVal.getValue())) {
            return as;
        }
        String quote = ""\"""";
        if(asVal.getValueSource() != null && asVal.getValueSource().trim().startsWith(""'"")) {
            quote = ""'"";
        }
        return as.withAssignment(asVal.withValue(value)
                .withValueSource(quote + value + quote));
    }
}
","{
  ""key"": ""String field"",
  ""value"": ""String field""
}"
Change Gradle dependency artifact,Change the artifact of a specified Gradle dependency.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.semver.DependencyMatcher;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeDependencyArtifactId extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New artifactId"",
            description = ""The new artifactId to use."",
            example = ""jackson-custom"")
    String newArtifactId;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change Gradle dependency artifact"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Change the artifact of a specified Gradle dependency."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(DependencyMatcher.build(groupId + "":"" + artifactId));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(groupId + "":"" + artifactId).getValue());

            GradleProject gradleProject;

            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);
                if (!maybeGp.isPresent()) {
                    return cu;
                }

                gradleProject = maybeGp.get();

                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);
                if (g != cu) {
                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));
                }
                return g;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .configuration(configuration)
                        .groupId(groupId)
                        .artifactId(artifactId);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral) {
                    m = updateDependency(m);
                } else if (depArgs.get(0) instanceof J.MethodInvocation &&
                           (""platform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()) ||
                            ""enforcedPlatform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()))) {
                    m = m.withArguments(ListUtils.map(depArgs, platform -> updateDependency((J.MethodInvocation) platform)));
                }

                return m;
            }

            private J.MethodInvocation updateDependency(J.MethodInvocation m) {
                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal) {
                    String gav = (String) ((J.Literal) depArgs.get(0)).getValue();
                    if (gav != null) {
                        Dependency dependency = DependencyStringNotationConverter.parse(gav);
                        if (dependency != null && !newArtifactId.equals(dependency.getArtifactId())) {
                            Dependency newDependency = dependency.withArtifactId(newArtifactId);
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, newDependency.toStringNotation())));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.GString) {
                    List<J> strings = ((G.GString) depArgs.get(0)).getStrings();
                    if (strings.size() >= 2 &&
                        strings.get(0) instanceof J.Literal) {
                        Dependency dependency = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) strings.get(0)).getValue()));
                        if (dependency != null && !newArtifactId.equals(dependency.getArtifactId())) {
                            Dependency newDependency = dependency.withArtifactId(newArtifactId);
                            String replacement = newDependency.toStringNotation();
                            m = m.withArguments(ListUtils.mapFirst(depArgs, arg -> {
                                G.GString gString = (G.GString) arg;
                                return gString.withStrings(ListUtils.mapFirst(gString.getStrings(), l -> ((J.Literal) l).withValue(replacement).withValueSource(replacement)));
                            }));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.MapEntry) {
                    G.MapEntry artifactEntry = null;
                    String groupId = null;
                    String artifactId = null;

                    String versionStringDelimiter = ""'"";
                    for (Expression e : depArgs) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue) && !newArtifactId.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                versionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            artifactEntry = arg;
                            artifactId = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    String delimiter = versionStringDelimiter;
                    G.MapEntry finalArtifact = artifactEntry;
                    m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                        if (arg == finalArtifact) {
                            return finalArtifact.withValue(((J.Literal) finalArtifact.getValue())
                                    .withValue(newArtifactId)
                                    .withValueSource(delimiter + newArtifactId + delimiter));
                        }
                        return arg;
                    }));
                } else if (depArgs.get(0) instanceof G.MapLiteral) {
                    G.MapLiteral map = (G.MapLiteral) depArgs.get(0);
                    G.MapEntry artifactEntry = null;
                    String groupId = null;
                    String artifactId = null;

                    String versionStringDelimiter = ""'"";
                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue)) {
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue) && !newArtifactId.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                versionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            artifactEntry = arg;
                            artifactId = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    String delimiter = versionStringDelimiter;
                    G.MapEntry finalArtifact = artifactEntry;
                    m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                        G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                        return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> {
                            if (e == finalArtifact) {
                                return finalArtifact.withValue(((J.Literal) finalArtifact.getValue())
                                        .withValue(newArtifactId)
                                        .withValueSource(delimiter + newArtifactId + delimiter));
                            }
                            return e;
                        }));
                    }));
                }

                return m;
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    if (!StringUtils.isBlank(configuration) && configuration.equals(gdc.getName())) {
                        newNameToConfiguration.put(gdc.getName(), gdc);
                        continue;
                    }

                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId())) {
                            return requested.withGav(requested.getGav().withArtifactId(newArtifactId));
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId())) {
                            return resolved.withGav(resolved.getGav().withArtifactId(newArtifactId));
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newArtifactId"": ""String field""
}"
Remove build extension by name,Remove a Gradle build extension from `settings.gradle(.kts)` or `build.gradle(.kts)` files.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;

import static org.openrewrite.Preconditions.or;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveExtension extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove build extension by name"";
    }

    @Override
    public String getDescription() {
        return ""Remove a Gradle build extension from `settings.gradle(.kts)` or `build.gradle(.kts)` files."";
    }

    @Option(displayName = ""Method name"",
            description = ""The name of the build extension to remove, e.g., `buildCache`."",
            example = ""buildCache"")
    String methodName;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(or(new IsBuildGradle<>(), new IsSettingsGradle<>()), new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        if (methodName.equals(method.getSimpleName())) {
                            return null;
                        }
                        return super.visitMethodInvocation(method, ctx);
                    }
                }
        );
    }
}
","{
  ""methodName"": ""String field""
}"
Upgrade Gradle dependency versions,,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Markup;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.*;

import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradeDependencyVersion extends ScanningRecipe<UpgradeDependencyVersion.DependencyVersionState> {
    private static final String GRADLE_PROPERTIES_FILE_NAME = ""gradle.properties"";

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'newVersion' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Override
    public String getDisplayName() {
        return ""Upgrade Gradle dependency versions"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        //language=markdown
        return ""Upgrade the version of a dependency in a build.gradle file. "" +
               ""Supports updating dependency declarations of various forms:\n"" +
               "" * `String` notation: `\""group:artifact:version\""` \n"" +
               "" * `Map` notation: `group: 'group', name: 'artifact', version: 'version'`\n"" +
               ""Can update version numbers which are defined earlier in the same file in variable declarations."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    private static final String UPDATE_VERSION_ERROR_KEY = ""UPDATE_VERSION_ERROR_KEY"";

    @Value
    public static class DependencyVersionState {
        Map<String, Map<GroupArtifact, Set<String>>> variableNames = new HashMap<>();
        Map<String, Map<GroupArtifact, Set<String>>> versionPropNameToGA = new HashMap<>();

        /**
         * The value is either a String representing the resolved version
         * or a MavenDownloadingException representing an error during resolution.
         */
        Map<GroupArtifact, @Nullable Object> gaToNewVersion = new HashMap<>();

        Map<String, Map<GroupArtifact, Set<String>>> configurationPerGAPerModule = new HashMap<>();
    }

    @Override
    public DependencyVersionState getInitialValue(ExecutionContext ctx) {
        return new DependencyVersionState();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(DependencyVersionState acc) {

        //noinspection BooleanMethodIsAlwaysInverted
        return new JavaVisitor<ExecutionContext>() {
            @Nullable
            GradleProject gradleProject;

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith("".gradle"")) ||
                       (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith("".gradle.kts""));
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    gradleProject = tree.getMarkers().findFirst(GradleProject.class).orElse(null);
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher();

                if (gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    List<Expression> depArgs = m.getArguments();
                    if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {
                        gatherVariables(m);
                    } else if (depArgs.get(0) instanceof J.MethodInvocation &&
                            (""platform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()) ||
                                    ""enforcedPlatform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()))) {
                        gatherVariables((J.MethodInvocation) depArgs.get(0));
                    }

                    if (m.getArguments().get(0) instanceof G.MapEntry) {
                        String declaredGroupId = null;
                        String declaredArtifactId = null;
                        String declaredVersion = null;

                        for (Expression e : m.getArguments()) {
                            if (!(e instanceof G.MapEntry)) {
                                continue;
                            }
                            G.MapEntry arg = (G.MapEntry) e;
                            if (!(arg.getKey() instanceof J.Literal)) {
                                continue;
                            }
                            J.Literal key = (J.Literal) arg.getKey();
                            String valueValue = null;
                            if (arg.getValue() instanceof J.Literal) {
                                J.Literal value = (J.Literal) arg.getValue();
                                if (value.getValue() instanceof String) {
                                    valueValue = (String) value.getValue();
                                }
                            } else if (arg.getValue() instanceof J.Identifier) {
                                J.Identifier value = (J.Identifier) arg.getValue();
                                valueValue = value.getSimpleName();
                            } else if (arg.getValue() instanceof J.FieldAccess) {
                                valueValue = arg.getValue().printTrimmed(getCursor());
                            } else if (arg.getValue() instanceof G.GString) {
                                G.GString value = (G.GString) arg.getValue();
                                List<J> strings = value.getStrings();
                                if (!strings.isEmpty() && strings.get(0) instanceof G.GString.Value) {
                                    G.GString.Value versionGStringValue = (G.GString.Value) strings.get(0);
                                    if (versionGStringValue.getTree() instanceof J.Identifier) {
                                        valueValue = ((J.Identifier) versionGStringValue.getTree()).getSimpleName();
                                    } else if (versionGStringValue.getTree() instanceof J.FieldAccess) {
                                        valueValue = versionGStringValue.getTree().printTrimmed(getCursor());
                                    }
                                }
                            }
                            if (!(key.getValue() instanceof String)) {
                                continue;
                            }
                            String keyValue = (String) key.getValue();
                            switch (keyValue) {
                                case ""group"":
                                    declaredGroupId = valueValue;
                                    break;
                                case ""name"":
                                    declaredArtifactId = valueValue;
                                    break;
                                case ""version"":
                                    declaredVersion = valueValue;
                                    break;
                            }
                        }
                        if (declaredGroupId == null || declaredArtifactId == null || declaredVersion == null) {
                            return m;
                        }

                        String versionVariableName = declaredVersion;
                        GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);
                        if (gradleProject != null) {
                            acc.getConfigurationPerGAPerModule().computeIfAbsent(getGradleProjectKey(gradleProject), k -> new HashMap<>())
                                    .computeIfAbsent(ga, k -> new HashSet<>())
                                    .add(m.getSimpleName());
                        }
                        if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {
                            return m;
                        }
                        try {
                            String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(new GroupArtifact(declaredGroupId, declaredArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);
                            acc.versionPropNameToGA
                                    .computeIfAbsent(versionVariableName, k -> new HashMap<>())
                                    .computeIfAbsent(ga, k -> new HashSet<>())
                                    .add(m.getSimpleName());
                            // It is fine for this value to be null, record it in the map to avoid future lookups
                            acc.gaToNewVersion.put(ga, resolvedVersion);
                        } catch (MavenDownloadingException e) {
                            acc.gaToNewVersion.put(ga, e);
                            return m;
                        }
                    } else if (m.getArguments().get(0) instanceof J.Assignment) {
                        String declaredGroupId = null;
                        String declaredArtifactId = null;
                        String declaredVersion = null;

                        for (Expression e : m.getArguments()) {
                            if (!(e instanceof J.Assignment)) {
                                continue;
                            }
                            J.Assignment assignment = (J.Assignment) e;
                            if (!(assignment.getVariable() instanceof J.Identifier)) {
                                continue;
                            }
                            J.Identifier variable = (J.Identifier) assignment.getVariable();
                            String valueValue = null;
                            if (assignment.getAssignment() instanceof J.Literal) {
                                J.Literal value = (J.Literal) assignment.getAssignment();
                                if (value.getValue() instanceof String) {
                                    valueValue = (String) value.getValue();
                                }
                            } else if (assignment.getAssignment() instanceof J.Identifier) {
                                J.Identifier value = (J.Identifier) assignment.getAssignment();
                                valueValue = value.getSimpleName();
                            } else if (assignment.getAssignment() instanceof K.StringTemplate) {
                                K.StringTemplate value = (K.StringTemplate) assignment.getAssignment();
                                List<J> strings = value.getStrings();
                                if (!strings.isEmpty() && strings.get(0) instanceof K.StringTemplate.Expression) {
                                    K.StringTemplate.Expression versionTemplateValue = (K.StringTemplate.Expression) strings.get(0);
                                    if (versionTemplateValue.getTree() instanceof J.Identifier) {
                                        valueValue = ((J.Identifier) versionTemplateValue.getTree()).getSimpleName();
                                    }
                                }
                            }
                            switch (variable.getSimpleName()) {
                                case ""group"":
                                    declaredGroupId = valueValue;
                                    break;
                                case ""name"":
                                    declaredArtifactId = valueValue;
                                    break;
                                case ""version"":
                                    declaredVersion = valueValue;
                                    break;
                            }
                        }
                        if (declaredGroupId == null || declaredArtifactId == null || declaredVersion == null) {
                            return m;
                        }

                        String versionVariableName = declaredVersion;
                        GroupArtifact ga = new GroupArtifact(declaredGroupId, declaredArtifactId);
                        if (gradleProject != null) {
                            acc.getConfigurationPerGAPerModule().computeIfAbsent(getGradleProjectKey(gradleProject), k -> new HashMap<>())
                                    .computeIfAbsent(ga, k -> new HashSet<>())
                                    .add(m.getSimpleName());
                        }
                        if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(declaredGroupId, declaredArtifactId)) {
                            return m;
                        }
                        try {
                            String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(new GroupArtifact(declaredGroupId, declaredArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);
                            acc.versionPropNameToGA
                                    .computeIfAbsent(versionVariableName, k -> new HashMap<>())
                                    .computeIfAbsent(ga, k -> new HashSet<>())
                                    .add(m.getSimpleName());
                            // It is fine for this value to be null, record it in the map to avoid future lookups
                            acc.gaToNewVersion.put(ga, resolvedVersion);
                        } catch (MavenDownloadingException e) {
                            acc.gaToNewVersion.put(ga, e);
                            return m;
                        }
                    } else {
                        for (Expression depArg : m.getArguments()) {
                            Dependency dep = null;
                            String versionVariableName = null;
                            if (depArg instanceof J.Literal && ((J.Literal) depArg).getValue() instanceof String) {
                                String gav = (String) ((J.Literal) depArg).getValue();
                                dep = DependencyStringNotationConverter.parse(gav);
                                if (dep != null) {
                                    versionVariableName = dep.getVersion();
                                }
                            } else if (depArg instanceof G.GString) {
                                G.GString gString = (G.GString) depArg;
                                List<J> strings = gString.getStrings();
                                if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof G.GString.Value)) {
                                    continue;
                                }
                                J.Literal groupArtifact = (J.Literal) strings.get(0);
                                G.GString.Value versionValue = (G.GString.Value) strings.get(1);
                                if (!(groupArtifact.getValue() instanceof String)) {
                                    continue;
                                }
                                dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                                if (dep == null) {
                                    continue;
                                }
                                if (versionValue.getTree() instanceof J.FieldAccess) {
                                    J.FieldAccess f = (J.FieldAccess) versionValue.getTree();
                                    versionVariableName = f.toString();
                                } else if (versionValue.getTree() instanceof J.Identifier) {
                                    versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();
                                }
                            } else if (depArg instanceof K.StringTemplate) {
                                K.StringTemplate template = (K.StringTemplate) depArg;
                                List<J> strings = template.getStrings();
                                if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {
                                    continue;
                                }
                                J.Literal groupArtifact = (J.Literal) strings.get(0);
                                K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);
                                if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {
                                    continue;
                                }
                                dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                                versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();
                            } else if (depArg instanceof J.Binary && ((J.Binary) depArg).getLeft() instanceof J.Literal && ((J.Binary) depArg).getRight() instanceof J.Identifier) {
                                dep = DependencyStringNotationConverter.parse((String) ((J.Literal) ((J.Binary) depArg).getLeft()).getValue());
                                versionVariableName = ((J.Identifier) ((J.Binary) depArg).getRight()).getSimpleName();
                            }
                            if (dep == null || versionVariableName == null) {
                                continue;
                            }
                            GroupArtifact ga = new GroupArtifact(dep.getGroupId(), dep.getArtifactId());
                            if (gradleProject != null) {
                                acc.getConfigurationPerGAPerModule().computeIfAbsent(getGradleProjectKey(gradleProject), k -> new HashMap<>())
                                        .computeIfAbsent(ga, k -> new HashSet<>())
                                        .add(m.getSimpleName());
                            }
                            if (acc.gaToNewVersion.containsKey(ga) || !shouldResolveVersion(dep.getGroupId(), dep.getArtifactId())) {
                                continue;
                            }
                            try {
                                String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                        .select(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);
                                acc.versionPropNameToGA
                                        .computeIfAbsent(versionVariableName, k -> new HashMap<>())
                                        .computeIfAbsent(ga, k -> new HashSet<>())
                                        .add(m.getSimpleName());
                                // It is fine for this value to be null, record it in the map to avoid future lookups
                                acc.gaToNewVersion.put(ga, resolvedVersion);
                            } catch (MavenDownloadingException e) {
                                acc.gaToNewVersion.put(ga, e);
                            }
                        }
                    }
                }
                return m;
            }

            // Some recipes make use of UpgradeDependencyVersion as an implementation detail.
            // Those other recipes might not know up-front which dependency needs upgrading
            // So they use the UpgradeDependencyVersion recipe with null groupId and artifactId to pre-populate all data they could possibly need
            // This works around the lack of proper recipe pipelining which might allow us to have multiple scanning phases as necessary
            private boolean shouldResolveVersion(String declaredGroupId, String declaredArtifactId) {
                //noinspection ConstantValue
                return (groupId == null || artifactId == null) ||
                       new DependencyMatcher(groupId, artifactId, null).matches(declaredGroupId, declaredArtifactId);
            }

            private void gatherVariables(J.MethodInvocation method) {
                List<Expression> depArgs = method.getArguments();
                if (depArgs.size() == 1) {
                    Expression arg = depArgs.get(0);
                    J.Literal groupArtifact = null;
                    Object versionVariable = null;
                    if (arg instanceof G.GString) {
                        List<J> strings = ((G.GString) arg).getStrings();
                        if (strings.size() == 2 && strings.get(0) instanceof J.Literal && strings.get(1) instanceof G.GString.Value) {
                            groupArtifact = (J.Literal) strings.get(0);
                            versionVariable = ((G.GString.Value) strings.get(1)).getTree();
                        }
                    } else if (arg instanceof K.StringTemplate) {
                        List<J> strings = ((K.StringTemplate) arg).getStrings();
                        if (strings.size() == 2 && strings.get(0) instanceof J.Literal && strings.get(1) instanceof K.StringTemplate.Expression) {
                            groupArtifact = (J.Literal) strings.get(0);
                            versionVariable = ((K.StringTemplate.Expression) strings.get(1)).getTree();
                        }
                    }
                    if (groupArtifact != null && groupArtifact.getValue() instanceof String && versionVariable instanceof J.Identifier) {
                        Dependency dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                        if (dep != null && shouldResolveVersion(dep.getGroupId(), dep.getArtifactId())) {
                            acc.variableNames.computeIfAbsent(((J.Identifier) versionVariable).getSimpleName(), it -> new HashMap<>())
                                    .computeIfAbsent(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()), it -> new HashSet<>())
                                    .add(method.getSimpleName());
                        }
                    }
                } else if (depArgs.size() >= 3) {
                    Expression groupValue = null;
                    Expression artifactValue = null;
                    Expression versionExp = null;
                    if (depArgs.get(0) instanceof G.MapEntry && depArgs.get(1) instanceof G.MapEntry && depArgs.get(2) instanceof G.MapEntry) {
                        groupValue = ((G.MapEntry) depArgs.get(0)).getValue();
                        artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();
                        versionExp = ((G.MapEntry) depArgs.get(2)).getValue();

                    } else if (depArgs.get(0) instanceof J.Assignment && depArgs.get(1) instanceof J.Assignment && depArgs.get(2) instanceof J.Assignment) {
                        groupValue = ((J.Assignment) depArgs.get(0)).getAssignment();
                        artifactValue = ((J.Assignment) depArgs.get(1)).getAssignment();
                        versionExp = ((J.Assignment) depArgs.get(2)).getAssignment();
                    }
                    if (groupValue instanceof J.Literal && artifactValue instanceof J.Literal && (versionExp instanceof J.Identifier || versionExp instanceof J.FieldAccess)) {
                        J.Literal groupLiteral = (J.Literal) groupValue;
                        J.Literal artifactLiteral = (J.Literal) artifactValue;
                        if (groupLiteral.getValue() instanceof String && artifactLiteral.getValue() instanceof String && shouldResolveVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {
                            String versionVariableName = versionExp instanceof J.Identifier ?
                                    ((J.Identifier) versionExp).getSimpleName() :
                                    (versionExp).printTrimmed(getCursor());
                            acc.variableNames.computeIfAbsent(versionVariableName, it -> new HashMap<>())
                                    .computeIfAbsent(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()), it -> new HashSet<>())
                                    .add(method.getSimpleName());
                        }
                    }
                }
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            private final UpdateGradle updateGradle = new UpdateGradle(acc);
            private final UpdateProperties updateProperties = new UpdateProperties(acc);

            @Override
            public boolean isAcceptable(SourceFile sf, ExecutionContext ctx) {
                return updateProperties.isAcceptable(sf, ctx) || updateGradle.isAcceptable(sf, ctx);
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                Tree t = tree;
                if (t instanceof SourceFile) {
                    SourceFile sf = (SourceFile) t;
                    if (updateProperties.isAcceptable(sf, ctx)) {
                        t = updateProperties.visitNonNull(t, ctx);
                    } else if (updateGradle.isAcceptable(sf, ctx)) {
                        t = updateGradle.visitNonNull(t, ctx);
                    }
                    Optional<GradleProject> projectMarker = t.getMarkers().findFirst(GradleProject.class);
                    if (tree != t && projectMarker.isPresent()) {
                        try {
                            GradleProject gradleProject = projectMarker.get();
                            Map<GroupArtifact, Set<String>> configurationsPerGa = acc.getConfigurationPerGAPerModule().getOrDefault(getGradleProjectKey(gradleProject), emptyMap());
                            List<GroupArtifactVersion> upgrades = new ArrayList<>();
                            if (acc.gaToNewVersion.isEmpty()) {
                                DependencyMatcher matcher = new DependencyMatcher(groupId, artifactId, null);
                                DependencyVersionSelector versionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);
                                for (GroupArtifact groupArtifact : configurationsPerGa.keySet()) {
                                    if (!matcher.matches(groupArtifact.getGroupId(), groupArtifact.getArtifactId())) {
                                        continue;
                                    }

                                    String selectedVersion = versionSelector.select(groupArtifact, null, newVersion, versionPattern, ctx);
                                    GroupArtifactVersion gav = new GroupArtifactVersion(groupArtifact.getGroupId(), groupArtifact.getArtifactId(), selectedVersion);
                                    upgrades.add(gav);

                                }

                            } else {
                                for (Map.Entry<GroupArtifact, @Nullable Object> newVersion : acc.gaToNewVersion.entrySet()) {
                                    if (newVersion.getValue() instanceof String) {
                                        GroupArtifactVersion gav = new GroupArtifactVersion(newVersion.getKey().getGroupId(), newVersion.getKey().getArtifactId(), (String) newVersion.getValue());
                                        upgrades.add(gav);
                                    }
                                }
                            }

                            gradleProject = gradleProject.upgradeDirectDependencyVersions(upgrades, ctx)
                                    .upgradeBuildscriptDirectDependencyVersions(upgrades, ctx);
                            if (projectMarker.get() != gradleProject) {
                                t = t.withMarkers(t.getMarkers().setByType(gradleProject));
                            }
                        } catch (MavenDownloadingException e) {
                            t = Markup.warn(t, e);
                        }
                    }
                }
                return t;
            }
        };
    }

    @RequiredArgsConstructor
    private class UpdateProperties extends PropertiesVisitor<ExecutionContext> {
        final DependencyVersionState acc;
        final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);

        @Override
        public Properties visitFile(Properties.File file, ExecutionContext ctx) {
            if (!file.getSourcePath().endsWith(GRADLE_PROPERTIES_FILE_NAME)) {
                return file;
            }
            return super.visitFile(file, ctx);
        }

        @Override
        public org.openrewrite.properties.tree.Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
            if (acc.versionPropNameToGA.containsKey(entry.getKey())) {
                GroupArtifact ga = acc.versionPropNameToGA.get(entry.getKey()).keySet().stream().findFirst().orElse(null);
                if (ga == null || !dependencyMatcher.matches(ga.getGroupId(), ga.getArtifactId())) {
                    return entry;
                }
                Object result = acc.gaToNewVersion.get(ga);
                if (result == null || result instanceof Exception) {
                    return entry;
                }
                VersionComparator versionComparator = getVersionComparator();
                if (versionComparator == null) {
                    return entry;
                }
                Optional<String> finalVersion = versionComparator.upgrade(entry.getValue().getText(), singletonList((String) result));
                return finalVersion.map(v -> entry.withValue(entry.getValue().withText(v))).orElse(entry);
            }
            return entry;
        }
    }

    private @Nullable VersionComparator getVersionComparator() {
        return Semver.validate(StringUtils.isBlank(newVersion) ? ""latest.release"" : newVersion, versionPattern).getValue();
    }

    @RequiredArgsConstructor
    private class UpdateGradle extends JavaVisitor<ExecutionContext> {
        final DependencyVersionState acc;

        @Nullable
        GradleProject gradleProject;

        final DependencyMatcher dependencyMatcher = new DependencyMatcher(groupId, artifactId, null);

        @Override
        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
            return (sourceFile instanceof G.CompilationUnit && sourceFile.getSourcePath().toString().endsWith("".gradle"")) ||
                   (sourceFile instanceof K.CompilationUnit && sourceFile.getSourcePath().toString().endsWith("".gradle.kts""));
        }

        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile sourceFile = (JavaSourceFile) tree;
                gradleProject = sourceFile.getMarkers().findFirst(GradleProject.class)
                        .orElse(null);
                return super.visit(sourceFile, ctx);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J postVisit(J tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) tree;
                if (!acc.variableNames.isEmpty()) {
                    cu = (JavaSourceFile) new UpdateVariable(acc.variableNames, gradleProject).visitNonNull(cu, ctx);
                }
                return cu;
            }
            return tree;
        }

        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
            GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher();

            if (gradleDependencyMatcher.get(getCursor()).isPresent()) {
                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {
                    m = updateDependency(m, ctx);
                } else if (depArgs.get(0) instanceof J.MethodInvocation &&
                           (""platform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()) ||
                            ""enforcedPlatform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()))) {
                    m = m.withArguments(ListUtils.mapFirst(depArgs, platform -> updateDependency((J.MethodInvocation) platform, ctx)));
                }
            } else if (""ext"".equals(method.getSimpleName()) && getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().endsWith(""settings.gradle"")) {
                // rare case that gradle versions are set via settings.gradle ext block (only possible for Groovy DSL)
                m = (J.MethodInvocation) new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext executionContext) {
                        J.Assignment a = super.visitAssignment(assignment, executionContext);
                        if (!(a.getVariable() instanceof J.Identifier)) {
                            return a;
                        }
                        Map<GroupArtifact, Set<String>> groupArtifactSetMap = acc.versionPropNameToGA.get(""gradle."" + a.getVariable());
                        // Guard to ensure that an unsupported notation doesn't throw an exception
                        if (groupArtifactSetMap == null) {
                            return a;
                        }
                        GroupArtifact ga = groupArtifactSetMap.entrySet().stream().findFirst().map(Map.Entry::getKey).orElse(null);
                        if (ga == null) {
                            return a;
                        }
                        String newVersion = (String) acc.gaToNewVersion.get(ga);
                        if (newVersion == null) {
                            return a;
                        }
                        if (!(a.getAssignment() instanceof J.Literal)) {
                            return a;
                        }
                        J.Literal l = (J.Literal) a.getAssignment();
                        if (J.Literal.isLiteralValue(l, newVersion)) {
                            return a;
                        }

                        VersionComparator versionComparator = getVersionComparator();
                        if (versionComparator != null) {
                            String currentVersion = (String) l.getValue();
                            Optional<String> finalVersion = versionComparator.upgrade(currentVersion, singletonList(newVersion));
                            if (!finalVersion.isPresent()) {
                                // Would be a downgrade, don't change
                                return a;
                            }
                        }

                        String quote = l.getValueSource() == null ? ""\"""" : l.getValueSource().substring(0, 1);
                        return a.withAssignment(l.withValue(newVersion).withValueSource(quote + newVersion + quote));
                    }
                }.visitNonNull(m, ctx, getCursor().getParentTreeCursor());
            } else if (""ext"".equals(m.getSimpleName())) {
                return m.withArguments(ListUtils.map(m.getArguments(), arg -> (Expression) new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext executionContext) {
                        if(assignment.getVariable() instanceof J.Identifier &&  acc.versionPropNameToGA.containsKey(((J.Identifier) assignment.getVariable()).getSimpleName())) {
                            acc.variableNames
                                    .computeIfAbsent(((J.Identifier) assignment.getVariable()).getSimpleName(), it -> acc.versionPropNameToGA.get(((J.Identifier) assignment.getVariable()).getSimpleName()));
                        }
                        return super.visitAssignment(assignment, executionContext);
                    }
                }.visit(arg, ctx)));
            }
            return m;
        }

        private J.MethodInvocation updateDependency(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = method;
            m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                if (arg instanceof G.GString) {
                    G.GString gString = (G.GString) arg;
                    List<J> strings = gString.getStrings();
                    if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof G.GString.Value)) {
                        return arg;
                    }
                    J.Literal groupArtifact = (J.Literal) strings.get(0);
                    G.GString.Value versionValue = (G.GString.Value) strings.get(1);
                    if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {
                        return arg;
                    }
                    Dependency dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                    if (dep != null && dependencyMatcher.matches(dep.getGroupId(), dep.getArtifactId())) {
                        Object scanResult = acc.gaToNewVersion.get(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));
                        if (scanResult instanceof Exception) {
                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, scanResult);
                            return arg;
                        }

                        String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();
                        replaceVariableValue(versionVariableName, method, dep.getGroupId(), dep.getArtifactId());
                    }
                } else if (arg instanceof K.StringTemplate) {
                    K.StringTemplate template = (K.StringTemplate) arg;
                    List<J> strings = template.getStrings();
                    if (strings.size() != 2 || !(strings.get(0) instanceof J.Literal) || !(strings.get(1) instanceof K.StringTemplate.Expression)) {
                        return arg;
                    }
                    J.Literal groupArtifact = (J.Literal) strings.get(0);
                    K.StringTemplate.Expression versionValue = (K.StringTemplate.Expression) strings.get(1);
                    if (!(versionValue.getTree() instanceof J.Identifier) || !(groupArtifact.getValue() instanceof String)) {
                        return arg;
                    }
                    Dependency dep = DependencyStringNotationConverter.parse((String) groupArtifact.getValue());
                    if (dep != null && dependencyMatcher.matches(dep.getGroupId(), dep.getArtifactId())) {
                        Object scanResult = acc.gaToNewVersion.get(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));
                        if (scanResult instanceof Exception) {
                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, scanResult);
                            return arg;
                        }

                        String versionVariableName = ((J.Identifier) versionValue.getTree()).getSimpleName();
                        replaceVariableValue(versionVariableName, method, dep.getGroupId(), dep.getArtifactId());
                    }
                } else if (arg instanceof J.Literal) {
                    J.Literal literal = (J.Literal) arg;
                    if (literal.getType() != JavaType.Primitive.String) {
                        return arg;
                    }
                    String gav = (String) literal.getValue();
                    if (gav == null) {
                        getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, new IllegalStateException(""Unable to update version""));
                        return arg;
                    }
                    Dependency dep = DependencyStringNotationConverter.parse(gav);
                    if (dep != null && dependencyMatcher.matches(dep.getGroupId(), dep.getArtifactId()) &&
                        dep.getVersion() != null &&
                        !dep.getVersion().startsWith(""$"")) {
                        Object scanResult = acc.gaToNewVersion.get(new GroupArtifact(dep.getGroupId(), dep.getArtifactId()));
                        if (scanResult instanceof Exception) {
                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, scanResult);
                            return arg;
                        }

                        try {
                            String selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(dep.getGav(), method.getSimpleName(), newVersion, versionPattern, ctx);
                            if (selectedVersion == null || dep.getVersion().equals(selectedVersion)) {
                                return arg;
                            }

                            String newGav = dep
                                    .withVersion(selectedVersion)
                                    .toStringNotation();
                            return literal
                                    .withValue(newGav)
                                    .withValueSource(literal.getValueSource() == null ? newGav : literal.getValueSource().replace(gav, newGav));
                        } catch (MavenDownloadingException e) {
                            getCursor().putMessage(UPDATE_VERSION_ERROR_KEY, e);
                        }
                    }
                }
                return arg;
            }));
            Exception err = getCursor().pollMessage(UPDATE_VERSION_ERROR_KEY);
            if (err != null) {
                m = Markup.warn(m, err);
            }
            List<Expression> depArgs = m.getArguments();
            if (depArgs.size() >= 3) {
                if (depArgs.get(0) instanceof G.MapEntry &&
                    depArgs.get(1) instanceof G.MapEntry &&
                    depArgs.get(2) instanceof G.MapEntry) {
                    Expression groupValue = ((G.MapEntry) depArgs.get(0)).getValue();
                    Expression artifactValue = ((G.MapEntry) depArgs.get(1)).getValue();
                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {
                        return m;
                    }
                    J.Literal groupLiteral = (J.Literal) groupValue;
                    J.Literal artifactLiteral = (J.Literal) artifactValue;
                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {
                        return m;
                    }
                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));
                    if (scanResult instanceof Exception) {
                        return Markup.warn(m, (Exception) scanResult);
                    }
                    G.MapEntry versionEntry = (G.MapEntry) depArgs.get(2);
                    Expression versionExp = versionEntry.getValue();
                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {
                        J.Literal versionLiteral = (J.Literal) versionExp;
                        String version = (String) versionLiteral.getValue();
                        if (version.startsWith(""$"")) {
                            return m;
                        }
                        String selectedVersion;
                        try {
                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);
                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);
                        } catch (MavenDownloadingException e) {
                            return e.warn(m);
                        }
                        if (selectedVersion == null || version.equals(selectedVersion)) {
                            return m;
                        }
                        List<Expression> newArgs = new ArrayList<>(3);
                        newArgs.add(depArgs.get(0));
                        newArgs.add(depArgs.get(1));
                        newArgs.add(versionEntry.withValue(
                                versionLiteral
                                        .withValueSource(versionLiteral.getValueSource() == null ?
                                                selectedVersion :
                                                versionLiteral.getValueSource().replace(version, selectedVersion))
                                        .withValue(selectedVersion)));
                        newArgs.addAll(depArgs.subList(3, depArgs.size()));

                        return m.withArguments(newArgs);
                    } else if (versionExp instanceof J.Identifier) {
                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();
                        replaceVariableValue(versionVariableName, m, (String) groupLiteral.getValue(), (String) artifactLiteral.getValue());
                    } else if (versionExp instanceof G.GString) {
                        G.GString gString = (G.GString) versionExp;

                        if (gString.getStrings().size() != 1) {
                            return m;
                        }

                        G.GString.Value versionLiteral = (G.GString.Value) gString.getStrings().get(0);
                        String versionVariableName = versionLiteral.printTrimmed(getCursor());

                        if (versionVariableName.startsWith(""$"")) {
                            versionVariableName = versionVariableName.replaceAll(""^\\$\\{?|}?$"", """");
                        }

                        replaceVariableValue(versionVariableName, m, (String) groupLiteral.getValue(), (String) artifactLiteral.getValue());
                    }
                } else if (depArgs.get(0) instanceof J.Assignment &&
                           depArgs.get(1) instanceof J.Assignment &&
                           depArgs.get(2) instanceof J.Assignment) {
                    Expression groupValue = ((J.Assignment) depArgs.get(0)).getAssignment();
                    Expression artifactValue = ((J.Assignment) depArgs.get(1)).getAssignment();
                    if (!(groupValue instanceof J.Literal) || !(artifactValue instanceof J.Literal)) {
                        return m;
                    }
                    J.Literal groupLiteral = (J.Literal) groupValue;
                    J.Literal artifactLiteral = (J.Literal) artifactValue;
                    if (groupLiteral.getValue() == null || artifactLiteral.getValue() == null || !dependencyMatcher.matches((String) groupLiteral.getValue(), (String) artifactLiteral.getValue())) {
                        return m;
                    }
                    Object scanResult = acc.gaToNewVersion.get(new GroupArtifact((String) groupLiteral.getValue(), (String) artifactLiteral.getValue()));
                    if (scanResult instanceof Exception) {
                        return Markup.warn(m, (Exception) scanResult);
                    }
                    K.Assignment versionEntry = (J.Assignment) depArgs.get(2);
                    Expression versionExp = versionEntry.getAssignment();
                    if (versionExp instanceof J.Literal && ((J.Literal) versionExp).getValue() instanceof String) {
                        J.Literal versionLiteral = (J.Literal) versionExp;
                        String version = (String) versionLiteral.getValue();
                        if (version.startsWith(""$"")) {
                            return m;
                        }
                        String selectedVersion;
                        try {
                            GroupArtifactVersion gav = new GroupArtifactVersion((String) groupLiteral.getValue(), (String) artifactLiteral.getValue(), version);
                            selectedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(gav, m.getSimpleName(), newVersion, versionPattern, ctx);
                        } catch (MavenDownloadingException e) {
                            return e.warn(m);
                        }
                        if (selectedVersion == null || version.equals(selectedVersion)) {
                            return m;
                        }
                        List<Expression> newArgs = new ArrayList<>(3);
                        newArgs.add(depArgs.get(0));
                        newArgs.add(depArgs.get(1));
                        newArgs.add(versionEntry.withAssignment(
                                versionLiteral
                                        .withValueSource(versionLiteral.getValueSource() == null ?
                                                selectedVersion :
                                                versionLiteral.getValueSource().replace(version, selectedVersion))
                                        .withValue(selectedVersion)));
                        newArgs.addAll(depArgs.subList(3, depArgs.size()));

                        return m.withArguments(newArgs);
                    } else if (versionExp instanceof J.Identifier) {
                        String versionVariableName = ((J.Identifier) versionExp).getSimpleName();
                        replaceVariableValue(versionVariableName, m, (String) groupLiteral.getValue(), (String) artifactLiteral.getValue());
                    } else if (versionExp instanceof K.StringTemplate) {
                        K.StringTemplate kString = (K.StringTemplate) versionExp;

                        if (kString.getStrings().size() != 1) {
                            return m;
                        }

                        K.StringTemplate.Expression versionLiteral = (K.StringTemplate.Expression) kString.getStrings().get(0);
                        String versionVariableName = versionLiteral.printTrimmed(getCursor());

                        if (versionVariableName.startsWith(""$"")) {
                            versionVariableName = versionVariableName.replaceAll(""^\\$\\{?|}?$"", """");
                        }

                        replaceVariableValue(versionVariableName, m, (String) groupLiteral.getValue(), (String) artifactLiteral.getValue());
                    }
                }
            }

            return m;
        }

        private void replaceVariableValue(String versionVariableName, J.MethodInvocation m, String groupId, String artifactId) {
            acc.variableNames.computeIfAbsent(versionVariableName, it -> new HashMap<>())
                    .computeIfAbsent(new GroupArtifact(groupId, artifactId), it -> new HashSet<>())
                    .add(m.getSimpleName());
        }
    }

    @AllArgsConstructor
    private class UpdateVariable extends JavaIsoVisitor<ExecutionContext> {
        private final Map<String, Map<GroupArtifact, Set<String>>> versionVariableNames;

        @Nullable
        private final GradleProject gradleProject;

        @Override
        public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext ctx) {
            J.VariableDeclarations.NamedVariable v = super.visitVariable(variable, ctx);
            if (!(v.getInitializer() instanceof J.Literal) ||
                ((J.Literal) v.getInitializer()).getValue() == null ||
                ((J.Literal) v.getInitializer()).getType() != JavaType.Primitive.String) {
                return v;
            }
            Map.Entry<GroupArtifact, Set<String>> gaWithConfigs = getGroupArtifactWithConfigs((v.getSimpleName()));
            if (gaWithConfigs == null) {
                return v;
            }

            try {
                J.Literal newVersion = getNewVersion((J.Literal) v.getInitializer(), gaWithConfigs, ctx);
                return newVersion == null ? v : v.withInitializer(newVersion);
            } catch (MavenDownloadingException e) {
                return e.warn(v);
            }
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            J.Assignment a = super.visitAssignment(assignment, ctx);
            if (!(a.getVariable() instanceof J.Identifier) ||
                !(a.getAssignment() instanceof J.Literal) ||
                ((J.Literal) a.getAssignment()).getValue() == null ||
                ((J.Literal) a.getAssignment()).getType() != JavaType.Primitive.String) {
                return a;
            }
            Map.Entry<GroupArtifact, Set<String>> gaWithConfigs = getGroupArtifactWithConfigs(((J.Identifier) a.getVariable()).getSimpleName());
            if (gaWithConfigs == null) {
                return a;
            }

            try {
                J.Literal newVersion = getNewVersion((J.Literal) a.getAssignment(), gaWithConfigs, ctx);
                return newVersion == null ? a : a.withAssignment(newVersion);
            } catch (MavenDownloadingException e) {
                return e.warn(a);
            }
        }

        private Map.@Nullable Entry<GroupArtifact, Set<String>> getGroupArtifactWithConfigs(String identifier) {
            for (Map.Entry<String, Map<GroupArtifact, Set<String>>> versionVariableNameEntry : versionVariableNames.entrySet()) {
                if (versionVariableNameEntry.getKey().equals(identifier)) {
                    // take first matching group artifact with its configurations
                    return versionVariableNameEntry.getValue().entrySet().iterator().next();
                }
            }
            return null;
        }

        private J.@Nullable Literal getNewVersion(J.Literal literal, Map.Entry<GroupArtifact, Set<String>> gaWithConfigurations, ExecutionContext ctx) throws MavenDownloadingException {
            GroupArtifact ga = gaWithConfigurations.getKey();
            DependencyVersionSelector dependencyVersionSelector = new DependencyVersionSelector(metadataFailures, gradleProject, null);
            GroupArtifactVersion gav = new GroupArtifactVersion(ga.getGroupId(), ga.getArtifactId(), (String) literal.getValue());

            String selectedVersion;
            try {
                selectedVersion = dependencyVersionSelector.select(gav, null, newVersion, versionPattern, ctx);
            } catch (MavenDownloadingException e) {
                if (!gaWithConfigurations.getValue().contains(""classpath"")) {
                    throw e;
                }
                // try again with ""classpath"" configuration; if this one fails as well, the MavenDownloadingException is bubbled up so it can be handled
                selectedVersion = dependencyVersionSelector.select(gav, ""classpath"", newVersion, versionPattern, ctx);
            }
            if (selectedVersion == null) {
                return null;
            }

            return ChangeStringLiteral.withStringValue(literal, selectedVersion);
        }
    }

    static String getGradleProjectKey(GradleProject project) {
        if (StringUtils.isBlank(project.getGroup())) {
            return project.getName();
        }
        if ("":"".equals(project.getPath())) {
            return project.getGroup();
        }
        return project.getGroup() + project.getPath();
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Change Gradle dependency group,Change the group of a specified Gradle dependency.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.semver.DependencyMatcher;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeDependencyGroupId extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""New groupId"",
            description = ""The new groupId to use."",
            example = ""corp.internal.jackson"")
    String newGroupId;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Change Gradle dependency group"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Change the group of a specified Gradle dependency."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(DependencyMatcher.build(groupId + "":"" + artifactId));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(groupId + "":"" + artifactId).getValue());

            GradleProject gradleProject;

            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);
                if (!maybeGp.isPresent()) {
                    return cu;
                }

                gradleProject = maybeGp.get();

                G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);
                if (g != cu) {
                    g = g.withMarkers(g.getMarkers().setByType(updateGradleModel(gradleProject)));
                }
                return g;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .configuration(configuration)
                        .groupId(groupId)
                        .artifactId(artifactId);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral) {
                    m = updateDependency(m);
                } else if (depArgs.get(0) instanceof J.MethodInvocation &&
                        (""platform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()) ||
                                ""enforcedPlatform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()))) {
                    m = m.withArguments(ListUtils.mapFirst(depArgs, platform -> updateDependency((J.MethodInvocation) platform)));
                }

                return m;
            }

            private J.MethodInvocation updateDependency(J.MethodInvocation m) {
                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal) {
                    String gav = (String) ((J.Literal) depArgs.get(0)).getValue();
                    if (gav != null) {
                        Dependency dependency = DependencyStringNotationConverter.parse(gav);
                        if (dependency != null && !newGroupId.equals(dependency.getGroupId())) {
                            Dependency newDependency = dependency.withGroupId(newGroupId);
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, newDependency.toStringNotation())));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.GString) {
                    List<J> strings = ((G.GString) depArgs.get(0)).getStrings();
                    if (strings.size() >= 2 &&
                            strings.get(0) instanceof J.Literal) {
                        Dependency dependency = DependencyStringNotationConverter.parse((String) requireNonNull(((J.Literal) strings.get(0)).getValue()));
                        if (dependency != null && !newGroupId.equals(dependency.getGroupId())) {
                            Dependency newDependency = dependency.withGroupId(newGroupId);
                            String replacement = newDependency.toStringNotation();
                            m = m.withArguments(ListUtils.mapFirst(depArgs, arg -> {
                                G.GString gString = (G.GString) arg;
                                return gString.withStrings(ListUtils.mapFirst(gString.getStrings(), l -> ((J.Literal) l).withValue(replacement).withValueSource(replacement)));
                            }));
                        }
                    }
                } else if (depArgs.get(0) instanceof G.MapEntry) {
                    G.MapEntry groupEntry = null;
                    String groupId = null;
                    String artifactId = null;

                    String versionStringDelimiter = ""'"";
                    for (Expression e : depArgs) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue) && !newGroupId.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                versionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            groupEntry = arg;
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    String delimiter = versionStringDelimiter;
                    G.MapEntry finalGroup = groupEntry;
                    m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                        if (arg == finalGroup) {
                            return finalGroup.withValue(((J.Literal) finalGroup.getValue())
                                    .withValue(newGroupId)
                                    .withValueSource(delimiter + newGroupId + delimiter));
                        }
                        return arg;
                    }));
                } else if (depArgs.get(0) instanceof G.MapLiteral) {
                    G.MapLiteral map = (G.MapLiteral) depArgs.get(0);
                    G.MapEntry groupEntry = null;
                    String groupId = null;
                    String artifactId = null;

                    String versionStringDelimiter = ""'"";
                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        if (""group"".equals(keyValue) && !newGroupId.equals(valueValue)) {
                            if (value.getValueSource() != null) {
                                versionStringDelimiter = value.getValueSource().substring(0, value.getValueSource().indexOf(valueValue));
                            }
                            groupEntry = arg;
                            groupId = valueValue;
                        } else if (""name"".equals(keyValue)) {
                            artifactId = valueValue;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    String delimiter = versionStringDelimiter;
                    G.MapEntry finalGroup = groupEntry;
                    m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                        G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                        return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> {
                            if (e == finalGroup) {
                                return finalGroup.withValue(((J.Literal) finalGroup.getValue())
                                        .withValue(newGroupId)
                                        .withValueSource(delimiter + newGroupId + delimiter));
                            }
                            return e;
                        }));
                    }));
                }

                return m;
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    if (!StringUtils.isBlank(configuration) && configuration.equals(gdc.getName())) {
                        newNameToConfiguration.put(gdc.getName(), gdc);
                        continue;
                    }

                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId())) {
                            return requested.withGav(requested.getGav().withGroupId(newGroupId));
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId())) {
                            return resolved.withGav(resolved.getGav().withGroupId(newGroupId));
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field"",
  ""newGroupId"": ""String field""
}"
Remove repository,Removes a repository from Gradle build scripts. Named repositories include \,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveRepository extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove repository"";
    }

    @Override
    public String getDescription() {
        return ""Removes a repository from Gradle build scripts. Named repositories include \""jcenter\"", \""mavenCentral\"", \""mavenLocal\"", and \""google\""."";
    }

    @Option(displayName = ""Repository"",
            description = ""The name of the repository to remove"",
            example = ""jcenter"")
    String repository;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (repository.equals(method.getSimpleName())) {
                    try {
                        Cursor cursor = getCursor().dropParentUntil(e -> e instanceof J.MethodInvocation);
                        if (""repositories"".equals(((J.MethodInvocation) cursor.getValue()).getSimpleName())) {
                            return null;
                        }
                    } catch (Exception ignored) {}
                }
                return super.visitMethodInvocation(method, ctx);
            }
        });
    }
}
","{
  ""repository"": ""String field""
}"
Add Gradle dependency,Add a gradle dependency to a `build.gradle` file in the correct configuration based on where it is used.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.search.FindJVMTestSuites;
import org.openrewrite.gradle.trait.JvmTestSuite;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.semver.Semver;

import java.util.*;

import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddDependency extends ScanningRecipe<AddDependency.Scanned> {

    @EqualsAndHashCode.Exclude
    MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate 'com.google.guava:guava:VERSION'."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate 'com.google.guava:guava:VERSION'"",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                    ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                    ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                    ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""29.X"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example, "" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Configuration"",
            description = ""A configuration to use when it is not what can be inferred from usage. Most of the time this will be left empty, but "" +
                    ""is used when adding a new as of yet unused dependency."",
            example = ""implementation"",
            required = false)
    @Nullable
    String configuration;

    @Option(displayName = ""Only if using"",
            description = ""Used to determine if the dependency will be added and in which scope it should be placed."",
            example = ""org.junit.jupiter.api.*"",
            required = false)
    @Nullable
    String onlyIfUsing;

    @Option(displayName = ""Classifier"",
            description = ""A classifier to add. Commonly used to select variants of a library."",
            example = ""test"",
            required = false)
    @Nullable
    String classifier;

    @Option(displayName = ""Extension"",
            description = ""The extension of the dependency to add. If omitted Gradle defaults to assuming the type is \""jar\""."",
            example = ""jar"",
            required = false)
    @Nullable
    String extension;

    @Option(displayName = ""Family pattern"",
            description = ""A pattern, applied to groupIds, used to determine which other dependencies should have aligned version numbers. "" +
                    ""Accepts '*' as a wildcard character."",
            example = ""com.fasterxml.jackson*"",
            required = false)
    @Nullable
    String familyPattern;

    @Option(displayName = ""Accept transitive"",
            description = ""Default false. If enabled, the dependency will not be added if it is already on the classpath as a transitive dependency."",
            example = ""true"",
            required = false)
    @Nullable
    Boolean acceptTransitive;

    @Override
    public String getDisplayName() {
        return ""Add Gradle dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s:%s`"", groupId, artifactId, version);
    }

    @Override
    public String getDescription() {
        return ""Add a gradle dependency to a `build.gradle` file in the correct configuration based on where it is used."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    public static class Scanned {
        Map<JavaProject, Boolean> usingType = new HashMap<>();
        Map<JavaProject, Set<String>> configurationsByProject = new HashMap<>();
    }

    @Override
    public Scanned getInitialValue(ExecutionContext ctx) {
        return new Scanned();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Scanned acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Nullable
            UsesType<ExecutionContext> usesType = null;

            private boolean usesType(SourceFile sourceFile, ExecutionContext ctx) {
                if (onlyIfUsing == null) {
                    return true;
                }
                if (usesType == null) {
                    usesType = new UsesType<>(onlyIfUsing, true);
                }
                return usesType.isAcceptable(sourceFile, ctx) && usesType.visit(sourceFile, ctx) != sourceFile;
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile sourceFile = (SourceFile) tree;
                sourceFile.getMarkers().findFirst(JavaProject.class).ifPresent(javaProject -> {
                    acc.usingType.compute(javaProject, (jp, usingType) -> Boolean.TRUE.equals(usingType) || usesType(sourceFile, ctx));

                    Set<String> configurations = acc.configurationsByProject.computeIfAbsent(javaProject, ignored -> new HashSet<>());
                    sourceFile.getMarkers().findFirst(JavaSourceSet.class).ifPresent(sourceSet ->
                            configurations.add(""main"".equals(sourceSet.getName()) ? ""implementation"" : sourceSet.getName() + ""Implementation""));
                });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Scanned acc) {
        return Preconditions.check(!acc.configurationsByProject.isEmpty(),
                Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {

                    @Override
                    public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                        if (!(tree instanceof JavaSourceFile)) {
                            return (J) tree;
                        }
                        JavaSourceFile s = (JavaSourceFile) tree;
                        Optional<JavaProject> maybeJp = s.getMarkers().findFirst(JavaProject.class);
                        Optional<GradleProject> maybeGp = s.getMarkers().findFirst(GradleProject.class);
                        if (!maybeJp.isPresent() ||
                                (onlyIfUsing != null && !acc.usingType.getOrDefault(maybeJp.get(), false)) || !acc.configurationsByProject.containsKey(maybeJp.get()) ||
                                !maybeGp.isPresent()) {
                            return s;
                        }

                        JavaProject jp = maybeJp.get();
                        GradleProject gp = maybeGp.get();

                        Set<String> resolvedConfigurations = StringUtils.isBlank(configuration) ?
                                acc.configurationsByProject.getOrDefault(jp, new HashSet<>()) :
                                new HashSet<>(singletonList(configuration));
                        if (resolvedConfigurations.isEmpty()) {
                            resolvedConfigurations.add(""implementation"");
                        }

                        GradleConfigurationFilter gradleConfigurationFilter = new GradleConfigurationFilter(gp, resolvedConfigurations);
                        gradleConfigurationFilter.removeTransitiveConfigurations();
                        gradleConfigurationFilter.removeConfigurationsContainingDependency(new GroupArtifact(groupId, artifactId));
                        gradleConfigurationFilter.removeConfigurationsContainingTransitiveDependency(new GroupArtifact(groupId, artifactId));
                        resolvedConfigurations = gradleConfigurationFilter.getFilteredConfigurations();

                        if (resolvedConfigurations.isEmpty()) {
                            return s;
                        }

                        Set<JvmTestSuite> jvmTestSuites = FindJVMTestSuites.jvmTestSuites(s);
                        for (String resolvedConfiguration : resolvedConfigurations) {
                            JvmTestSuite jvmTestSuite = maybeJvmTestSuite(resolvedConfiguration, jvmTestSuites);
                            if (jvmTestSuite != null) {
                                s = (JavaSourceFile) jvmTestSuite.addDependency(resolvedConfiguration, groupId, artifactId, version, versionPattern, classifier, extension, metadataFailures, null, ctx)
                                        .visitNonNull(s, ctx);
                            } else {
                                s = (JavaSourceFile) new AddDependencyVisitor(groupId, artifactId, version, versionPattern, resolvedConfiguration,
                                        classifier, extension, metadataFailures, this::isTopLevel, null).visitNonNull(s, ctx);
                            }
                        }

                        return s;
                    }

                    private boolean isTopLevel(Cursor cursor) {
                        if (cursor.getValue() instanceof J.Block) {
                            return cursor.getParentOrThrow().getValue() instanceof JavaSourceFile;
                        }
                        return cursor.getParentOrThrow().firstEnclosing(J.MethodInvocation.class) == null;
                    }

                    private @Nullable JvmTestSuite maybeJvmTestSuite(String configuration, Set<JvmTestSuite> jvmTestSuites) {
                        for (JvmTestSuite jvmTestSuite : jvmTestSuites) {
                            if (jvmTestSuite.isAcceptable(configuration)) {
                                return jvmTestSuite;
                            }
                        }
                        return null;
                    }
                })
        );
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Dependency constraint to resolution rule,Gradle [dependency constraints](https://docs.gradle.org/current/userguide/dependency_constraints.html#dependency-constraints) ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.*;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.groovy.GroovyParser;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.*;
import org.openrewrite.kotlin.KotlinParser;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Markers;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class DependencyConstraintToRule extends Recipe {

    private static final MethodMatcher DEPENDENCIES_DSL_MATCHER = new MethodMatcher(""RewriteGradleProject dependencies(..)"");
    private static final String CONSTRAINT_MATCHER = ""org.gradle.api.artifacts.dsl.DependencyHandler *(..)"";

    @Override
    public String getDisplayName() {
        return ""Dependency constraint to resolution rule"";
    }

    @Override
    public String getDescription() {
        return ""Gradle [dependency constraints](https://docs.gradle.org/current/userguide/dependency_constraints.html#dependency-constraints) "" +
                ""are useful for managing the versions of transitive dependencies. "" +
                ""Some plugins, such as the Spring Dependency Management plugin, do not respect these constraints. "" +
                ""This recipe converts constraints into [resolution rules](https://docs.gradle.org/current/userguide/resolution_rules.html), "" +
                ""which can achieve similar effects to constraints but are harder for plugins to ignore."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof JavaSourceFile)) {
                    return (J) tree;
                }
                List<GroupArtifactVersionBecause> gavs = new ArrayList<>();
                JavaSourceFile cu = (JavaSourceFile) new RemoveConstraints().visitNonNull(tree, gavs);
                if (gavs.isEmpty()) {
                    return (J) tree;
                }
                cu = (JavaSourceFile) new MaybeAddEachDependency().visitNonNull(cu, ctx);
                cu = (JavaSourceFile) new UpdateEachDependency(gavs, cu instanceof K.CompilationUnit).visitNonNull(cu, ctx);
                return new MaybeRemoveDependencyBlock().visitNonNull(cu, ctx);
            }
        });
    }

    @Value
    static class GroupArtifactVersionBecause {
        @Nullable
        String groupId;

        String artifactId;

        @Nullable
        String version;

        @Nullable
        String because;
    }

    static class RemoveConstraints extends JavaIsoVisitor<List<GroupArtifactVersionBecause>> {

        @SuppressWarnings({""DataFlowIssue"", ""NullableProblems""})
        @Override
        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, List<GroupArtifactVersionBecause> groupArtifactVersions) {
            J.MethodInvocation m = super.visitMethodInvocation(method, groupArtifactVersions);
            if (""constraints"".equals(m.getSimpleName()) && isInDependenciesBlock(getCursor())) {
                if (!(m.getArguments().get(0) instanceof J.Lambda)) {
                    return null;
                }
                J.Lambda closure = (J.Lambda) m.getArguments().get(0);
                if (!(closure.getBody() instanceof J.Block)) {
                    return null;
                }
                List<Statement> withoutConvertableConstraints = ListUtils.map(((J.Block) closure.getBody()).getStatements(), statement -> {
                    J.MethodInvocation constraint = null;
                    if (statement instanceof J.MethodInvocation) {
                        constraint = (J.MethodInvocation) statement;
                    } else if (statement instanceof J.Return) {
                        constraint = (J.MethodInvocation) ((J.Return) statement).getExpression();
                    }
                    if (constraint == null) {
                        return statement;
                    }
                    if (!(constraint.getArguments().get(0) instanceof J.Literal)) {
                        return statement;
                    }
                    J.Literal rawGav = (J.Literal) constraint.getArguments().get(0);
                    String[] gav = rawGav.getValue().toString().split("":"");
                    if (gav.length != 3) {
                        return statement;
                    }
                    AtomicReference<String> because = new AtomicReference<>(null);
                    new JavaIsoVisitor<Integer>() {
                        @Override
                        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, Integer integer) {
                            J.MethodInvocation m1 = super.visitMethodInvocation(method, integer);
                            if (""because"".equals(m1.getSimpleName()) && m1.getArguments().get(0) instanceof J.Literal) {
                                because.set(((J.Literal) m1.getArguments().get(0)).getValue().toString());
                            }
                            return m1;
                        }
                    }.visit(constraint.getArguments(), 0);

                    groupArtifactVersions.add(new GroupArtifactVersionBecause(gav[0], gav[1], gav[2], because.get()));
                    return null;
                });
                // If nothing remains in the constraints{} it can be removed entirely
                if (withoutConvertableConstraints.isEmpty()) {
                    return null;
                } else {
                    return m.withArguments(singletonList(closure.withBody(((J.Block) closure.getBody()).withStatements(withoutConvertableConstraints))));
                }
            }
            return m;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    static class UpdateEachDependency extends JavaIsoVisitor<ExecutionContext> {
        List<GroupArtifactVersionBecause> groupArtifactVersions;
        boolean isKotlinDsl;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (isEachDependency(m) && !isInBuildscriptBlock(getCursor())) {
                Cursor parent = requireNonNull(getCursor().getParent());
                for (GroupArtifactVersionBecause gav : groupArtifactVersions) {
                    m = (J.MethodInvocation) new MaybeAddIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);
                    m = (J.MethodInvocation) new UpdateIf(gav, isKotlinDsl).visitNonNull(m, ctx, parent);
                }
            }
            return m;
        }
    }

    @RequiredArgsConstructor
    static class MaybeAddIf extends JavaIsoVisitor<ExecutionContext> {
        @NonNull
        GroupArtifactVersionBecause groupArtifactVersion;

        final boolean isKotlinDsl;

        boolean containsAnyIfStatement;
        boolean containsMatchingIfStatement;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (containsMatchingIfStatement) {
                return m;
            }
            if (!isEachDependency(m)) {
                return m;
            }
            // Identify the parameter name used in the eachDependency closure
            Expression maybeClosure = m.getArguments().get(0);
            if (!(maybeClosure instanceof J.Lambda) || !(((J.Lambda) maybeClosure).getBody() instanceof J.Block)) {
                return m;
            }
            J.Lambda closure = (J.Lambda) maybeClosure;
            J.Block closureBody = (J.Block) closure.getBody();
            J rawParam = ((J.Lambda) maybeClosure).getParameters().getParameters().get(0);
            if (!(rawParam instanceof J.VariableDeclarations)) {
                return m;
            }
            String p = ((J.VariableDeclarations) rawParam).getVariables().get(0).getSimpleName();
            J.If newIf;
            if (!isKotlinDsl) {
                @SuppressWarnings(""GroovyEmptyStatementBody"") @Language(""groovy"")
                String snippet = ""Object "" + p + "" = null\n"" +
                        ""if ("" + p + "".requested.group == '"" + groupArtifactVersion.getGroupId() + ""' && "" +
                        p + "".requested.name == '"" + groupArtifactVersion.getArtifactId() + ""') {\n}"";
                newIf = GroovyParser.builder().build()
                        .parse(ctx, snippet)
                        .map(G.CompilationUnit.class::cast)
                        .map(cu -> cu.getStatements().get(1))
                        .map(J.If.class::cast)
                        .findFirst()
                        .orElseThrow(() -> new IllegalStateException(""Unable to produce a new if statement""));
            } else {
                String snippet = ""var "" + p + "": Any = null\n"" +
                        ""if ("" + p + "".requested.group == \"""" + groupArtifactVersion.getGroupId() + ""\"" && "" +
                        p + "".requested.name == \"""" + groupArtifactVersion.getArtifactId() + ""\"") {\n}"";
                newIf = KotlinParser.builder().isKotlinScript(true).build()
                        .parse(ctx, snippet)
                        .map(K.CompilationUnit.class::cast)
                        .map(cu -> (J.Block) cu.getStatements().get(0))
                        .map(block -> (J.If) block.getStatements().get(1))
                        .findFirst()
                        .orElseThrow(() -> new IllegalStateException(""Unable to produce a new if statement""));
            }
            if (containsAnyIfStatement) {
                m = (J.MethodInvocation) new JavaIsoVisitor<Integer>() {
                    boolean inserted;

                    @Override
                    public J.If visitIf(J.If iff, Integer integer) {
                        J.If anIf = super.visitIf(iff, integer);
                        J.If.Else currentElse = anIf.getElsePart();
                        if (!inserted && (currentElse == null || currentElse.getBody() instanceof J.Block)) {
                            inserted = true;
                            J.If.Else newElsePart = new J.If.Else(Tree.randomId(), Space.SINGLE_SPACE, Markers.EMPTY,
                                    JRightPadded.build(newIf
                                            .withPrefix(Space.SINGLE_SPACE)
                                            .withElsePart(currentElse)));
                            anIf = autoFormat(anIf.withElsePart(newElsePart), 0, requireNonNull(getCursor().getParent()));
                        }
                        return anIf;
                    }
                }.visitNonNull(m, 0, requireNonNull(getCursor().getParent()));
            } else {
                J.Block newBody = autoFormat(closureBody.withStatements(ListUtils.concat(newIf, closureBody.getStatements())), ctx, getCursor());
                m = m.withArguments(singletonList(closure.withBody(newBody)));
            }
            return m;
        }


        @Override
        public J.If visitIf(J.If iff, ExecutionContext ctx) {
            containsAnyIfStatement = true;
            J.If f = super.visitIf(iff, ctx);
            if (predicateRelatesToGav(f, groupArtifactVersion)) {
                containsMatchingIfStatement = true;
            }
            return iff;
        }

        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            // Avoid wasting time if we've already found it
            if (containsMatchingIfStatement) {
                return (J) tree;
            }
            return super.visit(tree, ctx);
        }
    }

    @AllArgsConstructor
    static class UpdateIf extends JavaIsoVisitor<ExecutionContext> {
        GroupArtifactVersionBecause groupArtifactVersionBecause;
        boolean isKotlinDsl;

        @Override
        public J.If visitIf(J.If iff, ExecutionContext ctx) {
            J.If anIf = super.visitIf(iff, ctx);
            if (predicateRelatesToGav(anIf, groupArtifactVersionBecause)) {
                // The predicate of the if condition will already contain the relevant variable name
                AtomicReference<String> variableName = new AtomicReference<>();
                new JavaIsoVisitor<Integer>() {
                    @Override
                    public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Integer integer) {
                        // Comparison will involve ""<variable name>.requested.group""
                        J.FieldAccess field = super.visitFieldAccess(fieldAccess, integer);
                        if (field.getTarget() instanceof J.Identifier) {
                            variableName.set(((J.Identifier) field.getTarget()).getSimpleName());
                        }
                        return fieldAccess;
                    }
                }.visit(anIf.getIfCondition(), 0);
                List<Statement> newStatements;
                if (!isKotlinDsl) {
                    @Language(""groovy"")
                    String snippet = variableName + "".useVersion('"" + groupArtifactVersionBecause.getVersion() + ""')\n"";
                    if (groupArtifactVersionBecause.getBecause() != null) {
                        snippet += variableName + "".because('"" + groupArtifactVersionBecause.getBecause() + ""')\n"";
                    }
                    newStatements = GroovyParser.builder()
                            .build()
                            .parse(ctx, snippet)
                            .map(G.CompilationUnit.class::cast)
                            .map(G.CompilationUnit::getStatements)
                            .findFirst()
                            .orElseThrow(() -> new IllegalStateException(""Unable to produce a new block statement""));
                } else {
                    @Language(""kotlin"")
                    String snippet = variableName + "".useVersion(\"""" + groupArtifactVersionBecause.getVersion() + ""\"")\n"";
                    if (groupArtifactVersionBecause.getBecause() != null) {
                        snippet += variableName + "".because(\"""" + groupArtifactVersionBecause.getBecause() + ""\"")\n"";
                    }
                    newStatements = KotlinParser.builder()
                            .isKotlinScript(true)
                            .build()
                            .parse(ctx, snippet)
                            .map(K.CompilationUnit.class::cast)
                            .map(cu -> (J.Block) cu.getStatements().get(0))
                            .map(J.Block::getStatements)
                            .findFirst()
                            .orElseThrow(() -> new IllegalStateException(""Unable to produce a new block statement""));
                }
                J.Block block = (J.Block) anIf.getThenPart();
                block = block.withStatements(newStatements);
                block = autoFormat(block, ctx, getCursor());
                anIf = anIf.withThenPart(block);
            }
            return anIf;
        }
    }

    static class MaybeAddEachDependency extends JavaIsoVisitor<ExecutionContext> {
        boolean alreadyExists;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (isEachDependency(m) && !isInBuildscriptBlock(getCursor())) {
                alreadyExists = true;
            }
            return m;
        }

        @Override
        public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
            // Avoid wasting time if we've already found it
            if (alreadyExists) {
                return (J) tree;
            }
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile sourceFile = (JavaSourceFile) super.visit(tree, ctx);
                if (alreadyExists) {
                    return sourceFile;
                }
                // Prefer to insert before the dependencies block for readability
                if (sourceFile instanceof G.CompilationUnit) {
                    G.CompilationUnit cu = (G.CompilationUnit) sourceFile;
                    int insertionIndex = 0;
                    while (insertionIndex < cu.getStatements().size()) {
                        Statement s = cu.getStatements().get(insertionIndex);
                        if (s instanceof J.MethodInvocation && DEPENDENCIES_DSL_MATCHER.matches((J.MethodInvocation) s)) {
                            break;
                        }
                        insertionIndex++;
                    }
                    J.MethodInvocation m = GradleParser.builder()
                            .build()
                            .parse(ctx,
                                    ""\n"" +
                                            ""configurations.all {\n"" +
                                            ""    resolutionStrategy.eachDependency { details ->\n"" +
                                            ""    }\n"" +
                                            ""}"")
                            .map(G.CompilationUnit.class::cast)
                            .map(G.CompilationUnit::getStatements)
                            .map(it -> it.get(0))
                            .map(J.MethodInvocation.class::cast)
                            .findFirst()
                            .orElseThrow(() -> new IllegalStateException(""Unable to create a new configurations.all block""));
                    return cu.withStatements(ListUtils.insert(cu.getStatements(), m, insertionIndex));
                } else {
                    K.CompilationUnit cu = (K.CompilationUnit) sourceFile;
                    assert cu != null;
                    J.Block block = (J.Block) cu.getStatements().get(0);
                    int insertionIndex = 0;
                    while (insertionIndex < block.getStatements().size()) {
                        Statement s = block.getStatements().get(insertionIndex);
                        if (s instanceof J.MethodInvocation && ""dependencies"".equals(((J.MethodInvocation) s).getSimpleName())) {
                            break;
                        }
                        insertionIndex++;
                    }
                    J.MethodInvocation m = GradleParser.builder()
                            .build()
                            .parseInputs(singletonList(
                                    new Parser.Input(
                                            Paths.get(""build.gradle.kts""),
                                            () -> new ByteArrayInputStream(
                                                    (""\n"" +
                                                            ""configurations.all {\n"" +
                                                            ""    resolutionStrategy.eachDependency { details ->}\n"" +
                                                            ""}"").getBytes(StandardCharsets.UTF_8)))
                            ), null, ctx)
                            .map(K.CompilationUnit.class::cast)
                            .map(k -> (J.Block) k.getStatements().get(0))
                            .map(J.Block::getStatements)
                            .map(it -> it.get(0))
                            .map(J.MethodInvocation.class::cast)
                            .findFirst()
                            .map(m2 -> m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg -> {
                                J.Lambda lambda1 = (J.Lambda) arg;
                                J.Block block1 = (J.Block) lambda1.getBody();
                                return lambda1.withBody(block1.withStatements(ListUtils.mapFirst(block1.getStatements(), arg2 -> {
                                    J.MethodInvocation m3 = (J.MethodInvocation) arg2;
                                    return m3.withArguments(ListUtils.mapFirst(m3.getArguments(), arg3 -> {
                                        J.Lambda lambda2 = (J.Lambda) arg3;
                                        return lambda2.withBody(((J.Block) lambda2.getBody()).withEnd(Space.format(""\n"")));
                                    }));
                                })));
                            })))
                            .orElseThrow(() -> new IllegalStateException(""Unable to create a new configurations.all block""));
                    final int finalInsertionIndex = insertionIndex;
                    return cu.withStatements(ListUtils.mapFirst(cu.getStatements(), arg -> {
                        if (arg == block) {
                            return block.withStatements(ListUtils.insert(block.getStatements(), m, finalInsertionIndex));
                        }
                        return arg;
                    }));
                }
            }
            return super.visit(tree, ctx);
        }
    }

    static class MaybeRemoveDependencyBlock extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (isEmptyDependenciesBlock(m)) {
                return null;
            }
            return m;
        }
    }

    private static boolean isEmptyDependenciesBlock(J.MethodInvocation m) {
        if (!""dependencies"".equals(m.getSimpleName())) {
            return false;
        }
        if (m.getArguments().size() != 1 || !(m.getArguments().get(0) instanceof J.Lambda)) {
            return false;
        }
        // `dependencies` should always take a single ""closure""
        if (m.getArguments().size() != 1 || !(m.getArguments().get(0) instanceof J.Lambda)) {
            return false;
        }
        J.Lambda l = (J.Lambda) m.getArguments().get(0);
        if (l.getBody() instanceof J.Block) {
            J.Block b = (J.Block) l.getBody();
            if (b.getStatements().size() == 1) {
                return b.getStatements().get(0) instanceof J.Return && ((J.Return) b.getStatements().get(0)).getExpression() == null;
            }
        }
        return false;
    }

    private static boolean isInDependenciesBlock(Cursor cursor) {
        Cursor c = cursor.dropParentUntil(value ->
                value == Cursor.ROOT_VALUE ||
                        (value instanceof J.MethodInvocation && ""dependencies"".equals(((J.MethodInvocation) value).getSimpleName())));
        if (!(c.getValue() instanceof J.MethodInvocation)) {
            return false;
        }
        // Exclude ""dependencies"" blocks inside of buildscripts
        // No plugins can prevent the ""constraints"" block from working there, as they can for regular dependencies block
        return !isInBuildscriptBlock(c);
    }

    private static boolean isInBuildscriptBlock(Cursor c) {
        Cursor maybeBuildscript = c.dropParentUntil(value -> value == Cursor.ROOT_VALUE || (value instanceof J.MethodInvocation && ""buildscript"".equals(((J.MethodInvocation) value).getSimpleName())));
        return maybeBuildscript.getValue() != Cursor.ROOT_VALUE;
    }

    private static boolean isEachDependency(J.MethodInvocation m) {
        return ""eachDependency"".equals(m.getSimpleName()) &&
                (m.getSelect() instanceof J.Identifier &&
                        ""resolutionStrategy"".equals(((J.Identifier) m.getSelect()).getSimpleName()));
    }

    private static boolean predicateRelatesToGav(J.If iff, GroupArtifactVersionBecause groupArtifactVersion) {
        Expression predicate = iff.getIfCondition().getTree();
        if (!(predicate instanceof J.Binary)) {
            return false;
        }
        J.Binary and = (J.Binary) predicate;
        // Looking for a comparison of group id && artifact id
        if (and.getOperator() != J.Binary.Type.And) {
            return false;
        }
        // GroupId and artifactId might be compared in either order or this could be an unrelated comparison
        AtomicBoolean groupIdCompared = new AtomicBoolean();
        AtomicBoolean artifactIdCompared = new AtomicBoolean();
        new JavaIsoVisitor<GroupArtifactVersionBecause>() {
            @Override
            public J.Binary visitBinary(J.Binary binary, GroupArtifactVersionBecause groupArtifactVersion) {
                J.Binary b = super.visitBinary(binary, groupArtifactVersion);
                if (b.getOperator() != J.Binary.Type.Equal) {
                    return b;
                }
                J.FieldAccess access = null;
                J.Literal literal = null;
                if (b.getLeft() instanceof J.FieldAccess && b.getRight() instanceof J.Literal) {
                    access = (J.FieldAccess) b.getLeft();
                    literal = (J.Literal) b.getRight();
                } else if (b.getRight() instanceof J.FieldAccess && b.getLeft() instanceof J.Literal) {
                    access = (J.FieldAccess) b.getRight();
                    literal = (J.Literal) b.getLeft();
                }
                //noinspection ConstantValue
                if (access == null || literal == null) {
                    return b;
                }
                if (""group"".equals(access.getSimpleName()) && Objects.equals(groupArtifactVersion.getGroupId(), literal.getValue())) {
                    groupIdCompared.set(true);
                } else if (""name"".equals(access.getSimpleName()) && Objects.equals(groupArtifactVersion.getArtifactId(), literal.getValue())) {
                    artifactIdCompared.set(true);
                }
                return b;
            }
        }.visit(and, groupArtifactVersion);

        return groupIdCompared.get() && artifactIdCompared.get();
    }
}
",{}
Change Gradle dependency,Change a Gradle dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.internal.DependencyStringNotationConverter;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.search.FindGradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.InlineMe;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.semver.DependencyMatcher;
import org.openrewrite.semver.Semver;

import java.util.*;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeDependency extends Recipe {

    // Individual dependencies tend to appear in several places within a given dependency graph.
    // Minimize the number of allocations by caching the updated dependencies.
    @EqualsAndHashCode.Exclude
    transient Map<org.openrewrite.maven.tree.Dependency, org.openrewrite.maven.tree.Dependency> updatedRequested = new HashMap<>();

    @EqualsAndHashCode.Exclude
    transient Map<org.openrewrite.maven.tree.ResolvedDependency, org.openrewrite.maven.tree.ResolvedDependency> updatedResolved = new HashMap<>();

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Old groupId"",
            description = ""The old groupId to replace. The groupId is the first part of a dependency coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""org.openrewrite.recipe"")
    String oldGroupId;

    @Option(displayName = ""Old artifactId"",
            description = ""The old artifactId to replace. The artifactId is the second part of a dependency coordinate 'com.google.guava:guava:VERSION'. Supports glob expressions."",
            example = ""rewrite-testing-frameworks"")
    String oldArtifactId;

    @Option(displayName = ""New groupId"",
            description = ""The new groupId to use. Defaults to the existing group id."",
            example = ""corp.internal.openrewrite.recipe"",
            required = false)
    @Nullable
    String newGroupId;

    @Option(displayName = ""New artifactId"",
            description = ""The new artifactId to use. Defaults to the existing artifact id."",
            example = ""rewrite-testing-frameworks"",
            required = false)
    @Nullable
    String newArtifactId;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                    ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                    ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                    ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Override managed version"",
            description = ""If the old dependency has a managed version, this flag can be used to explicitly set the version on the new dependency. "" +
                    ""WARNING: No check is done on the NEW dependency to verify if it is managed, it relies on whether the OLD dependency had a managed version. "" +
                    ""The default for this flag is `false`."",
            required = false)
    @Nullable
    Boolean overrideManagedVersion;

    @Option(displayName = ""Update dependency management"",
            description = ""Also update the dependency management section. The default for this flag is `true`."",
            required = false)
    @Nullable
    Boolean changeManagedDependency;

    @JsonCreator
    public ChangeDependency(String oldGroupId, String oldArtifactId, @Nullable String newGroupId, @Nullable String newArtifactId, @Nullable String newVersion, @Nullable String versionPattern, @Nullable Boolean overrideManagedVersion, @Nullable Boolean changeManagedDependency) {
        this.oldGroupId = oldGroupId;
        this.oldArtifactId = oldArtifactId;
        this.newGroupId = newGroupId;
        this.newArtifactId = newArtifactId;
        this.newVersion = newVersion;
        this.versionPattern = versionPattern;
        this.overrideManagedVersion = overrideManagedVersion;
        this.changeManagedDependency = changeManagedDependency;
    }

    @InlineMe(replacement = ""this(oldGroupId, oldArtifactId, newGroupId, newArtifactId, newVersion, versionPattern, overrideManagedVersion, true)"")
    public ChangeDependency(String oldGroupId, String oldArtifactId, @Nullable String newGroupId, @Nullable String newArtifactId, @Nullable String newVersion, @Nullable String versionPattern, @Nullable Boolean overrideManagedVersion) {
        this(oldGroupId, oldArtifactId, newGroupId, newArtifactId, newVersion, versionPattern, overrideManagedVersion, true);
    }

    @Override
    public String getDisplayName() {
        return ""Change Gradle dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", oldGroupId, oldArtifactId);
    }

    @Override
    public String getDescription() {
        return ""Change a Gradle dependency coordinates. The `newGroupId` or `newArtifactId` **MUST** be different from before."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        validated = validated.and(Validated.required(""newGroupId"", newGroupId).or(Validated.required(""newArtifactId"", newArtifactId)));
        return validated.and(Validated.test(
                ""coordinates"",
                ""newGroupId OR newArtifactId must be different from before"",
                this,
                r -> {
                    boolean sameGroupId = StringUtils.isBlank(r.newGroupId) || Objects.equals(r.oldGroupId, r.newGroupId);
                    boolean sameArtifactId = StringUtils.isBlank(r.newArtifactId) || Objects.equals(r.oldArtifactId, r.newArtifactId);
                    return !(sameGroupId && sameArtifactId);
                }
        ));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor(), new JavaIsoVisitor<ExecutionContext>() {
            final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(oldGroupId + "":"" + oldArtifactId).getValue());

            GradleProject gradleProject;

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile sourceFile = (JavaSourceFile) tree;
                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);
                    if (!maybeGp.isPresent()) {
                        return sourceFile;
                    }

                    gradleProject = maybeGp.get();

                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);
                    if (sourceFile != tree) {
                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));
                        if (changeManagedDependency == null || changeManagedDependency) {
                            doAfterVisit(new ChangeManagedDependency(oldGroupId, oldArtifactId, newGroupId, newArtifactId, newVersion, versionPattern).getVisitor());
                        }
                    }

                    return super.visit(sourceFile, ctx);
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                        .groupId(oldGroupId)
                        .artifactId(oldArtifactId);

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal || depArgs.get(0) instanceof G.GString || depArgs.get(0) instanceof G.MapEntry || depArgs.get(0) instanceof G.MapLiteral || depArgs.get(0) instanceof J.Assignment || depArgs.get(0) instanceof K.StringTemplate) {
                    m = updateDependency(m, ctx);
                } else if (depArgs.get(0) instanceof J.MethodInvocation &&
                        (""platform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()) ||
                                ""enforcedPlatform"".equals(((J.MethodInvocation) depArgs.get(0)).getSimpleName()))) {
                    m = m.withArguments(ListUtils.mapFirst(depArgs, platform -> updateDependency((J.MethodInvocation) platform, ctx)));
                }

                return m;
            }

            private J.MethodInvocation updateDependency(J.MethodInvocation m, ExecutionContext ctx) {
                List<Expression> depArgs = m.getArguments();
                if (depArgs.get(0) instanceof J.Literal) {
                    String gav = (String) ((J.Literal) depArgs.get(0)).getValue();
                    if (gav != null) {
                        Dependency original = DependencyStringNotationConverter.parse(gav);
                        if (original != null) {
                            Dependency updated = original;
                            if (!StringUtils.isBlank(newGroupId) && !updated.getGroupId().equals(newGroupId)) {
                                updated = updated.withGroupId(newGroupId);
                            }
                            if (!StringUtils.isBlank(newArtifactId) && !updated.getArtifactId().equals(newArtifactId)) {
                                updated = updated.withArtifactId(newArtifactId);
                            }
                            if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(original.getVersion()) || Boolean.TRUE.equals(overrideManagedVersion))) {
                                String resolvedVersion;
                                try {
                                    resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                            .select(new GroupArtifact(updated.getGroupId(), updated.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);
                                } catch (MavenDownloadingException e) {
                                    return e.warn(m);
                                }
                                if (resolvedVersion != null && !resolvedVersion.equals(updated.getVersion())) {
                                    updated = updated.withVersion(resolvedVersion);
                                }
                            }
                            if (original != updated) {
                                String replacement = updated.toStringNotation();
                                m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, replacement)));
                            }
                        }
                    }
                } else if (m.getArguments().get(0) instanceof G.GString) {
                    G.GString gstring = (G.GString) depArgs.get(0);
                    List<J> strings = gstring.getStrings();
                    if (strings.size() >= 2 && strings.get(0) instanceof J.Literal &&
                            ((J.Literal) strings.get(0)).getValue() != null) {

                        J.Literal literal = (J.Literal) strings.get(0);
                        Dependency original = DependencyStringNotationConverter.parse((String) requireNonNull(literal.getValue()));
                        if (original != null) {
                            Dependency updated = original;
                            if (!StringUtils.isBlank(newGroupId) && !updated.getGroupId().equals(newGroupId)) {
                                updated = updated.withGroupId(newGroupId);
                            }
                            if (!StringUtils.isBlank(newArtifactId) && !updated.getArtifactId().equals(newArtifactId)) {
                                updated = updated.withArtifactId(newArtifactId);
                            }
                            if (!StringUtils.isBlank(newVersion)) {
                                String resolvedVersion;
                                try {
                                    resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                            .select(new GroupArtifact(updated.getGroupId(), updated.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);
                                } catch (MavenDownloadingException e) {
                                    return e.warn(m);
                                }
                                if (resolvedVersion != null && !resolvedVersion.equals(updated.getVersion())) {
                                    updated = updated.withVersion(resolvedVersion);
                                }
                            }
                            if (original != updated) {
                                String replacement = updated.toStringNotation();
                                J.Literal newLiteral = literal.withValue(replacement)
                                        .withValueSource(gstring.getDelimiter() + replacement + gstring.getDelimiter());
                                m = m.withArguments(singletonList(newLiteral));
                            }
                        }
                    }
                } else if (m.getArguments().get(0) instanceof G.MapEntry) {
                    G.MapEntry groupEntry = null;
                    G.MapEntry artifactEntry = null;
                    G.MapEntry versionEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String version = null;

                    for (Expression e : depArgs) {
                        if (!(e instanceof G.MapEntry)) {
                            continue;
                        }
                        G.MapEntry arg = (G.MapEntry) e;
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        switch (keyValue) {
                            case ""group"":
                                groupEntry = arg;
                                groupId = valueValue;
                                break;
                            case ""name"":
                                artifactEntry = arg;
                                artifactId = valueValue;
                                break;
                            case ""version"":
                                versionEntry = arg;
                                version = valueValue;
                                break;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    if (!depMatcher.matches(groupId, artifactId)) {
                        return m;
                    }
                    String updatedGroupId = groupId;
                    if (!StringUtils.isBlank(newGroupId) && !updatedGroupId.equals(newGroupId)) {
                        updatedGroupId = newGroupId;
                    }
                    String updatedArtifactId = artifactId;
                    if (!StringUtils.isBlank(newArtifactId) && !updatedArtifactId.equals(newArtifactId)) {
                        updatedArtifactId = newArtifactId;
                    }
                    String updatedVersion = version;
                    if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(version) || Boolean.TRUE.equals(overrideManagedVersion))) {
                        String resolvedVersion;
                        try {
                            resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(new GroupArtifact(updatedGroupId, updatedArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);
                        } catch (MavenDownloadingException e) {
                            return e.warn(m);
                        }
                        if (resolvedVersion != null && !resolvedVersion.equals(updatedVersion)) {
                            updatedVersion = resolvedVersion;
                        }
                    }

                    if (!updatedGroupId.equals(groupId) || !updatedArtifactId.equals(artifactId) || updatedVersion != null && !updatedVersion.equals(version)) {
                        G.MapEntry finalGroup = groupEntry;
                        String finalGroupIdValue = updatedGroupId;
                        G.MapEntry finalArtifact = artifactEntry;
                        String finalArtifactIdValue = updatedArtifactId;
                        G.MapEntry finalVersion = versionEntry;
                        String finalVersionValue = updatedVersion;
                        m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                            if (arg == finalGroup) {
                                return finalGroup.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalGroup.getValue(), finalGroupIdValue));
                            }
                            if (arg == finalArtifact) {
                                return finalArtifact.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalArtifact.getValue(), finalArtifactIdValue));
                            }
                            if (arg == finalVersion) {
                                return finalVersion.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalVersion.getValue(), finalVersionValue));
                            }
                            return arg;
                        }));
                    }
                } else if (m.getArguments().get(0) instanceof G.MapLiteral) {
                    G.MapLiteral map = (G.MapLiteral) depArgs.get(0);
                    G.MapEntry groupEntry = null;
                    G.MapEntry artifactEntry = null;
                    G.MapEntry versionEntry = null;
                    String groupId = null;
                    String artifactId = null;
                    String version = null;

                    for (G.MapEntry arg : map.getElements()) {
                        if (!(arg.getKey() instanceof J.Literal) || !(arg.getValue() instanceof J.Literal)) {
                            continue;
                        }
                        J.Literal key = (J.Literal) arg.getKey();
                        J.Literal value = (J.Literal) arg.getValue();
                        if (!(key.getValue() instanceof String) || !(value.getValue() instanceof String)) {
                            continue;
                        }
                        String keyValue = (String) key.getValue();
                        String valueValue = (String) value.getValue();
                        switch (keyValue) {
                            case ""group"":
                                groupEntry = arg;
                                groupId = valueValue;
                                break;
                            case ""name"":
                                artifactEntry = arg;
                                artifactId = valueValue;
                                break;
                            case ""version"":
                                versionEntry = arg;
                                version = valueValue;
                                break;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    if (!depMatcher.matches(groupId, artifactId)) {
                        return m;
                    }
                    String updatedGroupId = groupId;
                    if (!StringUtils.isBlank(newGroupId) && !updatedGroupId.equals(newGroupId)) {
                        updatedGroupId = newGroupId;
                    }
                    String updatedArtifactId = artifactId;
                    if (!StringUtils.isBlank(newArtifactId) && !updatedArtifactId.equals(newArtifactId)) {
                        updatedArtifactId = newArtifactId;
                    }
                    String updatedVersion = version;
                    if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(version) || Boolean.TRUE.equals(overrideManagedVersion))) {
                        String resolvedVersion;
                        try {
                            resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(new GroupArtifact(updatedGroupId, updatedArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);
                        } catch (MavenDownloadingException e) {
                            return e.warn(m);
                        }
                        if (resolvedVersion != null && !resolvedVersion.equals(updatedVersion)) {
                            updatedVersion = resolvedVersion;
                        }
                    }

                    if (!updatedGroupId.equals(groupId) || !updatedArtifactId.equals(artifactId) || updatedVersion != null && !updatedVersion.equals(version)) {
                        G.MapEntry finalGroup = groupEntry;
                        String finalGroupIdValue = updatedGroupId;
                        G.MapEntry finalArtifact = artifactEntry;
                        String finalArtifactIdValue = updatedArtifactId;
                        G.MapEntry finalVersion = versionEntry;
                        String finalVersionValue = updatedVersion;
                        m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                            G.MapLiteral mapLiteral = (G.MapLiteral) arg;
                            return mapLiteral.withElements(ListUtils.map(mapLiteral.getElements(), e -> {
                                if (e == finalGroup) {
                                    return finalGroup.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalGroup.getValue(), finalGroupIdValue));
                                }
                                if (e == finalArtifact) {
                                    return finalArtifact.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalArtifact.getValue(), finalArtifactIdValue));
                                }
                                if (e == finalVersion) {
                                    return finalVersion.withValue(ChangeStringLiteral.withStringValue((J.Literal) finalVersion.getValue(), finalVersionValue));
                                }
                                return e;
                            }));
                        }));
                    }
                } else if (m.getArguments().get(0) instanceof J.Assignment) {
                    J.Assignment groupAssignment = null;
                    J.Assignment artifactAssignment = null;
                    J.Assignment versionAssignment = null;
                    String groupId = null;
                    String artifactId = null;
                    String version = null;

                    for (Expression e : depArgs) {
                        if (!(e instanceof J.Assignment)) {
                            continue;
                        }
                        J.Assignment arg = (J.Assignment) e;
                        if (!(arg.getVariable() instanceof J.Identifier) || !(arg.getAssignment() instanceof J.Literal)) {
                            continue;
                        }
                        J.Identifier identifier = (J.Identifier) arg.getVariable();
                        J.Literal assignment = (J.Literal) arg.getAssignment();
                        if (!(assignment.getValue() instanceof String)) {
                            continue;
                        }
                        String valueValue = (String) assignment.getValue();
                        switch (identifier.getSimpleName()) {
                            case ""group"":
                                groupAssignment = arg;
                                groupId = valueValue;
                                break;
                            case ""name"":
                                artifactAssignment = arg;
                                artifactId = valueValue;
                                break;
                            case ""version"":
                                versionAssignment = arg;
                                version = valueValue;
                                break;
                        }
                    }
                    if (groupId == null || artifactId == null) {
                        return m;
                    }
                    if (!depMatcher.matches(groupId, artifactId)) {
                        return m;
                    }
                    String updatedGroupId = groupId;
                    if (!StringUtils.isBlank(newGroupId) && !updatedGroupId.equals(newGroupId)) {
                        updatedGroupId = newGroupId;
                    }
                    String updatedArtifactId = artifactId;
                    if (!StringUtils.isBlank(newArtifactId) && !updatedArtifactId.equals(newArtifactId)) {
                        updatedArtifactId = newArtifactId;
                    }
                    String updatedVersion = version;
                    if (!StringUtils.isBlank(newVersion) && (!StringUtils.isBlank(version) || Boolean.TRUE.equals(overrideManagedVersion))) {
                        String resolvedVersion;
                        try {
                            resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                    .select(new GroupArtifact(updatedGroupId, updatedArtifactId), m.getSimpleName(), newVersion, versionPattern, ctx);
                        } catch (MavenDownloadingException e) {
                            return e.warn(m);
                        }
                        if (resolvedVersion != null && !resolvedVersion.equals(updatedVersion)) {
                            updatedVersion = resolvedVersion;
                        }
                    }

                    if (!updatedGroupId.equals(groupId) || !updatedArtifactId.equals(artifactId) || updatedVersion != null && !updatedVersion.equals(version)) {
                        J.Assignment finalGroup = groupAssignment;
                        String finalGroupIdValue = updatedGroupId;
                        J.Assignment finalArtifact = artifactAssignment;
                        String finalArtifactIdValue = updatedArtifactId;
                        J.Assignment finalVersion = versionAssignment;
                        String finalVersionValue = updatedVersion;
                        m = m.withArguments(ListUtils.map(m.getArguments(), arg -> {
                            if (arg == finalGroup) {
                                return finalGroup.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalGroup.getAssignment(), finalGroupIdValue));
                            }
                            if (arg == finalArtifact) {
                                return finalArtifact.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalArtifact.getAssignment(), finalArtifactIdValue));
                            }
                            if (arg == finalVersion) {
                                return finalVersion.withAssignment(ChangeStringLiteral.withStringValue((J.Literal) finalVersion.getAssignment(), finalVersionValue));
                            }
                            return arg;
                        }));
                    }
                } else if (depArgs.get(0) instanceof K.StringTemplate) {
                    K.StringTemplate template = (K.StringTemplate) depArgs.get(0);
                    List<J> strings = template.getStrings();
                    if (strings.size() >= 2 && strings.get(0) instanceof J.Literal &&
                            ((J.Literal) strings.get(0)).getValue() != null) {

                        J.Literal literal = (J.Literal) strings.get(0);
                        Dependency original = DependencyStringNotationConverter.parse((String) requireNonNull(literal.getValue()));
                        if (original != null) {
                            Dependency updated = original;
                            if (!StringUtils.isBlank(newGroupId) && !updated.getGroupId().equals(newGroupId)) {
                                updated = updated.withGroupId(newGroupId);
                            }
                            if (!StringUtils.isBlank(newArtifactId) && !updated.getArtifactId().equals(newArtifactId)) {
                                updated = updated.withArtifactId(newArtifactId);
                            }
                            if (!StringUtils.isBlank(newVersion)) {
                                String resolvedVersion;
                                try {
                                    resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, null)
                                            .select(new GroupArtifact(updated.getGroupId(), updated.getArtifactId()), m.getSimpleName(), newVersion, versionPattern, ctx);
                                } catch (MavenDownloadingException e) {
                                    return e.warn(m);
                                }
                                if (resolvedVersion != null && !resolvedVersion.equals(updated.getVersion())) {
                                    updated = updated.withVersion(resolvedVersion);
                                }
                            }
                            if (original != updated) {
                                String replacement = updated.toStringNotation();
                                J.Literal newLiteral = literal.withValue(replacement)
                                        .withValueSource(template.getDelimiter() + replacement + template.getDelimiter());
                                m = m.withArguments(singletonList(newLiteral));
                            }
                        }
                    }
                }

                return m;
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        assert requested != null;
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId())) {
                            requested = updatedRequested.computeIfAbsent(requested, r -> {
                                GroupArtifactVersion gav = r.getGav();
                                if (newGroupId != null) {
                                    gav = gav.withGroupId(newGroupId);
                                }
                                if (newArtifactId != null) {
                                    gav = gav.withArtifactId(newArtifactId);
                                }
                                if (gav != r.getGav()) {
                                    r = r.withGav(gav);
                                }
                                return r;
                            });
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        assert resolved != null;
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId())) {
                            resolved = updatedResolved.computeIfAbsent(resolved, r -> {
                                ResolvedGroupArtifactVersion gav = r.getGav();
                                if (newGroupId != null) {
                                    gav = gav.withGroupId(newGroupId);
                                }
                                if (newArtifactId != null) {
                                    gav = gav.withArtifactId(newArtifactId);
                                }
                                if (gav != r.getGav()) {
                                    r = r.withGav(gav);
                                }
                                return r;
                            });
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""oldGroupId"": ""String field"",
  ""oldArtifactId"": ""String field""
}"
Add Gradle property,Add a property to the `gradle.properties` file.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.properties.ChangePropertyValue;
import org.openrewrite.properties.PropertiesParser;

import java.nio.file.Paths;
import java.util.Collection;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddProperty extends ScanningRecipe<AddProperty.NeedsProperty> {

    @Option(displayName = ""Property name"",
            description = ""The name of the property to add."",
            example = ""org.gradle.caching"")
    String key;

    @Option(example = ""true"", displayName = ""Property value"",
            description = ""The value of the property to add."")
    String value;

    @Option(displayName = ""Overwrite if exists"",
            description = ""If a property with the same key exists, overwrite."",
            example = ""true"")
    @Nullable
    Boolean overwrite;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                          ""When not set, all source files are searched."",
            required = false,
            example = ""**/*.properties"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Add Gradle property"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s=%s`"", key, value);
    }

    @Override
    public String getDescription() {
        return ""Add a property to the `gradle.properties` file."";
    }

    public static class NeedsProperty {
        boolean isGradleProject;
        boolean hasGradleProperties;
    }

    @Override
    public NeedsProperty getInitialValue(ExecutionContext ctx) {
        return new NeedsProperty();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(NeedsProperty acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (filePattern != null) {
                    if (new FindSourceFiles(filePattern).getVisitor().visitNonNull(tree, ctx) != tree &&
                        sourceFile.getSourcePath().endsWith(""gradle.properties"")) {
                        acc.hasGradleProperties = true;
                    }
                } else if (sourceFile.getSourcePath().endsWith(""gradle.properties"")) {
                    acc.hasGradleProperties = true;
                }

                if (IsBuildGradle.matches(sourceFile.getSourcePath())) {
                    acc.isGradleProject = true;
                }

                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(NeedsProperty acc, ExecutionContext ctx) {
        if (!acc.hasGradleProperties) {
            return PropertiesParser.builder().build()
                    .parseInputs(singletonList(Parser.Input.fromString(Paths.get(""gradle.properties""),
                            key + ""="" + value)), null, ctx)
                    .collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(NeedsProperty acc) {
        return Preconditions.check(acc.isGradleProject && acc.hasGradleProperties, new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (filePattern != null) {
                    if (new FindSourceFiles(filePattern).getVisitor().visitNonNull(sourceFile, ctx) != sourceFile &&
                        sourceFile.getSourcePath().endsWith(""gradle.properties"")) {
                        Tree t = !Boolean.TRUE.equals(overwrite) ?
                                sourceFile :
                                new ChangePropertyValue(key, value, null, false, null)
                                        .getVisitor().visitNonNull(sourceFile, ctx);
                        return new org.openrewrite.properties.AddProperty(key, value, null, null)
                                .getVisitor()
                                .visitNonNull(t, ctx);
                    }
                } else if (sourceFile.getSourcePath().endsWith(""gradle.properties"")) {
                    Tree t = !Boolean.TRUE.equals(overwrite) ?
                            sourceFile :
                            new ChangePropertyValue(key, value, null, false, null)
                                    .getVisitor().visitNonNull(sourceFile, ctx);
                    return new org.openrewrite.properties.AddProperty(key, value, null, null)
                            .getVisitor()
                            .visitNonNull(t, ctx);
                }
                return sourceFile;
            }
        });
    }
}
","{
  ""key"": ""String field"",
  ""value"": ""String field""
}"
Update Gradle wrapper,Update the version of Gradle used in an existing Gradle wrapper. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.*;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.search.FindGradleProject;
import org.openrewrite.gradle.util.GradleWrapper;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.BuildTool;
import org.openrewrite.marker.Markers;
import org.openrewrite.properties.PropertiesParser;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.text.PlainText;

import java.net.URI;
import java.time.ZonedDateTime;
import java.util.*;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.PathUtils.equalIgnoringSeparators;
import static org.openrewrite.gradle.util.GradleWrapper.*;
import static org.openrewrite.internal.StringUtils.isBlank;

@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@EqualsAndHashCode(callSuper = false)
public class UpdateGradleWrapper extends ScanningRecipe<UpdateGradleWrapper.GradleWrapperState> {

    @Override
    public String getDisplayName() {
        return ""Update Gradle wrapper"";
    }

    @Override
    public String getDescription() {
        return ""Update the version of Gradle used in an existing Gradle wrapper. "" +
               ""Queries services.gradle.org to determine the available releases, but prefers the artifact repository URL "" +
               ""which already exists within the wrapper properties file. "" +
               ""If your artifact repository does not contain the same Gradle distributions as services.gradle.org, "" +
               ""then the recipe may suggest a version which is not available in your artifact repository."";
    }

    @Getter
    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""Defaults to the latest release available from services.gradle.org if not specified."",
            example = ""7.x"",
            required = false)
    @Nullable
    final String version;

    @Getter
    @Option(displayName = ""Distribution type"",
            description = ""The distribution of Gradle to use. \""bin\"" includes Gradle binaries. "" +
                          ""\""all\"" includes Gradle binaries, source code, and documentation. "" +
                          ""Defaults to \""bin\""."",
            valid = {""bin"", ""all""},
            required = false
    )
    @Nullable
    final String distribution;

    @Getter
    @Option(displayName = ""Add if missing"",
            description = ""Add a Gradle wrapper, if it's missing. Defaults to `true`."",
            required = false)
    @Nullable
    final Boolean addIfMissing;

    @Getter
    @Option(example = ""https://services.gradle.org/distributions/gradle-8.5-bin.zip"",
            displayName = ""Wrapper URI"",
            description = ""The URI of the Gradle wrapper distribution.\n"" +
                    ""Specifies a custom location from which to download the Gradle wrapper scripts (gradlew, gradlew.bat, etc.). This is useful for setting up the Gradle wrapper without relying on Gradle's official distribution services.\n\n"" +
                    ""When this option is set, the version and distribution fields must not be specified â€” only one source of truth is allowed. The URI should point to a valid and reachable Gradle wrapper distribution (typically a .zip archive containing the wrapper files).\n"" +
                    ""This is particularly helpful in environments where access to Gradle's central services is restricted or where custom Gradle wrapper setups are required.\n"" +
                    ""If the URI is inaccessible, the recipe will leave the existing wrapper files in the repository unchanged, as they are generally compatible with various Gradle versions."",
            required = false)
    @Nullable
    final String wrapperUri;

    @Getter
    @Option(example = ""29e49b10984e585d8118b7d0bc452f944e386458df27371b49b4ac1dec4b7fda"",
            displayName = ""SHA-256 checksum"",
            description = ""The SHA-256 checksum of the Gradle distribution. "" +
                          ""If specified, the recipe will add the checksum along with the custom distribution URL."",
            required = false)
    @Nullable
    final String distributionChecksum;

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (wrapperUri != null && (version != null || distribution != null)) {
            return Validated.invalid(""wrapperUri"", wrapperUri, ""WrapperUri cannot be used with version and/or distribution parameter"");
        }
        if (wrapperUri == null && distributionChecksum != null) {
            return Validated.invalid(""distributionChecksum"", distributionChecksum, ""DistributionChecksum can only be used with wrapperUri"");
        }
        if (version != null) {
            validated = validated.and(Semver.validate(version, null));
        }
        return validated;
    }

    @NonFinal
    @Nullable
    transient GradleWrapper gradleWrapper;

    private GradleWrapper getGradleWrapper(@Nullable String distributionUrl, ExecutionContext ctx) {
        if (gradleWrapper == null) {
            if (wrapperUri != null) {
                return gradleWrapper = GradleWrapper.create(URI.create(wrapperUri), ctx);
            }

            gradleWrapper = GradleWrapper.create(distributionUrl, distribution, version, ctx);
        }
        return gradleWrapper;
    }

    @Data
    public static class GradleWrapperState {
        boolean gradleProject = false;
        boolean needsWrapperUpdate = false;
        BuildTool currentMarker;

        @Nullable
        String currentDistributionUrl;

        @Nullable
        BuildTool updatedMarker;

        boolean addGradleWrapperProperties = true;
        boolean addGradleWrapperJar = true;
        boolean addGradleShellScript = true;
        boolean addGradleBatchScript = true;
    }

    @Override
    public GradleWrapperState getInitialValue(ExecutionContext ctx) {
        return new GradleWrapperState();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(GradleWrapperState acc) {
        return Preconditions.or(
                new PropertiesVisitor<ExecutionContext>() {
                    @Override
                    public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                        if (!super.isAcceptable(sourceFile, ctx)) {
                            return false;
                        }

                        if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_PROPERTIES_LOCATION)) {
                            acc.addGradleWrapperProperties = false;
                        } else if (!PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_PROPERTIES_LOCATION_RELATIVE_PATH)) {
                            return false;
                        }

                        Optional<BuildTool> maybeBuildTool = sourceFile.getMarkers().findFirst(BuildTool.class);
                        if (!maybeBuildTool.isPresent()) {
                            return false;
                        }
                        BuildTool buildTool = maybeBuildTool.get();
                        if (buildTool.getType() != BuildTool.Type.Gradle) {
                            return false;
                        }

                        acc.currentMarker = buildTool;
                        return true;
                    }

                    @Override
                    public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                        if (!""distributionUrl"".equals(entry.getKey())) {
                            return entry;
                        }

                        // Typical example: https://services.gradle.org/distributions/gradle-7.4-all.zip or https://company.com/repo/gradle-8.2-bin.zip
                        String currentDistributionUrl = entry.getValue().getText();
                        acc.currentDistributionUrl = currentDistributionUrl;

                        String newVersion = isBlank(version) ? ""latest.release"" : version;
                        VersionComparator versionComparator = requireNonNull(Semver.validate(newVersion, null).getValue());
                        if (versionComparator.compare(null, acc.currentMarker.getVersion(), newVersion) > 0) {
                            return entry;
                        }

                        GradleWrapper gradleWrapper = getGradleWrapper(currentDistributionUrl, ctx);
                        String gradleWrapperVersion = gradleWrapper.getVersion();

                        int compare = versionComparator.compare(null, acc.currentMarker.getVersion(), gradleWrapperVersion);
                        // maybe we want to update the distribution type or url
                        if (compare < 0) {
                            acc.needsWrapperUpdate = true;
                            acc.updatedMarker = acc.currentMarker.withVersion(gradleWrapperVersion);
                            return entry;
                        } else if (compare == 0 && !gradleWrapper.getPropertiesFormattedUrl().equals(currentDistributionUrl)) {
                            acc.needsWrapperUpdate = true;
                        }

                        return entry;
                    }
                },
                new TreeVisitor<Tree, ExecutionContext>() {
                    @Override
                    public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                        if (new FindGradleProject(FindGradleProject.SearchCriteria.Marker).getVisitor().visitNonNull(sourceFile, ctx) != sourceFile) {
                            acc.gradleProject = true;
                        }

                        if ((sourceFile instanceof Quark || sourceFile instanceof Remote) &&
                            equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_JAR_LOCATION)) {
                            acc.addGradleWrapperJar = false;
                            return true;
                        }

                        if (sourceFile instanceof PlainText) {
                            if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_BATCH_LOCATION)) {
                                acc.addGradleBatchScript = false;
                                return true;
                            } else if (equalIgnoringSeparators(sourceFile.getSourcePath(), WRAPPER_SCRIPT_LOCATION)) {
                                acc.addGradleShellScript = false;
                                return true;
                            }
                        }

                        return false;
                    }

                    @Override
                    public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                        // ""work"" already performed by `isAcceptable()`; no need to visit anymore
                        return tree;
                    }
                }
        );
    }

    @Override
    public Collection<SourceFile> generate(GradleWrapperState acc, ExecutionContext ctx) {
        if (Boolean.FALSE.equals(addIfMissing)) {
            return emptyList();
        }

        if (!acc.gradleProject) {
            return emptyList();
        }

        if (!(acc.addGradleWrapperJar || acc.addGradleWrapperProperties || acc.addGradleBatchScript || acc.addGradleShellScript)) {
            return emptyList();
        }

        List<SourceFile> gradleWrapperFiles = new ArrayList<>();
        ZonedDateTime now = ZonedDateTime.now();

        GradleWrapper gradleWrapper = getGradleWrapper(acc.currentDistributionUrl, ctx);

        if (acc.addGradleWrapperProperties) {
            String checksum = gradleWrapper.getDistributionChecksum() == null ? null : gradleWrapper.getDistributionChecksum().getHexValue();
            if (wrapperUri != null && distributionChecksum != null && checksum == null) {
                checksum = distributionChecksum;
            }

            //noinspection UnusedProperty
            Properties.File gradleWrapperProperties = new PropertiesParser().parse(
                            ""distributionBase=GRADLE_USER_HOME\n"" +
                            ""distributionPath=wrapper/dists\n"" +
                            ""distributionUrl="" + gradleWrapper.getPropertiesFormattedUrl() + ""\n"" +
                            (checksum == null ? """" : ""distributionSha256Sum="" + checksum + ""\n"") +
                            ""zipStoreBase=GRADLE_USER_HOME\n"" +
                            ""zipStorePath=wrapper/dists"")
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException(""Could not parse as properties""))
                    .withSourcePath(WRAPPER_PROPERTIES_LOCATION);
            gradleWrapperFiles.add(gradleWrapperProperties);
        }

        FileAttributes wrapperScriptAttributes = new FileAttributes(now, now, now, true, true, true, 1L);
        if (acc.addGradleShellScript) {
            String gradlewText = unixScript(gradleWrapper, ctx);
            PlainText gradlew = PlainText.builder()
                    .text(gradlewText)
                    .sourcePath(WRAPPER_SCRIPT_LOCATION)
                    .fileAttributes(wrapperScriptAttributes)
                    .build();
            gradleWrapperFiles.add(gradlew);
        }

        if (acc.addGradleBatchScript) {
            String gradlewBatText = batchScript(gradleWrapper, ctx);
            PlainText gradlewBat = PlainText.builder()
                    .text(gradlewBatText)
                    .sourcePath(WRAPPER_BATCH_LOCATION)
                    .fileAttributes(wrapperScriptAttributes)
                    .build();
            gradleWrapperFiles.add(gradlewBat);
        }

        if (acc.addGradleWrapperJar) {
            gradleWrapperFiles.add(gradleWrapper.wrapperJar());
        }

        return gradleWrapperFiles;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(GradleWrapperState acc) {
        if (!acc.needsWrapperUpdate) {
            return TreeVisitor.noop();
        }

        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    //noinspection DataFlowIssue
                    return tree;
                }

                SourceFile sourceFile = (SourceFile) tree;
                if (acc.updatedMarker != null) {
                    Optional<BuildTool> maybeCurrentMarker = sourceFile.getMarkers().findFirst(BuildTool.class);
                    if (maybeCurrentMarker.isPresent()) {
                        BuildTool currentMarker = maybeCurrentMarker.get();
                        if (currentMarker.getType() != BuildTool.Type.Gradle) {
                            return sourceFile;
                        }
                        VersionComparator versionComparator = requireNonNull(Semver.validate(isBlank(version) ? ""latest.release"" : version, null).getValue());
                        int compare = versionComparator.compare(null, currentMarker.getVersion(), acc.updatedMarker.getVersion());
                        if (compare < 0) {
                            sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(acc.updatedMarker));
                        } else {
                            return sourceFile;
                        }
                    }
                }

                GradleWrapper gradleWrapper = getGradleWrapper(acc.currentDistributionUrl, ctx);
                if (sourceFile instanceof PlainText && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_SCRIPT_LOCATION_RELATIVE_PATH)) {
                    String gradlewText = unixScript(gradleWrapper, ctx);
                    PlainText gradlew = (PlainText) setExecutable(sourceFile);
                    if (!gradlewText.equals(gradlew.getText())) {
                        gradlew = gradlew.withText(gradlewText);
                    }
                    return gradlew;
                }
                if (sourceFile instanceof PlainText && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_BATCH_LOCATION_RELATIVE_PATH)) {
                    String gradlewBatText = batchScript(gradleWrapper, ctx);
                    PlainText gradlewBat = (PlainText) setExecutable(sourceFile);
                    if (!gradlewBatText.equals(gradlewBat.getText())) {
                        gradlewBat = gradlewBat.withText(gradlewBatText);
                    }
                    return gradlewBat;
                }
                if (sourceFile instanceof Properties.File && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_PROPERTIES_LOCATION_RELATIVE_PATH)) {
                    return new WrapperPropertiesVisitor(gradleWrapper).visitNonNull(sourceFile, ctx);
                }
                if ((sourceFile instanceof Quark || sourceFile instanceof Remote) && PathUtils.matchesGlob(sourceFile.getSourcePath(), ""**/"" + WRAPPER_JAR_LOCATION_RELATIVE_PATH)) {
                    return gradleWrapper.wrapperJar(sourceFile);
                }
                return sourceFile;
            }
        };
    }

    private static <T extends SourceFile> T setExecutable(T sourceFile) {
        FileAttributes attributes = sourceFile.getFileAttributes();
        if (attributes == null) {
            ZonedDateTime now = ZonedDateTime.now();
            return sourceFile.withFileAttributes(new FileAttributes(now, now, now, true, true, true, 1));
        } else if (!attributes.isExecutable()) {
            return sourceFile.withFileAttributes(attributes.withExecutable(true));
        }
        return sourceFile;
    }

    private String unixScript(GradleWrapper gradleWrapper, ExecutionContext ctx) {
        Map<String, String> binding = new HashMap<>();
        String defaultJvmOpts = defaultJvmOpts(gradleWrapper);
        binding.put(""defaultJvmOpts"", StringUtils.isNotEmpty(defaultJvmOpts) ? ""'"" + defaultJvmOpts + ""'"" : """");
        if (requireNonNull(Semver.validate(""[8.14,)"", null).getValue()).compare(null, gradleWrapper.getVersion(), ""8.14"") >= 0) {
            binding.put(""classpath"", ""\""\\\\\\\\\\\""\\\\\\\\\\\""\"""");
            binding.put(""entryPointArgs"", ""-jar \""$APP_HOME/gradle/wrapper/gradle-wrapper.jar\"""");
            binding.put(""mainClassName"", """");
        } else {
            binding.put(""classpath"", ""$APP_HOME/gradle/wrapper/gradle-wrapper.jar"");
            binding.put(""entryPointArgs"", """");
            binding.put(""mainClassName"", ""org.gradle.wrapper.GradleWrapperMain"");
        }

        String gradlewTemplate = StringUtils.readFully(gradleWrapper.gradlew().getInputStream(ctx));
        return renderTemplate(gradlewTemplate, binding, ""\n"");
    }

    private String batchScript(GradleWrapper gradleWrapper, ExecutionContext ctx) {
        Map<String, String> binding = new HashMap<>();
        binding.put(""defaultJvmOpts"", defaultJvmOpts(gradleWrapper));
        if (requireNonNull(Semver.validate(""[8.14,)"", null).getValue()).compare(null, gradleWrapper.getVersion(), ""8.14"") >= 0) {
            binding.put(""classpath"", """");
            binding.put(""mainClassName"", """");
            binding.put(""entryPointArgs"", ""-jar \""%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\"""");
        } else {
            binding.put(""classpath"", ""%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar"");
            binding.put(""mainClassName"", ""org.gradle.wrapper.GradleWrapperMain"");
            binding.put(""entryPointArgs"", """");
        }

        String gradlewBatTemplate = StringUtils.readFully(gradleWrapper.gradlewBat().getInputStream(ctx));
        return renderTemplate(gradlewBatTemplate, binding, ""\r\n"");
    }

    private String defaultJvmOpts(GradleWrapper gradleWrapper) {
        VersionComparator gradle53VersionComparator = requireNonNull(Semver.validate(""[5.3,)"", null).getValue());
        VersionComparator gradle50VersionComparator = requireNonNull(Semver.validate(""[5.0,)"", null).getValue());

        if (gradle53VersionComparator.isValid(null, gradleWrapper.getVersion())) {
            return ""\""-Xmx64m\"" \""-Xms64m\"""";
        } else if (gradle50VersionComparator.isValid(null, gradleWrapper.getVersion())) {
            return ""\""-Xmx64m\"""";
        }
        return """";
    }

    private String renderTemplate(String source, Map<String, String> parameters, String lineSeparator) {
        Map<String, String> binding = new HashMap<>(parameters);
        binding.put(""applicationName"", ""Gradle"");
        binding.put(""optsEnvironmentVar"", ""GRADLE_OPTS"");
        binding.put(""exitEnvironmentVar"", ""GRADLE_EXIT_CONSOLE"");
        binding.put(""moduleEntryPoint"", """");
        binding.put(""appNameSystemProperty"", ""org.gradle.appname"");
        binding.put(""appHomeRelativePath"", """");
        binding.put(""modulePath"", """");

        String script = source;
        for (Map.Entry<String, String> variable : binding.entrySet()) {
            script = script.replace(""${"" + variable.getKey() + ""}"", variable.getValue())
                    .replace(""$"" + variable.getKey(), variable.getValue());
        }
        script = script.replace(""${mainClassName ?: entryPointArgs}"", StringUtils.isNotEmpty(binding.get(""mainClassName"")) ? binding.get(""mainClassName"") : binding.get(""entryPointArgs""));

        script = script.replaceAll(""(?sm)<% /\\*.*?\\*/ %>"", """");
        script = script.replaceAll(""(?sm)<% if \\( mainClassName\\.startsWith\\('--module '\\) \\) \\{.*?} %>"", """");
        script = script.replaceAll(""(?sm)<% if \\( appNameSystemProperty \\) \\{.*?%>(.*?)<% } %>"", ""$1"");
        script = script.replace(""\\$"", ""$"");
        script = script.replaceAll(""DIRNAME=\\.\\\\[\r\n]"", ""DIRNAME=."");
        script = script.replace(""\\\\"", ""\\"");
        return script.replaceAll(""\r\n|\r|\n"", lineSeparator);
    }

    private static class WrapperPropertiesVisitor extends PropertiesVisitor<ExecutionContext> {

        private static final String DISTRIBUTION_SHA_256_SUM_KEY = ""distributionSha256Sum"";
        private final GradleWrapper gradleWrapper;

        public WrapperPropertiesVisitor(GradleWrapper gradleWrapper) {
            this.gradleWrapper = gradleWrapper;
        }

        @Override
        public Properties visitFile(Properties.File file, ExecutionContext ctx) {
            Properties p = super.visitFile(file, ctx);
            Set<Properties.Entry> checksumKey = FindProperties.find(p, DISTRIBUTION_SHA_256_SUM_KEY, false);
            if (checksumKey.isEmpty() && gradleWrapper.getDistributionChecksum() != null) {
                Properties.Value propertyValue = new Properties.Value(Tree.randomId(), """", Markers.EMPTY, gradleWrapper.getDistributionChecksum().getHexValue());
                Properties.Entry entry = new Properties.Entry(Tree.randomId(), ""\n"", Markers.EMPTY, DISTRIBUTION_SHA_256_SUM_KEY, """", Properties.Entry.Delimiter.EQUALS, propertyValue);
                List<Properties.Content> contentList = ListUtils.concat(((Properties.File) p).getContent(), entry);
                p = ((Properties.File) p).withContent(contentList);
            } else if (!checksumKey.isEmpty() && gradleWrapper.getDistributionChecksum() == null) {
                List<Properties.Content> contentList = ListUtils.map(((Properties.File) p).getContent(), c -> {
                    if (c instanceof Properties.Entry && DISTRIBUTION_SHA_256_SUM_KEY.equals(((Properties.Entry) c).getKey())) {
                        return null;
                    }
                    return c;
                });
                p = ((Properties.File) p).withContent(contentList);
            }
            return p;
        }

        @Override
        public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
            if (""distributionUrl"".equals(entry.getKey())) {
                Properties.Value value = entry.getValue();
                return entry.withValue(value.withText(gradleWrapper.getPropertiesFormattedUrl()));
            }
            if (DISTRIBUTION_SHA_256_SUM_KEY.equals(entry.getKey()) && gradleWrapper.getDistributionChecksum() != null) {
                return entry.withValue(entry.getValue().withText(gradleWrapper.getDistributionChecksum().getHexValue()));
            }
            return entry;
        }
    }
}
",{}
Remove a Gradle dependency,Removes a single dependency from the dependencies section of the `build.gradle`.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.semver.DependencyMatcher;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""com.fasterxml.jackson*"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. This can be a glob expression."",
            example = ""jackson-module*"")
    String artifactId;

    @Option(displayName = ""The dependency configuration"",
            description = ""The dependency configuration to remove from."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Remove a Gradle dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Removes a single dependency from the dependencies section of the `build.gradle`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
            final GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher()
                    .configuration(configuration)
                    .groupId(groupId)
                    .artifactId(artifactId);
            final DependencyMatcher depMatcher = requireNonNull(DependencyMatcher.build(groupId + "":"" + artifactId).getValue());

            GradleProject gradleProject;

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof G.CompilationUnit || sourceFile instanceof K.CompilationUnit;
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile sourceFile = (JavaSourceFile) tree;
                    Optional<GradleProject> maybeGp = sourceFile.getMarkers().findFirst(GradleProject.class);
                    if (!maybeGp.isPresent()) {
                        return sourceFile;
                    }

                    gradleProject = maybeGp.get();

                    sourceFile = (JavaSourceFile) super.visit(sourceFile, ctx);
                    if (sourceFile != tree) {
                        sourceFile = sourceFile.withMarkers(sourceFile.getMarkers().setByType(updateGradleModel(gradleProject)));
                    }
                    return sourceFile;
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J.@Nullable Return visitReturn(J.Return return_, ExecutionContext ctx) {
                boolean dependencyInvocation = return_.getExpression() instanceof J.MethodInvocation && gradleDependencyMatcher.get(return_.getExpression(), getCursor()).isPresent();
                J.Return r = super.visitReturn(return_, ctx);
                if (dependencyInvocation && r.getExpression() == null) {
                    //noinspection DataFlowIssue
                    return null;
                }
                return r;
            }

            @Override
            public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                if (gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return null;
                }

                return m;
            }

            private GradleProject updateGradleModel(GradleProject gp) {
                Map<String, GradleDependencyConfiguration> nameToConfiguration = gp.getNameToConfiguration();
                Map<String, GradleDependencyConfiguration> newNameToConfiguration = new HashMap<>(nameToConfiguration.size());
                boolean anyChanged = false;
                for (GradleDependencyConfiguration gdc : nameToConfiguration.values()) {
                    if (!StringUtils.isBlank(configuration) && configuration.equals(gdc.getName())) {
                        newNameToConfiguration.put(gdc.getName(), gdc);
                        continue;
                    }

                    GradleDependencyConfiguration newGdc = gdc;
                    newGdc = newGdc.withRequested(ListUtils.map(gdc.getRequested(), requested -> {
                        if (depMatcher.matches(requested.getGroupId(), requested.getArtifactId())) {
                            return null;
                        }
                        return requested;
                    }));
                    newGdc = newGdc.withDirectResolved(ListUtils.map(gdc.getDirectResolved(), resolved -> {
                        if (depMatcher.matches(resolved.getGroupId(), resolved.getArtifactId())) {
                            return null;
                        }
                        return resolved;
                    }));
                    anyChanged |= newGdc != gdc;
                    newNameToConfiguration.put(newGdc.getName(), newGdc);
                }
                if (anyChanged) {
                    gp = gp.withNameToConfiguration(newNameToConfiguration);
                }
                return gp;
            }
        });
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Update Gradle project Java compatibility,Find and updates the Java compatibility for the Gradle project.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.*;
import org.openrewrite.kotlin.KotlinIsoVisitor;
import org.openrewrite.kotlin.KotlinParser;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;

import java.util.List;

import static java.lang.Boolean.TRUE;
import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpdateJavaCompatibility extends Recipe {
    private static final MethodMatcher SOURCE_COMPATIBILITY_DSL = new MethodMatcher(""RewriteGradleProject setSourceCompatibility(..)"");
    private static final MethodMatcher TARGET_COMPATIBILITY_DSL = new MethodMatcher(""RewriteGradleProject setTargetCompatibility(..)"");

    @Option(displayName = ""Java version"",
            description = ""The Java version to upgrade to."",
            example = ""11"")
    Integer version;

    @Option(displayName = ""Compatibility type"",
            description = ""The compatibility type to change"",
            valid = {""source"", ""target""},
            required = false)
    @Nullable
    CompatibilityType compatibilityType;

    @Option(displayName = ""Declaration style"",
            description = ""The desired style to write the new version as when being written to the `sourceCompatibility` "" +
                    ""or `targetCompatibility` variables. Default, match current source style. "" +
                    ""(ex. Enum: `JavaVersion.VERSION_11`, Number: 11, or String: \""11\"")"",
            valid = {""Enum"", ""Number"", ""String""},
            required = false)
    @Nullable
    DeclarationStyle declarationStyle;

    @Option(displayName = ""Allow downgrade"",
            description = ""Allow downgrading the Java version."",
            required = false)
    @Nullable
    Boolean allowDowngrade;

    @Option(displayName = ""Add compatibility type if missing"",
            description = ""Adds the specified compatibility type if one is not found."",
            required = false)
    @Nullable
    Boolean addIfMissing;

    private static final String SOURCE_COMPATIBILITY_FOUND = ""SOURCE_COMPATIBILITY_FOUND"";
    private static final String TARGET_COMPATIBILITY_FOUND = ""TARGET_COMPATIBILITY_FOUND"";

    @Override
    public String getDisplayName() {
        return ""Update Gradle project Java compatibility"";
    }

    @Override
    public String getDescription() {
        return ""Find and updates the Java compatibility for the Gradle project."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""version"", ""Version must be > 0."", version, v -> v > 0));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), Preconditions.or(new GroovyScriptVisitor(), new KotlinScriptVisitor()));
    }

    private class GroovyScriptVisitor extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
            G.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
            if (getCursor().pollMessage(SOURCE_COMPATIBILITY_FOUND) == null) {
                c = addCompatibilityTypeToSourceFile(c, ""source"", ctx);
            }
            if (getCursor().pollMessage(TARGET_COMPATIBILITY_FOUND) == null) {
                c = addCompatibilityTypeToSourceFile(c, ""target"", ctx);
            }
            return c;
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            return handleAssignment(super.visitAssignment(assignment, ctx), getCursor(), G.CompilationUnit.class);
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            return handleMethodInvocation(super.visitMethodInvocation(method, ctx), getCursor(), G.CompilationUnit.class);
        }

        private G.CompilationUnit addCompatibilityTypeToSourceFile(G.CompilationUnit c, String targetCompatibilityType, ExecutionContext ctx) {
            if ((compatibilityType == null || targetCompatibilityType.equals(compatibilityType.toString())) && TRUE.equals(addIfMissing)) {
                G.CompilationUnit sourceFile = (G.CompilationUnit) GradleParser.builder().build()
                        .parse(ctx, ""\n"" + targetCompatibilityType + ""Compatibility = "" + styleMissingCompatibilityVersion(declarationStyle))
                        .findFirst()
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse compatibility type as a Gradle file""));
                c = c.withStatements(ListUtils.concatAll(c.getStatements(), sourceFile.getStatements()));
            }
            return c;
        }
    }

    private class KotlinScriptVisitor extends KotlinIsoVisitor<ExecutionContext> {
        @Override
        public K.CompilationUnit visitCompilationUnit(K.CompilationUnit cu, ExecutionContext ctx) {
            K.CompilationUnit c = super.visitCompilationUnit(cu, ctx);
            if (getCursor().pollMessage(SOURCE_COMPATIBILITY_FOUND) == null) {
                c = addCompatibilityTypeToSourceFile(c, ""source"", ctx);
            }
            if (getCursor().pollMessage(TARGET_COMPATIBILITY_FOUND) == null) {
                c = addCompatibilityTypeToSourceFile(c, ""target"", ctx);
            }
            return super.visitCompilationUnit(c, ctx);
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            return handleAssignment(super.visitAssignment(assignment, ctx), getCursor(), K.CompilationUnit.class);
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            return handleMethodInvocation(super.visitMethodInvocation(method, ctx), getCursor(), K.CompilationUnit.class);
        }

        private K.CompilationUnit addCompatibilityTypeToSourceFile(K.CompilationUnit c, String targetCompatibilityType, ExecutionContext ctx) {
            if ((compatibilityType == null || targetCompatibilityType.equals(compatibilityType.toString())) && TRUE.equals(addIfMissing)) {
                J withExistingJavaMethod = maybeAddToExistingJavaMethod(c, targetCompatibilityType, ctx);
                if (withExistingJavaMethod != c) {
                    return (K.CompilationUnit) withExistingJavaMethod;
                }

                K.CompilationUnit sourceFile = (K.CompilationUnit) KotlinParser.builder()
                        .isKotlinScript(true)
                        .build().parse(ctx, ""\n\njava {\n    "" + targetCompatibilityType + ""Compatibility = "" + styleMissingCompatibilityVersion(DeclarationStyle.Enum) + ""\n}"")
                        .findFirst()
                        .orElseThrow(() -> new IllegalStateException(""Unable to parse compatibility type as a Gradle file""));
                c = c.withStatements(ListUtils.concatAll(c.getStatements(), sourceFile.getStatements()));
            }
            return c;
        }

        private J maybeAddToExistingJavaMethod(K.CompilationUnit c, String compatibilityType, ExecutionContext ctx) {
            return new JavaIsoVisitor<ExecutionContext>() {
                @Override
                public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                    if (""java"".equals(method.getSimpleName())) {
                        return new JavaIsoVisitor<ExecutionContext>() {
                            @Override
                            public J.Lambda visitLambda(J.Lambda lambda, ExecutionContext ctx) {
                                J.Block body = (J.Block) lambda.getBody();
                                List<Statement> statements = body.getStatements();
                                K.CompilationUnit sourceFile = (K.CompilationUnit) KotlinParser.builder()
                                        .isKotlinScript(true)
                                        .build().parse(ctx, ""\n    "" + compatibilityType + ""Compatibility = "" + styleMissingCompatibilityVersion(DeclarationStyle.Enum))
                                        .findFirst()
                                        .orElseThrow(() -> new IllegalStateException(""Unable to parse compatibility type as a Gradle file""));
                                return lambda.withBody(body.withStatements(ListUtils.concatAll(statements, sourceFile.getStatements())));
                            }
                        }.visitMethodInvocation(method, ctx);
                    }
                    return super.visitMethodInvocation(method, ctx);
                }
            }.visitNonNull(c, ctx);
        }
    }

    public J.Assignment handleAssignment(J.Assignment a, Cursor c, Class<?> enclosing) {
        if (a.getVariable() instanceof J.Identifier) {
            J.Identifier variable = (J.Identifier) a.getVariable();
            if (""sourceCompatibility"".equals(variable.getSimpleName())) {
                c.putMessageOnFirstEnclosing(enclosing, SOURCE_COMPATIBILITY_FOUND, true);
            }
            if (""targetCompatibility"".equals(variable.getSimpleName())) {
                c.putMessageOnFirstEnclosing(enclosing, TARGET_COMPATIBILITY_FOUND, true);
            }

            if (compatibilityType == null) {
                if (!(""sourceCompatibility"".equals(variable.getSimpleName()) || ""targetCompatibility"".equals(variable.getSimpleName()))) {
                    return a;
                }
            } else if (!(compatibilityType.toString().toLowerCase() + ""Compatibility"").equals(variable.getSimpleName())) {
                return a;
            }
        } else if (a.getVariable() instanceof J.FieldAccess) {
            J.FieldAccess fieldAccess = (J.FieldAccess) a.getVariable();
            if (compatibilityType == null) {
                if (!(""sourceCompatibility"".equals(fieldAccess.getSimpleName()) || ""targetCompatibility"".equals(fieldAccess.getSimpleName()) ||
                        (""release"".equals(fieldAccess.getSimpleName()) &&
                                ((fieldAccess.getTarget() instanceof J.Identifier && ""options"".equals(((J.Identifier) fieldAccess.getTarget()).getSimpleName())) ||
                                        (fieldAccess.getTarget() instanceof J.FieldAccess && ""options"".equals(((J.FieldAccess) fieldAccess.getTarget()).getSimpleName())))))) {
                    return a;
                }
            } else if (!(compatibilityType.toString().toLowerCase() + ""Compatibility"").equals(fieldAccess.getSimpleName())) {
                return a;
            }
        } else {
            return a;
        }

        DeclarationStyle currentStyle = getCurrentStyle(a.getAssignment());
        Integer currentMajor = getMajorVersion(a.getAssignment());
        if (shouldUpdateVersion(currentMajor) || shouldUpdateStyle(currentStyle)) {
            DeclarationStyle actualStyle = declarationStyle == null ? currentStyle : declarationStyle;
            return a.withAssignment(changeJavaVersion(a.getAssignment(), actualStyle));
        }

        return a;
    }

    private boolean shouldUpdateVersion(@Nullable Integer currentMajor) {
        return currentMajor != null && (currentMajor < version || currentMajor > version && TRUE.equals(allowDowngrade));
    }

    private boolean shouldUpdateStyle(@Nullable DeclarationStyle currentStyle) {
        return declarationStyle != null && declarationStyle != currentStyle;
    }

    public J.MethodInvocation handleMethodInvocation(J.MethodInvocation m, Cursor c, Class<?> enclosing) {
        if (""sourceCompatibility"".equals(m.getSimpleName())) {
            c.putMessageOnFirstEnclosing(enclosing, SOURCE_COMPATIBILITY_FOUND, true);
        }
        if (""targetCompatibility"".equals(m.getSimpleName())) {
            c.putMessageOnFirstEnclosing(enclosing, TARGET_COMPATIBILITY_FOUND, true);
        }
        if (""jvmToolchain"".equals(m.getSimpleName()) || isMethodInvocation(m, ""JavaLanguageVersion"", ""of"")) {
            List<Expression> args = m.getArguments();

            if (args.size() == 1) {
                if (args.get(0) instanceof J.Literal || (""jvmToolchain"".equals(m.getSimpleName()) && args.get(0) instanceof J.Lambda)) {
                    Integer currentMajor = getMajorVersion(args.get(0));
                    if (shouldUpdateVersion(currentMajor)) {
                        return m.withArguments(ListUtils.mapFirst(m.getArguments(), it -> changeJavaVersion(it, null)));
                    }
                    return m;
                }
            }

            return SearchResult.found(m, ""Attempted to update to Java version to "" + version +
                    ""  but was unsuccessful, please update manually"");
        }

        if (SOURCE_COMPATIBILITY_DSL.matches(m) || TARGET_COMPATIBILITY_DSL.matches(m)) {
            if (compatibilityType != null && (
                    (compatibilityType == CompatibilityType.source && !SOURCE_COMPATIBILITY_DSL.matches(m)) ||
                            (compatibilityType == CompatibilityType.target && !TARGET_COMPATIBILITY_DSL.matches(m)))) {
                return m;
            }

            if (m.getArguments().size() == 1 && (m.getArguments().get(0) instanceof J.Literal || m.getArguments().get(0) instanceof J.FieldAccess)) {
                DeclarationStyle currentStyle = getCurrentStyle(m.getArguments().get(0));
                Integer currentMajor = getMajorVersion(m.getArguments().get(0));
                if (shouldUpdateVersion(currentMajor) || shouldUpdateStyle(declarationStyle)) {
                    DeclarationStyle actualStyle = declarationStyle == null ? currentStyle : declarationStyle;
                    return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> changeJavaVersion(arg, actualStyle)));
                }
                return m;
            }

            return SearchResult.found(m, ""Attempted to update to Java version to "" + version +
                    ""  but was unsuccessful, please update manually"");
        }

        return m;
    }

    private int getMajorVersion(@Nullable String version) {
        if (version == null) {
            return -1;
        }
        try {
            return Integer.parseInt(normalize(version));
        } catch (NumberFormatException e) {
            return -1;
        }
    }

    private @Nullable Integer getMajorVersion(Expression expression) {
        if (expression instanceof J.Literal) {
            J.Literal argument = (J.Literal) expression;
            JavaType.Primitive type = argument.getType();
            if (type == JavaType.Primitive.String) {
                return getMajorVersion((String) argument.getValue());
            } else if (type == JavaType.Primitive.Int) {
                return (int) requireNonNull(argument.getValue());
            } else if (type == JavaType.Primitive.Double) {
                return getMajorVersion(requireNonNull(argument.getValue()).toString());
            }
        } else if (expression instanceof J.FieldAccess) {
            J.FieldAccess field = (J.FieldAccess) expression;
            J.Identifier identifier = field.getName();
            return getMajorVersion(identifier.getSimpleName());
        } else if (isMethodInvocation(expression, ""JavaVersion"", ""toVersion"")) {
            J.MethodInvocation method = (J.MethodInvocation) expression;
            if (method.getArguments().get(0) instanceof J.Literal) {
                return getMajorVersion(method.getArguments().get(0));
            }
        }

        return null;
    }

    private @Nullable DeclarationStyle getCurrentStyle(Expression expression) {
        if (expression instanceof J.Literal) {
            J.Literal argument = (J.Literal) expression;
            JavaType.Primitive type = argument.getType();
            if (type == JavaType.Primitive.String) {
                return DeclarationStyle.String;
            } else if (type == JavaType.Primitive.Int) {
                return DeclarationStyle.Number;
            } else if (type == JavaType.Primitive.Double) {
                return DeclarationStyle.Number;
            }
        } else if (expression instanceof J.FieldAccess) {
            return DeclarationStyle.Enum;
        }

        return null;
    }

    private String normalize(String version) {
        if (version.contains(""\"""") || version.contains(""'"")) {
            version = version.replace(""\"""", """").replace(""'"", """");
        }

        if (!version.contains(""."") && !version.contains(""_"")) {
            return version;
        }

        if (version.contains(""_"")) {
            String removePrefix = version.substring(version.indexOf(""_"") + 1);
            if (removePrefix.startsWith(""1_"")) {
                return removePrefix.substring(removePrefix.indexOf(""_"") + 1);
            }
            return removePrefix;
        }

        return version.substring(version.indexOf(""."") + 1);
    }

    private Expression changeJavaVersion(Expression expression, @Nullable DeclarationStyle style) {
        String newJavaVersion = version <= 8 ? ""1."" + version : String.valueOf(version);
        String newJavaVersionEnum = version <= 8 ? ""VERSION_1_"" + version : ""VERSION_"" + version;
        double newJavaVersionDouble = Double.parseDouble(""1."" + version);

        if (expression instanceof J.Literal) {
            J.Literal literal = (J.Literal) expression;
            if (style == null) {
                if (literal.getType() == JavaType.Primitive.String) {
                    return changeJavaVersion(literal, DeclarationStyle.String);
                } else if (literal.getType() == JavaType.Primitive.Int || literal.getType() == JavaType.Primitive.Double) {
                    return changeJavaVersion(literal, DeclarationStyle.Number);
                }
            } else if (style == DeclarationStyle.String) {
                if (literal.getType() == JavaType.Primitive.String) {
                    expression = ChangeStringLiteral.withStringValue(literal, newJavaVersion);
                } else {
                    expression = literal.withType(JavaType.Primitive.String).withValue(newJavaVersion).withValueSource(""'"" + newJavaVersion + ""'"");
                }
            } else if (style == DeclarationStyle.Enum) {
                expression = changeJavaVersion(newJavaVersionEnum, literal.getPrefix(), literal.getMarkers());
            } else if (style == DeclarationStyle.Number) {
                if (version <= 8) {
                    expression = literal.withType(JavaType.Primitive.Double).withValue(newJavaVersionDouble).withValueSource(""1."" + version);
                } else {
                    expression = literal.withType(JavaType.Primitive.Int).withValue(version).withValueSource(String.valueOf(version));
                }
            }
        } else if (expression instanceof J.FieldAccess) {
            J.FieldAccess fieldAccess = (J.FieldAccess) expression;
            if (style == DeclarationStyle.String) {
                expression = new J.Literal(randomId(), fieldAccess.getPrefix(), fieldAccess.getMarkers(), newJavaVersion, ""'"" + newJavaVersion + ""'"", emptyList(), JavaType.Primitive.String);
            } else if (style == DeclarationStyle.Enum) {
                expression = fieldAccess.withName(fieldAccess.getName().withSimpleName(newJavaVersionEnum));
            } else if (style == DeclarationStyle.Number) {
                expression = changeJavaVersion(newJavaVersionDouble, fieldAccess.getPrefix(), fieldAccess.getMarkers());
            }
        } else if (isMethodInvocation(expression, ""JavaVersion"", ""toVersion"")) {
            J.MethodInvocation m = (J.MethodInvocation) expression;
            if (style == null) {
                expression = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                    if (arg instanceof J.Literal) {
                        if (arg.getType() == JavaType.Primitive.String) {
                            return changeJavaVersion(arg, DeclarationStyle.String);
                        } else if (arg.getType() == JavaType.Primitive.Int || arg.getType() == JavaType.Primitive.Double) {
                            return changeJavaVersion(arg, DeclarationStyle.Number);
                        }
                    }
                    return arg;
                }));
            } else if (style == DeclarationStyle.String) {
                expression = new J.Literal(randomId(), m.getPrefix(), m.getMarkers(), newJavaVersion, ""'"" + newJavaVersion + ""'"", emptyList(), JavaType.Primitive.String);
            } else if (style == DeclarationStyle.Enum) {
                expression = changeJavaVersion(newJavaVersionEnum, m.getPrefix(), m.getMarkers());
            } else if (style == DeclarationStyle.Number) {
                expression = changeJavaVersion(newJavaVersionDouble, m.getPrefix(), m.getMarkers());
            }
        }

        return expression;
    }

    private Expression changeJavaVersion(String newJavaVersionEnum, Space prefix, Markers markers) {
        return new J.FieldAccess(
                randomId(),
                prefix,
                markers,
                new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), ""JavaVersion"", JavaType.ShallowClass.build(""org.gradle.api.JavaVersion""), null),
                new JLeftPadded<>(Space.EMPTY, new J.Identifier(randomId(), Space.EMPTY, Markers.EMPTY, emptyList(), newJavaVersionEnum, null, null), Markers.EMPTY),
                JavaType.ShallowClass.build(""org.gradle.api.JavaVersion"")
        );
    }

    private Expression changeJavaVersion(double newJavaVersionDouble, Space prefix, Markers markers) {
        if (version <= 8) {
            return new J.Literal(randomId(), prefix, markers, newJavaVersionDouble, String.valueOf(newJavaVersionDouble), emptyList(), JavaType.Primitive.Double);
        }
        return new J.Literal(randomId(), prefix, markers, version, String.valueOf(version), emptyList(), JavaType.Primitive.Int);
    }

    private static boolean isMethodInvocation(J expression, String clazz, String method) {
        return expression instanceof J.MethodInvocation &&
                ((J.MethodInvocation) expression).getSimpleName().equals(method) &&
                ((J.MethodInvocation) expression).getSelect() instanceof J.Identifier &&
                ((J.Identifier) ((J.MethodInvocation) expression).getSelect()).getSimpleName().equals(clazz);
    }

    private String styleMissingCompatibilityVersion(@Nullable DeclarationStyle declarationStyle) {
        if (declarationStyle == DeclarationStyle.String) {
            return version <= 8 ? ""'1."" + version + ""'"" : ""'"" + version + ""'"";
        } else if (declarationStyle == DeclarationStyle.Enum) {
            return version <= 8 ? ""JavaVersion.VERSION_1_"" + version : ""JavaVersion.VERSION_"" + version;
        } else if (version <= 8) {
            return ""1."" + version;
        }
        return String.valueOf(version);
    }

    public enum CompatibilityType {
        source, target
    }

    public enum DeclarationStyle {
        Enum, Number, String
    }
}
","{
  ""version"": ""Integer field""
}"
Use `String` notation for Gradle dependency declarations,"In Gradle, dependencies can be expressed as a `String` like `\",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.internal.Dependency;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

public class DependencyUseStringNotation extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Use `String` notation for Gradle dependency declarations"";
    }

    @Override
    public String getDescription() {
        return ""In Gradle, dependencies can be expressed as a `String` like `\""groupId:artifactId:version\""`, "" +
                ""or equivalently as a `Map` like `group: 'groupId', name: 'artifactId', version: 'version'`. "" +
                ""This recipe replaces dependencies represented as `Maps` with an equivalent dependency represented as a `String`, "" +
                ""as recommended per the [Gradle best practices for dependencies to use a single GAV](https://docs.gradle.org/8.14.2/userguide/best_practices_dependencies.html#single-gav-string)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);

                GradleDependency.Matcher gradleDependencyMatcher = new GradleDependency.Matcher();

                if (!gradleDependencyMatcher.get(getCursor()).isPresent()) {
                    return m;
                }

                if (m.getArguments().isEmpty()) {
                    return m;
                }

                Map<String, Expression> mapNotation = new HashMap<>();
                if (m.getArguments().get(0) instanceof G.MapLiteral) {
                    G.MapLiteral arg = (G.MapLiteral) m.getArguments().get(0);

                    for (G.MapEntry entry : arg.getElements()) {
                        if (entry.getKey() instanceof J.Literal) {
                            J.Literal key = (J.Literal) entry.getKey();
                            if (key.getType() == JavaType.Primitive.String) {
                                mapNotation.put((String) key.getValue(), entry.getValue());
                            }
                        }
                    }

                    J.Literal stringNotation = toLiteral(arg.getPrefix(), arg.getMarkers(), mapNotation);
                    if (stringNotation == null) {
                        return m;
                    }

                    Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);
                    if (lastArg instanceof J.Lambda) {
                        m = m.withArguments(Arrays.asList(stringNotation, lastArg));
                    } else {
                        m = m.withArguments(singletonList(stringNotation));
                    }
                } else if (m.getArguments().get(0) instanceof G.MapEntry) {
                    G.MapEntry firstEntry = (G.MapEntry) m.getArguments().get(0);
                    Space prefix = firstEntry.getPrefix();
                    Markers markers = firstEntry.getMarkers();

                    for (Expression e : m.getArguments()) {
                        if (e instanceof G.MapEntry) {
                            G.MapEntry entry = (G.MapEntry) e;
                            if (entry.getKey() instanceof J.Literal) {
                                J.Literal key = (J.Literal) entry.getKey();
                                if (key.getType() == JavaType.Primitive.String) {
                                    mapNotation.put((String) key.getValue(), entry.getValue());
                                }
                            }
                        }
                    }

                    J.Literal stringNotation = toLiteral(prefix, markers, mapNotation);
                    if (stringNotation == null) {
                        return m;
                    }

                    Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);
                    if (lastArg instanceof J.Lambda) {
                        m = m.withArguments(Arrays.asList(stringNotation, lastArg));
                    } else {
                        m = m.withArguments(singletonList(stringNotation));
                    }
                } else if (m.getArguments().get(0) instanceof J.Assignment) {
                    J.Assignment firstEntry = (J.Assignment) m.getArguments().get(0);
                    Space prefix = firstEntry.getPrefix();
                    Markers markers = firstEntry.getMarkers();

                    for (Expression e : m.getArguments()) {
                        if (e instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) e;
                            if (assignment.getVariable() instanceof J.Identifier) {
                                J.Identifier key = (J.Identifier) assignment.getVariable();
                                mapNotation.put(key.getSimpleName(), assignment.getAssignment());
                            }
                        }
                    }

                    J.Literal stringNotation = toLiteral(prefix, markers, mapNotation);
                    if (stringNotation == null) {
                        return m;
                    }

                    Expression lastArg = m.getArguments().get(m.getArguments().size() - 1);
                    if (lastArg instanceof J.Lambda) {
                        m = m.withArguments(Arrays.asList(stringNotation, lastArg));
                    } else {
                        m = m.withArguments(singletonList(stringNotation));
                    }
                }

                return m;
            }

            private J.@Nullable Literal toLiteral(Space prefix, Markers markers, Map<String, Expression> mapNotation) {
                // Name is the only required key in a dependency map.
                if (mapNotation.containsKey(""name"")) {
                    String group = coerceToStringNotation(mapNotation.get(""group""));
                    String name = coerceToStringNotation(mapNotation.get(""name""));
                    String version = coerceToStringNotation(mapNotation.get(""version""));
                    String classifier = coerceToStringNotation(mapNotation.get(""classifier""));
                    String extension = coerceToStringNotation(mapNotation.get(""ext""));

                    Dependency dependency = new Dependency(group, name, version, classifier, extension);
                    String stringNotation = dependency.toStringNotation();

                    return new J.Literal(randomId(), prefix, markers, stringNotation, ""\"""" + stringNotation + ""\"""", emptyList(), JavaType.Primitive.String);
                }

                return null;
            }

            private @Nullable String coerceToStringNotation(Expression expression) {
                if (expression instanceof J.Literal) {
                    return (String) ((J.Literal) expression).getValue();
                } else if (expression instanceof J.Identifier) {
                    return ""$"" + ((J.Identifier) expression).getSimpleName();
                } else if (expression instanceof G.GString) {
                    List<J> str = ((G.GString) expression).getStrings();
                    StringBuilder sb = new StringBuilder();
                    for (J valuePart : str) {
                        if (valuePart instanceof Expression) {
                            sb.append(coerceToStringNotation((Expression) valuePart));
                        } else if (valuePart instanceof G.GString.Value) {
                            J tree = ((G.GString.Value) valuePart).getTree();
                            if (tree instanceof Expression) {
                                sb.append(coerceToStringNotation((Expression) tree));
                            }
                            //Can it be something else? If so, what?
                        }
                    }
                    return sb.toString();
                }
                return null;
            }
        });
    }
}
",{}
Replace Gradle 8 introduced deprecations in JaCoCo report task,Set the `enabled` to `required` and the `destination` to `outputLocation` for Reports deprecations that were removed in gradle 8. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.gradle8;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class JacocoReportDeprecations extends Recipe {

    private static final String JACOCO_SETTINGS_INDEX = ""JACOCO_SETTINGS_INDEX"";

    @Override
    public String getDisplayName() {
        return ""Replace Gradle 8 introduced deprecations in JaCoCo report task"";
    }

    @Override
    public String getDescription() {
        return ""Set the `enabled` to `required` and the `destination` to `outputLocation` for Reports deprecations that were removed in gradle 8. "" +
                ""See [the gradle docs on this topic](https://docs.gradle.org/current/userguide/upgrading_version_7.html#report_and_testreport_api_cleanup)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
                Integer index = getCursor().getNearestMessage(JACOCO_SETTINGS_INDEX);
                if (index == null) {
                    index = 0;
                } else {
                    index++;
                }
                if (assignment.getVariable() instanceof J.FieldAccess) {
                    J.FieldAccess fieldAccess = (J.FieldAccess) assignment.getVariable();
                    String fieldName = getFieldName(fieldAccess);
                    return replaceDeprecations(assignment, index, fieldName);
                } else if (assignment.getVariable() instanceof J.Identifier) {
                    J.Identifier identifier = (J.Identifier) assignment.getVariable();
                    return replaceDeprecations(assignment, index, identifier.getSimpleName());
                }
                return assignment;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                Integer parent = getCursor().getNearestMessage(JACOCO_SETTINGS_INDEX);
                if (parent == null) {
                    parent = 0;
                } else {
                    parent++;
                }
                if (isPartOfDeprecatedPath(method.getSimpleName(), parent)) {
                    getCursor().putMessage(JACOCO_SETTINGS_INDEX, parent);

                    return super.visitMethodInvocation(method, ctx);
                }
                return method;
            }

            private J.Assignment replaceDeprecations(J.Assignment assignment, int index, String path) {
                if (isDeprecatedPath(path, index)) {
                    String field = path.substring(path.lastIndexOf(""."") + 1);
                    if (assignment.getVariable() instanceof J.FieldAccess) {
                        J.FieldAccess fieldAccess = (J.FieldAccess) assignment.getVariable();
                        if (""enabled"".equalsIgnoreCase(field) || ""isEnabled"".equalsIgnoreCase(field)) {
                            return assignment.withVariable(fieldAccess.withName(fieldAccess.getName().withSimpleName(""required"")));
                        } else if (""destination"".equalsIgnoreCase(field)) {
                            return assignment.withVariable(fieldAccess.withName(fieldAccess.getName().withSimpleName(""outputLocation"")));
                        }
                    } else if (assignment.getVariable() instanceof J.Identifier) {
                        J.Identifier identifier = (J.Identifier) assignment.getVariable();
                        if (""enabled"".equalsIgnoreCase(field) || ""isEnabled"".equalsIgnoreCase(field)) {
                            return assignment.withVariable(identifier.withSimpleName(""required""));
                        } else if (""destination"".equalsIgnoreCase(field)) {
                            return assignment.withVariable(identifier.withSimpleName(""outputLocation""));
                        }
                    }
                }
                return assignment;
            }

            private boolean isPartOfDeprecatedPath(String path, int index) {
                if (StringUtils.isNullOrEmpty(path)) {
                    return false;
                }
                switch (index) {
                    case 0:
                        return ""jacocoTestReport"".equalsIgnoreCase(path);
                    case 1:
                        return ""reports"".equalsIgnoreCase(path);
                    case 2:
                        return ""xml"".equalsIgnoreCase(path) || ""csv"".equalsIgnoreCase(path) || ""html"".equalsIgnoreCase(path);
                    case 3:
                        return ""enabled"".equalsIgnoreCase(path) || ""isEnabled"".equalsIgnoreCase(path) || ""destination"".equalsIgnoreCase(path);
                    default:
                        return false;
                }
            }

            private boolean isDeprecatedPath(String path, int index) {
                if (StringUtils.isNullOrEmpty(path)) {
                    return false;
                }
                String[] parts = path.split(""\\."");
                for (int i = 0; i < parts.length; i++) {
                    if (!isPartOfDeprecatedPath(parts[i], index + i)) {
                        return false;
                    }
                }
                return true;
            }

            private String getFieldName(J.FieldAccess fieldAccess) {
                String fieldName = fieldAccess.getSimpleName();
                Expression target = fieldAccess;
                while (target instanceof J.FieldAccess) {
                    target = ((J.FieldAccess) target).getTarget();
                    if (target instanceof J.Identifier) {
                        fieldName = ((J.Identifier) target).getSimpleName() + ""."" + fieldName;
                    } else if (target instanceof J.FieldAccess) {
                        fieldName = ((J.FieldAccess) target).getSimpleName() + ""."" + fieldName;
                    }
                }
                return fieldName;
            }
        });
    }
}
",{}
Use HTTPS for repositories,Use HTTPS for repository URLs.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.security;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Preconditions;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.kotlin.tree.K;

import java.time.Duration;
import java.util.Set;

import static java.util.Collections.singleton;

public class UseHttpsForRepositories extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Use HTTPS for repositories"";
    }

    @Override
    public String getDescription() {
        return ""Use HTTPS for repository URLs."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""security"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new JavaIsoVisitor<ExecutionContext>() {
            private J.Literal fixupLiteralIfNeeded(J.Literal arg) {
                String url = (String) arg.getValue();
                //noinspection HttpUrlsUsage
                if (url != null && url.startsWith(""http://"")) {
                    String newUrl = url.replaceAll(""^http://(.*)"", ""https://$1"");
                    return ChangeStringLiteral.withStringValue(arg, newUrl);
                }
                return arg;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (""url"".equals(m.getSimpleName()) || ""uri"".equals(m.getSimpleName())) {
                    try {
                        getCursor()
                                .dropParentUntil(e -> e instanceof J.MethodInvocation && ""maven"".equals(((J.MethodInvocation) e).getSimpleName()))
                                .dropParentUntil(e -> e instanceof J.MethodInvocation && ""repositories"".equals(((J.MethodInvocation) e).getSimpleName()));
                        m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                            if (arg instanceof J.Literal) {
                                return fixupLiteralIfNeeded((J.Literal) arg);
                            } else if (arg instanceof G.GString) {
                                G.GString garg = (G.GString) arg;
                                return garg.withStrings(ListUtils.mapFirst(garg.getStrings(),
                                        lit -> lit instanceof J.Literal ? fixupLiteralIfNeeded((J.Literal) lit) : lit));
                            } else if (arg instanceof K.StringTemplate) {
                                K.StringTemplate karg = (K.StringTemplate) arg;
                                return karg.withStrings(ListUtils.mapFirst(karg.getStrings(),
                                        lit -> lit instanceof J.Literal ? fixupLiteralIfNeeded((J.Literal) lit) : lit));
                            }
                            return arg;
                        }));
                    } catch (Exception ignored) {}
                }
                return m;
            }
        });
    }
}
",{}
Add Gradle settings plugin,Add plugin to Gradle settings file `plugins` block by id.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.semver.Semver;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddSettingsPlugin extends Recipe {
    @Option(displayName = ""Plugin id"",
            description = ""The plugin id to apply."",
            example = ""com.jfrog.bintray"")
    String pluginId;

    @Option(displayName = ""Plugin version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""3.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Apply plugin"",
            description = ""Immediate apply the plugin. Defaults to `true`."",
            valid = {""true"", ""false""},
            required = false)
    @Nullable
    Boolean apply;

    @Option(displayName = ""Accept transitive"",
            description = ""Some plugins apply other plugins. When this is set to true no plugin declaration will be added if the plugin is already applied transitively. "" +
                          ""When this is set to false the plugin will be added explicitly even if it is already applied transitively. "" +
                          ""Defaults to `true`."",
            valid = {""true"", ""false""},
            required = false)
    @Nullable
    Boolean acceptTransitive;

    @Override
    public String getDisplayName() {
        return ""Add Gradle settings plugin"";
    }

    @Override
    public String getDescription() {
        return ""Add plugin to Gradle settings file `plugins` block by id."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new IsSettingsGradle<>(),
                new AddPluginVisitor(pluginId, StringUtils.isBlank(version) ? ""latest.release"" : version, versionPattern, apply, acceptTransitive)
        );
    }
}
","{
  ""pluginId"": ""String field""
}"
Add Gradle plugin,Add a build plugin to a Gradle build file's `plugins` block.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.search.FindGradleProject;
import org.openrewrite.semver.Semver;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddBuildPlugin extends Recipe {
    @Option(displayName = ""Plugin id"",
            description = ""The plugin id to apply."",
            example = ""com.jfrog.bintray"")
    String pluginId;

    @Option(displayName = ""Plugin version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""3.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Apply plugin"",
            description = ""Immediate apply the plugin. Defaults to `true`."",
            valid = {""true"", ""false""},
            required = false)
    @Nullable
    Boolean apply;

    @Option(displayName = ""Accept transitive"",
            description = ""Some plugins apply other plugins. When this is set to true no plugin declaration will be added if the plugin is already applied transitively. "" +
                          ""When this is set to false the plugin will be added explicitly even if it is already applied transitively. "" +
                          ""Defaults to `true`."",
            valid = {""true"", ""false""},
            required = false)
    @Nullable
    Boolean acceptTransitive;

    @Override
    public String getDisplayName() {
        return ""Add Gradle plugin"";
    }

    @Override
    public String getDescription() {
        return ""Add a build plugin to a Gradle build file's `plugins` block."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new FindGradleProject(FindGradleProject.SearchCriteria.Marker),
                new AddPluginVisitor(pluginId, version, versionPattern, apply, acceptTransitive)
        );
    }
}
","{
  ""pluginId"": ""String field""
}"
Remove Develocity configuration,Remove Develocity configuration from a Gradle build.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import org.openrewrite.Recipe;
import org.openrewrite.gradle.RemoveExtension;

import java.util.Arrays;
import java.util.List;

public class RemoveDevelocityConfiguration extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove Develocity configuration"";
    }

    @Override
    public String getDescription() {
        return ""Remove Develocity configuration from a Gradle build."";
    }

    @Override
    public List<Recipe> getRecipeList() {
        return Arrays.asList(
                new RemoveExtension(""develocity""),
                new RemoveExtension(""gradleEnterprise""));
    }
}
",{}
MigrateGradleEnterpriseToDevelocity,Migrate from the Gradle Enterprise Gradle plugin to the Develocity Gradle plugin.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.DependencyVersionSelector;
import org.openrewrite.gradle.GradleParser;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.marker.GradleSettings;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.TabsAndIndentsStyle;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.style.Style;

import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class MigrateGradleEnterpriseToDevelocity extends Recipe {

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Plugin version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""3.x"",
            required = false)
    @Nullable
    String version;

    @Override
    public String getDisplayName() {
        //noinspection DialogTitleCapitalization
        return ""Migrate from Gradle Enterprise to Develocity"";
    }

    @Override
    public String getDescription() {
        return ""Migrate from the Gradle Enterprise Gradle plugin to the Develocity Gradle plugin."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new IsSettingsGradle<>(),
                new GroovyIsoVisitor<ExecutionContext>() {
                    @Override
                    public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                        Optional<GradleSettings> maybeGs = cu.getMarkers().findFirst(GradleSettings.class);
                        if (!maybeGs.isPresent()) {
                            return cu;
                        }

                        try {
                            String newVersion = new DependencyVersionSelector(metadataFailures, null, maybeGs.get())
                                    .select(new GroupArtifact(""com.gradle.develocity"", ""com.gradle.develocity.gradle.plugin""), ""classpath"", version, null, ctx);
                            if (newVersion == null) {
                                // The develocity plugin was first published as of 3.17
                                return cu;
                            }
                        } catch (MavenDownloadingException e) {
                            return e.warn(cu);
                        }

                        G.CompilationUnit g = cu;
                        g = (G.CompilationUnit) new ChangePlugin(""com.gradle.enterprise"", ""com.gradle.develocity"", version).getVisitor()
                                .visitNonNull(g, ctx);
                        g = (G.CompilationUnit) new UpgradePluginVersion(""com.gradle.common-custom-user-data-gradle-plugin"", ""2.x"", null).getVisitor()
                                .visitNonNull(g, ctx);
                        return (G.CompilationUnit) new MigrateConfigurationVisitor().visitNonNull(g, ctx);
                    }
                }
        );
    }

    private static class MigrateConfigurationVisitor extends GroovyIsoVisitor<ExecutionContext> {
        @Override
        public J.@Nullable MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (""gradleEnterprise"".equals(m.getSimpleName()) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Lambda) {
                return m.withName(m.getName().withSimpleName(""develocity""));
            }

            if (m.getSimpleName().startsWith(""publishAlways"") && withinMethodInvocations(Arrays.asList(""gradleEnterprise"", ""buildScan""))) {
                if (""publishAlways"".equals(m.getSimpleName()) && noArguments(m.getArguments())) {
                    // As of 3.17+, `publishAlways` is the default, so it is recommended to not configure anything
                    return null;
                }

                if (""publishAlwaysIf"".equals(m.getSimpleName())) {
                    J.MethodInvocation publishingTemplate = develocityPublishAlwaysIfDsl(getIndent(getCursor().firstEnclosing(G.CompilationUnit.class)), ctx);
                    if (publishingTemplate == null) {
                        return m;
                    }

                    return publishingTemplate.withArguments(ListUtils.mapFirst(publishingTemplate.getArguments(), arg -> {
                        if (arg instanceof J.Lambda) {
                            J.Lambda lambda = (J.Lambda) arg;
                            J.Block block = (J.Block) lambda.getBody();
                            return lambda.withBody(block.withStatements(ListUtils.mapFirst(block.getStatements(), s -> {
                                if (s instanceof J.Return) {
                                    J.Return _return = (J.Return) s;
                                    return _return.withExpression(m.getArguments().get(0));
                                }
                                return s;
                            })));
                        }
                        return arg;
                    }));
                }
            }

            if (m.getSimpleName().startsWith(""publishOnFailure"") && withinMethodInvocations(Arrays.asList(""gradleEnterprise"", ""buildScan""))) {
                J.MethodInvocation publishingTemplate = develocityPublishOnFailureIfDsl(getIndent(getCursor().firstEnclosing(G.CompilationUnit.class)), ctx);
                if (publishingTemplate == null) {
                    return m;
                }

                if (""publishOnFailure"".equals(m.getSimpleName()) && noArguments(m.getArguments())) {
                    return publishingTemplate;
                }

                if (""publishOnFailureIf"".equals(m.getSimpleName()) && m.getArguments().size() == 1 && m.getArguments().get(0) instanceof J.Binary) {
                    return publishingTemplate.withArguments(ListUtils.mapFirst(publishingTemplate.getArguments(), arg -> {
                        if (arg instanceof J.Lambda) {
                            J.Lambda lambda = (J.Lambda) arg;
                            J.Block block = (J.Block) lambda.getBody();
                            return lambda.withBody(block.withStatements(ListUtils.mapFirst(block.getStatements(), s -> {
                                if (s instanceof J.Return && ((J.Return) s).getExpression() instanceof J.Unary) {
                                    J.Return _return = (J.Return) s;
                                    return _return.withExpression(new J.Binary(
                                            Tree.randomId(),
                                            Space.EMPTY,
                                            Markers.EMPTY,
                                            _return.getExpression(),
                                            JLeftPadded.build(J.Binary.Type.And).withBefore(Space.SINGLE_SPACE),
                                            Space.formatFirstPrefix(m.getArguments(), Space.SINGLE_SPACE).get(0),
                                            JavaType.Primitive.Boolean
                                    ));
                                }
                                return s;
                            })));
                        }
                        return arg;
                    }));
                }
            }

            if (""remote"".equals(m.getSimpleName()) && withinMethodInvocations(Arrays.asList(""gradleEnterprise"", ""buildCache""))) {
                return m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                    if (arg instanceof J.FieldAccess) {
                        J.FieldAccess field = (J.FieldAccess) arg;
                        if (""buildCache"".equals(field.getSimpleName()) && field.getTarget() instanceof J.Identifier && ""gradleEnterprise"".equals(((J.Identifier) field.getTarget()).getSimpleName())) {
                            return field.withTarget(((J.Identifier) field.getTarget()).withSimpleName(""develocity""));
                        }
                    }
                    return arg;
                }));
            }
            return m;
        }

        @Override
        public J.Assignment visitAssignment(J.Assignment assignment, ExecutionContext ctx) {
            J.Assignment a = super.visitAssignment(assignment, ctx);

            if (a.getVariable() instanceof J.Identifier && ""taskInputFiles"".equals(((J.Identifier) a.getVariable()).getSimpleName()) && withinMethodInvocations(Arrays.asList(""gradleEnterprise"", ""buildScan"", ""capture""))) {
                return a.withVariable(((J.Identifier) a.getVariable()).withSimpleName(""fileFingerprints""));
            }

            return a;
        }

        private boolean noArguments(List<Expression> arguments) {
            return arguments.isEmpty() || (arguments.size() == 1 && arguments.get(0) instanceof J.Empty);
        }

        private boolean withinMethodInvocations(List<String> methods) {
            Cursor current = getCursor().getParent();
            for (int i = methods.size() - 1; i >= 0; i--) {
                current = findMethodInvocation(current);
                if (current == null) {
                    return false;
                }

                if (!((J.MethodInvocation) current.getValue()).getSimpleName().equals(methods.get(i))) {
                    return false;
                }

                current = current.getParent();
            }

            return true;
        }

        private @Nullable Cursor findMethodInvocation(@Nullable Cursor start) {
            if (start == null) {
                return null;
            }

            Cursor current = start;
            while (current.getParent() != null) {
                if (current.getValue() instanceof J.MethodInvocation) {
                    return current;
                }

                current = current.getParent();
            }

            return null;
        }

        private J.@Nullable MethodInvocation develocityPublishAlwaysIfDsl(String indent, ExecutionContext ctx) {
            StringBuilder ge = new StringBuilder(""\ndevelocity {\n"");
            ge.append(indent).append(""buildScan {\n"");
            ge.append(indent).append(indent).append(""publishing.onlyIf { true }\n"");
            ge.append(indent).append(""}\n"");
            ge.append(""}\n"");

            G.CompilationUnit cu = GradleParser.builder().build()
                    .parseInputs(singletonList(
                            Parser.Input.fromString(Paths.get(""settings.gradle""), ge.toString())), null, ctx)
                    .map(G.CompilationUnit.class::cast)
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException(""Could not parse as Gradle""));

            J.MethodInvocation develocity = (J.MethodInvocation) cu.getStatements().get(0);
            J.MethodInvocation buildScan = (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) develocity.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();
            return (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) buildScan.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();
        }

        private J.@Nullable MethodInvocation develocityPublishOnFailureIfDsl(String indent, ExecutionContext ctx) {
            StringBuilder ge = new StringBuilder(""\ndevelocity {\n"");
            ge.append(indent).append(""buildScan {\n"");
            ge.append(indent).append(indent).append(""publishing.onlyIf { !it.buildResult.failures.empty }\n"");
            ge.append(indent).append(""}\n"");
            ge.append(""}\n"");

            G.CompilationUnit cu = GradleParser.builder().build()
                    .parseInputs(singletonList(
                            Parser.Input.fromString(Paths.get(""settings.gradle""), ge.toString())), null, ctx)
                    .map(G.CompilationUnit.class::cast)
                    .findFirst()
                    .orElseThrow(() -> new IllegalArgumentException(""Could not parse as Gradle""));

            J.MethodInvocation develocity = (J.MethodInvocation) cu.getStatements().get(0);
            J.MethodInvocation buildScan = (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) develocity.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();
            return (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) buildScan.getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();
        }

        private String getIndent(G.CompilationUnit cu) {
            TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, cu, IntelliJ::tabsAndIndents);
            if (style.getUseTabCharacter()) {
                return ""\t"";
            } else {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < style.getIndentSize(); i++) {
                    sb.append("" "");
                }
                return sb.toString();
            }
        }
    }
}
",{}
Change a Gradle plugin version by id,Change a Gradle plugin by id to a later version.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.DependencyVersionSelector;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.marker.GradleSettings;
import org.openrewrite.groovy.GroovyVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.Markup;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.semver.Semver;

import java.util.List;

/**
 * @deprecated in favor of {@link org.openrewrite.gradle.plugins.UpgradePluginVersion}.
 */
@Value
@EqualsAndHashCode(callSuper = false)
@Deprecated
public class ChangePluginVersion extends Recipe {
    private static final String GRADLE_PROPERTIES_FILE_NAME = ""gradle.properties"";

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Plugin id"",
            description = ""The `ID` part of `plugin { ID }`, as a glob expression."",
            example = ""com.jfrog.bintray"")
    String pluginIdPattern;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                          ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Override
    public String getDisplayName() {
        return ""Change a Gradle plugin version by id"";
    }

    @Override
    public String getDescription() {
        return ""Change a Gradle plugin by id to a later version."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher pluginMatcher = new MethodMatcher(""PluginSpec id(..)"", false);
        MethodMatcher versionMatcher = new MethodMatcher(""Plugin version(..)"", false);
        GroovyVisitor<ExecutionContext> groovyVisitor = new GroovyVisitor<ExecutionContext>() {
            @Nullable
            private GradleProject gradleProject;

            @Nullable
            private GradleSettings gradleSettings;

            @Override
            public J visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                gradleProject = cu.getMarkers().findFirst(GradleProject.class).orElse(null);
                gradleSettings = cu.getMarkers().findFirst(GradleSettings.class).orElse(null);
                if (gradleProject == null && gradleSettings == null) {
                    return cu;
                }
                return super.visitCompilationUnit(cu, ctx);
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (!(versionMatcher.matches(m) &&
                      m.getSelect() instanceof J.MethodInvocation &&
                      pluginMatcher.matches(m.getSelect()))) {
                    return m;
                }
                List<Expression> pluginArgs = ((J.MethodInvocation) m.getSelect()).getArguments();
                if (!(pluginArgs.get(0) instanceof J.Literal)) {
                    return m;
                }
                String pluginId = (String) ((J.Literal) pluginArgs.get(0)).getValue();
                if (pluginId == null || !StringUtils.matchesGlob(pluginId, pluginIdPattern)) {
                    return m;
                }

                List<Expression> versionArgs = m.getArguments();
                String currentVersion = ""0"";
                if (versionArgs.get(0) instanceof J.Literal) {
                    currentVersion = (String) ((J.Literal) versionArgs.get(0)).getValue();
                    if (currentVersion == null) {
                        currentVersion = ""0"";
                    }
                }

                String selectedNewVersion = newVersion;
                if (""0"".equals(currentVersion) && ""latest.patch"".equals(newVersion)) {
                    selectedNewVersion = ""latest.release"";
                }

                try {
                    String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)
                            .select(new GroupArtifactVersion(pluginId, pluginId + "".gradle.plugin"", currentVersion), ""classpath"", selectedNewVersion, versionPattern, ctx);
                    if (resolvedVersion == null) {
                        return m;
                    }
                    return m.withArguments(ListUtils.map(versionArgs, v -> new J.Literal(
                            Tree.randomId(),
                            v.getPrefix(),
                            v.getMarkers(),
                            resolvedVersion,
                            ""'"" + resolvedVersion + ""'"",
                            null,
                            JavaType.Primitive.String
                    )));
                } catch (MavenDownloadingException e) {
                    return Markup.warn(m, e);
                }
            }
        };
        return Preconditions.or(Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), groovyVisitor));
    }
}
","{
  ""pluginIdPattern"": ""String field""
}"
Remove Gradle settings plugin,Remove plugin from Gradle settings file `plugins` block by id.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.gradle.IsSettingsGradle;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveSettingsPlugin extends Recipe {
    @Option(displayName = ""Plugin id"",
            description = ""The plugin id to remove."",
            example = ""com.jfrog.bintray""
    )
    String pluginId;

    @Override
    public String getDisplayName() {
        return ""Remove Gradle settings plugin"";
    }

    @Override
    public String getDescription() {
        return ""Remove plugin from Gradle settings file `plugins` block by id."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsSettingsGradle<>(), new RemovePluginVisitor(pluginId));
    }
}
","{
  ""pluginId"": ""String field""
}"
Update a Gradle plugin by id,Update a Gradle plugin by id to a later version defined by the plugins DSL. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.DependencyVersionSelector;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.marker.GradleSettings;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.singletonList;

@SuppressWarnings(""DuplicatedCode"")
@Value
@EqualsAndHashCode(callSuper = false)
public class UpgradePluginVersion extends ScanningRecipe<UpgradePluginVersion.DependencyVersionState> {
    private static final String GRADLE_PROPERTIES_FILE_NAME = ""gradle.properties"";

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Plugin id"",
            description = ""The `ID` part of `plugin { ID }`, as a glob expression."",
            example = ""com.jfrog.bintray"")
    String pluginIdPattern;

    @Option(displayName = ""New version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                    ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                    ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                    ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                    ""Defaults to `latest.release`."",
            example = ""29.X"",
            required = false)
    @Nullable
    String newVersion;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Override
    public String getDisplayName() {
        return ""Update a Gradle plugin by id"";
    }

    @Override
    public String getDescription() {
        return ""Update a Gradle plugin by id to a later version defined by the plugins DSL. "" +
                ""To upgrade a plugin dependency defined by `buildscript.dependencies`, use the `UpgradeDependencyVersion` "" +
                ""recipe instead."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, versionPattern));
        }
        return validated;
    }

    public static class DependencyVersionState {
        Map<String, String> versionPropNameToPluginId = new HashMap<>();
        Map<String, @Nullable String> pluginIdToNewVersion = new HashMap<>();
    }

    @Override
    public DependencyVersionState getInitialValue(ExecutionContext ctx) {
        return new DependencyVersionState();
    }

    @SuppressWarnings(""BooleanMethodIsAlwaysInverted"")
    private boolean isPluginVersion(Cursor cursor) {
        if (!(cursor.getValue() instanceof J.MethodInvocation)) {
            return false;
        }
        J.MethodInvocation maybeVersion = cursor.getValue();
        if (!""version"".equals(maybeVersion.getSimpleName())) {
            return false;
        }
        Cursor parent = cursor.dropParentUntil(it -> (it instanceof J.MethodInvocation) || it == Cursor.ROOT_VALUE);
        if (!(parent.getValue() instanceof J.MethodInvocation)) {
            return false;
        }
        J.MethodInvocation maybePlugins = parent.getValue();
        return ""plugins"".equals(maybePlugins.getSimpleName());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(DependencyVersionState acc) {

        JavaVisitor<ExecutionContext> javaVisitor = new JavaVisitor<ExecutionContext>() {
            @Nullable
            private GradleProject gradleProject;

            @Nullable
            private GradleSettings gradleSettings;

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    gradleProject = tree.getMarkers().findFirst(GradleProject.class).orElse(null);
                    gradleSettings = tree.getMarkers().findFirst(GradleSettings.class).orElse(null);
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (!isPluginVersion(getCursor())) {
                    return m;
                }
                assert m.getSelect() != null;
                List<Expression> pluginArgs = ((J.MethodInvocation) m.getSelect()).getArguments();
                if (!(pluginArgs.get(0) instanceof J.Literal)) {
                    return m;
                }
                String pluginId = literalValue(pluginArgs.get(0));
                if (pluginId == null || !StringUtils.matchesGlob(pluginId, pluginIdPattern)) {
                    return m;
                }

                List<Expression> versionArgs = m.getArguments();
                try {
                    String currentVersion = literalValue(versionArgs.get(0));
                    if (currentVersion != null) {
                        String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)
                                .select(new GroupArtifactVersion(pluginId, pluginId + "".gradle.plugin"", currentVersion), ""classpath"", newVersion, versionPattern, ctx);
                        acc.pluginIdToNewVersion.put(pluginId, resolvedVersion);
                    } else if (versionArgs.get(0) instanceof G.GString) {
                        G.GString gString = (G.GString) versionArgs.get(0);
                        if (gString.getStrings().isEmpty() || !(gString.getStrings().get(0) instanceof G.GString.Value)) {
                            return m;
                        }

                        G.GString.Value gStringValue = (G.GString.Value) gString.getStrings().get(0);
                        String versionVariableName = gStringValue.getTree().toString();
                        String resolvedPluginVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)
                                .select(new GroupArtifact(pluginId, pluginId + "".gradle.plugin""), ""classpath"", newVersion, versionPattern, ctx);

                        acc.versionPropNameToPluginId.put(versionVariableName, pluginId);
                        assert resolvedPluginVersion != null;
                        acc.pluginIdToNewVersion.put(pluginId, resolvedPluginVersion);
                    } else if (versionArgs.get(0) instanceof J.Identifier) {
                        J.Identifier identifier = (J.Identifier) versionArgs.get(0);
                        String versionVariableName = identifier.getSimpleName();
                        String resolvedPluginVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)
                                .select(new GroupArtifact(pluginId, pluginId + "".gradle.plugin""), ""classpath"", newVersion, versionPattern, ctx);

                        acc.versionPropNameToPluginId.put(versionVariableName, pluginId);
                        assert resolvedPluginVersion != null;
                        acc.pluginIdToNewVersion.put(pluginId, resolvedPluginVersion);
                    }
                } catch (MavenDownloadingException e) {
                    // continue
                }
                return m;
            }
        };
        return Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), javaVisitor);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(DependencyVersionState acc) {
        PropertiesVisitor<ExecutionContext> propertiesVisitor = new PropertiesVisitor<ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return super.isAcceptable(sourceFile, ctx) && sourceFile.getSourcePath().endsWith(GRADLE_PROPERTIES_FILE_NAME);
            }

            @Override
            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                if (acc.versionPropNameToPluginId.containsKey(entry.getKey())) {
                    String currentVersion = entry.getValue().getText();
                    String pluginId = acc.versionPropNameToPluginId.get(entry.getKey());
                    if (!StringUtils.isBlank(newVersion)) {
                        String resolvedVersion = acc.pluginIdToNewVersion.get(pluginId);
                        VersionComparator versionComparator = Semver.validate(newVersion, versionPattern).getValue();
                        if (versionComparator == null) {
                            return entry;
                        }

                        Optional<String> finalVersion = versionComparator.upgrade(currentVersion, singletonList(resolvedVersion));
                        if (finalVersion.isPresent()) {
                            return entry.withValue(entry.getValue().withText(finalVersion.get()));
                        }
                    }
                }
                return entry;
            }
        };
        JavaVisitor<ExecutionContext> javaVisitor = new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (!isPluginVersion(getCursor())) {
                    return m;
                }
                assert m.getSelect() != null;
                List<Expression> pluginArgs = ((J.MethodInvocation) m.getSelect()).getArguments();
                String pluginId = literalValue(pluginArgs.get(0));
                if (pluginId == null || !StringUtils.matchesGlob(pluginId, pluginIdPattern)) {
                    return m;
                }

                List<Expression> versionArgs = m.getArguments();
                String currentVersion = literalValue(m.getArguments().get(0));
                if (currentVersion == null) {
                    return m;
                }
                String resolvedVersion = acc.pluginIdToNewVersion.get(pluginId);
                if (resolvedVersion == null) {
                    return m;
                }
                return m.withArguments(ListUtils.map(versionArgs, v -> {
                    assert v != null;
                    return ChangeStringLiteral.withStringValue(v, resolvedVersion);
                }));
            }

            @Override
            public J visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext ctx) {
                J.VariableDeclarations.NamedVariable visited = (J.VariableDeclarations.NamedVariable) super.visitVariable(variable, ctx);
                if (acc.versionPropNameToPluginId.containsKey(visited.getSimpleName()) && visited.getInitializer() instanceof J.Literal) {
                    J.Literal initializer = (J.Literal) visited.getInitializer();
                    String oldVersion = literalValue(initializer);
                    String newVersion = acc.pluginIdToNewVersion.get(acc.versionPropNameToPluginId.get(visited.getSimpleName()));
                    if (newVersion != null && !newVersion.equals(oldVersion)) {
                        String valueSource = initializer.getValueSource() == null || oldVersion == null ? initializer.getValueSource() : initializer.getValueSource().replace(oldVersion, newVersion);
                        return visited.withInitializer(initializer.withValueSource(valueSource).withValue(newVersion));
                    }
                }
                return visited;
            }
        };
        return Preconditions.or(propertiesVisitor, Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), javaVisitor));
    }

    @SuppressWarnings(""DataFlowIssue"")
    private @Nullable String literalValue(Expression expr) {
        AtomicReference<String> value = new AtomicReference<>(null);
        new JavaVisitor<Integer>() {
            @Override
            public J visitLiteral(J.Literal literal, Integer integer) {
                value.set((String) literal.getValue());
                return literal;
            }
        }.visit(expr, 0);
        return value.get();
    }
}
","{
  ""pluginIdPattern"": ""String field""
}"
Add the Develocity Gradle plugin,Add the Develocity Gradle plugin to settings.gradle files.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.DependencyVersionSelector;
import org.openrewrite.gradle.GradleParser;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.marker.GradleSettings;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.TabsAndIndentsStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.marker.BuildTool;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;
import org.openrewrite.style.Style;

import java.nio.file.Paths;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddDevelocityGradlePlugin extends Recipe {
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Plugin version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors). "" +
                          ""Defaults to `latest.release`."",
            example = ""3.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Server URL"",
            description = ""The URL of the Develocity server. If omitted the recipe will set no URL and Gradle will direct scans to https://scans.gradle.com/"",
            required = false,
            example = ""https://scans.gradle.com/"")
    @Nullable
    String server;

    @Option(displayName = ""Allow untrusted server"",
            description = ""When set to `true` the plugin will be configured to allow unencrypted http connections with the server. "" +
                          ""If set to `false` or omitted, the plugin will refuse to communicate without transport layer security enabled."",
            required = false,
            example = ""true"")
    @Nullable
    Boolean allowUntrustedServer;

    @Option(displayName = ""Capture task input files"",
            description = ""When set to `true` the plugin will capture additional information about the inputs to Gradle tasks. "" +
                          ""This increases the size of build scans, but is useful for diagnosing issues with task caching. "",
            required = false,
            example = ""true"")
    @Nullable
    Boolean captureTaskInputFiles;

    @Option(displayName = ""Upload in background"",
            description = ""When set to `true` the plugin will capture additional information about the outputs of Gradle tasks. "" +
                          ""This increases the size of build scans, but is useful for diagnosing issues with task caching. "",
            required = false,
            example = ""true"")
    @Nullable
    Boolean uploadInBackground;

    @Option(displayName = ""Publish criteria"",
            description = ""When set to `Always` the plugin will publish build scans of every single build. "" +
                          ""When set to `Failure` the plugin will only publish build scans when the build fails. "" +
                          ""When omitted scans will be published only when the `--scan` option is passed to the build."",
            required = false,
            valid = {""Always"", ""Failure""},
            example = ""Always"")
    @Nullable
    PublishCriteria publishCriteria;

    public enum PublishCriteria {
        Always,
        Failure
    }

    @Override
    public String getDisplayName() {
        return ""Add the Develocity Gradle plugin"";
    }

    @Override
    public String getDescription() {
        return ""Add the Develocity Gradle plugin to settings.gradle files."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, null));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                Optional<BuildTool> maybeBuildTool = cu.getMarkers().findFirst(BuildTool.class);
                if (!maybeBuildTool.isPresent()) {
                    return cu;
                }
                BuildTool buildTool = maybeBuildTool.get();
                if (buildTool.getType() != BuildTool.Type.Gradle) {
                    return cu;
                }
                VersionComparator versionComparator = Semver.validate(""(,6)"", null).getValue();
                if (versionComparator == null) {
                    return cu;
                }
                // Don't modify an existing gradle enterprise DSL, only add one which is not already present
                if (containsGradleDevelocityDsl(cu)) {
                    return cu;
                }

                boolean gradleSixOrLater = versionComparator.compare(null, buildTool.getVersion(), ""6.0"") >= 0;
                if (gradleSixOrLater && cu.getSourcePath().endsWith(""settings.gradle"")) {
                    // Newer than 6.0 goes in settings
                    Optional<GradleSettings> maybeGradleSettings = cu.getMarkers().findFirst(GradleSettings.class);
                    if (!maybeGradleSettings.isPresent()) {
                        return cu;
                    }
                    GradleSettings gradleSettings = maybeGradleSettings.get();

                    try {
                        String newVersion = findNewerVersion(new DependencyVersionSelector(metadataFailures, null, gradleSettings), ctx);
                        if (newVersion == null) {
                            return cu;
                        }

                        String pluginId;
                        if (versionComparator.compare(null, newVersion, ""3.17"") >= 0) {
                            pluginId = ""com.gradle.develocity"";
                        } else {
                            pluginId = ""com.gradle.enterprise"";
                        }

                        cu = withPlugin(cu, pluginId, newVersion, versionComparator, ctx);
                    } catch (MavenDownloadingException e) {
                        return e.warn(cu);
                    }
                } else if (!gradleSixOrLater && ""build.gradle"".equals(cu.getSourcePath().toString())) {
                    // Older than 6.0 goes in root build.gradle only, not in build.gradle of subprojects
                    Optional<GradleProject> maybeGradleProject = cu.getMarkers().findFirst(GradleProject.class);
                    if (!maybeGradleProject.isPresent()) {
                        return cu;
                    }
                    GradleProject gradleProject = maybeGradleProject.get();

                    try {
                        String newVersion = findNewerVersion(new DependencyVersionSelector(metadataFailures, gradleProject, null), ctx);
                        if (newVersion == null) {
                            return cu;
                        }

                        cu = withPlugin(cu, ""com.gradle.build-scan"", newVersion, versionComparator, ctx);
                    } catch (MavenDownloadingException e) {
                        return e.warn(cu);
                    }
                }

                return cu;
            }

            private @Nullable String findNewerVersion(DependencyVersionSelector versionSelector, ExecutionContext ctx) throws MavenDownloadingException {
                String newVersion = versionSelector
                        .select(new GroupArtifact(""com.gradle.develocity"", ""com.gradle.develocity.gradle.plugin""), ""classpath"", version, null, ctx);
                if (newVersion == null) {
                    newVersion = versionSelector
                            .select(new GroupArtifact(""com.gradle.enterprise"", ""com.gradle.enterprise.gradle.plugin""), ""classpath"", version, null, ctx);
                }
                return newVersion;
            }
        });
    }

    private G.CompilationUnit withPlugin(G.CompilationUnit cu, String pluginId, String newVersion, VersionComparator versionComparator, ExecutionContext ctx) {
        cu = (G.CompilationUnit) new AddPluginVisitor(pluginId, newVersion, null, null, false)
                .visitNonNull(cu, ctx);
        cu = (G.CompilationUnit) new UpgradePluginVersion(pluginId, newVersion, null).getVisitor()
                .visitNonNull(cu, ctx);
        J.MethodInvocation gradleEnterpriseInvocation = gradleEnterpriseDsl(
                newVersion,
                versionComparator,
                getIndent(cu),
                ctx);
        return cu.withStatements(ListUtils.concat(cu.getStatements(), gradleEnterpriseInvocation));
    }

    private static boolean containsGradleDevelocityDsl(JavaSourceFile cu) {
        AtomicBoolean found = new AtomicBoolean(false);
        new GroovyIsoVisitor<AtomicBoolean>() {
            @Override
            public @Nullable J visit(@Nullable Tree tree, AtomicBoolean atomicBoolean) {
                if (atomicBoolean.get()) {
                    return (J) tree;
                }
                return super.visit(tree, atomicBoolean);
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, AtomicBoolean atomicBoolean) {
                if (""gradleEnterprise"".equals(method.getSimpleName()) || ""develocity"".equals(method.getSimpleName())) {
                    atomicBoolean.set(true);
                }
                return super.visitMethodInvocation(method, atomicBoolean);
            }
        }.visit(cu, found);

        return found.get();
    }

    private J.@Nullable MethodInvocation gradleEnterpriseDsl(String newVersion, VersionComparator versionComparator, String indent, ExecutionContext ctx) {
        if (server == null && allowUntrustedServer == null && captureTaskInputFiles == null && uploadInBackground == null && publishCriteria == null) {
            return null;
        }
        boolean versionIsAtLeast3_2 = versionComparator.compare(null, newVersion, ""3.2"") >= 0;
        boolean versionIsAtLeast3_7 = versionComparator.compare(null, newVersion, ""3.7"") >= 0;
        boolean versionIsAtLeast3_17 = versionComparator.compare(null, newVersion, ""3.17"") >= 0;
        StringBuilder ge;
        if (versionIsAtLeast3_17) {
            ge = new StringBuilder(""\ndevelocity {\n"");
        } else {
            ge = new StringBuilder(""\ngradleEnterprise {\n"");
        }
        if (server != null && !server.isEmpty()) {
            ge.append(indent).append(""server = '"").append(server).append(""'\n"");
        }
        if (allowUntrustedServer != null && versionIsAtLeast3_2) {
            ge.append(indent).append(""allowUntrustedServer = "").append(allowUntrustedServer).append(""\n"");
        }
        if (captureTaskInputFiles != null || uploadInBackground != null || (allowUntrustedServer != null && !versionIsAtLeast3_2) || publishCriteria != null) {
            ge.append(indent).append(""buildScan {\n"");
            if (publishCriteria != null) {
                if (publishCriteria == PublishCriteria.Always) {
                    if (versionIsAtLeast3_17) {
                        ge.append(indent).append(indent).append(""publishing.onlyIf { true }\n"");
                    } else {
                        ge.append(indent).append(indent).append(""publishAlways()\n"");
                    }
                } else {
                    if (versionIsAtLeast3_17) {
                        ge.append(indent).append(indent).append(""publishing.onlyIf { !it.buildResult.failures.empty }\n"");
                    } else {
                        ge.append(indent).append(indent).append(""publishOnFailure()\n"");
                    }
                }
            }
            if (allowUntrustedServer != null && !versionIsAtLeast3_2) {
                ge.append(indent).append(indent).append(""allowUntrustedServer = "").append(allowUntrustedServer).append(""\n"");
            }
            if (uploadInBackground != null) {
                ge.append(indent).append(indent).append(""uploadInBackground = "").append(uploadInBackground).append(""\n"");
            }
            if (captureTaskInputFiles != null) {
                if (versionIsAtLeast3_7) {
                    ge.append(indent).append(indent).append(""capture {\n"");
                    if (versionIsAtLeast3_17) {
                        ge.append(indent).append(indent).append(indent).append(""fileFingerprints = "").append(captureTaskInputFiles).append(""\n"");
                    } else {
                        ge.append(indent).append(indent).append(indent).append(""taskInputFiles = "").append(captureTaskInputFiles).append(""\n"");
                    }
                    ge.append(indent).append(indent).append(""}\n"");
                } else {
                    ge.append(indent).append(indent).append(""captureTaskInputFiles = "").append(captureTaskInputFiles).append(""\n"");
                }
            }
            ge.append(indent).append(""}\n"");
        }
        ge.append(""}\n"");
        G.CompilationUnit cu = GradleParser.builder().build()
                .parseInputs(singletonList(
                        Parser.Input.fromString(Paths.get(""settings.gradle""), ge.toString())), null, ctx)
                .map(G.CompilationUnit.class::cast)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException(""Could not parse as Gradle""));

        return (J.MethodInvocation) cu.getStatements().get(0);
    }

    private static String getIndent(G.CompilationUnit cu) {
        TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, cu, IntelliJ::tabsAndIndents);
        if (style.getUseTabCharacter()) {
            return ""\t"";
        } else {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < style.getIndentSize(); i++) {
                sb.append("" "");
            }
            return sb.toString();
        }
    }
}
",{}
Remove Gradle plugin,Remove plugin from Gradle `plugins` block by its id. Does not remove plugins from the `buildscript` block.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.gradle.IsBuildGradle;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveBuildPlugin extends Recipe {
    @Option(displayName = ""Plugin id"",
            description = ""The plugin id to remove."",
            example = ""com.jfrog.bintray""
    )
    String pluginId;

    @Override
    public String getDisplayName() {
        return ""Remove Gradle plugin"";
    }

    @Override
    public String getDescription() {
        return ""Remove plugin from Gradle `plugins` block by its id. Does not remove plugins from the `buildscript` block."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsBuildGradle<>(), new RemovePluginVisitor(pluginId));
    }
}
","{
  ""pluginId"": ""String field""
}"
Change a Gradle plugin,Changes the selected Gradle plugin to the new plugin.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.DependencyVersionSelector;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.internal.ChangeStringLiteral;
import org.openrewrite.gradle.marker.GradlePluginDescriptor;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.marker.GradleSettings;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.maven.MavenDownloadingException;
import org.openrewrite.maven.table.MavenMetadataFailures;
import org.openrewrite.maven.tree.GroupArtifact;
import org.openrewrite.semver.Semver;

import java.util.List;
import java.util.Optional;

import static java.util.Collections.singletonList;

/**
 * When changing a plugin id that uses the `apply` syntax or versionless plugins syntax, the version is will not be changed.
 * At the time of this writing, we do not have a relationship between the plugin id and the jar that contains it that is
 * required in order to update the version for the apply syntax. For the versionless plugins syntax, the version for a
 * third party plugin must be defined in another file that is presently outside the scope of change for this recipe.
 * If you are using either of these plugin styles, you should ensure that the plugin's version is appropriately updated.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePlugin extends Recipe {

    @EqualsAndHashCode.Exclude
    transient MavenMetadataFailures metadataFailures = new MavenMetadataFailures(this);

    @Option(displayName = ""Plugin ID"",
            description = ""The current Gradle plugin id."",
            example = ""org.openrewrite.rewrite"")
    String pluginId;

    @Option(displayName = ""New plugin ID"",
            description = ""The new Gradle plugin id."",
            example = ""org.openrewrite.rewrite"")
    String newPluginId;

    @Option(displayName = ""New plugin version"",
            description = ""An exact version number or node-style semver selector used to select the version number. "" +
                          ""You can also use `latest.release` for the latest available version and `latest.patch` if "" +
                          ""the current version is a valid semantic version. For more details, you can look at the documentation "" +
                          ""page of [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors)."",
            example = ""7.x"",
            required = false)
    @Nullable
    String newVersion;

    @Override
    public String getDisplayName() {
        return ""Change a Gradle plugin"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", pluginId, newPluginId);
    }

    @Override
    public String getDescription() {
        return ""Changes the selected Gradle plugin to the new plugin."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (newVersion != null) {
            validated = validated.and(Semver.validate(newVersion, null));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher pluginMatcher = new MethodMatcher(""PluginSpec id(..)"");
        MethodMatcher versionMatcher = new MethodMatcher(""Plugin version(..)"");
        MethodMatcher applyMatcher = new MethodMatcher(""RewriteGradleProject apply(..)"");
        return Preconditions.check(
                Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()),
                new GroovyIsoVisitor<ExecutionContext>() {
                    @Nullable
                    GradleProject gradleProject;
                    @Nullable
                    GradleSettings gradleSettings;

                    @Override
                    public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                        Optional<GradleProject> maybeGp = cu.getMarkers().findFirst(GradleProject.class);
                        Optional<GradleSettings> maybeGs = cu.getMarkers().findFirst(GradleSettings.class);
                        if (!maybeGp.isPresent() && !maybeGs.isPresent()) {
                            return cu;
                        }

                        gradleProject = maybeGp.orElse(null);
                        gradleSettings = maybeGs.orElse(null);

                        G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);
                        if (g != cu) {
                            if (gradleProject != null) {
                                GradleProject updatedGp = gradleProject.withPlugins(ListUtils.map(gradleProject.getPlugins(), plugin -> {
                                    if (pluginId.equals(plugin.getId())) {
                                        return new GradlePluginDescriptor(""unknown"", newPluginId);
                                    }
                                    return plugin;
                                }));
                                g = g.withMarkers(g.getMarkers().setByType(updatedGp));
                            } else if (gradleSettings != null) {
                                GradleSettings updatedGs = gradleSettings.withPlugins(ListUtils.map(gradleSettings.getPlugins(), plugin -> {
                                    if (pluginId.equals(plugin.getId())) {
                                        return new GradlePluginDescriptor(""unknown"", newPluginId);
                                    }
                                    return plugin;
                                }));
                                g = g.withMarkers(g.getMarkers().setByType(updatedGs));
                            }
                        }
                        return g;
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                        J.MethodInvocation m = method;
                        if (versionMatcher.matches(m) &&
                            m.getSelect() instanceof J.MethodInvocation &&
                            pluginMatcher.matches(m.getSelect())) {
                            m = maybeUpdateVersion(m, ctx);
                        } else if (pluginMatcher.matches(m)) {
                            m = maybeUpdatePluginSyntax(m);
                        } else if (applyMatcher.matches(m)) {
                            m = maybeUpdateApplySyntax(m);
                        }
                        return super.visitMethodInvocation(m, ctx);
                    }

                    private J.MethodInvocation maybeUpdateVersion(J.MethodInvocation m, ExecutionContext ctx) {
                        J.MethodInvocation select = (J.MethodInvocation) m.getSelect();
                        if (select == null || !pluginId.equals(((J.Literal) select.getArguments().get(0)).getValue())) {
                            return m;
                        }

                        List<Expression> args = m.getArguments();
                        if (!(args.get(0) instanceof J.Literal)) {
                            return m;
                        }

                        J.Literal versionLiteral = (J.Literal) args.get(0);
                        if (versionLiteral.getType() != JavaType.Primitive.String) {
                            return m;
                        }

                        if (!StringUtils.isBlank(newVersion)) {
                            try {
                                String resolvedVersion = new DependencyVersionSelector(metadataFailures, gradleProject, gradleSettings)
                                        .select(new GroupArtifact(newPluginId, newPluginId + "".gradle.plugin""), ""classpath"", newVersion, null, ctx);
                                if (resolvedVersion == null) {
                                    return m;
                                }

                                m = m.withSelect(select.withArguments(ListUtils.mapFirst(select.getArguments(), arg -> ChangeStringLiteral.withStringValue((J.Literal) arg, newPluginId))))
                                        .withArguments(singletonList(ChangeStringLiteral.withStringValue(versionLiteral, resolvedVersion)));
                            } catch (MavenDownloadingException e) {
                                return e.warn(m);
                            }
                        }

                        return m;
                    }

                    private J.MethodInvocation maybeUpdatePluginSyntax(J.MethodInvocation m) {
                        List<Expression> args = m.getArguments();
                        if (!(args.get(0) instanceof J.Literal)) {
                            return m;
                        }

                        J.Literal pluginIdLiteral = (J.Literal) args.get(0);
                        if (pluginIdLiteral.getType() != JavaType.Primitive.String) {
                            return m;
                        }

                        String pluginIdValue = (String) pluginIdLiteral.getValue();
                        if (!pluginId.equals(pluginIdValue)) {
                            return m;
                        }

                        return m.withArguments(ListUtils.concat(ChangeStringLiteral.withStringValue(pluginIdLiteral, newPluginId), args.subList(1, args.size())));
                    }

                    private J.MethodInvocation maybeUpdateApplySyntax(J.MethodInvocation m) {
                        List<Expression> args = m.getArguments();
                        if (!(args.get(0) instanceof G.MapEntry)) {
                            return m;
                        }

                        G.MapEntry entry = (G.MapEntry) args.get(0);
                        if (!(entry.getKey() instanceof J.Literal) || !(entry.getValue() instanceof J.Literal)) {
                            return m;
                        }

                        J.Literal keyLiteral = (J.Literal) entry.getKey();
                        if (keyLiteral.getType() != JavaType.Primitive.String) {
                            return m;
                        }

                        String keyValue = (String) keyLiteral.getValue();
                        if (!""plugin"".equals(keyValue)) {
                            return m;
                        }

                        J.Literal valueLiteral = (J.Literal) entry.getValue();
                        if (valueLiteral.getType() != JavaType.Primitive.String) {
                            return m;
                        }

                        String valueValue = (String) valueLiteral.getValue();
                        if (!pluginId.equals(valueValue)) {
                            return m;
                        }

                        entry = entry.withValue(ChangeStringLiteral.withStringValue(valueLiteral, newPluginId));
                        return m.withArguments(ListUtils.concat(entry, args.subList(1, args.size())));
                    }
                }
        );
    }
}
","{
  ""pluginId"": ""String field"",
  ""newPluginId"": ""String field""
}"
Add a Gradle settings repository,Add a Gradle settings repository to `settings.gradle(.kts)`.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.plugins;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.GradleParser;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.search.FindRepository;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.Statement;

import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddSettingsPluginRepository extends Recipe {

    @Option(displayName = ""Type"",
            description = ""The type of the artifact repository"",
            example = ""maven"")
    String type;

    @Option(displayName = ""URL"",
            description = ""The url of the artifact repository"",
            required = false,
            example = ""https://repo.spring.io"")
    @Nullable
    String url;

    @Override
    public String getDisplayName() {
        return ""Add a Gradle settings repository"";
    }

    @Override
    public String getDescription() {
        return ""Add a Gradle settings repository to `settings.gradle(.kts)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsSettingsGradle<>(), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public G.CompilationUnit visitCompilationUnit(G.CompilationUnit cu, ExecutionContext ctx) {
                if (cu == new FindRepository(type, url, FindRepository.Purpose.Plugin).getVisitor().visit(cu, ctx)) {
                    G.CompilationUnit g = super.visitCompilationUnit(cu, ctx);

                    J.MethodInvocation pluginManagement = generatePluginManagementBlock(ctx);

                    List<Statement> statements = new ArrayList<>(g.getStatements());
                    if (statements.isEmpty()) {
                        statements.add(pluginManagement);
                    } else {
                        Statement statement = statements.get(0);
                        if (statement instanceof J.MethodInvocation &&
                            ""pluginManagement"".equals(((J.MethodInvocation) statement).getSimpleName())) {
                            J.MethodInvocation m = (J.MethodInvocation) statement;
                            m = m.withArguments(ListUtils.mapFirst(m.getArguments(), arg -> {
                                if (arg instanceof J.Lambda && ((J.Lambda) arg).getBody() instanceof J.Block) {
                                    J.Lambda lambda = (J.Lambda) arg;
                                    J.Block block = (J.Block) lambda.getBody();
                                    return lambda.withBody(block.withStatements(ListUtils.map(block.getStatements(), statement2 -> {
                                        if ((statement2 instanceof J.MethodInvocation && ""repositories"".equals(((J.MethodInvocation) statement2).getSimpleName())) ||
                                            (statement2 instanceof J.Return && ((J.Return) statement2).getExpression() instanceof J.MethodInvocation && ""repositories"".equals(((J.MethodInvocation) ((J.Return) statement2).getExpression()).getSimpleName()))) {
                                            J.MethodInvocation m2 = (J.MethodInvocation) (statement2 instanceof J.Return ? ((J.Return) statement2).getExpression() : statement2);
                                            return m2.withArguments(ListUtils.mapFirst(m2.getArguments(), arg2 -> {
                                                if (arg2 instanceof J.Lambda && ((J.Lambda) arg2).getBody() instanceof J.Block) {
                                                    J.Lambda lambda2 = (J.Lambda) arg2;
                                                    J.Block block2 = (J.Block) lambda2.getBody();
                                                    return lambda2.withBody(block2.withStatements(ListUtils.concat(block2.getStatements(), extractRepository(pluginManagement))));
                                                }
                                                return arg2;
                                            }));
                                        }
                                        return statement2;
                                    })));
                                }
                                return arg;
                            }));
                            statements.set(0, m);
                        } else {
                            statements.add(0, pluginManagement);
                            statements.set(1, statements.get(1).withPrefix(Space.format(""\n\n"")));
                        }
                    }

                    return autoFormat(g.withStatements(statements), ctx);
                }

                return cu;
            }

            private J.MethodInvocation generatePluginManagementBlock(ExecutionContext ctx) {
                String code;
                if (url == null) {
                    code = ""pluginManagement {"" +
                           ""    repositories {"" +
                           ""        "" + type + ""()"" +
                           ""    }"" +
                           ""}"";
                } else {
                    code = ""pluginManagement {"" +
                           ""    repositories {"" +
                           ""        "" + type + "" {"" +
                           ""            url = \"""" + url + ""\"""" +
                           ""        }"" +
                           ""    }"" +
                           ""}"";
                }

                return (J.MethodInvocation) GradleParser.builder().build().parseInputs(singletonList(Parser.Input.fromString(Paths.get(""settings.gradle""), code)), null, ctx)
                        .map(G.CompilationUnit.class::cast)
                        .collect(toList()).get(0).getStatements().get(0);
            }

            private J.MethodInvocation extractRepository(J.MethodInvocation pluginManagement) {
                J.MethodInvocation repositories = (J.MethodInvocation) ((J.Return) ((J.Block) ((J.Lambda) pluginManagement
                        .getArguments().get(0)).getBody()).getStatements().get(0)).getExpression();
                return (J.MethodInvocation) requireNonNull(((J.Return) ((J.Block) ((J.Lambda) requireNonNull(repositories)
                        .getArguments().get(0)).getBody()).getStatements().get(0)).getExpression());
            }
        });
    }
}
","{
  ""type"": ""String field""
}"
Module has dependency,Searches for Gradle Projects (modules) that have a dependency matching the specified id or implementing class. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class ModuleHasDependency extends ScanningRecipe<ModuleHasDependency.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Module has dependency"";
    }

    @Override
    public String getDescription() {
        return ""Searches for Gradle Projects (modules) that have a dependency matching the specified id or implementing class. "" +
               ""Places a `SearchResult` marker on all sources within a project with a matching dependency. "" +
               ""This recipe is intended to be used as a precondition for other recipes. "" +
               ""For example this could be used to limit the application of a spring boot migration to only projects "" +
               ""that use spring-boot-starter, limiting unnecessary upgrading. "" +
               ""If the search result you want is instead just the build.gradle(.kts) file that use the dependency, use the `FindDependency` recipe instead."";
    }

    @Option(displayName = ""Group pattern"",
            description = ""Group glob pattern used to match dependencies."",
            example = ""com.fasterxml.jackson.module"")
    String groupIdPattern;

    @Option(displayName = ""Artifact pattern"",
            description = ""Artifact glob pattern used to match dependencies."",
            example = ""jackson-module-*"")
    String artifactIdPattern;

    @Option(displayName = ""Version"",
            description = ""Match only dependencies with the specified version. "" +
                          ""Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used."" +
                          ""All versions are searched by default."",
            example = ""1.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. If not specified, all configurations will be searched."",
            example = ""compileClasspath"",
            required = false)
    @Nullable
    String configuration;

    @Value
    public static class Accumulator {
        Set<JavaProject> projectsWithDependency;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator(new HashSet<>());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                tree.getMarkers()
                        .findFirst(JavaProject.class)
                        .ifPresent(jp -> {
                            Tree t = new DependencyInsight(groupIdPattern, artifactIdPattern, version, configuration).getVisitor().visit(tree, ctx);
                            if (t != tree) {
                                acc.getProjectsWithDependency().add(jp);
                            }
                        });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                Optional<JavaProject> maybeJp = tree.getMarkers().findFirst(JavaProject.class);
                if (!maybeJp.isPresent()) {
                    return tree;
                }
                JavaProject jp = maybeJp.get();
                if (acc.getProjectsWithDependency().contains(jp)) {
                    return SearchResult.found(tree, ""Module has dependency: "" + groupIdPattern + "":"" + artifactIdPattern + (StringUtils.isNullOrEmpty(version) ? """" : "":"" + version) + (StringUtils.isNullOrEmpty(configuration) ? """" : "" in configuration ""));
                }
                return tree;
            }
        };
    }
}
","{
  ""groupIdPattern"": ""String field"",
  ""artifactIdPattern"": ""String field""
}"
Find Gradle dependency,Finds dependencies declared in gradle build files. See the [reference](https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph) on Gradle configurations or the diagram below for a description of what configuration to use. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDependency extends Recipe {
    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate identifying its publisher."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate uniquely identifying it among artifacts from the same publisher."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Dependency configuration"",
            description = ""The dependency configuration to search for dependencies in. If omitted then all configurations will be searched."",
            example = ""api"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Find Gradle dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""Finds dependencies declared in gradle build files. See the [reference](https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph) on Gradle configurations or the diagram below for a description of what configuration to use. "" +
                ""A project's compile and runtime classpath is based on these configurations.\n\n<img alt=\""Gradle compile classpath\"" src=\""https://docs.gradle.org/current/userguide/img/java-library-ignore-deprecated-main.png\"" width=\""200px\""/>\n"" +
                ""A project's test classpath is based on these configurations.\n\n<img alt=\""Gradle test classpath\"" src=\""https://docs.gradle.org/current/userguide/img/java-library-ignore-deprecated-test.png\"" width=\""200px\""/>."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new GradleDependency.Matcher()
                .groupId(groupId)
                .artifactId(artifactId)
                .configuration(configuration)
                .asVisitor(gd -> SearchResult.found(gd.getTree()));
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Find Gradle projects,Gradle projects are those with `build.gradle` or `build.gradle.kts` files.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.marker.SearchResult;

import java.nio.file.Paths;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindGradleProject extends Recipe {

    @Option(displayName = ""Search criteria"",
            description = ""Whether to identify gradle projects by source file name or the presence of a marker"",
            valid = {""File"", ""Marker""},
            example = ""Marker"")
    @Nullable
    SearchCriteria searchCriteria;

    @Override
    public String getDisplayName() {
        return ""Find Gradle projects"";
    }

    @Override
    public String getDescription() {
        return ""Gradle projects are those with `build.gradle` or `build.gradle.kts` files."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        if (searchCriteria == SearchCriteria.Marker) {
            return new TreeVisitor<Tree, ExecutionContext>() {
                @Override
                public Tree preVisit(Tree tree, ExecutionContext ctx) {
                    stopAfterPreVisit();
                    if (tree instanceof SourceFile) {
                        SourceFile file = (SourceFile) requireNonNull(tree);
                        if (file.getMarkers().findFirst(GradleProject.class).isPresent()) {
                            return SearchResult.found(file);
                        }
                    }
                    return tree;
                }
            };
        }

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    stopAfterPreVisit();
                    SourceFile sourceFile = (SourceFile) tree;
                    if (sourceFile.getSourcePath().endsWith(Paths.get(""build.gradle"")) ||
                        sourceFile.getSourcePath().endsWith(Paths.get(""build.gradle.kts""))) {
                        return SearchResult.found(sourceFile);
                    }
                }
                return tree;
            }
        };
    }

    public enum SearchCriteria {
        File,
        Marker
    }
}
",{}
Module has plugin,Searches for Gradle Projects (modules) that have a plugin matching the specified id or implementing class. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class ModuleHasPlugin extends ScanningRecipe<ModuleHasPlugin.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Module has plugin"";
    }

    @Override
    public String getDescription() {
        return ""Searches for Gradle Projects (modules) that have a plugin matching the specified id or implementing class. "" +
               ""Places a `SearchResult` marker on all sources within a project with a matching plugin. "" +
               ""This recipe is intended to be used as a precondition for other recipes. "" +
               ""For example this could be used to limit the application of a spring boot migration to only projects "" +
               ""that apply the spring dependency management plugin, limiting unnecessary upgrading. "" +
               ""If the search result you want is instead just the build.gradle(.kts) file applying the plugin, use the `FindPlugins` recipe instead."";
    }

    @Option(displayName = ""Plugin id"",
            description = ""The unique identifier used to apply a plugin in the `plugins` block. "" +
                          ""Note that this alone is insufficient to search for plugins applied by fully qualified class name and the `buildscript` block."",
            example = ""`com.jfrog.bintray`"")
    String pluginId;

    @Option(displayName = ""Plugin class"",
            description = ""The fully qualified name of a class implementing a Gradle plugin. "",
            required = false,
            example = ""com.jfrog.bintray.gradle.BintrayPlugin"")
    @Nullable
    String pluginClass;

    @Value
    public static class Accumulator {
        Set<JavaProject> projectsWithDependency;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator(new HashSet<>());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                tree.getMarkers()
                        .findFirst(JavaProject.class)
                        .ifPresent(jp -> {
                            Tree t = new FindPlugins(pluginId, pluginClass).getVisitor().visit(tree, ctx);
                            if (t != tree) {
                                acc.getProjectsWithDependency().add(jp);
                            }
                        });
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                Optional<JavaProject> maybeJp = tree.getMarkers().findFirst(JavaProject.class);
                if (!maybeJp.isPresent()) {
                    return tree;
                }
                JavaProject jp = maybeJp.get();
                if (acc.getProjectsWithDependency().contains(jp)) {
                    return SearchResult.found(tree, ""Module has plugin: "" + pluginId);
                }
                return tree;
            }
        };
    }
}
","{
  ""pluginId"": ""String field""
}"
Gradle dependency insight,"Find direct and transitive dependencies matching a group, artifact, resolved version, and optionally a configuration name. ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.marker.GradleDependencyConfiguration;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.trait.GradleDependency;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.Markup;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.maven.table.DependenciesInUse;
import org.openrewrite.maven.tree.Dependency;
import org.openrewrite.maven.tree.GroupArtifactVersion;
import org.openrewrite.maven.tree.ResolvedDependency;
import org.openrewrite.maven.tree.ResolvedGroupArtifactVersion;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.*;
import java.util.function.Function;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

@Value
@EqualsAndHashCode(callSuper = false)
public class DependencyInsight extends Recipe {
    transient DependenciesInUse dependenciesInUse = new DependenciesInUse(this);

    private static final MethodMatcher DEPENDENCY_CONFIGURATION_MATCHER = new MethodMatcher(""DependencyHandlerSpec *(..)"");
    private static final MethodMatcher DEPENDENCY_CLOSURE_MATCHER = new MethodMatcher(""RewriteGradleProject dependencies(..)"");
    private static final Function<Object, Set<GroupArtifactVersion>> EMPTY = gav -> new HashSet<>();

    @Option(displayName = ""Group pattern"",
            description = ""Group glob pattern used to match dependencies."",
            example = ""com.fasterxml.jackson.module"")
    String groupIdPattern;

    @Option(displayName = ""Artifact pattern"",
            description = ""Artifact glob pattern used to match dependencies."",
            example = ""jackson-module-*"")
    String artifactIdPattern;

    @Option(displayName = ""Version"",
            description = ""Match only dependencies with the specified resolved version. "" +
                    ""Node-style [version selectors](https://docs.openrewrite.org/reference/dependency-version-selectors) may be used."" +
                    ""All versions are searched by default."",
            example = ""1.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. If not specified, all configurations will be searched."",
            example = ""compileClasspath"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Gradle dependency insight"";
    }

    @Override
    public String getDescription() {
        return ""Find direct and transitive dependencies matching a group, artifact, resolved version, and optionally a configuration name. "" +
                ""Results include dependencies that either directly match or transitively include a matching dependency."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> v = super.validate();
        if (version != null) {
            v = v.and(Semver.validate(version, null));
        }
        return v;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile.getMarkers().findFirst(GradleProject.class).isPresent();
            }

            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                Optional<GradleProject> maybeGradleProject = sourceFile.getMarkers().findFirst(GradleProject.class);
                if (!maybeGradleProject.isPresent()) {
                    return sourceFile;
                }
                GradleProject gp = maybeGradleProject.get();
                String projectName = sourceFile.getMarkers()
                        .findFirst(JavaProject.class)
                        .map(JavaProject::getProjectName)
                        .orElse("""");
                String sourceSetName = sourceFile.getMarkers()
                        .findFirst(JavaSourceSet.class)
                        .map(JavaSourceSet::getName)
                        .orElse(""main"");
                // configuration -> dependency which is or transitively depends on search target -> search target
                Map<String, Set<GroupArtifactVersion>> configurationToDirectDependency = new HashMap<>();
                Map<GroupArtifactVersion, Set<GroupArtifactVersion>> directDependencyToTargetDependency = new HashMap<>();
                for (GradleDependencyConfiguration c : gp.getConfigurations()) {
                    if (!(configuration == null || configuration.isEmpty() || c.getName().equals(configuration))) {
                        continue;
                    }
                    for (ResolvedDependency resolvedDependency : c.getDirectResolved()) {
                        if (!resolvedDependency.isDirect()) { // for some reason the direct resolved ones are also containing depth ones.
                            continue;
                        }
                        List<ResolvedDependency> nestedMatchingDependencies = resolvedDependency.findDependencies(groupIdPattern, artifactIdPattern);
                        for (ResolvedDependency dep : nestedMatchingDependencies) {
                            if (version != null) {
                                VersionComparator versionComparator = Semver.validate(version, null).getValue();
                                if (versionComparator == null) {
                                    sourceFile = Markup.warn(sourceFile, new IllegalArgumentException(""Could not construct a valid version comparator from "" + version + "".""));
                                } else {
                                    if (!versionComparator.isValid(null, dep.getVersion())) {
                                        continue;
                                    }
                                }
                            }
                            GroupArtifactVersion requestedGav = new GroupArtifactVersion(resolvedDependency.getGroupId(), resolvedDependency.getArtifactId(), resolvedDependency.getVersion());
                            GroupArtifactVersion targetGav = new GroupArtifactVersion(dep.getGroupId(), dep.getArtifactId(), dep.getVersion());
                            configurationToDirectDependency.computeIfAbsent(c.getName(), EMPTY).add(requestedGav);
                            directDependencyToTargetDependency.computeIfAbsent(requestedGav, EMPTY).add(targetGav);
                            dependenciesInUse.insertRow(ctx, new DependenciesInUse.Row(
                                    projectName,
                                    sourceSetName,
                                    dep.getGroupId(),
                                    dep.getArtifactId(),
                                    dep.getVersion(),
                                    dep.getDatedSnapshotVersion(),
                                    dep.getRequested().getScope(),
                                    dep.getDepth()
                            ));
                        }
                    }
                }
                if (directDependencyToTargetDependency.isEmpty()) {
                    return sourceFile;
                }
                // Non-resolvable configurations may contain the requested which has been found to transitively depend on the target
                for (GradleDependencyConfiguration c : gp.getConfigurations()) {
                    if (configurationToDirectDependency.containsKey(c.getName())) {
                        continue;
                    }
                    for (Dependency dependency : c.getRequested()) {
                        GroupArtifactVersion gav = dependency.getGav();
                        Optional<GroupArtifactVersion> matchingGroupArtifact = directDependencyToTargetDependency.keySet().stream().filter(key -> key.equals(gav)).findFirst();
                        if (!matchingGroupArtifact.isPresent()) {
                            matchingGroupArtifact = directDependencyToTargetDependency.keySet().stream().filter(key -> key.asGroupArtifact().equals(gav.asGroupArtifact())).findFirst();
                        }

                        matchingGroupArtifact.ifPresent(version ->
                                configurationToDirectDependency.computeIfAbsent(c.getName(), EMPTY).add(version));
                    }
                }
                return new MarkIndividualDependency(configurationToDirectDependency, directDependencyToTargetDependency).attachMarkers(sourceFile, ctx);
            }
        };
    }

    @EqualsAndHashCode(callSuper = false)
    @RequiredArgsConstructor
    @Data
    private static class MarkIndividualDependency extends JavaIsoVisitor<ExecutionContext> {
        private final Map<String, Set<GroupArtifactVersion>> configurationToDirectDependency;
        private final Map<GroupArtifactVersion, Set<GroupArtifactVersion>> directDependencyToTargetDependency;
        private final Set<GroupArtifactVersion> individuallyMarkedDependencies = new HashSet<>();

        public Tree attachMarkers(Tree before, ExecutionContext ctx) {
            Tree after = super.visitNonNull(before, ctx);
            if (after == before) {
                String resultText = directDependencyToTargetDependency.entrySet().stream()
                        .filter(target -> !individuallyMarkedDependencies.contains(target.getKey()))
                        .map(Map.Entry::getValue)
                        .flatMap(Set::stream)
                        .distinct()
                        .map(target -> target.getGroupId() + "":"" + target.getArtifactId() + "":"" + target.getVersion())
                        .collect(joining("",""));
                if (!resultText.isEmpty()) {
                    return SearchResult.found(after, resultText);
                }
            }
            return after;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (DEPENDENCY_CLOSURE_MATCHER.matches(m)) {
                String resultText = directDependencyToTargetDependency.entrySet().stream()
                        .filter(target -> !individuallyMarkedDependencies.contains(target.getKey()))
                        .map(Map.Entry::getValue)
                        .flatMap(Set::stream)
                        .distinct()
                        .map(target -> target.getGroupId() + "":"" + target.getArtifactId() + "":"" + target.getVersion())
                        .collect(joining("",""));
                if (!resultText.isEmpty()) {
                    directDependencyToTargetDependency.clear();
                    return SearchResult.found(m, resultText);
                }
            }

            if (configurationToDirectDependency.containsKey(m.getSimpleName())) {
                return new GradleDependency.Matcher().get(getCursor()).map(dependency -> {
                    ResolvedGroupArtifactVersion gav = dependency.getResolvedDependency().getGav();
                    Optional<GroupArtifactVersion> configurationGav = configurationToDirectDependency.get(m.getSimpleName()).stream()
                            .filter(dep -> dep.asGroupArtifact().equals(gav.asGroupArtifact()))
                            .findAny();
                    if (configurationGav.isPresent()) {
                        configurationToDirectDependency.get(m.getSimpleName());
                        Set<GroupArtifactVersion> mark = directDependencyToTargetDependency.get(configurationGav.get());
                        if (mark == null) {
                            return null;
                        }
                        individuallyMarkedDependencies.add(configurationGav.get());
                        String resultText = mark.stream()
                                .map(target -> target.getGroupId() + "":"" + target.getArtifactId() + "":"" + target.getVersion())
                                .collect(joining("",""));
                        if (!resultText.isEmpty()) {
                            return SearchResult.found(m, resultText);
                        }
                    }
                    return null;
                }).orElse(m);
            }
            return m;
        }
    }
}
","{
  ""groupIdPattern"": ""String field"",
  ""artifactIdPattern"": ""String field""
}"
Does not include Gradle dependency,A precondition which returns false if visiting a Gradle file which includes the specified dependency in the classpath of some scope. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;

import static org.openrewrite.Validated.notBlank;

@Value
@EqualsAndHashCode(callSuper = false)
public class DoesNotIncludeDependency extends Recipe {

    @Option(displayName = ""Group"",
            description = ""The first part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""com.google.guava"")
    String groupId;

    @Option(displayName = ""Artifact"",
            description = ""The second part of a dependency coordinate `com.google.guava:guava:VERSION`. Supports glob."",
            example = ""guava"")
    String artifactId;

    @Option(displayName = ""Scope"",
            description = ""Match dependencies with the specified scope. If not specified, all configurations will be searched."",
            example = ""compileClasspath"",
            required = false)
    @Nullable
    String configuration;

    @Override
    public String getDisplayName() {
        return ""Does not include Gradle dependency"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s:%s`"", groupId, artifactId);
    }

    @Override
    public String getDescription() {
        return ""A precondition which returns false if visiting a Gradle file which includes the specified dependency in the classpath of some scope. "" +
                ""For compatibility with multimodule projects, this should most often be applied as a precondition."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate()
                .and(notBlank(""groupId"", groupId))
                .and(notBlank(""artifactId"", artifactId));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            final TreeVisitor<?, ExecutionContext> di = new DependencyInsight(groupId, artifactId, null, configuration).getVisitor();

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return di.isAcceptable(sourceFile, ctx);
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                Tree t2 = di.visit(tree, ctx);
                // if Gradle file is unchanged, we found something without the dependency
                if (t2 == tree) {
                    return SearchResult.found(tree);
                }
                return tree;
            }
        };
    }
}
","{
  ""groupId"": ""String field"",
  ""artifactId"": ""String field""
}"
Find Gradle repository,Find a Gradle repository by url.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.groovy.GroovyIsoVisitor;
import org.openrewrite.groovy.GroovyPrinter;
import org.openrewrite.groovy.tree.G;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindRepository extends Recipe {
    @Option(displayName = ""Type"",
            description = ""The type of the artifact repository"",
            example = ""maven"",
            required = false)
    @Nullable
    String type;

    @Option(displayName = ""URL"",
            description = ""The url of the artifact repository"",
            example = ""https://repo.spring.io"",
            required = false)
    @Nullable
    String url;

    @Option(displayName = ""Purpose"",
            description = ""The purpose of this repository in terms of resolving project or plugin dependencies"",
            valid = {""Project"", ""Plugin""},
            required = false)
    @Nullable
    Purpose purpose;

    @Override
    public String getDisplayName() {
        return ""Find Gradle repository"";
    }

    @Override
    public String getDescription() {
        return ""Find a Gradle repository by url."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher pluginManagementMatcher = new MethodMatcher(""RewriteSettings pluginManagement(..)"");
        MethodMatcher buildscriptMatcher = new MethodMatcher(""RewriteGradleProject buildscript(..)"");
        return Preconditions.check(Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()), new GroovyIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (purpose == null) {
                    return new RepositoryVisitor().visitMethodInvocation(method, ctx);
                } else {
                    boolean isPluginBlock = pluginManagementMatcher.matches(method) || buildscriptMatcher.matches(method);
                    if ((purpose == Purpose.Project && !isPluginBlock) ||
                        (purpose == Purpose.Plugin && isPluginBlock)) {
                        return new RepositoryVisitor().visitMethodInvocation(method, ctx);
                    }
                }

                return method;
            }
        });
    }

    private class RepositoryVisitor extends GroovyIsoVisitor<ExecutionContext> {
        private final MethodMatcher repositoryMatcher = new MethodMatcher(""org.gradle.api.artifacts.dsl.RepositoryHandler *(..)"", true);

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

            if (!repositoryMatcher.matches(m)) {
                return m;
            }

            boolean match = type == null || m.getSimpleName().equals(type);

            if (url != null && !urlMatches(m, url)) {
                match = false;
            }

            if (!match) {
                return m;
            }

            return SearchResult.found(m);
        }

        private boolean urlMatches(J.MethodInvocation m, String url) {
            if (!(m.getArguments().get(0) instanceof J.Lambda)) {
                return false;
            }

            J.Lambda lambda = (J.Lambda) m.getArguments().get(0);
            if (!(lambda.getBody() instanceof J.Block)) {
                return false;
            }

            J.Block block = (J.Block) lambda.getBody();
            for (Statement statement : block.getStatements()) {
                if (statement instanceof J.Assignment || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.Assignment)) {
                    J.Assignment assignment = (J.Assignment) (statement instanceof J.Return ? ((J.Return) statement).getExpression() : statement);
                    if (assignment.getVariable() instanceof J.Identifier &&
                        ""url"".equals(((J.Identifier) assignment.getVariable()).getSimpleName())) {
                        if (assignment.getAssignment() instanceof J.Literal &&
                            url.equals(((J.Literal) assignment.getAssignment()).getValue())) {
                            return true;
                        } else if (assignment.getAssignment() instanceof J.MethodInvocation &&
                                   ""uri"".equals(((J.MethodInvocation) assignment.getAssignment()).getSimpleName()) &&
                                   ((J.MethodInvocation) assignment.getAssignment()).getArguments().get(0) instanceof J.Literal &&
                                   url.equals(((J.Literal) ((J.MethodInvocation) assignment.getAssignment()).getArguments().get(0)).getValue())) {
                            return true;
                        } else if (assignment.getAssignment() instanceof G.GString) {
                            String valueSource = assignment.getAssignment().withPrefix(Space.EMPTY).printTrimmed(new GroovyPrinter<>());
                            String testSource = ((G.GString) assignment.getAssignment()).getDelimiter() + url + ((G.GString) assignment.getAssignment()).getDelimiter();
                            return testSource.equals(valueSource);
                        }
                    }
                } else if (statement instanceof J.MethodInvocation || (statement instanceof J.Return && ((J.Return) statement).getExpression() instanceof J.MethodInvocation)) {
                    J.MethodInvocation m1 = (J.MethodInvocation) (statement instanceof J.Return ? ((J.Return) statement).getExpression() : statement);
                    if (""setUrl"".equals(m1.getSimpleName()) || ""url"".equals(m1.getSimpleName())) {
                        if (m1.getArguments().get(0) instanceof J.Literal &&
                            url.equals(((J.Literal) m1.getArguments().get(0)).getValue())) {
                            return true;
                        } else if (m1.getArguments().get(0) instanceof J.MethodInvocation &&
                                   ""uri"".equals(((J.MethodInvocation) m1.getArguments().get(0)).getSimpleName()) &&
                                   ((J.MethodInvocation) m1.getArguments().get(0)).getArguments().get(0) instanceof J.Literal &&
                                   url.equals(((J.Literal) ((J.MethodInvocation) m1.getArguments().get(0)).getArguments().get(0)).getValue())) {
                            return true;
                        } else if (m1.getArguments().get(0) instanceof G.GString) {
                            G.GString value = (G.GString) m1.getArguments().get(0);
                            String valueSource = value.withPrefix(Space.EMPTY).printTrimmed(new GroovyPrinter<>());
                            String testSource = value.getDelimiter() + url + value.getDelimiter();
                            return testSource.equals(valueSource);
                        }
                    }
                }
            }

            return false;
        }
    }

    public enum Purpose {
        Project, Plugin
    }
}
",{}
Find Gradle plugin,Find a Gradle plugin by id and/or class name. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.IsSettingsGradle;
import org.openrewrite.gradle.marker.GradleProject;
import org.openrewrite.gradle.tree.GradlePlugin;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.stream.Stream;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.internal.StringUtils.matchesGlob;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindPlugins extends Recipe {
    @Option(displayName = ""Plugin id"",
            description = ""The unique identifier used to apply a plugin in the `plugins` block. "" +
                          ""Note that this alone is insufficient to search for plugins applied by fully qualified class name and the `buildscript` block."",
            example = ""`com.jfrog.bintray`"")
    String pluginId;

    @Option(displayName = ""Plugin class"",
            description = ""The fully qualified name of a class implementing a Gradle plugin. "",
            required = false,
            example = ""com.jfrog.bintray.gradle.BintrayPlugin"")
    @Nullable
    String pluginClass;

    @Override
    public Validated<Object> validate(ExecutionContext ctx) {
        return Validated.none().and(new Validated.Either<>(
                Validated.notBlank(""pluginId"", pluginId),
                Validated.notBlank(""pluginClass"", pluginClass)));
    }

    @Override
    public String getDisplayName() {
        return ""Find Gradle plugin"";
    }

    @Override
    public String getDescription() {
        return ""Find a Gradle plugin by id and/or class name. "" +
               ""For best results both should be specified, as one cannot automatically be used to infer the other."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher pluginMatcher = new MethodMatcher(""PluginSpec id(..)"", false);

        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (!(tree instanceof SourceFile)) {
                    return tree;
                }
                SourceFile s = (SourceFile) tree;

                AtomicBoolean found = new AtomicBoolean(false);
                TreeVisitor<?, ExecutionContext> jv = Preconditions.check(
                        Preconditions.or(new IsBuildGradle<>(), new IsSettingsGradle<>()),
                        new JavaVisitor<ExecutionContext>() {

                            @Override
                            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                                if (pluginMatcher.matches(method)) {
                                    if (method.getArguments().get(0) instanceof J.Literal &&
                                        pluginId.equals(((J.Literal) method.getArguments().get(0)).getValue())) {
                                        found.set(true);
                                        return SearchResult.found(method);
                                    }
                                }
                                return super.visitMethodInvocation(method, ctx);
                            }
                        });
                if (jv.isAcceptable(s, ctx)) {
                    s = (SourceFile) jv.visitNonNull(s, ctx);
                }

                // Even if we couldn't find a declaration the metadata might show the plugin is in use
                GradleProject gp = s.getMarkers().findFirst(GradleProject.class).orElse(null);
                if (!found.get() && gp != null && gp.getPlugins().stream().anyMatch(plugin ->
                        matchesGlob(plugin.getId(), pluginId) || matchesGlob(plugin.getFullyQualifiedClassName(), pluginClass))) {
                    s = SearchResult.found(s);
                }

                return s;
            }
        };
    }

    /**
     * @param j               The subtree to search.
     * @param pluginIdPattern A method pattern. See {@link MethodMatcher} for details about this syntax.
     * @return A set of {@link J.MethodInvocation} and {@link J.MemberReference} representing plugin
     * definitions in the plugins block.
     */
    public static List<GradlePlugin> find(J j, String pluginIdPattern) {
        List<J.MethodInvocation> plugins = TreeVisitor.collect(
                new FindPlugins(pluginIdPattern, null).getVisitor(),
                j,
                new ArrayList<>(),
                J.MethodInvocation.class,
                Function.identity()
        );

        MethodMatcher idMatcher = new MethodMatcher(""PluginSpec id(..)"", false);
        MethodMatcher versionMatcher = new MethodMatcher(""Plugin version(..)"", false);
        List<GradlePlugin> pluginsWithVersion = plugins.stream()
                .flatMap(plugin -> {
                    if (versionMatcher.matches(plugin) && idMatcher.matches(plugin.getSelect()) && plugin.getArguments().get(0) instanceof J.Literal) {
                        return Stream.of(new GradlePlugin(
                                plugin,
                                requireNonNull(((J.Literal) requireNonNull(((J.MethodInvocation) plugin.getSelect()))
                                        .getArguments().get(0)).getValue()).toString(),
                                requireNonNull(((J.Literal) plugin.getArguments().get(0)).getValue()).toString()
                        ));
                    }
                    return Stream.empty();
                }).collect(toList());
        List<GradlePlugin> pluginsWithoutVersion = plugins.stream().flatMap(plugin -> {
            if (idMatcher.matches(plugin) && pluginsWithVersion.stream()
                    .noneMatch(it -> it.getPluginId().equals(plugin.getSimpleName()))) {
                return Stream.of(new GradlePlugin(
                        plugin,
                        requireNonNull(((J.Literal) requireNonNull(plugin)
                                .getArguments().get(0)).getValue()).toString(),
                        null
                ));
            }
            return Stream.empty();
        }).collect(toList());

        List<GradlePlugin> result = new ArrayList<>(pluginsWithVersion.size() + pluginsWithoutVersion.size());
        result.addAll(pluginsWithVersion);
        result.addAll(pluginsWithoutVersion);
        return result;
    }
}
","{
  ""pluginId"": ""String field""
}"
Find Gradle wrappers,Find Gradle wrappers.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.gradle.table.GradleWrappersInUse;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.openrewrite.PathUtils.equalIgnoringSeparators;
import static org.openrewrite.gradle.util.GradleWrapper.WRAPPER_PROPERTIES_LOCATION;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindGradleWrapper extends Recipe {
    transient GradleWrappersInUse wrappersInUse = new GradleWrappersInUse(this);

    private static final Pattern GRADLE_VERSION = Pattern.compile(""gradle-(.*?)-(all|bin).zip"");

    @Option(displayName = ""Version expression"",
            description = ""A version expression representing the versions to search for"",
            example = ""7.x"",
            required = false)
    @Nullable
    String version;

    @Option(displayName = ""Version pattern"",
            description = ""Allows version selection to be extended beyond the original Node Semver semantics. So for example,"" +
                    ""Setting 'version' to \""25-29\"" can be paired with a metadata pattern of \""-jre\"" to select Guava 29.0-jre"",
            example = ""-jre"",
            required = false)
    @Nullable
    String versionPattern;

    @Option(displayName = ""Distribution type"",
            description = ""The distribution of Gradle to find. \""bin\"" includes Gradle binaries. "" +
                    ""\""all\"" includes Gradle binaries, source code, and documentation."",
            valid = {""bin"", ""all""},
            required = false
    )
    @Nullable
    String distribution;

    @Override
    public String getDisplayName() {
        return ""Find Gradle wrappers"";
    }

    @Override
    public String getDescription() {
        return ""Find Gradle wrappers."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                return !equalIgnoringSeparators(file.getSourcePath(), WRAPPER_PROPERTIES_LOCATION) ? file :
                        super.visitFile(file, ctx);
            }

            @Override
            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                if (!""distributionUrl"".equals(entry.getKey())) {
                    return entry;
                }

                String currentDistributionUrl = entry.getValue().getText();
                Matcher matcher = GRADLE_VERSION.matcher(currentDistributionUrl);
                if (matcher.find()) {
                    String currentVersion = matcher.group(1);
                    boolean requireVersion = !StringUtils.isNullOrEmpty(version);
                    String currentDistribution = matcher.group(2);
                    boolean requireMeta = !StringUtils.isNullOrEmpty(distribution);

                    wrappersInUse.insertRow(ctx, new GradleWrappersInUse.Row(
                            currentVersion,
                            currentDistribution
                    ));

                    if (requireVersion) {
                        VersionComparator versionComparator = Semver.validate(version, versionPattern).getValue();
                        if (versionComparator == null || versionComparator.isValid(null, currentVersion)) {
                            if (requireMeta) {
                                if (currentDistribution.matches(distribution)) {
                                    return SearchResult.found(entry);
                                }
                            } else {
                                return SearchResult.found(entry);
                            }
                        }
                    } else if (requireMeta) {
                        if (currentDistribution.matches(distribution)) {
                            return SearchResult.found(entry);
                        }
                    } else {
                        return SearchResult.found(entry);
                    }
                }
                return entry;
            }
        };
    }
}
",{}
Find Gradle JVMTestSuite plugin configuration,Find Gradle JVMTestSuite plugin configurations and produce a data table.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.gradle.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.gradle.IsBuildGradle;
import org.openrewrite.gradle.table.JVMTestSuitesDefined;
import org.openrewrite.gradle.trait.JvmTestSuite;
import org.openrewrite.marker.SearchResult;

import java.util.Set;

import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.toSet;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindJVMTestSuites extends Recipe {

    transient JVMTestSuitesDefined jvmTestSuitesDefined = new JVMTestSuitesDefined(this);

    @Option(displayName = ""Insert rows"",
            description = ""Whether to insert rows into the table. Defaults to true."")
    @Nullable
    Boolean insertRows;

    @Override
    public String getDisplayName() {
        return ""Find Gradle JVMTestSuite plugin configuration"";
    }

    @Override
    public String getDescription() {
        return ""Find Gradle JVMTestSuite plugin configurations and produce a data table."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        boolean tableAvailable = this.insertRows == null || this.insertRows;
        return Preconditions.check(new IsBuildGradle<>(), new JvmTestSuite.Matcher().asVisitor((suite, ctx) -> {
            if (tableAvailable) {
                jvmTestSuitesDefined.insertRow(ctx, new JVMTestSuitesDefined.Row(suite.getName()));
            }
            return SearchResult.found(suite.getTree());
        }));
    }

    public static Set<JvmTestSuite> jvmTestSuites(SourceFile sourceFile) {
        if (!IsBuildGradle.matches(sourceFile.getSourcePath())) {
            return emptySet();
        }

        return new JvmTestSuite.Matcher().lower(sourceFile)
                .collect(toSet());
    }
}
",{}
Rename type alias,Change the name of a given type alias.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.kotlin.tree.K;

@Value
@EqualsAndHashCode(callSuper = false)
public class RenameTypeAlias extends Recipe {

    @Option(displayName = ""Old alias name"",
            description = ""Name of the alias type."",
            example = ""OldAlias"")
    String aliasName;

    @Option(displayName = ""New alias name"",
            description = ""Name of the alias type."",
            example = ""NewAlias"")
    String newName;

    @Option(displayName = ""Target fully qualified type"",
            description = ""Fully-qualified class name of the aliased type."",
            example = ""org.junit.Assume"")
    String fullyQualifiedAliasedType;


    @Override
    public String getDisplayName() {
        return ""Rename type alias"";
    }

    @Override
    public String getDescription() {
        return ""Change the name of a given type alias."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinIsoVisitor<ExecutionContext>() {
            @Override
            public K.TypeAlias visitTypeAlias(K.TypeAlias typeAlias, ExecutionContext ctx) {
                if (!aliasName.equals(typeAlias.getSimpleName()) || !TypeUtils.isOfClassType(typeAlias.getType(), fullyQualifiedAliasedType)) {
                    return typeAlias;
                }
                return typeAlias.withName(typeAlias.getName().withSimpleName(newName));
            }

            @Override
            public J.Identifier visitIdentifier(J.Identifier i, ExecutionContext ctx) {
                if (!i.getSimpleName().equals(aliasName) || !TypeUtils.isOfClassType(i.getType(), fullyQualifiedAliasedType)) {
                    return i;
                }
                if (!isVariableName(getCursor().getParentTreeCursor(), i) ||
                        isAliasImport(getCursor().getParentTreeCursor(), i)) {
                    i = i.withSimpleName(newName);
                }
                return i;
            }
        };
    }

    private boolean isVariableName(Cursor cursor, J.Identifier ident) {
        Object value = cursor.getValue();
        if (value instanceof J.MethodInvocation) {
            J.MethodInvocation m = (J.MethodInvocation) value;
            return m.getName() != ident;
        } else if (value instanceof J.NewClass) {
            J.NewClass m = (J.NewClass) value;
            return m.getClazz() != ident;
        } else if (value instanceof J.NewArray) {
            J.NewArray a = (J.NewArray) value;
            return a.getTypeExpression() != ident;
        } else if (value instanceof J.VariableDeclarations) {
            J.VariableDeclarations v = (J.VariableDeclarations) value;
            return ident != v.getTypeExpression();
        } else if (value instanceof J.VariableDeclarations.NamedVariable) {
            Object maybeVd = cursor.getParentTreeCursor().getValue();
            if (maybeVd instanceof J.VariableDeclarations) {
                J.VariableDeclarations vd = (J.VariableDeclarations) maybeVd;
                return vd.getModifiers().stream().noneMatch(x -> x.getType() == J.Modifier.Type.LanguageExtension && ""typealias"".equals(x.getKeyword()));
            }
            return true;
        } else {
            return !(value instanceof J.ParameterizedType);
        }
    }

    private boolean isAliasImport(Cursor cursor, J.Identifier id) {
        if (cursor.getValue() instanceof J.Import) {
            J.Import ji = cursor.getValue();
            return ji.getAlias() == id;
        }

        return false;
    }
}
","{
  ""aliasName"": ""String field"",
  ""newName"": ""String field"",
  ""fullyQualifiedAliasedType"": ""String field""
}"
Find Kotlin sources and collect data metrics,Use data table to collect source files types and counts of files with extensions `.kt`.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.kotlin.table.KotlinSourceFile;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;
import org.openrewrite.text.PlainText;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindKotlinSources extends Recipe {
    transient KotlinSourceFile kotlinSourceFile = new KotlinSourceFile(this);

    @Option(displayName = ""Find Kotlin compilation units"",
            description = ""Limit the search results to Kotlin CompilationUnits."",
            required = false)
    @Nullable
    Boolean markCompilationUnits;

    @Override
    public String getDisplayName() {
        return ""Find Kotlin sources and collect data metrics"";
    }

    @Override
    public String getDescription() {
        return ""Use data table to collect source files types and counts of files with extensions `.kt`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    if (Boolean.TRUE.equals(markCompilationUnits) && !(tree instanceof K.CompilationUnit)) {
                        return tree;
                    }
                    SourceFile sourceFile = (SourceFile) tree;
                    if (sourceFile.getSourcePath().toString().endsWith("".kt"")) {
                        KotlinSourceFile.SourceFileType sourceFileType = getSourceFileType(sourceFile);
                        kotlinSourceFile.insertRow(ctx, new KotlinSourceFile.Row(sourceFile.getSourcePath().toString(), sourceFileType));
                        return SearchResult.found(sourceFile);
                    }
                }
                return tree;
            }

            private KotlinSourceFile.@Nullable SourceFileType getSourceFileType(SourceFile sourceFile) {
                KotlinSourceFile.SourceFileType sourceFileType = null;
                if (sourceFile instanceof K.CompilationUnit) {
                    sourceFileType = KotlinSourceFile.SourceFileType.Kotlin;
                } else if (sourceFile instanceof Quark) {
                    sourceFileType = KotlinSourceFile.SourceFileType.Quark;
                } else if (sourceFile instanceof PlainText) {
                    sourceFileType = KotlinSourceFile.SourceFileType.PlainText;
                }
                return sourceFileType;
            }
        };
    }
}
",{}
`it` shouldn't be used as a lambda parameter name,`it` is a special identifier that allows you to refer to the current parameter being passed to a ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.kotlin.KotlinVisitor;

import java.time.Duration;
import java.util.Set;

import static java.util.Collections.emptyList;
import static java.util.Collections.singleton;


@Value
@EqualsAndHashCode(callSuper = false)
public class ImplicitParameterInLambda extends Recipe {
    @Override
    public String getDisplayName() {
        return ""`it` shouldn't be used as a lambda parameter name"";
    }

    @Override
    public String getDescription() {
        return ""`it` is a special identifier that allows you to refer to the current parameter being passed to a "" +
               ""lambda expression without explicitly naming the parameter. "" +
               ""Lambda expressions are a concise way of writing anonymous functions. Many lambda expressions have "" +
               ""only one parameter, when this is true the compiler can determine the parameter type by context. Thus "" +
               ""when using it with single parameter lambda expressions, you do not need to declare the type."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S6558"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinVisitor<ExecutionContext>() {
            @Override
            public J visitLambda(J.Lambda lambda, ExecutionContext ctx) {
                lambda = (J.Lambda) super.visitLambda(lambda, ctx);
                if (isParameterExplicitIt(lambda)) {
                    lambda = lambda.withParameters(lambda.getParameters().withParameters(emptyList()));
                    return autoFormat(lambda, ctx);
                }
                return lambda;
            }
        };
    }

    /**
     * Return ture when the lambda has only one parameter `it` and with no type.
     */
    private static boolean isParameterExplicitIt(J.Lambda lambda) {
        J.Lambda.Parameters parameters = lambda.getParameters();
        if (parameters.getParameters().size() != 1) {
            return false;
        }

        J parameter = parameters.getParameters().get(0);
        if (parameter instanceof J.VariableDeclarations) {
            J.VariableDeclarations vs = (J.VariableDeclarations) parameter;
            if (vs.getVariables().size() != 1 || vs.getTypeExpression() != null) {
                return false;
            }

            J.VariableDeclarations.NamedVariable v = vs.getVariables().get(0);
            return ""it"".equals(v.getSimpleName());
        }
        return false;
    }
}
",{}
Remove trailing comma in Kotlin,"Remove trailing commas in variable, parameter, and class property lists.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.kotlin.format.TrailingCommaVisitor;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveTrailingComma extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove trailing comma in Kotlin"";
    }

    @Override
    public String getDescription() {
        return ""Remove trailing commas in variable, parameter, and class property lists."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TrailingCommaVisitor<>(false);
    }
}
",{}
Replace `Char#toInt()` with `Char#code`,Replace the usage of the deprecated `Char#toInt()` with `Char#code`. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.kotlin.KotlinTemplate;
import org.openrewrite.kotlin.KotlinVisitor;


@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceCharToIntWithCode extends Recipe {
    private static final MethodMatcher CHAR_TO_INT_METHOD_MATCHER = new MethodMatcher(""kotlin.Char toInt()"");

    @Override
    public String getDisplayName() {
        return ""Replace `Char#toInt()` with `Char#code`"";
    }

    @Override
    public String getDescription() {
        return ""Replace the usage of the deprecated `Char#toInt()` with `Char#code`. "" +
               ""Please ensure that your Kotlin version is 1.5 or later to support the `Char#code` property. "" +
               ""Note that the current implementation does not perform a Kotlin version check."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (CHAR_TO_INT_METHOD_MATCHER.matches(method) && method.getSelect() != null) {
                    return KotlinTemplate.builder(""#{any(kotlin.Char)}.code"")
                            .build()
                            .apply(getCursor(), method.getCoordinates().replace(), method.getSelect())
                            .withPrefix(method.getPrefix());
                }
                return super.visitMethodInvocation(method, ctx);
            }
        };
    }

}
",{}
Remove unnecessary trailing semicolon,"Some Java programmers may mistakenly add semicolons at the end when writing Kotlin code, but in ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.PrintOutputCapture;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.kotlin.KotlinIsoVisitor;
import org.openrewrite.kotlin.internal.KotlinPrinter;
import org.openrewrite.kotlin.marker.Semicolon;
import org.openrewrite.kotlin.tree.K;
import org.openrewrite.marker.Marker;

import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveTrailingSemicolon extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove unnecessary trailing semicolon"";
    }

    @Override
    public String getDescription() {
        return ""Some Java programmers may mistakenly add semicolons at the end when writing Kotlin code, but in "" +
               ""reality, they are not necessary."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return new KotlinIsoVisitor<ExecutionContext>() {
            @Nullable
            Set<Marker> semiColonRemovable;

            @Override
            public K.CompilationUnit visitCompilationUnit(K.CompilationUnit cu, ExecutionContext ctx) {
                semiColonRemovable = CollectSemicolonRemovableElements.collect(cu);
                return super.visitCompilationUnit(cu, ctx);
            }

            @Override
            @SuppressWarnings(""DataFlowIssue"")
            public <M extends Marker> @Nullable M visitMarker(Marker marker, ExecutionContext ctx) {
                return semiColonRemovable.remove(marker) ? null : super.visitMarker(marker, ctx);
            }
        };
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class CollectSemicolonRemovableElements extends KotlinPrinter<Set<Marker>> {
        Pattern WS = Pattern.compile(""^\\s+"");

        private class MyKotlinJavaPrinter extends KotlinPrinter.KotlinJavaPrinter<Set<Marker>> {

            @Nullable
            private Integer mark;

            @Nullable
            private Marker semicolonMarker;

            MyKotlinJavaPrinter(KotlinPrinter<Set<Marker>> kp) {
                super(kp);
            }

            @SuppressWarnings(""unchecked"")
            @Override
            public <M extends Marker> M visitMarker(Marker marker, PrintOutputCapture<Set<Marker>> p) {
                Marker m = super.visitMarker(marker, p);
                if (marker instanceof Semicolon) {
                    mark(marker, p);
                }
                return (M) m;
            }

            @Override
            public Space visitSpace(Space space, Space.Location loc, PrintOutputCapture<Set<Marker>> p) {
                p.append(space.getWhitespace());
                checkMark(p);
                return space;
            }

            private void mark(Marker semicolonMarker, PrintOutputCapture<Set<Marker>> p) {
                mark = p.out.length();
                this.semicolonMarker = semicolonMarker;
            }

            private void checkMark(PrintOutputCapture<Set<Marker>> p) {
                if (mark != null) {
                    String substring = p.out.substring(mark);
                    Matcher matcher = WS.matcher(substring);
                    if (matcher.find()) {
                        if (matcher.group().indexOf('\n') != -1) {
                            p.getContext().add(semicolonMarker);
                        }
                        mark = null;
                    }
                }
            }
        }

        public static Set<Marker> collect(J j) {
            Set<Marker> removable = new HashSet<>();
            new CollectSemicolonRemovableElements().visit(j, new PrintOutputCapture<>(removable));
            return removable;
        }

        @Override
        protected KotlinJavaPrinter<Set<Marker>> delegate() {
            return new MyKotlinJavaPrinter(this);
        }
    }
}
",{}
Remove unnecessary parentheses on Kotlin types,"In Kotlin, it's possible to add redundant nested parentheses in type definitions. This recipe is designed to remove those unnecessary parentheses.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeTree;
import org.openrewrite.kotlin.KotlinVisitor;

import java.time.Duration;

public class UnnecessaryTypeParentheses extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove unnecessary parentheses on Kotlin types"";
    }

    @Override
    public String getDescription() {
        return ""In Kotlin, it's possible to add redundant nested parentheses in type definitions. This recipe is designed to remove those unnecessary parentheses."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(3);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinVisitor<ExecutionContext>() {
            @Override
            public J visitParenthesizedTypeTree(J.ParenthesizedTypeTree parTree, ExecutionContext ctx) {
                J j = super.visitParenthesizedTypeTree(parTree, ctx);
                if (!(j instanceof J.ParenthesizedTypeTree)) {
                    return j;
                }

                Space prefix = j.getPrefix();
                TypeTree tt = (TypeTree) j;
                while (tt instanceof J.ParenthesizedTypeTree) {
                    tt = ((J.ParenthesizedTypeTree) tt).getParenthesizedType().getTree();
                }

                return tt.withPrefix(prefix);
            }
        };
    }
}
",{}
Remove method invocation parentheses around single lambda argument,"For example, convert `1.let({ it + 1 })` to `1.let { it + 1 }`.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.marker.OmitParentheses;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JContainer;
import org.openrewrite.java.tree.Space;
import org.openrewrite.kotlin.KotlinVisitor;
import org.openrewrite.marker.Markers;

import java.time.Duration;

public class RemoveLambdaArgumentParentheses extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove method invocation parentheses around single lambda argument"";
    }

    @Override
    public String getDescription() {
        return ""For example, convert `1.let({ it + 1 })` to `1.let { it + 1 }`."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                if (method.getArguments().size() == 1 && method.getArguments().get(0) instanceof J.Lambda) {
                    J.MethodInvocation.Padding padding = method.getPadding();
                    JContainer<Expression> arguments = padding.getArguments();
                    Markers argumentsMarkers = arguments.getMarkers();
                    if (!argumentsMarkers.findFirst(OmitParentheses.class).isPresent()) {
                        return padding.withArguments(arguments
                                .withMarkers(argumentsMarkers.add(new OmitParentheses(Tree.randomId())))
                                .withBefore(Space.SINGLE_SPACE));
                    }
                }
                return method;
            }
        };
    }

}
",{}
Structural equality tests should use `==` or `!=`,"In Kotlin, `==` means structural equality and `!=` structural inequality and both map to the left-side ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.cleanup;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.kotlin.KotlinParser;
import org.openrewrite.kotlin.KotlinVisitor;
import org.openrewrite.kotlin.tree.K;

import java.time.Duration;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.singleton;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class EqualsMethodUsage extends Recipe {

    @SuppressWarnings(""ALL"")
    private static J.@Nullable Binary equalsBinaryTemplate;

    @Override
    public String getDisplayName() {
        return ""Structural equality tests should use `==` or `!=`"";
    }

    @Override
    public String getDescription() {
        return ""In Kotlin, `==` means structural equality and `!=` structural inequality and both map to the left-side "" +
               ""termâ€™s `equals()` function. It is, therefore, redundant to call `equals()` as a function. Also, `==` and `!=` "" +
               ""are more general than `equals()` and `!equals()` because it allows either of both operands to be `null`.\n"" +
               ""Developers using `equals()` instead of `==` or `!=` is often the result of adapting styles from other "" +
               ""languages like Java, where `==` means reference equality and `!=` means reference inequality.\n"" +
               ""The `==` and `!=` operators are a more concise and elegant way to test structural equality than calling a function."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S6519"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(3);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new KotlinVisitor<ExecutionContext>() {
            @Override
            public J visitUnary(J.Unary unary, ExecutionContext ctx) {
                unary = (J.Unary) super.visitUnary(unary, ctx);
                if (unary.getExpression() instanceof J.Binary &&
                    getCursor().pollMessage(""replaced"") != null) {
                    J.Binary binary = (J.Binary) unary.getExpression();
                    if (binary.getOperator() == J.Binary.Type.Equal) {
                        return binary.withOperator(J.Binary.Type.NotEqual);
                    }
                }
                return unary;
            }

            @Override
            public <T extends J> J visitParentheses(J.Parentheses<T> parens, ExecutionContext ctx) {
                J pa = super.visitParentheses(parens, ctx);
                if (pa instanceof J.Parentheses && getCursor().pollMessage(""replaced"") != null) {
                    getCursor().getParentTreeCursor().putMessage(""replaced"", true);
                    return ((J.Parentheses<?>) pa).getTree();
                }
                return pa;
            }

            @Override
            public J visitMethodInvocation(J.MethodInvocation method,
                                           ExecutionContext ctx) {
                method = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (""equals"".equals(method.getSimpleName()) &&
                    method.getMethodType() != null &&
                    method.getArguments().size() == 1 &&
                    TypeUtils.isOfClassType(method.getMethodType().getReturnType(), ""kotlin.Boolean"") &&
                    method.getSelect() != null
                ) {
                    Expression lhs = method.getSelect();
                    Expression rhs = method.getArguments().get(0);
                    Cursor parentCursor = getCursor().getParentTreeCursor();
                    parentCursor.putMessage(""replaced"", true);
                    J.Binary binary = buildEqualsBinary(lhs, rhs);
                    return parentCursor.getValue() instanceof J.Block ? new K.ExpressionStatement(randomId(), binary) : binary;
                }
                return method;
            }
        };
    }

    @SuppressWarnings(""all"")
    private static J.Binary buildEqualsBinary(Expression left, Expression right) {
        if (equalsBinaryTemplate == null) {
            K.CompilationUnit kcu = KotlinParser.builder().build()
                    .parse(""fun method(a : String, b : String) {val isSame = a == b}"")
                    .map(K.CompilationUnit.class::cast)
                    .findFirst()
                    .get();

            equalsBinaryTemplate = new KotlinVisitor<AtomicReference<J.Binary>>() {
                @Override
                public J visitBinary(J.Binary binary, AtomicReference<J.Binary> target) {
                    target.set(binary);
                    return binary;
                }
            }.reduce(kcu, new AtomicReference<J.Binary>()).get();
        }

        Space rhsPrefix = right.getPrefix();
        if (rhsPrefix.getWhitespace().isEmpty()) {
            rhsPrefix = rhsPrefix.withWhitespace("" "");
        }
        return equalsBinaryTemplate.withLeft(left.withPrefix(left.getPrefix())).withRight(right.withPrefix(rhsPrefix));
    }
}
",{}
Format Kotlin code,Format Kotlin code using a standard comprehensive set of Kotlin formatting recipes.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.kotlin.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class AutoFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Format Kotlin code"";
    }

    @Override
    public String getDescription() {
        return ""Format Kotlin code using a standard comprehensive set of Kotlin formatting recipes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>(null);
    }
}
",{}
Test recipe,Test recipe.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.test;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.config.CompositeRecipe;

import java.util.List;

import static java.util.Collections.singletonList;
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

class RecipePrinterTest implements RewriteTest {

    private StringBuilder sb;

    @BeforeEach
    void beforeEach() {
        sb = new StringBuilder();
    }

    @Test
    void printRecipeTreeForSimpleRecipe() {
        rewriteRun(
          spec -> spec
            .recipe(new AnotherTestRecipe())
            .printRecipe(() -> sb::append)
        );

        assertThat(sb.toString()).isEqualTo(AnotherTestRecipe.class.getName() + System.lineSeparator());
    }

    @Test
    void printRecipeTreeForRecipeWithNestedRecipes() {
        Recipe recipe = new CompositeRecipe(List.of(
          new TestRecipe(""the option""),
          new AnotherTestRecipe(),
          new CompositeRecipe(singletonList(new AnotherTestRecipe()))
        ));
        rewriteRun(
          spec -> spec
            .recipe(recipe)
            .printRecipe(() -> sb::append)
        );

        String output = sb.toString();

        String expected = String.format(
          ""%1$s%n"" +
          ""  %2$s: {theOption=the option}%n"" +
          ""  %3$s%n"" +
          ""  %1$s%n"" +
          ""    %3$s%n"",
          CompositeRecipe.class.getName(), TestRecipe.class.getName(), AnotherTestRecipe.class.getName()
        );

        assertThat(output).isEqualTo(expected);
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class TestRecipe extends Recipe {

        @Option(displayName = ""An option"",
          description = ""A sample option."",
          example = ""Some text."")
        String theOption;

        @Override
        public String getDisplayName() {
            return ""Test recipe"";
        }

        @Override
        public String getDescription() {
            return ""Test recipe."";
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class AnotherTestRecipe extends Recipe {

        @Override
        public String getDisplayName() {
            return ""Another Test recipe"";
        }

        @Override
        public String getDescription() {
            return ""Another Test recipe."";
        }
    }
}
","{
  ""theOption"": ""String field""
}"
Attempts mutation during getScanner(),Any changes attempted by a visitor returned from getScanner() should be an error during test execution.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.test.internal;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.test.TypeValidation;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.nio.file.Path;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.openrewrite.java.Assertions.java;
import static org.openrewrite.test.SourceSpecs.text;

@SuppressWarnings(""UnnecessarySemicolon"")
class RewriteTestTest implements RewriteTest {

    @Test
    void rejectRecipeWithNameOption() {
        assertThrows(AssertionError.class, () -> rewriteRun(
          spec -> spec.recipe(new RecipeWithNameOption(""test"")),
          text(
            ""hello world!""
          )
        ));
    }

    @Test
    void acceptsRecipeWithDescriptionListOfLinks() {
        validateRecipeNameAndDescription(new RecipeWithDescriptionListOfLinks());
    }

    @Test
    void acceptsRecipeWithDescriptionListOfDescribedLinks() {
        validateRecipeNameAndDescription(new RecipeWithDescriptionListOfDescribedLinks());
    }

    @Test
    void rejectsRecipeWithDescriptionNotEndingWithPeriod() {
        assertThrows(
          AssertionError.class,
          () -> validateRecipeNameAndDescription(new RecipeWithDescriptionNotEndingWithPeriod())
        );
    }

    @Test
    void verifyAll() {
        assertThrows(AssertionError.class, this::assertRecipesConfigure);
    }

    @Test
    void multipleFilesWithSamePath() {
        assertThrows(AssertionError.class,
          () -> rewriteRun(
            spec -> spec.recipe(new CreatesTwoFilesSamePath()),
            text(null, ""duplicate"", spec -> spec.path(""duplicate.txt""))));
    }

    @Test
    void cursorValidation() {
        assertThrows(AssertionError.class, () ->
          rewriteRun(
            spec -> spec.recipe(new ImproperCursorUsage()),
            text("""")
          )
        );

        rewriteRun(
          spec -> spec.recipe(new ImproperCursorUsage()).typeValidationOptions(TypeValidation.builder()
            .cursorAcyclic(false)
            .build()),
          text("""")
        );
    }


    @Test
    void rejectRecipeValidationFailure() {
        assertThrows(AssertionError.class, () ->
          rewriteRun(
            spec -> spec.recipeFromYaml(""""""
              type: specs.openrewrite.org/v1beta/recipe
              name: org.openrewrite.RefersToNonExistentRecipe
              displayName: Refers to non-existent recipe
              description: Deliberately has a non-existent recipe in its recipe list to trigger a validation failure.
              recipeList:
                - org.openrewrite.DoesNotExist

              """""", ""org.openrewrite.RefersToNonExistentRecipe"")
          ));
    }

    @Test
    void rejectExecutionContextMutation() {
        assertThrows(AssertionError.class, () ->
          rewriteRun(
            spec -> spec.recipe(new MutateExecutionContext()),
            text(""irrelevant"")
          ));
    }

    @Test
    void rejectScannerEdit() {
        assertThrows(AssertionError.class, () -> rewriteRun(
          spec -> spec.recipe(new ScannerEdit()),
          text(""foo"")
        ));
    }

    @Test
    void allowScannerEdit() {
        rewriteRun(
          spec -> spec
            .typeValidationOptions(TypeValidation.builder().immutableScanning(false).build())
            .recipe(new ScannerEdit()),
          text(""foo"")
        );
    }

    @Test
    void allowNonWhitespaceInWhitespace() {
        rewriteRun(
          spec -> spec.typeValidationOptions(TypeValidation.all().allowNonWhitespaceInWhitespace(true)),
          java(
            """"""
              import java.util.List;;
              interface A {
                  List<String> getList();
              }
              """"""
          )
        );
    }
}

@EqualsAndHashCode(callSuper = false)
@NullMarked
@Value
class ScannerEdit extends ScanningRecipe<AtomicBoolean> {

    @Override
    public String getDisplayName() {
        return ""Attempts mutation during getScanner()"";
    }

    @Override
    public String getDescription() {
        return ""Any changes attempted by a visitor returned from getScanner() should be an error during test execution."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new PlainTextVisitor<>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                return text.withText(""mutated"");
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@NullMarked
@Value
class MutateExecutionContext extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Mutate execution context"";
    }

    @Override
    public String getDescription() {
        return ""Mutates the execution context to trigger a validation failure."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                ctx.putMessage(""mutated"", true);
                return tree;
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@NullMarked
@Value
class ImproperCursorUsage extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Uses cursor improperly"";
    }

    @Override
    public String getDescription() {
        return ""LST elements are acyclic. So a cursor which indicates an element is its own parent is invalid."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        //noinspection NullableProblems
        return new TreeVisitor<>() {
            @Override
            public @Nullable Tree visit(Tree tree, ExecutionContext ctx) {
                return new TreeVisitor<>() {
                }.visit(tree, ctx, new Cursor(getCursor(), tree));
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@NullMarked
@Value
class CreatesTwoFilesSamePath extends ScanningRecipe<AtomicBoolean> {

    @Override
    public String getDisplayName() {
        return ""Creates two source files with the same path"";
    }

    @Override
    public String getDescription() {
        return ""A source file's path must be unique. "" +
          ""This recipe creates two source files with the same path to show that the test framework helps protect against this mistake."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean alreadyExists) {
        return new TreeVisitor<>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile s) {
                    if (""duplicate.txt"".equals(s.getSourcePath().toString())) {
                        alreadyExists.set(true);
                    }
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(AtomicBoolean alreadyExists, ExecutionContext ctx) {
        if (alreadyExists.get()) {
            return emptyList();
        }
        Path duplicatePath = Path.of(""duplicate.txt"");
        return List.of(PlainText.builder()
            .text(""duplicate"")
            .sourcePath(duplicatePath)
            .build(),
          PlainText.builder()
            .text(""duplicate"")
            .sourcePath(duplicatePath)
            .build()
        );
    }
}

@NullMarked
@SuppressWarnings({""FieldCanBeLocal"", ""unused""})
class RecipeWithNameOption extends Recipe {
    @Option
    private final String name;

    @JsonCreator
    public RecipeWithNameOption(String name) {
        this.name = name;
    }

    @Override
    public String getDisplayName() {
        return ""Recipe with name option"";
    }

    @Override
    public String getDescription() {
        return ""A fancy description."";
    }
}

@NullMarked
class RecipeWithDescriptionListOfLinks extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Recipe with name option"";
    }

    @Override
    public String getDescription() {
        return """"""
          A fancy description.
          For more information, see:
            - [link 1](https://example.com/link1)
            - [link 2](https://example.com/link2)"""""";
    }
}

@NullMarked
class RecipeWithDescriptionListOfDescribedLinks extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Recipe with name option"";
    }

    @Override
    public String getDescription() {
        return """"""
          A fancy description.
          For more information, see:
            - First Resource [link 1](https://example.com/link1).
            - Second Resource [link 2](https://example.com/link2)."""""";
    }
}

@NullMarked
class RecipeWithDescriptionNotEndingWithPeriod extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Recipe with name option"";
    }

    @Override
    public String getDescription() {
        return ""A fancy description"";
    }
}
",{}
Recipe with no parameters,"A recipe with no parameters, used in EnvironmentTest",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.Recipe;

@Value
@EqualsAndHashCode(callSuper = false)
public class RecipeNoParameters extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Recipe with no parameters"";
    }

    @Override
    public String getDescription() {
        return ""A recipe with no parameters, used in EnvironmentTest"";
    }
}
",{}
Recipe accepting parameters,"A recipe with parameters, used in EnvironmentTest",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.Option;
import org.openrewrite.Recipe;

@Value
@EqualsAndHashCode(callSuper = false)
public class RecipeAcceptingParameters extends Recipe {

    @Option(example = ""someString"", displayName = ""foo"")
    String foo;

    @Option(displayName = ""bar"")
    Integer bar;

    @Override
    public String getDisplayName() {
        return ""Recipe accepting parameters"";
    }

    @Override
    public String getDescription() {
        return ""A recipe with parameters, used in EnvironmentTest"";
    }
}
","{
  ""foo"": ""String field"",
  ""bar"": ""Integer field""
}"
AdHocRecipe,An ad hoc recipe used in RewriteTest.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.test;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.With;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;

import java.util.Collection;
import java.util.List;
import java.util.function.Supplier;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
@RequiredArgsConstructor
public class AdHocRecipe extends Recipe {
    @With
    @Nullable
    @Language(""markdown"")
    String displayName;

    @With
    @Nullable
    String name;

    @With
    @Nullable
    Boolean causesAnotherCycle;

    @With
    @Nullable
    transient Supplier<TreeVisitor<?, ExecutionContext>> getVisitor;

    @With
    @Nullable
    List<Maintainer> maintainers;

    @With
    @Nullable
    Integer maxCycles;

    public AdHocScanningRecipe withGenerator(Supplier<Collection<SourceFile>> generator) {
        return new AdHocScanningRecipe(displayName, name, causesAnotherCycle, getVisitor, generator, maintainers, maxCycles);
    }

    @Override
    public String getDisplayName() {
        return StringUtils.isBlank(displayName) ? ""Ad hoc recipe"" : displayName;
    }

    @Override
    public String getDescription() {
        return ""An ad hoc recipe used in RewriteTest."";
    }

    @Override
    public String getName() {
        return StringUtils.isBlank(name) ? super.getName() : name;
    }

    @Override
    public boolean causesAnotherCycle() {
        return causesAnotherCycle == null ? super.causesAnotherCycle() : causesAnotherCycle;
    }

    @Override
    public int maxCycles() {
        return maxCycles == null ? super.maxCycles() : maxCycles;
    }

    @Override
    public List<Maintainer> getMaintainers() {
        return maintainers == null ? emptyList() : maintainers;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return requireNonNull(getVisitor).get();
    }
}
",{}
AdHocScanningRecipe,An ad hoc recipe used in RewriteTest.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.test;

import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;

import java.util.Collection;
import java.util.List;
import java.util.function.Supplier;

import static java.util.Collections.emptyList;

@Value
@EqualsAndHashCode(callSuper = false)
public class AdHocScanningRecipe extends ScanningRecipe<Void> {
    @With
    @Nullable
    @Language(""markdown"")
    String displayName;

    @With
    @Nullable
    String name;

    @With
    @Nullable
    Boolean causesAnotherCycle;

    @With
    Supplier<TreeVisitor<?, ExecutionContext>> getVisitor;

    @Nullable
    @With
    Supplier<Collection<SourceFile>> generator;

    @With
    @Nullable
    List<Maintainer> maintainers;

    @With
    @Nullable
    Integer maxCycles;

    @Override
    public String getDisplayName() {
        return StringUtils.isBlank(displayName) ? ""Ad hoc recipe"" : displayName;
    }

    @Override
    public String getDescription() {
        return ""An ad hoc recipe used in RewriteTest."";
    }

    @Override
    public String getName() {
        return StringUtils.isBlank(name) ? super.getName() : name;
    }

    @Override
    public boolean causesAnotherCycle() {
        return causesAnotherCycle == null ? super.causesAnotherCycle() : causesAnotherCycle;
    }

    @Override
    public int maxCycles() {
        return maxCycles == null ? super.maxCycles() : maxCycles;
    }

    @Override
    public List<Maintainer> getMaintainers() {
        return maintainers == null ? emptyList() : maintainers;
    }

    @Override
    public @Nullable Void getInitialValue(ExecutionContext ctx) {
        return null;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Void acc) {
        return TreeVisitor.noop();
    }

    @Override
    public Collection<? extends SourceFile> generate(Void acc, ExecutionContext ctx) {
        return generator == null ? emptyList() : generator.get();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Void acc) {
        return getVisitor.get();
    }
}
",{}
Add comment before property key,"Add a new comment before a property key if not already present, optionally commenting out the property.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;

import java.util.Arrays;
import java.util.function.Function;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddPropertyComment extends Recipe {

    @Option(displayName = ""Property key"",
            description = ""The name of the property to add comment."",
            example = ""management.metrics.binders"")
    String propertyKey;

    @Option(example = ""comment"", displayName = ""Comment"",
            description = ""The comment to be added."")
    String comment;

    @Option(example = ""true"", displayName = ""Comment out property"",
            description = ""If true, property will be commented out."",
            required = false)
    @Nullable
    Boolean commentOutProperty;

    @Override
    public String getDisplayName() {
        return ""Add comment before property key"";
    }

    @Override
    public String getDescription() {
        return ""Add a new comment before a property key if not already present, optionally commenting out the property."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        PropertiesVisitor<ExecutionContext> propertiesVisitor = new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                Properties.File p = file.withContent(ListUtils.flatMap(file.getContent(), new Function<Properties.Content, Object>() {
                            Properties.@Nullable Content previousContent = null;

                            @Override
                            public Object apply(Properties.Content c) {
                                if (c instanceof Properties.Entry &&
                                    ((Properties.Entry) c).getKey().equals(propertyKey) &&
                                    !isCommentAlreadyPresent(previousContent, comment)) {
                                    Properties.Comment commentContent = new Properties.Comment(
                                            randomId(),
                                            previousContent == null ? """" : ""\n"",
                                            Markers.EMPTY,
                                            Properties.Comment.Delimiter.HASH_TAG,
                                            "" "" + comment.trim());
                                    previousContent = c;
                                    return Arrays.asList(commentContent, c.getPrefix().contains(""\n"") ?
                                            c : c.withPrefix(""\n"" + c.getPrefix()));
                                }
                                previousContent = c;
                                return c;
                            }
                        }
                ));
                return super.visitFile(p, ctx);
            }

            @Override
            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                if (Boolean.TRUE.equals(commentOutProperty) && entry.getKey().equals(propertyKey)) {
                    return new Properties.Comment(
                            randomId(),
                            entry.getPrefix(),
                            entry.getMarkers(),
                            Properties.Comment.Delimiter.HASH_TAG,
                            "" "" + entry.printTrimmed(getCursor()));
                }
                return super.visitEntry(entry, ctx);
            }
        };
        return Preconditions.check(new FindProperties(propertyKey, false).getVisitor(), propertiesVisitor);
    }

    private boolean isCommentAlreadyPresent(Properties.@Nullable Content previousContent, String comment) {
        return previousContent instanceof Properties.Comment &&
               ((Properties.Comment) previousContent).getMessage().contains(comment.trim());
    }
}
","{
  ""propertyKey"": ""String field"",
  ""comment"": ""String field""
}"
Change property key,Change a property key leaving the value intact.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.properties.tree.Properties;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePropertyKey extends Recipe {

    @Option(displayName = ""Old property key"",
            description = ""The property key to rename."",
            example = ""management.metrics.binders.files.enabled"")
    String oldPropertyKey;

    @Option(displayName = ""New property key"",
            description = ""The new name for the key identified by `oldPropertyKey`."",
            example = ""management.metrics.enable.process.files"")
    String newPropertyKey;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `oldPropertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Default is `true`. Set to `false`  to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Option(displayName = ""Regex"",
            description = ""Default false. If enabled, `oldPropertyKey` will be interpreted as a Regular Expression, and capture group contents will be available in `newPropertyKey`"",
            required = false)
    @Nullable
    Boolean regex;

    @Override
    public String getDisplayName() {
        return ""Change property key"";
    }

    @Override
    public String getDescription() {
        return ""Change a property key leaving the value intact."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new ChangePropertyKeyVisitor<>();
    }

    public class ChangePropertyKeyVisitor<P> extends PropertiesVisitor<P> {
        public ChangePropertyKeyVisitor() {
        }

        @Override
        public Properties visitEntry(Properties.Entry entry, P p) {
            if (Boolean.TRUE.equals(regex)) {
                if (!Boolean.FALSE.equals(relaxedBinding) ?
                        NameCaseConvention.matchesRegexRelaxedBinding(entry.getKey(), oldPropertyKey) :
                        entry.getKey().matches(oldPropertyKey)) {
                    entry = entry.withKey(entry.getKey().replaceFirst(oldPropertyKey, newPropertyKey))
                            .withPrefix(entry.getPrefix());
                }
            } else {
                if (!Boolean.FALSE.equals(relaxedBinding) ?
                        NameCaseConvention.equalsRelaxedBinding(entry.getKey(), oldPropertyKey) :
                        entry.getKey().equals(oldPropertyKey)) {
                    entry = entry.withKey(newPropertyKey)
                            .withPrefix(entry.getPrefix());
                }
            }
            return super.visitEntry(entry, p);
        }
    }
}
","{
  ""oldPropertyKey"": ""String field"",
  ""newPropertyKey"": ""String field""
}"
Create Properties file,Create a new Properties file.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.properties.tree.Properties;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CreatePropertiesFile extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""Relative file path"",
            description = ""File path of new file."",
            example = ""foo/bar/baz.properties"")
    String relativeFileName;

    @Language(""properties"")
    @Option(displayName = ""File contents"",
            description = ""Multiline text content for the file."",
            example = ""a.property=value"",
            required = false)
    @Nullable
    String fileContents;

    @Option(displayName = ""Overwrite existing file"",
            description = ""If there is an existing file, should it be overwritten."",
            required = false)
    @Nullable
    Boolean overwriteExisting;

    @Override
    public String getDisplayName() {
        return ""Create Properties file"";
    }

    @Override
    public String getDescription() {
        return ""Create a new Properties file."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        return new CreateFileVisitor(Paths.get(relativeFileName), shouldCreate);
    }

    @Override
    public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            return PropertiesParser.builder().build().parse(fileContents == null ? """" : fileContents)
                    .map(brandNewFile -> (SourceFile) brandNewFile.withSourcePath(Paths.get(relativeFileName)))
                    .collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
        Path path = Paths.get(relativeFileName);
        return new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                if (Boolean.TRUE.equals(overwriteExisting) &&path.equals(file.getSourcePath())) {
                    if (StringUtils.isBlank(fileContents)) {
                        return file.withContent(emptyList());
                    }
                    Optional<SourceFile> sourceFiles = PropertiesParser.builder().build()
                            .parse(fileContents)
                            .findFirst();
                    if (sourceFiles.isPresent()) {
                        SourceFile sourceFile = sourceFiles.get();
                        if (sourceFile instanceof Properties.File) {
                            return file.withContent(((Properties.File) sourceFile).getContent());
                        }
                    }
                }
                return file;
            }
        };
    }
}
","{
  ""relativeFileName"": ""String field""
}"
Add a new property,Adds a new property to a property file. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.Validated;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.properties.search.FindProperties;
import org.openrewrite.properties.tree.Properties;

import java.util.*;
import java.util.stream.Stream;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddProperty extends Recipe {

    @Option(displayName = ""Property key"",
            description = ""The property key to add."",
            example = ""management.metrics.enable.process.files"")
    String property;

    @Option(example = ""newPropValue"", displayName = ""Property value"",
            description = ""The value of the new property key."")
    String value;

    @Option(displayName = ""Optional comment to be prepended to the property"",
            description = ""A comment that will be added to the new property."",
            required = false,
            example = ""This is a comment"")
    @Nullable
    String comment;

    @Option(displayName = ""Optional delimiter"",
            description = ""Property entries support different delimiters (`=`, `:`, or whitespace). The default value is `=` unless provided the delimiter of the new property entry."",
            required = false,
            example = "":"")
    @Nullable
    String delimiter;

    @Override
    public String getDisplayName() {
        return ""Add a new property"";
    }

    @Override
    public String getDescription() {
        return ""Adds a new property to a property file. "" +
               ""Attempts to place the new property in alphabetical order by the property keys. "" +
               ""Whitespace before and after the `=` must be included in the property and value."";
    }

    @Override
    public Validated<Object> validate() {
        return Validated.none()
                .and(Validated.required(""property"", property))
                .and(Validated.required(""value"", value));
    }

    @Override
    public PropertiesIsoVisitor<ExecutionContext> getVisitor() {
        return new PropertiesIsoVisitor<ExecutionContext>() {
            @Override
            public Properties.File visitFile(Properties.File file, ExecutionContext ctx) {
                Properties.File p = super.visitFile(file, ctx);
                if (StringUtils.isBlank(property) || StringUtils.isBlank(value)) {
                    return p;
                }
                Set<Properties.Entry> properties = FindProperties.find(p, property, false);
                if (!properties.isEmpty()) {
                    return p;
                }

                Properties.Value propertyValue = new Properties.Value(randomId(), """", Markers.EMPTY, value);
                Properties.Entry.Delimiter delimitedBy = StringUtils.isNotEmpty(delimiter) ? Properties.Entry.Delimiter.getDelimiter(delimiter) : Properties.Entry.Delimiter.EQUALS;
                String beforeEquals = delimitedBy == Properties.Entry.Delimiter.NONE ? delimiter : """";
                Properties.Entry entry = new Properties.Entry(randomId(), ""\n"", Markers.EMPTY, property, beforeEquals, delimitedBy, propertyValue);
                int insertionIndex = sortedInsertionIndex(entry, p.getContent());

                List<Properties.Content> newContents;
                if(StringUtils.isBlank(comment)) {
                    newContents = singletonList(entry);
                } else {
                    newContents = Arrays.asList(
                            new Properties.Comment(
                                    randomId(),
                                    ""\n"",
                                    Markers.EMPTY,
                                    Properties.Comment.Delimiter.HASH_TAG,
                                "" "" + comment.trim()),
                            entry);
                }

                List<Properties.Content> contentList = new ArrayList<>(p.getContent().size() + 1);
                contentList.addAll(p.getContent().subList(0, insertionIndex));
                contentList.addAll(newContents);
                contentList.addAll(p.getContent().subList(insertionIndex, p.getContent().size()));

                // First entry in the file does not need a newline, but every other entry does
                contentList = ListUtils.map(contentList, (i, c) -> {
                    if(i == 0) {
                        return (Properties.Content) c.withPrefix("""");
                    } else if(!c.getPrefix().contains(""\n"")) {
                        return (Properties.Content) c.withPrefix(""\n"" + c.getPrefix());
                    }
                    return c;
                });

                return p.withContent(contentList);
            }
        };
    }

    private static int sortedInsertionIndex(Properties.Entry entry, List<Properties.Content> contentsList) {
        if (contentsList.isEmpty()) {
            return 0;
        }
        List<Properties.Entry> sorted =
                Stream.concat(
                                Stream.of(entry),
                                contentsList.stream()
                                        .filter(Properties.Entry.class::isInstance)
                                        .map(Properties.Entry.class::cast))
                        .sorted(Comparator.comparing(Properties.Entry::getKey))
                        .collect(toList());
        int indexInSorted = sorted.indexOf(entry);
        if (indexInSorted == 0) {
            return 0;
        }
        Properties.Entry previous = sorted.get(indexInSorted - 1);
        return contentsList.indexOf(previous) + 1;
    }
}
","{
  ""property"": ""String field"",
  ""value"": ""String field""
}"
Change property value,Change a property value leaving the key intact.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.properties.tree.Properties;

import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePropertyValue extends Recipe {

    @Option(displayName = ""Property key"",
            description = ""The name of the property key whose value is to be changed. Supports glob patterns."",
            example = ""management.metrics.binders.*.enabled"")
    String propertyKey;

    @Option(example = ""newValue"", displayName = ""New value"",
            description = ""The new value to be used for key specified by `propertyKey`."")
    String newValue;

    @Option(example = ""oldValue"", displayName = ""Old value"",
            required = false,
            description = ""Only change the property value if it matches the configured `oldValue`."")
    @Nullable
    String oldValue;

    @Option(displayName = ""Regex"",
            description = ""Default `false`. If enabled, `oldValue` will be interpreted as a Regular Expression, "" +
                          ""to replace only all parts that match the regex. Capturing group can be used in `newValue`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                          ""rules. Default is `true`. Set to `false`  to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Override
    public String getDisplayName() {
        return ""Change property value"";
    }

    @Override
    public String getDescription() {
        return ""Change a property value leaving the key intact."";
    }

    @Override
    public Validated validate() {
        return super.validate().and(
                Validated.test(""oldValue"", ""is required if `regex` is enabled"", oldValue,
                        value -> !(Boolean.TRUE.equals(regex) && StringUtils.isNullOrEmpty(value))));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new ChangePropertyValueVisitor<>();
    }

    public class ChangePropertyValueVisitor<P> extends PropertiesVisitor<P> {
        public ChangePropertyValueVisitor() {
        }

        @Override
        public Properties visitEntry(Properties.Entry entry, P p) {
            Properties.Entry e = (Properties.Entry) super.visitEntry(entry, p);
            if (matchesPropertyKey(e.getKey()) && matchesOldValue(e.getValue())) {
                Properties.Value updatedValue = updateValue(e.getValue());
                if (updatedValue != null) {
                    e = e.withValue(updatedValue);
                }
            }
            return e;
        }

        // returns null if value should not change
        private Properties.@Nullable Value updateValue(Properties.Value value) {
            Properties.Value updatedValue = value.withText(Boolean.TRUE.equals(regex) ?
                    value.getText().replaceAll(oldValue, newValue) :
                    newValue);
            return updatedValue.getText().equals(value.getText()) ? null : updatedValue;
        }

        private boolean matchesPropertyKey(String prop) {
            return !Boolean.FALSE.equals(relaxedBinding) ?
                    NameCaseConvention.matchesGlobRelaxedBinding(prop, propertyKey) :
                    StringUtils.matchesGlob(prop, propertyKey);
        }

        private boolean matchesOldValue(Properties.Value value) {
            return StringUtils.isNullOrEmpty(oldValue) ||
                   (Boolean.TRUE.equals(regex) ?
                           Pattern.compile(oldValue).matcher(value.getText()).find() :
                           value.getText().equals(oldValue));
        }
    }

}
","{
  ""propertyKey"": ""String field"",
  ""newValue"": ""String field""
}"
Delete property by key,"Deletes key/value pairs from properties files, as well as any comments that immediately precede the key/value pair. ",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.properties.tree.Properties;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import static org.openrewrite.internal.NameCaseConvention.LOWER_CAMEL;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteProperty extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Delete property by key"";
    }

    @Override
    public String getDescription() {
        return ""Deletes key/value pairs from properties files, as well as any comments that immediately precede the key/value pair. "" +
                ""Comments separated by two or more newlines from the deleted key/value pair are preserved."" ;
    }

    @Option(displayName = ""Property key matcher"",
            description = ""The key(s) to be deleted. This is a glob expression."",
            example = ""management.metrics.binders.files.enabled or management.metrics.*"")
    String propertyKey;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Default is `true`. Set to `false`  to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitFile(Properties.File file, ExecutionContext ctx) {
                Properties.File f1 = (Properties.File) super.visitFile(file, ctx);
                AtomicReference<@Nullable String> prefixOnNextEntry = new AtomicReference<>(null);
                AtomicBoolean deleted = new AtomicBoolean(false);
                Properties.File mapped = f1.withContent(ListUtils.map(f1.getContent(), (index, current) -> {
                    if (current instanceof Properties.Comment && nextEntryMatches(f1.getContent(), index)) {
                        prefixOnNextEntry.compareAndSet(null, current.getPrefix());
                        return null;
                    }
                    if (isMatch(current)) {
                        deleted.set(true);
                        return null;
                    }
                    if (deleted.getAndSet(false)) {
                        String prefix = prefixOnNextEntry.getAndSet(null);
                        if (prefix != null) {
                            return (Properties.Content) current.withPrefix(prefix);
                        }
                    }
                    return current;
                }));
                if (f1 != mapped) {
                    return mapped.withContent(ListUtils.mapFirst(mapped.getContent(), c -> (Properties.Content) c.withPrefix("""")));
                }
                return mapped;
            }

            private boolean isMatch(Properties.Content current) {
                if (current instanceof Properties.Entry) {
                    String key = ((Properties.Entry) current).getKey();
                    if (Boolean.FALSE.equals(relaxedBinding)) {
                        return StringUtils.matchesGlob(key, propertyKey);
                    }
                    return StringUtils.matchesGlob(LOWER_CAMEL.format(key), LOWER_CAMEL.format(propertyKey));
                }
                return false;
            }

            /**
             * @return true if the next entry not separated by two or more newlines matches the property key.
             */
            private boolean nextEntryMatches(List<Properties.Content> contents, int index) {
                while (++index < contents.size()) {
                    Properties.Content next = contents.get(index);
                    if (next.getPrefix().matches(""\\R{2,}"")) {
                        return false; // Two or more newlines, stop checking.
                    }
                    if (isMatch(next)) {
                        return true;
                    }
                    if (next instanceof Properties.Entry) {
                        return false; // Unrelated entry, stop checking.
                    }
                }
                return false;
            }
        };
    }
}
",{}
Find property,Finds occurrences of a property key.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.properties.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.NameCaseConvention;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.properties.PropertiesVisitor;
import org.openrewrite.properties.tree.Properties;

import java.util.HashSet;
import java.util.Set;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindProperties extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Find property"";
    }

    @Override
    public String getDescription() {
        return ""Finds occurrences of a property key."";
    }

    @Option(displayName = ""Property key"",
            description = ""The property key to look for."",
            example = ""management.metrics.binders.files.enabled"")
    String propertyKey;

    @Option(displayName = ""Use relaxed binding"",
            description = ""Whether to match the `propertyKey` using [relaxed binding](https://docs.spring.io/spring-boot/docs/2.5.6/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding) "" +
                    ""rules. Default is `true`. Set to `false`  to use exact matching."",
            required = false)
    @Nullable
    Boolean relaxedBinding;

    /**
     * Find a set of matching {@link Properties}.
     *
     * @param p              The set of properties to search over.
     * @param propertyKey    The name of property key to look for.
     * @param relaxedBinding Whether to match the propertyKey using relaxed binding rules. Default is true. Explicitly set to ""false"" to use exact matching.
     * @return The set of found properties matching the propertyKey.
     */
    public static Set<Properties.Entry> find(Properties p, String propertyKey, @Nullable Boolean relaxedBinding) {
        PropertiesVisitor<Set<Properties.Entry>> findVisitor = new PropertiesVisitor<Set<Properties.Entry>>() {
            @Override
            public Properties visitEntry(Properties.Entry entry, Set<Properties.Entry> ps) {
                if (!Boolean.FALSE.equals(relaxedBinding) ? NameCaseConvention.matchesGlobRelaxedBinding(entry.getKey(), propertyKey) :
                        StringUtils.matchesGlob(entry.getKey(), propertyKey)) {
                    ps.add(entry);
                }
                return super.visitEntry(entry, ps);
            }
        };

        Set<Properties.Entry> ps = new HashSet<>();
        findVisitor.visit(p, ps);
        return ps;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PropertiesVisitor<ExecutionContext>() {
            @Override
            public Properties visitEntry(Properties.Entry entry, ExecutionContext ctx) {
                if (!Boolean.FALSE.equals(relaxedBinding) ? NameCaseConvention.matchesGlobRelaxedBinding(entry.getKey(), propertyKey) :
                        StringUtils.matchesGlob(entry.getKey(), propertyKey)) {
                    entry = entry.withValue(entry.getValue().withMarkers(entry.getValue().getMarkers()
                            .computeByType(new SearchResult(randomId(), null), (s1, s2) -> s1 == null ? s2 : s1)));
                }
                return super.visitEntry(entry, ctx);
            }
        };
    }
}
","{
  ""propertyKey"": ""String field""
}"
We go boom,Test recipe.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.openrewrite.config.DeclarativeRecipe;
import org.openrewrite.internal.RecipeRunException;
import org.openrewrite.marker.Markup;
import org.openrewrite.scheduling.WorkingDirectoryExecutionContextView;
import org.openrewrite.table.SourcesFileErrors;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptySet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.openrewrite.scheduling.WorkingDirectoryExecutionContextView.WORKING_DIRECTORY_ROOT;
import static org.openrewrite.test.RewriteTest.toRecipe;
import static org.openrewrite.test.SourceSpecs.text;

class RecipeSchedulerTest implements RewriteTest {

    @DocumentExample
    @Test
    void exceptionsCauseResult() {
        rewriteRun(
          spec -> spec
            .executionContext(new InMemoryExecutionContext())
            .recipe(new BoomRecipe())
            .afterRecipe(run -> {
                  SourceFile after = run.getChangeset().getAllResults().getFirst().getAfter();
                  assertThat(after).isNotNull();
                  assertThat(after.getMarkers().findFirst(Markup.Error.class))
                    .hasValueSatisfying(err -> {
                        assertThat(err.getMessage()).isEqualTo(""boom"");
                        assertThat(err.getDetail())
                          .matches(""org.openrewrite.BoomException: boom"" +
                            ""\\s+org.openrewrite.BoomRecipe\\$1.visitText\\(RecipeSchedulerTest.java:\\d+\\)"" +
                            ""\\s+org.openrewrite.BoomRecipe\\$1.visitText\\(RecipeSchedulerTest.java:\\d+\\)"");
                    });
              }
            ),
          text(
            ""hello"",
            ""~~(boom)~~>hello""
          )
        );
    }

    @Test
    void exceptionDuringGenerate() {
        rewriteRun(
          spec -> spec.recipe(new BoomGenerateRecipe(false))
            .executionContext(new InMemoryExecutionContext())
            .dataTable(SourcesFileErrors.Row.class, rows ->
              assertThat(rows)
                .singleElement()
                .extracting(SourcesFileErrors.Row::getRecipe)
                .isEqualTo(""org.openrewrite.BoomGenerateRecipe""))
        );
    }

    @Test
    void recipeRunExceptionDuringGenerate() {
        rewriteRun(
          spec -> spec.recipe(new BoomGenerateRecipe(true))
            .executionContext(new InMemoryExecutionContext())
            .dataTable(SourcesFileErrors.Row.class, rows ->
              assertThat(rows)
                .singleElement()
                .extracting(SourcesFileErrors.Row::getRecipe)
                .isEqualTo(""org.openrewrite.BoomGenerateRecipe""))
        );
    }

    @Test
    void suppliedWorkingDirectoryRoot(@TempDir Path path) {
        InMemoryExecutionContext ctx = new InMemoryExecutionContext();
        WorkingDirectoryExecutionContextView.view(ctx).setRoot(path);
        AtomicInteger cycle = new AtomicInteger(0);
        rewriteRun(
          spec -> spec.executionContext(ctx).recipe(toRecipe(() -> new TreeVisitor<>() {
              @Override
              public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                  assert tree != null;
                  PlainText plainText = (PlainText) tree;
                  Path workingDirectory = WorkingDirectoryExecutionContextView.view(ctx)
                    .getWorkingDirectory();
                  assertThat(workingDirectory).hasParent(path);
                  if (cycle.incrementAndGet() == 2) {
                      assertThat(workingDirectory.resolve(""foo.txt"")).hasContent(""foo"");
                  }
                  assertDoesNotThrow(() -> {
                      Files.writeString(workingDirectory.resolve(""foo.txt""), plainText.getText());
                  });
                  return plainText.withText(""bar"");
              }
          })),
          text(""foo"", ""bar"")
        );
        assertThat(path).doesNotExist();
    }

    @Test
    void managedWorkingDirectoryWithRecipe(@TempDir Path path) {
        InMemoryExecutionContext ctx = new InMemoryExecutionContext();
        WorkingDirectoryExecutionContextView.view(ctx).setRoot(path);
        rewriteRun(
          spec -> spec.executionContext(ctx).recipe(new RecipeWritingToFile(0)),
          text(""foo"", ""bar"")
        );
        assertThat(path).doesNotExist();
    }

    @Test
    void managedWorkingDirectoryWithMultipleRecipes(@TempDir Path path) {
        InMemoryExecutionContext ctx = new InMemoryExecutionContext();
        WorkingDirectoryExecutionContextView.view(ctx).setRoot(path);
        DeclarativeRecipe recipe = new DeclarativeRecipe(
          ""root"",
          ""Root recipe"",
          ""Root recipe."",
          emptySet(),
          null,
          URI.create(""dummy:recipe.yml""),
          false,
          emptyList()
        );
        recipe.addUninitialized(new RecipeWritingToFile(1));
        recipe.addUninitialized(new RecipeWritingToFile(2));
        recipe.initialize(List.of());
        rewriteRun(
          spec -> spec.executionContext(ctx).recipe(recipe),
          text(""foo"", ""bar"")
        );
        assertThat(path).doesNotExist();
    }
}

@AllArgsConstructor
class BoomRecipe extends Recipe {
    @Override
    public String getDisplayName() {
        return ""We go boom"";
    }

    @Override
    public String getDescription() {
        return ""Test recipe."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PlainTextVisitor<>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                throw new BoomException();
            }
        };
    }
}

@EqualsAndHashCode(callSuper = false)
@Value
class BoomGenerateRecipe extends ScanningRecipe<Integer> {

    boolean wrapAsRecipeRunException;

    @Override
    public String getDisplayName() {
        return ""Boom generate"";
    }

    @Override
    public String getDescription() {
        return ""Throws a boom exception during ScanningRecipe.generate()."";
    }

    @Override
    public Integer getInitialValue(ExecutionContext ctx) {
        return 0;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Integer acc) {
        return TreeVisitor.noop();
    }

    @Override
    public Collection<? extends SourceFile> generate(Integer acc, ExecutionContext ctx) {
        throw wrapAsRecipeRunException ? new RecipeRunException(new BoomException(), null) : new BoomException();
    }
}

/**
 * Simplified exception that only displays stack trace elements within the [BoomRecipe].
 */
class BoomException extends RuntimeException {
    public BoomException() {
        super(""boom"");
    }

    @Override
    public StackTraceElement[] getStackTrace() {
        return Arrays.stream(super.getStackTrace())
          .filter(st -> st.getClassName().startsWith(BoomRecipe.class.getName()))
          .toArray(StackTraceElement[]::new);
    }
}

@AllArgsConstructor
class RecipeWritingToFile extends ScanningRecipe<RecipeWritingToFile.Accumulator> {

    final int position;

    @Override
    public String getDisplayName() {
        return ""Write text to a file"";
    }

    @Override
    public String getDescription() {
        return ""Writes text to a file."";
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        Path workingDirectory = validateExecutionContext(ctx);
        return new Accumulator(workingDirectory);
    }

    private Path validateExecutionContext(ExecutionContext ctx) {
        Path workingDirectory = WorkingDirectoryExecutionContextView.view(ctx)
          .getWorkingDirectory();
        assertThat(workingDirectory).isDirectory();
        assertThat(workingDirectory).hasParent(ctx.getMessage(WORKING_DIRECTORY_ROOT));
        assertThat(ctx.getCycleDetails().getRecipePosition()).isEqualTo(position);
        assertThat(workingDirectory.getFileName().toString())
          .isEqualTo(""cycle"" + ctx.getCycle() + ""_recipe"" + position);
        return workingDirectory;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree != null;
                Path workingDirectory = validateExecutionContext(ctx);
                assertThat(acc.workingDirectory()).isEqualTo(workingDirectory);
                assertThat(workingDirectory).isEmptyDirectory();
                assertDoesNotThrow(() -> {
                    Files.writeString(workingDirectory.resolve(""manifest.txt""), ((SourceFile) tree).getSourcePath().toString(), StandardOpenOption.APPEND, StandardOpenOption.CREATE);
                });
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        Path workingDirectory = validateExecutionContext(ctx);
        assertThat(acc.workingDirectory()).isEqualTo(workingDirectory);
        assertThat(workingDirectory).isDirectoryContaining(path -> ""manifest.txt"".equals(path.getFileName().toString()));
        assertDoesNotThrow(() -> {
            assertThat(workingDirectory.resolve(""manifest.txt"")).hasContent(""file.txt"");
        });
        return List.of();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                Path workingDirectory = WorkingDirectoryExecutionContextView
                  .view(ctx).getWorkingDirectory();
                assertThat(workingDirectory).isDirectory();
                assertThat(acc.workingDirectory()).isEqualTo(workingDirectory);
                assertThat(workingDirectory).isDirectoryContaining(path -> ""manifest.txt"".equals(path.getFileName().toString()));
                assertDoesNotThrow(() -> {
                    assertThat(workingDirectory.resolve(""manifest.txt"")).hasContent(""file.txt"");
                });
                assert tree instanceof PlainText;
                return ((PlainText) tree).withText(""bar"");
            }
        };
    }

    public record Accumulator(Path workingDirectory) {
    }
}
",{}
Recipe base,Recipe base.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.openrewrite.config.RecipeDescriptor;
import org.openrewrite.text.ChangeText;

import java.util.HashMap;

import static org.assertj.core.api.Assertions.assertThat;

class RecipeBasicsTest {

    @Test
    void cloneRecipe() throws Exception {
        ChangeText ct = new ChangeText(""hi"");
        ChangeText ct2 = (ChangeText) ct.clone();
        ObjectMapper mapper = new ObjectMapper();
        mapper.updateValue(ct2, new HashMap<String, String>() {{
            put(""toText"", ""hello"");
        }});

        assertThat(ct2).isNotSameAs(ct);
        assertThat(ct.getToText()).isEqualTo(""hi"");
        assertThat(ct2.getToText()).isEqualTo(""hello"");
    }

    @Test
    void instanceName() {
        ChangeText ct = new ChangeText(""hi"");
        assertThat(ct.getInstanceName()).isEqualTo(""Change text to `hi`"");
    }


    static class RecipeBase extends Recipe {
        String option;
        public RecipeBase(String option) {
            this.option = option;
        }

        @Override
        public String getDisplayName() {
            return ""Recipe base"";
        }

        @Override
        public String getDescription() {
            return ""Recipe base."";
        }
    }

    static class ExtendingRecipe extends RecipeBase {
        @SuppressWarnings(""unused"")
        @Option(displayName = ""Option"", description = ""Option description"", example = ""Example"")
        String getOption() {
            return option;
        }

        public ExtendingRecipe(String option) {
            super(option);
        }
    }

    @Test
    void subclassExposesOptionsViaMethod() {
        RecipeDescriptor d = new ExtendingRecipe(""option"").createRecipeDescriptor();
        assertThat(d.getOptions().getFirst().getDisplayName()).isEqualTo(""Option"");
    }

    static class RecipeWithConstructorParameter extends Recipe {
        String option;

        public RecipeWithConstructorParameter(@Option(displayName = ""Option"", description = ""Option description"", example = ""Example"") String option) {
            this.option = option;
        }

        @Override
        public String getDisplayName() {
            return """";
        }

        @Override
        public String getDescription() {
            return """";
        }
    }

    @Test
    void optionExposedViaConstructorParameter() {
        RecipeDescriptor d = new RecipeWithConstructorParameter(""option"").createRecipeDescriptor();
        assertThat(d.getOptions().getFirst().getDisplayName()).isEqualTo(""Option"");
    }
}
",{}
Formal hello,Be formal. Be cool.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.junit.jupiter.api.Test;
import org.openrewrite.config.RecipeDescriptor;
import org.openrewrite.marker.RecipesThatMadeChanges;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.FindAndReplace;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.util.Optional;
import java.util.stream.Stream;

import static java.util.stream.Collectors.joining;
import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.test.SourceSpecs.text;

class RecipeListTest implements RewriteTest {

    @DocumentExample
    @Test
    void declarativeRecipeInCode() {
        rewriteRun(
          specs -> specs.recipe(new FormalHello(""jon"", ""jonathan""))
            .expectedCyclesThatMakeChanges(1).cycles(1),
          text(
            ""hi jon"",
            ""hello jonathan"",
            spec -> spec.afterRecipe(txt -> {
                Optional<Stream<String>> recipeNames = txt.getMarkers().findFirst(RecipesThatMadeChanges.class)
                  .map(recipes -> recipes.getRecipes().stream()
                    .map(stack -> stack.stream().map(Recipe::getDescriptor).map(RecipeDescriptor::getName)
                      .collect(joining(""->"")))
                  );

                assertThat(recipeNames).isPresent();
                assertThat(recipeNames.get()).containsExactly(
                  ""org.openrewrite.FormalHello->org.openrewrite.text.FindAndReplace"",
                  ""org.openrewrite.FormalHello->org.openrewrite.FormalHello$1""
                );
            })
          )
        );
    }
}

@EqualsAndHashCode(callSuper = false)
@Value
class FormalHello extends Recipe {
    @Option(example = ""TODO Provide a usage example for the docs"", displayName = ""Before name"",
            description = ""The name of a person being greeted"")
    String beforeName;

    @Option(example = ""TODO Provide a usage example for the docs"", displayName = ""After name"",
            description = ""The more formal name of the person."")
    String afterName;

    @Override
    public String getDisplayName() {
        return ""Formal hello"";
    }

    @Override
    public String getDescription() {
        return ""Be formal. Be cool."";
    }

    @Override
    public void buildRecipeList(RecipeList recipes) {
        recipes
          // TODO would these large option-set recipes
          //  benefit from builders?
          .recipe(new FindAndReplace(
            ""hi"", ""hello"", null, false, null,
            null, null, null)
          )
          .recipe(
            ""Say my name, say my name"",
            ""It's late and I'm making bad jokes."",
            new PlainTextVisitor<>() {
                @Override
                public PlainText visitText(PlainText text, ExecutionContext ctx) {
                    return text.withText(text.getText().replace(beforeName, afterName));
                }
            }
          );
    }
}
","{
  ""beforeName"": ""String field"",
  ""afterName"": ""String field""
}"
Test delegate recipe,Test onComplete with delegate recipe.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import org.junit.jupiter.api.Test;
import org.openrewrite.table.SourcesFileResults;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.test.TypeValidation;
import org.openrewrite.text.FindAndReplace;

import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.test.SourceSpecs.text;

class RecipeRunTest implements RewriteTest {
    @DocumentExample
    @Test
    void printDatatable() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new FindAndReplace(""replace_me"", ""replacement"", null, null, null, null, null, null))
            .afterRecipe(recipeRun -> {
                StringBuilder output = new StringBuilder();
                final String dataTableName = SourcesFileResults.class.getName();
                RecipeRun.exportCsv(new InMemoryExecutionContext(), recipeRun.getDataTable(dataTableName),
                  s -> output.append(s).append(""\n""), recipeRun.getDataTableRows(dataTableName));
                assertThat(output.toString()).contains(""org.openrewrite.text.FindAndReplace"");
            }), text(
                """"""
            replace_me
            """""",
                """"""
            replacement
            """""" ));
    }


    @Test
    void delegateRecipeWithOnComplete() {
        ExecutionContext ctx = new InMemoryExecutionContext();
        rewriteRun(recipeSpec -> recipeSpec.recipe(new DelegatingRecipe()).executionContext(ctx).typeValidationOptions(TypeValidation.none()));
        assertThat(ctx.<String>getMessage(""org.openrewrite.recipe.oncomplete"")).isEqualTo(""with delegate recipe."");
    }

    public static class DelegatingRecipe extends Recipe implements Recipe.DelegatingRecipe{

        @Override
        public String getDisplayName() {
            return ""Test delegate recipe"";
        }

        @Override
        public String getDescription() {
            return ""Test onComplete with delegate recipe."";
        }

        @Override
        public Recipe getDelegate() {
            return new Recipe() {
                @Override
                public String getDisplayName() {
                    return ""Actual recipe"";
                }

                @Override
                public String getDescription() {
                    return ""Actual recipe with onComplete."";
                }

                @Override
                public void onComplete(ExecutionContext ctx) {
                    ctx.putMessage(""org.openrewrite.recipe.oncomplete"", ""with delegate recipe."");
                }
            };
        }
    }
}
",{}
CustomEstimatedEffortRecipe,NoArgRecipe.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.marker.AlreadyReplaced;
import org.openrewrite.marker.GitProvenance;
import org.openrewrite.table.DistinctGitProvenance;
import org.openrewrite.table.RecipeRunStats;
import org.openrewrite.table.SourcesFileResults;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.*;

import java.nio.file.Path;
import java.time.Duration;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.marker.GitProvenance.AutoCRLF.False;
import static org.openrewrite.marker.GitProvenance.EOL.Native;
import static org.openrewrite.test.SourceSpecs.text;

class RecipeEstimatedEffortTest implements RewriteTest {
    private static final Long EXPECTED_DEFAULT_ESTIMATED_EFFORT = 300L;
    private static final Long EXPECTED_CUSTOM_ESTIMATED_EFFORT = 900L;

    @DocumentExample
    @Test
    void defaultEstimatedEffortForRecipeThatChangesSourceFiles() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new FindAndReplace(""replace_me"", ""replacement"", null, null, null, null, null, null))
            .dataTable(SourcesFileResults.Row.class, rows -> assertEstimatedEffortInFirstRowOfSourceFileResults(rows, EXPECTED_DEFAULT_ESTIMATED_EFFORT)),
          text(
            """"""
              replace_me
              """""",
            """"""
              replacement
              """"""
          ));
    }

    @Test
    void zeroEstimatedEffortForRecipeThatDoesNotGenerateSourcesFileResults() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(Recipe.noop())
            .afterRecipe(recipeRun -> assertThat(recipeRun.getDataTables()).isEmpty())
        );
    }

    @Test
    void zeroEstimatedEffortForRecipeThatOnlyCreatesCustomDataTable() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new FindGitProvenance())
            .afterRecipe(recipeRun -> {
                  assertThat(recipeRun.getDataTables()).hasSize(2);
                  assertThat(recipeRun.getDataTable(DistinctGitProvenance.class.getName())).isNotNull();
                  assertThat(recipeRun.getDataTable(RecipeRunStats.class.getName())).isNotNull();
                  assertThat(recipeRun.getDataTable(SourcesFileResults.class.getName())).isNull();
              }
            ),
          text(
            ""Hello, World!"",
            spec -> spec.markers(new GitProvenance(Tree.randomId(), ""https://github.com/openrewrite/rewrite"",
              ""main"", ""1234567"", False, Native, emptyList()))
          )
        );
    }

    @Test
    void customEstimatedEffortForRecipeThatChangesSourceFiles() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new CustomEstimatedEffortAppendToTextRecipe(""before"", ""after""))
            .dataTable(SourcesFileResults.Row.class, rows -> assertEstimatedEffortInFirstRowOfSourceFileResults(rows, EXPECTED_CUSTOM_ESTIMATED_EFFORT)),
          text(
            """"""
              before
              """""",
            """"""
              beforeafter
              """"""
          ));
    }

    @Test
    void defaultEstimatedEffortForRecipeThatGeneratesSourceFiles() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new CreateTextFile(""foo"", ""manifest.txt"", false))
            .dataTable(SourcesFileResults.Row.class, rows -> assertEstimatedEffortInFirstRowOfSourceFileResults(rows, EXPECTED_DEFAULT_ESTIMATED_EFFORT)),
          text(
            null,
            ""foo"",
            spec -> spec.path(""manifest.txt"")
          ));
    }

    @Test
    void customEstimatedEffortForRecipeThatGeneratesSourceFiles() {
        rewriteRun(
          recipeSpec -> recipeSpec.recipe(new CustomEstimatedEffortCreateTextFile(""foo"", ""manifest.txt"", false))
            .dataTable(SourcesFileResults.Row.class, rows -> assertEstimatedEffortInFirstRowOfSourceFileResults(rows, EXPECTED_CUSTOM_ESTIMATED_EFFORT)),
          text(
            null,
            ""foo"",
            spec -> spec.path(""manifest.txt"")
          ));
    }

    private static void assertEstimatedEffortInFirstRowOfSourceFileResults(List<SourcesFileResults.Row> rows, Long expectedEstimatedEffort) {
        assertThat(rows)
          .first()
          .extracting(SourcesFileResults.Row::getEstimatedTimeSaving)
          .isEqualTo(expectedEstimatedEffort);
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class CustomEstimatedEffortAppendToTextRecipe extends Recipe {
        @Option(displayName = ""Search term"",
          example = ""before"",
          description = ""The text to be searched for"")
        String searchTerm;

        @Option(displayName = ""Appended text"",
          example = ""after"",
          description = ""The text to be appended if the search term can found"")
        String appendText;

        @Override
        public String getDisplayName() {
            return ""CustomEstimatedEffortRecipe"";
        }

        @Override
        public String getDescription() {
            return ""NoArgRecipe."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new PlainTextVisitor<>() {
                @Override
                public PlainText visitText(PlainText text, ExecutionContext ctx) {
                    for (AlreadyReplaced alreadyReplaced : text.getMarkers().findAll(AlreadyReplaced.class)) {
                        if (Objects.equals(searchTerm, alreadyReplaced.getFind()) &&
                          Objects.equals(appendText, alreadyReplaced.getReplace())) {
                            return text;
                        }
                    }

                    if (text.getText().contains(searchTerm)) {
                        return text
                          .withText(text.getText() + appendText)
                          .withMarkers(text.getMarkers().add(new AlreadyReplaced(randomId(), searchTerm, appendText)));
                    }
                    return super.visitText(text, ctx);
                }
            };
        }

        @Override
        public Duration getEstimatedEffortPerOccurrence() {
            return Duration.ofMinutes(15);
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    private static class CustomEstimatedEffortCreateTextFile extends ScanningRecipe<AtomicBoolean> {
        @Option(displayName = ""File contents"",
          description = ""Multiline text content for the file."",
          example = ""Some text."")
        String fileContents;

        @Option(displayName = ""Relative file path"",
          description = ""File path of new file."",
          example = ""foo/bar/baz.txt"")
        String relativeFileName;

        @Option(displayName = ""Overwrite existing file"",
          description = ""If there is an existing file, should it be overwritten."",
          required = false)
        @Nullable
        Boolean overwriteExisting;

        @Override
        public String getDisplayName() {
            return ""Create text file"";
        }

        @Override
        public String getDescription() {
            return ""Creates a new plain text file."";
        }

        @Override
        public AtomicBoolean getInitialValue(ExecutionContext ctx) {
            return new AtomicBoolean(true);
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
            return new CreateFileVisitor(Path.of(relativeFileName), shouldCreate);
        }

        @Override
        public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
            if (shouldCreate.get()) {
                return PlainTextParser.builder().build().parse(fileContents)
                  .map(brandNewFile -> (SourceFile) brandNewFile.withSourcePath(Path.of(relativeFileName)))
                  .collect(toList());
            }
            return emptyList();
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
            Path path = Path.of(relativeFileName);
            return new TreeVisitor<SourceFile, ExecutionContext>() {
                @Override
                public SourceFile visit(@Nullable Tree tree, ExecutionContext ctx) {
                    SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                    if (Boolean.TRUE.equals(overwriteExisting) && path.equals(sourceFile.getSourcePath())) {
                        if (sourceFile instanceof PlainText text) {
                            return text.withText(fileContents);
                        }
                        PlainText plainText = PlainText.builder()
                          .id(sourceFile.getId())
                          .sourcePath(sourceFile.getSourcePath())
                          .fileAttributes(sourceFile.getFileAttributes())
                          .charsetBomMarked(sourceFile.isCharsetBomMarked())
                          .text(fileContents)
                          .build();
                        if (sourceFile.getCharset() != null) {
                            return plainText.withCharset(sourceFile.getCharset());
                        }
                        return plainText;
                    }
                    return sourceFile;
                }
            };
        }

        @Override
        public Duration getEstimatedEffortPerOccurrence() {
            return Duration.ofMinutes(15);
        }
    }
}
","{
  ""searchTerm"": ""String field"",
  ""appendText"": ""String field"",
  ""fileContents"": ""String field"",
  ""relativeFileName"": ""String field""
}"
Throw exception,Throws an exception in the scanning phase.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.config.Environment;
import org.openrewrite.config.RecipeDescriptor;
import org.openrewrite.config.YamlResourceLoader;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.RecipesThatMadeChanges;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.FindAndReplace;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.io.ByteArrayInputStream;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.List;
import java.util.Properties;
import java.util.UUID;

import static java.util.Objects.requireNonNull;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;
import static org.openrewrite.Recipe.noop;
import static org.openrewrite.test.RewriteTest.toRecipe;
import static org.openrewrite.test.SourceSpecs.text;

class RecipeLifecycleTest implements RewriteTest {

    @DocumentExample
    @Test
    void generateFile() {
        rewriteRun(
          spec -> spec
            .recipe(toRecipe()
              .withGenerator(() -> List.of(PlainText.builder().sourcePath(Path.of(""test.txt"")).text(""test"").build()))
              .withName(""test.GeneratingRecipe"")
              .withMaxCycles(1)
            )
            .afterRecipe(run -> assertThat(run.getChangeset().getAllResults().stream()
              .map(r -> r.getRecipeDescriptorsThatMadeChanges().getFirst().getName()))
              .containsOnly(""test.GeneratingRecipe"")),
          text(null, ""test"", spec -> spec.path(""test.txt""))
        );
    }

    @Test
    void panic() {
        var ctx = new InMemoryExecutionContext();
        ctx.putMessage(Recipe.PANIC, true);

        //noinspection NullableProblems
        rewriteRun(
          spec -> spec.recipe(toRecipe(() -> new TreeVisitor<>() {
              @Override
              public Tree visit(Tree tree, ExecutionContext ctx) {
                  fail(""Should never have reached a visit method"");
                  return tree;
              }
          })).executionContext(ctx),
          text(""hello"")
        );
    }

    @Test
    void twoGeneratingRecipesCreateOnlyOneFile() {
        rewriteRun(spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe
              displayName: Create twice
              description: Scanning recipes later in the stack should scan files created by earlier recipes, avoiding duplicate file creation.
              recipeList:
                - org.openrewrite.text.CreateTextFile:
                    fileContents: first
                    relativeFileName: test.txt
                    overwriteExisting: false
                - org.openrewrite.text.CreateTextFile:
                    fileContents: second
                    relativeFileName: test.txt
                    overwriteExisting: false
              """""",
            ""test.recipe""
          ),
          text(null, ""first"", spec -> spec.path(""test.txt"")));
    }

    @Test
    void errorDuringScanningPhase() {
        rewriteRun(
          spec -> spec.recipe(new ErrorDuringScanningPhase())
            .executionContext(new InMemoryExecutionContext()),
          text(""hello"",
            ""hello"",
            spec -> spec.afterRecipe(t -> assertThat(t.getMarkers().findFirst(RecipesThatMadeChanges.class))
              .isNotEmpty()
              .get()
              .as(""Exception thrown in the scanning phase should record the responsible recipe"")
              .matches(m -> ""org.openrewrite.RecipeLifecycleTest$ErrorDuringScanningPhase"".equals(m.getRecipes().iterator().next().getFirst().getDescriptor().getName()))
            )
          ));
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class ErrorDuringScanningPhase extends ScanningRecipe<Integer> {

        @Override
        public Integer getInitialValue(ExecutionContext ctx) {
            return 0;
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getScanner(Integer acc) {
            //noinspection NullableProblems
            return new TreeVisitor<>() {
                @Override
                public Tree visit(Tree tree, ExecutionContext ctx) {
                    if (tree.getMarkers().findFirst(RecipesThatMadeChanges.class).isPresent()) {
                        return tree;
                    }
                    throw new IllegalStateException("""");
                }
            };
        }

        @Override
        public String getDisplayName() {
            return ""Throw exception"";
        }

        @Override
        public String getDescription() {
            return ""Throws an exception in the scanning phase."";
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class DeleteFirst extends Recipe {

        @Override
        public String getDisplayName() {
            return ""Delete a file"";
        }

        @Override
        public String getDescription() {
            return ""Deletes a file early on in the recipe pipeline. "" +
                   ""Subsequent recipes should not be passed a null source file."";
        }

        @Override
        public List<Recipe> getRecipeList() {
            return List.of(
              new DeleteSourceFiles(""test.txt""),
              new FindAndReplace(""test"", """", null, null, null, null, null, null));
        }
    }

    @Test
    void deletionWithSubsequentRecipes() {
        rewriteRun(
          spec -> spec.recipe(new DeleteFirst()),
          text(""test"", null, spec -> spec.path(""test.txt""))
        );
    }

    @Test
    void deleteFileByReturningNullFromVisit() {
        rewriteRun(
          spec -> spec.recipe(toRecipe(() -> new PlainTextVisitor<>() {
              @Override
              public @Nullable PlainText visit(@Nullable Tree tree, ExecutionContext ctx) {
                  return null;
              }
          })),
          text(
            ""hello"",
            (String) null
          )
        );
    }

    class FooVisitor<P> extends TreeVisitor<FooSource, P> {
        @Override
        public @Nullable FooSource preVisit(FooSource tree, P p) {
            //noinspection ConstantConditions
            if (!(tree instanceof FooSource)) {
                throw new RuntimeException(""tree is not a FooSource"");
            }
            return super.preVisit(tree, p);
        }

        @Override
        public @Nullable FooSource postVisit(FooSource tree, P p) {
            //noinspection ConstantConditions
            if (!(tree instanceof FooSource)) {
                throw new RuntimeException(""tree is not a FooSource"");
            }
            return super.postVisit(tree, p);
        }
    }

    class FooSource implements SourceFile {
        @Override
        public Path getSourcePath() {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends SourceFile> T withSourcePath(Path path) {
            throw new UnsupportedOperationException();
        }

        @Override
        public @Nullable Charset getCharset() {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends SourceFile> T withCharset(Charset charset) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean isCharsetBomMarked() {
            return false;
        }

        @Override
        public <T extends SourceFile> T withCharsetBomMarked(boolean marked) {
            throw new UnsupportedOperationException();
        }

        @Override
        public @Nullable Checksum getChecksum() {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends SourceFile> T withChecksum(@Nullable Checksum checksum) {
            throw new UnsupportedOperationException();
        }

        @Override
        public @Nullable FileAttributes getFileAttributes() {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends SourceFile> T withFileAttributes(@Nullable FileAttributes fileAttributes) {
            throw new UnsupportedOperationException();
        }

        @Override
        public UUID getId() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Markers getMarkers() {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends Tree> T withMarkers(Markers markers) {
            throw new UnsupportedOperationException();
        }

        @Override
        public <T extends Tree> T withId(UUID id) {
            throw new UnsupportedOperationException();
        }

        @Override
        public <P> boolean isAcceptable(TreeVisitor<?, P> v, P p) {
            return v.isAdaptableTo(FooVisitor.class);
        }
    }

    @Test
    void accurateReportingOfRecipesMakingChanges() {
        rewriteRun(
          spec -> spec
            .recipes(testRecipe(""Change1""), noop(), testRecipe(""Change2""))
            .validateRecipeSerialization(false)
            .afterRecipe(run -> {
                var changes = run.getChangeset().getAllResults();
                assertThat(changes).hasSize(1);
                assertThat(changes.getFirst().getRecipeDescriptorsThatMadeChanges().stream().map(RecipeDescriptor::getName))
                  .containsExactlyInAnyOrder(""Change1"", ""Change2"");
            }),
          text(
            ""Hello"",
            ""Change2Change1Hello""
          )
        );
    }

    @Issue(""https://github.com/openrewrite/rewrite/issues/389"")
    @Test
    void sourceFilesAcceptOnlyApplicableVisitors() {
        var sources = List.of(new FooSource(), PlainText.builder().sourcePath(Path.of(""test.txt"")).text(""test"").build());
        var fooVisitor = new FooVisitor<ExecutionContext>();
        var textVisitor = new PlainTextVisitor<ExecutionContext>();
        var ctx = new InMemoryExecutionContext();

        for (SourceFile source : sources) {
            fooVisitor.visit(source, ctx);
            textVisitor.visit(source, ctx);
        }
    }

    private Recipe testRecipe(@Language(""markdown"") String name) {
        return toRecipe(() -> new PlainTextVisitor<>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                if (!text.getText().contains(name)) {
                    return text.withText(name + text.getText());
                }
                return super.visitText(text, ctx);
            }
        }).withName(name);
    }

    @Test
    void canCallImperativeRecipeWithoutArgsFromDeclarative() {
        rewriteRun(spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - org.openrewrite.NoArgRecipe
              """""",
            ""test.recipe""
          ),
          text(""Hi"", ""NoArgRecipeHi""));
    }

    @Test
    void canCallImperativeRecipeWithUnnecessaryArgsFromDeclarativeInTests() {
        rewriteRun(spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - org.openrewrite.NoArgRecipe:
                    foo: bar
              """""",
            ""test.recipe""
          ),
          text(""Hi"", ""NoArgRecipeHi"")
        );
    }

    @Test
    void canCallRecipeWithNoExplicitConstructor() {
        rewriteRun(spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - org.openrewrite.DefaultConstructorRecipe
              """""",
            ""test.recipe""
          ),
          text(""Hi"", ""DefaultConstructorRecipeHi""));
    }

    @Test
    void declarativeRecipeChain() {
        rewriteRun(spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.a
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - test.recipe.b
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.b
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - test.recipe.c
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.c
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - org.openrewrite.NoArgRecipe
              """""",
            ""test.recipe.a""
          ),
          text(""Hi"", ""NoArgRecipeHi""));
    }

    @Test
    void declarativeRecipeChainAcrossFiles() {
        rewriteRun(spec -> spec.recipe(Environment.builder()
            .load(new YamlResourceLoader(new ByteArrayInputStream(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.c
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - org.openrewrite.NoArgRecipe
              """""".getBytes()),
              URI.create(""rewrite.yml""), new Properties()))
            .load(new YamlResourceLoader(new ByteArrayInputStream(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.b
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - test.recipe.c
              """""".getBytes()),
              URI.create(""rewrite.yml""), new Properties()))
            .load(new YamlResourceLoader(new ByteArrayInputStream(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: test.recipe.a
              displayName: Test Recipe
              description: Test Recipe.
              recipeList:
                - test.recipe.b
              """""".getBytes()),
              URI.create(""rewrite.yml""), new Properties()))
            .build()
            .activateRecipes(""test.recipe.a"")),
          text(""Hi"", ""NoArgRecipeHi""));
    }

    @Test
    void declarativeRecipeChainFromResources() {
        rewriteRun(spec -> spec.recipeFromResources(""test.declarative.sample.a""),
          text(""Hi"", ""after""));
    }

    @Test
    void declarativeRecipeChainFromResourcesIncludesImperativeRecipesInDescriptors() {
        rewriteRun(spec -> spec.recipeFromResources(""test.declarative.sample.a"")
            .afterRecipe(recipeRun -> assertThat(recipeRun.getChangeset().getAllResults().getFirst()
              .getRecipeDescriptorsThatMadeChanges().getFirst().getRecipeList().getFirst()
              .getDisplayName()).isEqualTo(""Change text"")),
          text(""Hi"", ""after""));
    }

    @Test
    void declarativeRecipeChainFromResourcesLongList() {
        rewriteRun(spec -> spec.recipe(Environment.builder()
            .load(new YamlResourceLoader(requireNonNull(RecipeLifecycleTest.class.getResourceAsStream(""/META-INF/rewrite/test-sample-a.yml"")), URI.create(""rewrite.yml""), new Properties()))
            .load(new YamlResourceLoader(requireNonNull(RecipeLifecycleTest.class.getResourceAsStream(""/META-INF/rewrite/test-sample-b.yml"")), URI.create(""rewrite.yml""), new Properties()))
            .build()
            .activateRecipes(""test.declarative.sample.a"")),
          text(""Hi"", ""after""));
    }
}

@SuppressWarnings(""unused"") // referenced in yaml
class DefaultConstructorRecipe extends Recipe {
    @Override
    public String getDisplayName() {
        return ""DefaultConstructorRecipe"";
    }

    @Override
    public String getDescription() {
        return ""DefaultConstructorRecipe."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PlainTextVisitor<>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                if (!text.getText().contains(getDisplayName())) {
                    return text.withText(getDisplayName() + text.getText());
                }
                return super.visitText(text, ctx);
            }
        };
    }
}

@NoArgsConstructor // referenced in yaml
@SuppressWarnings(""unused"")
class NoArgRecipe extends Recipe {
    @Override
    public String getDisplayName() {
        return ""NoArgRecipe"";
    }

    @Override
    public String getDescription() {
        return ""NoArgRecipe."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PlainTextVisitor<>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                if (!text.getText().contains(getDisplayName())) {
                    return text.withText(getDisplayName() + text.getText());
                }
                return super.visitText(text, ctx);
            }
        };
    }
}
",{}
Validate nullable JSpecify annotations,NullUtils should see these annotations.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class RecipeValidationTest {

    @Test
    void validate() {
        assertThat(new JSpecifyAnnotatedRecipeOptions(null).validate().isValid())
          .isTrue();
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    public static class JSpecifyAnnotatedRecipeOptions extends Recipe {

        @Option(displayName = ""An optional field"",
          description = ""Something that can be null."",
          required = false,
          example = ""Anything"")
        @Nullable
        String optionalField;

        @Override
        public String getDisplayName() {
            return ""Validate nullable JSpecify annotations"";
        }

        @Override
        public String getDescription() {
            return ""NullUtils should see these annotations."";
        }
    }
}
",{}
Recipe with estimatedEffortPerOccurrence,A fancy description.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;

import java.time.Duration;

import static org.assertj.core.api.Assertions.assertThat;

class RecipeSerializerTest {

    @Test
    void shouldBeAbleToSerializeAndDeserializeEstimatedEffortPerOccurrence() {
        RecipeSerializer serializer = new RecipeSerializer();
        final var recipe = new RecipeWithEstimatedEffortPerOccurrence(Duration.ofDays(1));
        final Recipe read = serializer.read(serializer.write(recipe));
        assertThat(read.getEstimatedEffortPerOccurrence()).isEqualTo(Duration.ofDays(1));
    }

    @NullMarked
    static class RecipeWithEstimatedEffortPerOccurrence extends Recipe {
        @Nullable
        private Duration estimatedEffortPerOccurrence;

        public RecipeWithEstimatedEffortPerOccurrence() {
            this(null);
        }

        public RecipeWithEstimatedEffortPerOccurrence(@Nullable Duration estimatedEffortPerOccurrence) {
            this.estimatedEffortPerOccurrence = estimatedEffortPerOccurrence;
        }

        @Override
        public String getDisplayName() {
            return ""Recipe with estimatedEffortPerOccurrence"";
        }

        @Override
        public String getDescription() {
            return ""A fancy description."";
        }

        @Override
        public @Nullable Duration getEstimatedEffortPerOccurrence() {
            return this.estimatedEffortPerOccurrence;
        }

        public void setEstimatedEffortPerOccurrence(@Nullable Duration estimatedEffortPerOccurrence) {
            this.estimatedEffortPerOccurrence = estimatedEffortPerOccurrence;
        }
    }
}
",{}
RecipeWithBadStaticInitializer,,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.test.RewriteTest;

import java.io.ByteArrayInputStream;
import java.net.URI;
import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.openrewrite.test.SourceSpecs.text;

class YamlResourceLoaderTest implements RewriteTest {

    @BeforeAll
    static void beforeAll() {
        try {
            // Instantiate once to throw a ExceptionInInitializerError and subsequent
            // instantiations will throw a NoClassDefFoundError.
            new RecipeWithBadStaticInitializer();
        } catch (ExceptionInInitializerError ignored) {
        }
    }

    @DocumentExample
    @Test
    void recipeExamples() {
        Environment env = Environment.builder()
          .load(new YamlResourceLoader(new ByteArrayInputStream(
            //language=yml
            """"""
              type: specs.openrewrite.org/v1beta/recipe
              name: test.ChangeTextToHello
              displayName: Change text to hello
              recipeList:
                  - org.openrewrite.text.ChangeText:
                      toText: Hello!
              """""".getBytes()
          ), URI.create(""rewrite.yml""), new Properties()))
          .load(new YamlResourceLoader(new ByteArrayInputStream(
            //language=yml
            """"""
              type: specs.openrewrite.org/v1beta/example
              recipeName: test.ChangeTextToHello
              examples:
                - description: ""Change World to Hello in a text file""
                  sources:
                    - before: ""World""
                      after: ""Hello!""
                      path: ""1.txt""
                      language: ""text""
                    - before: ""World 2""
                      after: ""Hello 2!""
                      path: ""2.txt""
                      language: ""text""
                - description: ""Change World to Hello in a java file""
                  parameters:
                    - arg0
                    - 1
                  sources:
                    - before: |
                        public class A {
                            void method() {
                                System.out.println(""World"");
                            }
                        }
                      after: |
                        public class A {
                            void method() {
                                System.out.println(""Hello!"");
                            }
                        }
                      language: java
              """""".getBytes()
          ), URI.create(""attribution/test.ChangeTextToHello.yml""), new Properties()))
          .build();

        Collection<Recipe> recipes = env.listRecipes();
        assertThat(recipes).singleElement().satisfies(r -> {
            assertThat(r.getExamples()).hasSize(2);
            assertThat(r.getExamples()).first().satisfies(e -> {
                assertThat(e.getDescription()).isEqualTo(""Change World to Hello in a text file"");
                assertThat(e.getSources()).hasSize(2);
                assertThat(e.getSources()).first().satisfies(s -> {
                      assertThat(s.getBefore()).isEqualTo(""World"");
                      assertThat(s.getAfter()).isEqualTo(""Hello!"");
                      assertThat(s.getPath()).isEqualTo(""1.txt"");
                      assertThat(s.getLanguage()).isEqualTo(""text"");
                  }
                );

                assertThat(e.getSources().get(1)).satisfies(s -> {
                      assertThat(s.getBefore()).isEqualTo(""World 2"");
                      assertThat(s.getAfter()).isEqualTo(""Hello 2!"");
                      assertThat(s.getPath()).isEqualTo(""2.txt"");
                      assertThat(s.getLanguage()).isEqualTo(""text"");
                  }
                );
            });
            assertThat(r.getExamples().get(1)).satisfies(e -> {
                assertThat(e.getDescription()).isEqualTo(""Change World to Hello in a java file"");

                assertThat(e.getParameters()).hasSize(2);
                assertThat(e.getParameters().getFirst()).isEqualTo(""arg0"");
                assertThat(e.getParameters().get(1)).isEqualTo(""1"");

                assertThat(e.getSources()).hasSize(1);
                assertThat(e.getSources()).first().satisfies(s -> {
                    //language=java
                    assertThat(s.getBefore()).isEqualTo(""""""
                      public class A {
                          void method() {
                              System.out.println(""World"");
                          }
                      }
                      """""");
                    //language=java
                    assertThat(s.getAfter()).isEqualTo(""""""
                      public class A {
                          void method() {
                              System.out.println(""Hello!"");
                          }
                      }
                      """""");
                    assertThat(s.getPath()).isNull();
                    assertThat(s.getLanguage()).isEqualTo(""java"");
                });
            });
        });

        Collection<RecipeDescriptor> recipeDescriptors = env.listRecipeDescriptors();
        assertThat(recipeDescriptors).singleElement().satisfies(descriptor -> {
            List<RecipeExample> descriptorExamples = descriptor.getExamples();
            assertThat(descriptorExamples).containsExactlyElementsOf(recipes.iterator().next().getExamples());
        });
    }

    @Test
    void dataTables() {
        Environment env = Environment.builder()
          .load(new YamlResourceLoader(new ByteArrayInputStream(
            //language=yml
            """"""
              type: specs.openrewrite.org/v1beta/recipe
              name: test.ChangeTextToHello
              displayName: Change text to hello
              recipeList:
                  - org.openrewrite.text.ChangeText:
                      toText: Hello!
              """""".getBytes()
          ), URI.create(""rewrite.yml""), new Properties()))
          .build();

        Collection<RecipeDescriptor> recipeDescriptors = env.listRecipeDescriptors();
        assertThat(recipeDescriptors).hasSize(1);
        assertThat(recipeDescriptors.iterator().next().getDataTables()).isNotEmpty();
    }

    @Test
    void maintainers() {
        Environment env = Environment.builder()
          .load(new YamlResourceLoader(new ByteArrayInputStream(
            //language=yml
            """"""
              type: specs.openrewrite.org/v1beta/recipe
              name: test.ChangeTextToHello
              displayName: Change text to hello
              recipeList:
                  - org.openrewrite.text.ChangeText:
                      toText: Hello!
              maintainers:
                  - maintainer: Sam
                    logo: https://sam.com/logo.svg
                  - maintainer: Jon
              """""".getBytes()
          ), URI.create(""rewrite.yml""), new Properties()))
          .build();

        Collection<RecipeDescriptor> recipeDescriptors = env.listRecipeDescriptors();
        assertThat(recipeDescriptors).hasSize(1);
        RecipeDescriptor descriptor = recipeDescriptors.iterator().next();
        assertThat(descriptor.getDataTables()).isNotEmpty();
        assertThat(descriptor.getMaintainers()).hasSize(2);
        Maintainer sam = descriptor.getMaintainers().getFirst();
        assertThat(sam.getMaintainer()).isEqualTo(""Sam"");
        assertThat(sam.getLogo()).isNotNull();
        assertThat(sam.getLogo().toString()).isEqualTo(""https://sam.com/logo.svg"");
        Maintainer jon = descriptor.getMaintainers().get(1);
        assertThat(jon.getMaintainer()).isEqualTo(""Jon"");
        assertThat(jon.getLogo()).isNull();
    }

    @Test
    void caseInsensitiveEnums() {
        rewriteRun(
          spec -> spec.recipeFromYaml(
            //language=yml
            """"""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: org.openrewrite.gradle.testCaseInsensitiveEnumInYaml
              displayName: test Enum in yaml
              description: test Enum in yaml.
              recipeList:
                - org.openrewrite.text.AppendToTextFile:
                    relativeFileName: ""file.txt""
                    content: "" World!""
                    preamble: ""preamble""
                    appendNewline : false
                    existingFileStrategy: ""cOnTiNuE""
              """""",
            ""org.openrewrite.gradle.testCaseInsensitiveEnumInYaml""
          ),
          text(""Hello"", ""Hello World!"")
        );
    }

    @Test
    void loadRecipeWithRecipeDataStringThatThrowsNoClassDefFoundError() {
        assertRecipeWithRecipeDataThatThrowsNoClassDefFoundError(
          RecipeWithBadStaticInitializer.class.getName());
    }

    @Test
    void loadRecipeWithRecipeDataMapThatThrowsNoClassDefFoundError() {
        assertRecipeWithRecipeDataThatThrowsNoClassDefFoundError(
          Map.of(RecipeWithBadStaticInitializer.class.getName(), Map.of()));
    }

    private void assertRecipeWithRecipeDataThatThrowsNoClassDefFoundError(Object recipeData) {
        final List<Validated<Object>> invalidRecipes = new ArrayList<>();
        YamlResourceLoader resourceLoader = createYamlResourceLoader();

        resourceLoader.loadRecipe(
          ""org.company.CustomRecipe"",
          0,
          recipeData,
          recipe -> {
          },
          recipe -> {
          },
          invalidRecipes::add);

        assertEquals(1, invalidRecipes.size());
    }

    private YamlResourceLoader createYamlResourceLoader() {
        return new YamlResourceLoader(
          new ByteArrayInputStream(""type: specs.openrewrite.org/v1beta/recipe"".getBytes()),
          URI.create(""rewrite.yml""),
          new Properties());
    }

    private static class RecipeWithBadStaticInitializer extends Recipe {
        // Explicitly fail static initialization
        static final int val = 1 / 0;

        @Override
        public String getDisplayName() {
            return """";
        }

        @Override
        public String getDescription() {
            return """";
        }
    }
}
",{}
Executes recipes multiple times,Executes recipes multiple times.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.ChangeText;
import org.openrewrite.text.Find;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.net.URI;
import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptySet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.openrewrite.test.RewriteTest.toRecipe;
import static org.openrewrite.test.SourceSpecs.text;

class DeclarativeRecipeTest implements RewriteTest {

    @DocumentExample
    @Test
    void precondition() {
        rewriteRun(
          spec -> {
              spec.validateRecipeSerialization(false);
              DeclarativeRecipe dr = new DeclarativeRecipe(""test"", ""test"", ""test"", emptySet(),
                null, URI.create(""null""), true, emptyList());
              dr.addPrecondition(
                toRecipe(() -> new PlainTextVisitor<>() {
                    @Override
                    public PlainText visitText(PlainText text, ExecutionContext ctx) {
                        if (""1"".equals(text.getText())) {
                            return SearchResult.found(text);
                        }
                        return text;
                    }
                })
              );
              dr.addUninitialized(
                new ChangeText(""2"")
              );
              dr.addUninitialized(
                new ChangeText(""3"")
              );
              dr.initialize(List.of());
              spec.recipe(dr);
          },
          text(""1"", ""3""),
          text(""2"")
        );
    }

    @Test
    void addingPreconditionsWithOptions() {
        DeclarativeRecipe dr = new DeclarativeRecipe(""test"", ""test"", ""test"", emptySet(),
          null, URI.create(""dummy""), true, emptyList());
        dr.addPrecondition(
          toRecipe(() -> new PlainTextVisitor<>() {
              @Override
              public PlainText visitText(PlainText text, ExecutionContext ctx) {
                  if (""1"".equals(text.getText())) {
                      return SearchResult.found(text);
                  }
                  return text;
              }
          })
        );
        dr.addUninitialized(
          new ChangeText(""2"")
        );
        dr.addUninitialized(
          new ChangeText(""3"")
        );
        dr.initialize(List.of());
        assertThat(dr.getDescriptor().getRecipeList())
          .hasSize(3) // precondition + 2 recipes with options
          .flatExtracting(RecipeDescriptor::getOptions)
          .hasSize(2)
          .extracting(OptionDescriptor::getName)
          .containsOnly(""toText"");
    }

    @Test
    void uninitializedFailsValidation() {
        DeclarativeRecipe dr = new DeclarativeRecipe(""test"", ""test"", ""test"", emptySet(),
          null, URI.create(""dummy""), true, emptyList());
        dr.addUninitializedPrecondition(
          toRecipe(() -> new PlainTextVisitor<>() {
              @Override
              public PlainText visitText(PlainText text, ExecutionContext ctx) {
                  if (""1"".equals(text.getText())) {
                      return SearchResult.found(text);
                  }
                  return text;
              }
          })
        );
        dr.addUninitialized(
          new ChangeText(""2"")
        );
        dr.addUninitialized(
          new ChangeText(""3"")
        );
        Validated<Object> validation = dr.validate();
        assertThat(validation.isValid()).isFalse();
        assertThat(validation.failures().size()).isEqualTo(2);
        assertThat(validation.failures().getFirst().getProperty()).isEqualTo(""initialization"");
    }

    @Test
    void uninitializedWithInitializedRecipesPassesValidation() {
        DeclarativeRecipe dr = new DeclarativeRecipe(""test"", ""test"", ""test"", emptySet(),
          null, URI.create(""dummy""), true, emptyList());
        dr.setPreconditions(
          List.of(
            toRecipe(() -> new PlainTextVisitor<>() {
                @Override
                public PlainText visitText(PlainText text, ExecutionContext ctx) {
                    if (""1"".equals(text.getText())) {
                        return SearchResult.found(text);
                    }
                    return text;
                }
            }))
        );
        dr.setRecipeList(List.of(
          new ChangeText(""2""),
          new ChangeText(""3"")
        ));
        Validated<Object> validation = dr.validate();
        assertThat(validation.isValid()).isTrue();
    }

    @Test
    void yamlPrecondition() {
        rewriteRun(
          spec -> spec.recipeFromYaml(""""""
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: org.openrewrite.PreconditionTest
            description: Test.
            preconditions:
              - org.openrewrite.text.Find:
                  find: 1
            recipeList:
              - org.openrewrite.text.ChangeText:
                 toText: 2
              - org.openrewrite.text.ChangeText:
                 toText: 3
            """""", ""org.openrewrite.PreconditionTest""),
          text(""1"", ""3""),
          text(""2"")
        );
    }

    @Test
    void yamlDeclarativeRecipeAsPrecondition() {
        rewriteRun(
          spec -> spec.recipeFromYaml(
            """"""
              type: specs.openrewrite.org/v1beta/recipe
              name: org.openrewrite.PreconditionTest
              description: Test.
              preconditions:
                - org.openrewrite.DeclarativePrecondition
              recipeList:
                - org.openrewrite.text.ChangeText:
                   toText: 3
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: org.openrewrite.DeclarativePrecondition
              recipeList:
                - org.openrewrite.text.Find:
                    find: 1
              """""",
            ""org.openrewrite.PreconditionTest""
          ),
          text(""1"", ""3""),
          text(""2"")
        );
    }

    @Test
    void orPreconditions() {
        // As documented https://docs.openrewrite.org/reference/yaml-format-reference#creating-or-preconditions-instead-of-and
        rewriteRun(
          spec -> spec.recipeFromYaml(
            """"""
              type: specs.openrewrite.org/v1beta/recipe
              name: org.sample.DoSomething
              description: Test.
              preconditions:
                - org.sample.FindAnyJson
              recipeList:
                - org.openrewrite.text.ChangeText:
                   toText: 2
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: org.sample.FindAnyJson
              recipeList:
                - org.openrewrite.FindSourceFiles:
                    filePattern: ""**/my.json""
                - org.openrewrite.FindSourceFiles:
                    filePattern: ""**/your.json""
                - org.openrewrite.FindSourceFiles:
                    filePattern: ""**/our.json""
              """""",
            ""org.sample.DoSomething""
          ),
          text(""1"", ""2"", spec -> spec.path(""a/my.json"")),
          text(""a"", spec -> spec.path(""a/not-my.json""))
        );
    }

    @Test
    void yamlPreconditionWithScanningRecipe() {
        rewriteRun(
          spec -> spec.recipeFromYaml(""""""
              ---
              type: specs.openrewrite.org/v1beta/recipe
              name: org.openrewrite.PreconditionTest
              description: Test.
              preconditions:
                - org.openrewrite.text.Find:
                    find: 1
              recipeList:
                - org.openrewrite.text.CreateTextFile:
                   relativeFileName: test.txt
                   fileContents: ""test""
              """""", ""org.openrewrite.PreconditionTest"")
            .afterRecipe(run -> assertThat(run.getChangeset().getAllResults()).anySatisfy(
              s -> {
                  //noinspection DataFlowIssue
                  assertThat(s.getAfter()).isNotNull();
                  assertThat(s.getAfter().getSourcePath()).isEqualTo(Path.of(""test.txt""));
              }
            ))
            .expectedCyclesThatMakeChanges(1),
          text(""1"")
        );
    }

    @Test
    void scanningPreconditionMet() {
        rewriteRun(
          spec -> spec.recipeFromYaml(""""""
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: org.openrewrite.ScanningPreconditionTest
            description: Test.
            preconditions:
              - org.openrewrite.search.RepositoryContainsFile:
                  filePattern: sam.txt
            recipeList:
              - org.openrewrite.text.FindAndReplace:
                  find: foo
                  replace: bar
            """""", ""org.openrewrite.ScanningPreconditionTest""),
          text(""sam"", spec -> spec.path(""sam.txt"")),
          text(""foo"", ""bar"")
        );
    }

    @Test
    void scanningPreconditionNotMet() {
        rewriteRun(
          spec -> spec.recipeFromYaml(""""""
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: org.openrewrite.ScanningPreconditionTest
            description: Test.
            preconditions:
              - org.openrewrite.search.RepositoryContainsFile:
                  filePattern: sam.txt
            recipeList:
              - org.openrewrite.text.FindAndReplace:
                  find: foo
                  replace: bar
            """""", ""org.openrewrite.ScanningPreconditionTest""),
          text(""foo"")
        );
    }

    @Test
    void preconditionOnNestedDeclarative() {
        rewriteRun(
          spec -> spec.recipeFromYaml(""""""
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: org.openrewrite.PreconditionOnDeclarative
            description: Test.
            preconditions:
              - org.openrewrite.text.Find:
                  find: foo
            recipeList:
              - org.openrewrite.DeclarativeExample
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: org.openrewrite.DeclarativeExample
            description: Test.
            recipeList:
              - org.openrewrite.text.FindAndReplace:
                  find: foo
                  replace: bar
            """""", ""org.openrewrite.PreconditionOnDeclarative""),
          text(""foo"", ""bar"")
        );
    }

    @Test
    void exposesUnderlyingDataTables() {
        DeclarativeRecipe dr = new DeclarativeRecipe(""org.openrewrite.DeclarativeDataTable"", ""declarative with data table"",
          ""test"", emptySet(), null, URI.create(""dummy""), true, emptyList());
        dr.addUninitialized(new Find(""sam"", null, null, null, null, null, null, null));
        dr.initialize(List.of());
        assertThat(dr.getDataTableDescriptors()).anyMatch(it -> ""org.openrewrite.table.TextMatches"".equals(it.getName()));
    }

    @Test
    void maxCycles() {
        rewriteRun(
          spec -> spec.recipe(new RepeatedFindAndReplace("".+"", ""$0+1"", 1)),
          text(""1"", ""1+1"")
        );
        rewriteRun(
          spec -> spec.recipe(new RepeatedFindAndReplace("".+"", ""$0+1"", 2)).expectedCyclesThatMakeChanges(2),
          text(""1"", ""1+1+1"")
        );
    }

    @Test
    void maxCyclesNested() {
        AtomicInteger cycleCount = new AtomicInteger();
        Recipe root = new MaxCycles(
          100,
          List.of(new MaxCycles(
              2,
              List.of(new RepeatedFindAndReplace("".+"", ""$0+1"", 100))
            ),
            toRecipe(() -> new TreeVisitor<>() {
                @Override
                public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                    cycleCount.incrementAndGet();
                    return tree;
                }
            })
          )
        );
        rewriteRun(
          spec -> spec.recipe(root).cycles(10).cycles(3).expectedCyclesThatMakeChanges(2),
          text(""1"", ""1+1+1"")
        );
        assertThat(cycleCount).hasValue(3);
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class MaxCycles extends Recipe {
        int maxCycles;
        List<Recipe> recipeList;

        @Override
        public int maxCycles() {
            return maxCycles;
        }

        @Override
        public String getDisplayName() {
            return ""Executes recipes multiple times"";
        }

        @Override
        public String getDescription() {
            return ""Executes recipes multiple times."";
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class RepeatedFindAndReplace extends Recipe {
        String find;
        String replace;
        int maxCycles;

        @Override
        public int maxCycles() {
            return maxCycles;
        }

        @Override
        public String getDisplayName() {
            return ""Repeated find and replace"";
        }

        @Override
        public String getDescription() {
            return ""Find and replace repeatedly."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new TreeVisitor<>() {
                @Override
                public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                    PlainText text = ((PlainText) tree);
                    assert text != null;
                    return text.withText(text.getText().replaceAll(find, replace));
                }
            };
        }
    }

    @Test
    void selfReferencingRecipeDetectedAsCycle() {
        // Test that a recipe referencing itself is detected as a cycle
        DeclarativeRecipe selfReferencing = new DeclarativeRecipe(
            ""org.openrewrite.SelfReferencing"",
            ""Self Referencing Recipe"",
            ""A recipe that references itself"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        // Add itself as a sub-recipe
        selfReferencing.addUninitialized(""org.openrewrite.SelfReferencing"");

        // Initialize should throw RecipeIntrospectionException when cycle is detected
        assertThatThrownBy(() -> selfReferencing.initialize(List.of(selfReferencing)))
            .isInstanceOf(RecipeIntrospectionException.class)
            .hasMessageContaining(""creates a cycle"")
            .hasMessageContaining(""org.openrewrite.SelfReferencing -> org.openrewrite.SelfReferencing"");
    }

    @Test
    void mutuallyRecursiveRecipesDetectedAsCycle() {
        // Test that mutually recursive recipes are detected as a cycle
        DeclarativeRecipe recipeA = new DeclarativeRecipe(
            ""org.openrewrite.RecipeA"",
            ""Recipe A"",
            ""Recipe A that references Recipe B"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        DeclarativeRecipe recipeB = new DeclarativeRecipe(
            ""org.openrewrite.RecipeB"",
            ""Recipe B"",
            ""Recipe B that references Recipe A"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        // A references B
        recipeA.addUninitialized(""org.openrewrite.RecipeB"");

        // B references A
        recipeB.addUninitialized(""org.openrewrite.RecipeA"");

        // Initialize should throw RecipeIntrospectionException when cycle is detected
        assertThatThrownBy(() -> recipeA.initialize(List.of(recipeA, recipeB)))
            .isInstanceOf(RecipeIntrospectionException.class)
            .hasMessageContaining(""creates a cycle"")
            .hasMessageContaining(""RecipeA"")
            .hasMessageContaining(""RecipeB"");
    }

    @Test
    void deeperCyclicReferencesDetectedAsCycle() {
        // Test that deeper cyclic references (A -> B -> C -> A) are detected as a cycle
        DeclarativeRecipe recipeA = new DeclarativeRecipe(
            ""org.openrewrite.RecipeA"",
            ""Recipe A"",
            ""Recipe A that references Recipe B"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        DeclarativeRecipe recipeB = new DeclarativeRecipe(
            ""org.openrewrite.RecipeB"",
            ""Recipe B"",
            ""Recipe B that references Recipe C"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        DeclarativeRecipe recipeC = new DeclarativeRecipe(
            ""org.openrewrite.RecipeC"",
            ""Recipe C"",
            ""Recipe C that references Recipe A"",
            emptySet(),
            null,
            URI.create(""test""),
            false,
            emptyList()
        );

        // A references B
        recipeA.addUninitialized(""org.openrewrite.RecipeB"");

        // B references C
        recipeB.addUninitialized(""org.openrewrite.RecipeC"");

        // C references A (completing the cycle)
        recipeC.addUninitialized(""org.openrewrite.RecipeA"");

        // Initialize should throw RecipeIntrospectionException when cycle is detected
        assertThatThrownBy(() -> recipeA.initialize(List.of(recipeA, recipeB, recipeC)))
            .isInstanceOf(RecipeIntrospectionException.class)
            .hasMessageContaining(""creates a cycle"")
            // The cycle path should show A -> B -> C -> A
            .hasMessageContaining(""RecipeA"")
            .hasMessageContaining(""RecipeB"")
            .hasMessageContaining(""RecipeC"");
    }
}
",{}
Recipe with an applicability test,This recipe is a test utility which exists to exercise RecipeRunStats.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.table;

import lombok.AllArgsConstructor;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.test.SourceSpecs.text;

@AllArgsConstructor
class RecipeWithApplicabilityTest extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Recipe with an applicability test"";
    }

    @Override
    public String getDescription() {
        return ""This recipe is a test utility which exists to exercise RecipeRunStats."";
    }

    @Option(displayName = ""New text"", example = ""txt"")
    String newText;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
          new PlainTextVisitor<>() {
              @Override
              public PlainText visitText(PlainText text, ExecutionContext ctx) {
                  if (!""sam"".equals(text.getText())) {
                      return SearchResult.found(text);
                  }
                  return text;
              }
          },
          new PlainTextVisitor<>() {
              @Override
              public PlainText visitText(PlainText tree, ExecutionContext ctx) {
                  return tree.withText(newText);
              }
          }
        );
    }
}

class RecipeRunStatsTest implements RewriteTest {

    @DocumentExample
    @Test
    void singleRow() {
        rewriteRun(
          spec -> spec
            .recipe(new RecipeWithApplicabilityTest(""sam""))
            .dataTable(RecipeRunStats.Row.class, rows -> {
              assertThat(rows)
                .as(""Running a single recipe on a single source should produce a single row in the RecipeRunStats table"")
                .hasSize(1);
              RecipeRunStats.Row row = rows.getFirst();
              assertThat(row.getRecipe()).endsWith(""RecipeWithApplicabilityTest"");
              assertThat(row.getSourceFiles())
                .isEqualTo(1);
              assertThat(row.getEditMaxNs()).isGreaterThan(0);
              assertThat(row.getEditTotalTimeNs())
                .as(""Cumulative time should be greater than any single visit time"")
                .isGreaterThan(row.getEditMaxNs());
          }),
          text(""samuel"", ""sam"")
        );
    }

    @Test
    void sourceFilesCountStatsForSameRecipe() {
        rewriteRun(
          spec -> spec
            .recipeFromYaml(""""""
                ---
                type: specs.openrewrite.org/v1beta/recipe
                name: org.openrewrite.SeveralMethodNameChangeRecipes
                description: Test.
                recipeList:
                  - org.openrewrite.table.RecipeWithApplicabilityTest:
                      newText: sam1
                  - org.openrewrite.table.RecipeWithApplicabilityTest:
                      newText: sam2
                """""",
              ""org.openrewrite.SeveralMethodNameChangeRecipes"")
            .dataTable(RecipeRunStats.Row.class, rows -> {
                assertThat(rows)
                  .as(""Running declarative recipe with parametrized recipe a single source should produce a two rows in the RecipeRunStats table"")
                  .hasSize(2);
                for (RecipeRunStats.Row row : rows) {
                    assertThat(row.getSourceFiles())
                      .as(""If the same recipe runs with different parameters it shouldn't increment several times source files count"")
                      .isEqualTo(1);
                }
            }).expectedCyclesThatMakeChanges(2),
          text(""sem"", ""sam2"")
        );
    }
}
","{
  ""newText"": ""String field""
}"
A recipe that has a recipe list,To verify that it is possible for a recipe list to be called over RPC.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.rpc;

import io.moderne.jsonrpc.JsonRpc;
import io.moderne.jsonrpc.handler.HeaderDelimitedMessageHandler;
import lombok.SneakyThrows;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.config.Environment;
import org.openrewrite.table.TextMatches;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import static java.util.Objects.requireNonNull;
import static org.assertj.core.api.Assertions.assertThat;
import static org.openrewrite.test.RewriteTest.toRecipe;
import static org.openrewrite.test.SourceSpecs.text;

class RewriteRpcTest implements RewriteTest {
    Environment env = Environment.builder()
      .scanRuntimeClasspath(""org.openrewrite.text"")
      .build();

    RewriteRpc client;
    RewriteRpc server;

    @BeforeEach
    void before() throws IOException {
        PipedOutputStream serverOut = new PipedOutputStream();
        PipedOutputStream clientOut = new PipedOutputStream();
        PipedInputStream serverIn = new PipedInputStream(clientOut);
        PipedInputStream clientIn = new PipedInputStream(serverOut);

        client = new RewriteRpc(new JsonRpc(new HeaderDelimitedMessageHandler(clientIn, clientOut)), env)
          .batchSize(1);

        server = new RewriteRpc(new JsonRpc(new HeaderDelimitedMessageHandler(serverIn, serverOut)), env)
          .batchSize(1);
    }

    @AfterEach
    void after() {
        client.shutdown();
        server.shutdown();
    }

    @DocumentExample
    @Test
    void sendReceiveIdempotence() {
        rewriteRun(
          spec -> spec.recipe(toRecipe(() -> new TreeVisitor<>() {
              @Override
              @SneakyThrows
              public Tree preVisit(Tree tree, ExecutionContext ctx) {
                  Tree t = client.visit((SourceFile) tree, ChangeText.class.getName(), 0);
                  stopAfterPreVisit();
                  return requireNonNull(t);
              }
          })),
          text(
            ""Hello Jon!"",
            ""Hello World!""
          )
        );
    }

    @Test
    void print() {
        rewriteRun(
          text(
            ""Hello Jon!"",
            spec -> spec.beforeRecipe(text ->
              assertThat(client.print(text)).isEqualTo(""Hello Jon!""))
          )
        );
    }

    @Test
    void getRecipes() {
        assertThat(client.getRecipes()).isNotEmpty();
    }

    @Test
    void prepareRecipe() {
        Recipe recipe = client.prepareRecipe(""org.openrewrite.text.Find"",
          Map.of(""find"", ""hello""));
        assertThat(recipe.getDescriptor().getDisplayName()).isEqualTo(""Find text"");
    }

    @Disabled(""Disabled until https://github.com/openrewrite/rewrite/pull/5260 is complete"")
    @Test
    void runRecipe() {
        CountDownLatch latch = new CountDownLatch(1);
        rewriteRun(
          spec -> spec
            .recipe(client.prepareRecipe(""org.openrewrite.text.Find"",
              Map.of(""find"", ""hello"")))
            .validateRecipeSerialization(false)
            .dataTable(TextMatches.Row.class, rows -> {
                assertThat(rows).contains(new TextMatches.Row(
                  ""hello.txt"", ""~~>Hello Jon!""));
                latch.countDown();
            }),
          text(
            ""Hello Jon!"",
            ""~~>Hello Jon!"",
            spec -> spec.path(""hello.txt"")
          )
        );

        assertThat(latch.getCount()).isEqualTo(0);
    }

    @Test
    void runScanningRecipeThatGenerates() {
        rewriteRun(
          spec -> spec
            .recipe(client.prepareRecipe(""org.openrewrite.text.CreateTextFile"",
              Map.of(""fileContents"", ""hello"", ""relativeFileName"", ""hello.txt"")))
            .validateRecipeSerialization(false),
          text(
            null,
            ""hello"",
            spec -> spec.path(""hello.txt"")
          )
        );
    }

    @Test
    void runRecipeWithRecipeList() {
        rewriteRun(
          spec -> spec
            .recipe(client.prepareRecipe(""org.openrewrite.rpc.RewriteRpcTest$RecipeWithRecipeList"", Map.of()))
            .validateRecipeSerialization(false),
          text(
            ""hi"",
            ""hello""
          )
        );
    }

    @Test
    void getCursor() {
        Cursor parent = new Cursor(null, Cursor.ROOT_VALUE);
        Cursor c1 = new Cursor(parent, 0);
        Cursor c2 = new Cursor(c1, 1);

        Cursor clientC2 = server.getCursor(client.getCursorIds(c2));
        assertThat(clientC2.<Integer>getValue()).isEqualTo(1);
        assertThat(clientC2.getParentOrThrow().<Integer>getValue()).isEqualTo(0);
        assertThat(clientC2.getParentOrThrow(2).<String>getValue()).isEqualTo(Cursor.ROOT_VALUE);
    }

    static class ChangeText extends PlainTextVisitor<Integer> {
        @Override
        public PlainText visitText(PlainText text, Integer p) {
            return text.withText(""Hello World!"");
        }
    }

    @SuppressWarnings(""unused"")
    static class RecipeWithRecipeList extends Recipe {
        @Override
        public String getDisplayName() {
            return ""A recipe that has a recipe list"";
        }

        @Override
        public String getDescription() {
            return ""To verify that it is possible for a recipe list to be called over RPC."";
        }

        @Override
        public void buildRecipeList(RecipeList recipes) {
            recipes.recipe(new org.openrewrite.text.ChangeText(""hello""));
        }
    }
}
",{}
Show Git source control metadata,List out the contents of each unique `GitProvenance` marker in the set of source files. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import org.jspecify.annotations.Nullable;
import org.openrewrite.marker.GitProvenance;
import org.openrewrite.table.DistinctGitProvenance;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

public class FindGitProvenance extends ScanningRecipe<Set<GitProvenance>> {
    // we are looking for substantive differences, not just ID differences
    private static final UUID DONT_CONSIDER_ID_IN_HASH_CODE = UUID.randomUUID();

    private final DistinctGitProvenance distinct = new DistinctGitProvenance(this);

    @Override
    public String getDisplayName() {
        return ""Show Git source control metadata"";
    }

    @Override
    public String getDescription() {
        return ""List out the contents of each unique `GitProvenance` marker in the set of source files. "" +
               ""When everything is working correctly, exactly one such marker should be printed as all source files are "" +
               ""expected to come from the same repository / branch / commit hash."";
    }

    @Override
    public Set<GitProvenance> getInitialValue(ExecutionContext ctx) {
        return new HashSet<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Set<GitProvenance> provenances) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                sourceFile.getMarkers().findFirst(GitProvenance.class).ifPresent(provenance ->
                        provenances.add(provenance.withId(DONT_CONSIDER_ID_IN_HASH_CODE)));
                return sourceFile;
            }
        };
    }

    @Override
    public Collection<SourceFile> generate(Set<GitProvenance> provenances, ExecutionContext ctx) {
        for (GitProvenance provenance : provenances) {
            distinct.insertRow(ctx, new DistinctGitProvenance.Row(
                    provenance.getOrigin(),
                    provenance.getBranch(),
                    provenance.getChange(),
                    provenance.getAutocrlf(),
                    provenance.getEol())
            );
        }
        return emptyList();
    }
}
",{}
Find LST provenance,Produces a data table showing what versions of OpenRewrite/Moderne tooling was used to produce a given LST.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.marker.LstProvenance;
import org.openrewrite.table.LstProvenanceTable;

import static java.time.ZoneOffset.UTC;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindLstProvenance extends ScanningRecipe<FindLstProvenance.Accumulator> {

    @Override
    public String getDisplayName() {
        return ""Find LST provenance"";
    }

    @Override
    public String getDescription() {
        return ""Produces a data table showing what versions of OpenRewrite/Moderne tooling was used to produce a given LST."";
    }

    transient LstProvenanceTable provenanceTable = new LstProvenanceTable(this);

    public static class Accumulator {
        // There will only ever be one LstProvenance per repository, so after we have seen one we don't need to see more
        boolean foundLstProvenance;
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if(acc.foundLstProvenance) {
                    return tree;
                }
                LstProvenance lstProvenance = tree.getMarkers().findFirst(LstProvenance.class).orElse(null);
                if (lstProvenance == null) {
                    return tree;
                }
                provenanceTable.insertRow(ctx, new LstProvenanceTable.Row(lstProvenance.getBuildToolType(),
                        lstProvenance.getBuildToolVersion(), lstProvenance.getLstSerializerVersion(),
                        lstProvenance.getTimestampUtc() == null ? null : lstProvenance.getTimestampUtc().toEpochMilli(),
                        lstProvenance.getTimestampUtc() == null ? null : lstProvenance.getTimestampUtc().atZone(UTC).toString()));
                acc.foundLstProvenance = true;
                return tree;
            }
        };
    }
}
",{}
Delete files,Delete files by source path.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;

import java.nio.file.Path;
import java.nio.file.PathMatcher;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteSourceFiles extends Recipe {

    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to delete (relative to the project root)."",
            example = "".github/workflows/*.yml"")
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Delete files"";
    }

    @Override
    public String getDescription() {
        return ""Delete files by source path."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    SourceFile sourceFile = (SourceFile) tree;
                    Path sourcePath = sourceFile.getSourcePath();
                    PathMatcher pathMatcher = sourcePath.getFileSystem().getPathMatcher(""glob:"" + filePattern);
                    if (pathMatcher.matches(sourcePath)) {
                        return null;
                    }
                }
                return tree;
            }
        };
    }
}
",{}
Find colliding source files,Finds source files which share a path with another source file. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.table.CollidingSourceFiles;

import java.nio.file.Path;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindCollidingSourceFiles extends ScanningRecipe<FindCollidingSourceFiles.Accumulator> {
    transient CollidingSourceFiles collidingSourceFiles = new CollidingSourceFiles(this);

    @Override
    public String getDisplayName() {
        return ""Find colliding source files"";
    }

    @Override
    public String getDescription() {
        return ""Finds source files which share a path with another source file. "" +
               ""There should always be exactly one source file per path within a repository. "" +
               ""This is a diagnostic for finding problems in OpenRewrite parsers/build plugins."";
    }

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                assert tree instanceof SourceFile;
                Path p = ((SourceFile) tree).getSourcePath();
                if (!acc.getSourcePaths().add(p)) {
                    acc.getDuplicates().add(p);
                }
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        acc.getSourcePaths().clear(); // we don't need this anymore, might as well free the memory sooner
        return super.generate(acc, ctx);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    Path p = ((SourceFile) tree).getSourcePath();
                    if (acc.getDuplicates().contains(p)) {
                        collidingSourceFiles.insertRow(ctx, new CollidingSourceFiles.Row(
                                p.toString(),
                                tree.getClass().toString()
                        ));
                        return SearchResult.found(tree, ""Duplicate source file "" + p);
                    }
                }
                return tree;
            }
        };
    }

    @Value
    static class Accumulator {
        Set<Path> sourcePaths = new LinkedHashSet<>();
        Set<Path> duplicates = new LinkedHashSet<>();
    }
}
",{}
Move a file,Move a file to a different directory. The file name will remain the same.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.internal.StringUtils;

import java.nio.file.Path;
import java.nio.file.Paths;

import static org.openrewrite.PathUtils.*;

@Value
@EqualsAndHashCode(callSuper = false)
public class MoveFile extends Recipe {
    @Nullable
    @Option(displayName = ""Folder"",
            description = ""When using the folder option, all files / subfolders in the folder will be moved to the moveTo source path. "" +
                    ""Folder should be starting at root"",
            required = false,
            example = ""src/main/resources/"")
    String folder;

    @Nullable
    @Option(displayName = ""File matcher"",
            description = ""Matching files will be moved. This is a glob expression."",
            required = false,
            example = ""**/*.yml"")
    String fileMatcher;

    @Option(displayName = ""Move to"",
            description = ""Either a relative or absolute path. If relative, it is relative to the current file's directory."",
            example = ""../yamls/"")
    String moveTo;

    @Override
    public String getDisplayName() {
        return ""Move a file"";
    }

    @Override
    public String getDescription() {
        return ""Move a file to a different directory. The file name will remain the same."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (StringUtils.isNullOrEmpty(folder) && StringUtils.isNullOrEmpty(fileMatcher)) {
            return validated
                    .and(Validated.invalid(""folder"", folder, ""folder or fileMatcher must be set""))
                    .and(Validated.invalid(""fileMatcher"", fileMatcher, ""folder or fileMatcher must be set""));
        } else if (!(StringUtils.isNullOrEmpty(folder)) && !(StringUtils.isNullOrEmpty(fileMatcher))) {
            return validated
                    .and(Validated.invalid(""folder"", folder, ""folder and fileMatcher cannot both be set""))
                    .and(Validated.invalid(""fileMatcher"", fileMatcher, ""folder and fileMatcher cannot both be set""));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    String originalSourcePath = ((SourceFile) tree).getSourcePath().toString();
                    Path sourcePath = Paths.get(separatorsToSystem(originalSourcePath));
                    boolean isWindowsPath = originalSourcePath.equals(separatorsToWindows(originalSourcePath));
                    boolean isUnixPath = originalSourcePath.equals(separatorsToUnix(originalSourcePath));
                    boolean isFileOnRoot = sourcePath.getParent() == null;
                    if (!isFileOnRoot && (isWindowsPath && isUnixPath || (!isWindowsPath && !isUnixPath))) {
                        // This should never happen, but just in case
                        return tree;
                    }

                    Path destination;
                    if (folder() != null) {
                        destination = getFolderTarget(sourcePath, moveTo());
                    } else {
                        destination = getFilePatternTarget(sourcePath, moveTo());
                    }
                    if (destination != null && !destination.equals(sourcePath)) {
                        destination = destination.resolve(sourcePath.getFileName().toString());
                        if (!destination.equals(sourcePath)) {
                            if (isFileOnRoot) {
                                return ((SourceFile) tree).withSourcePath(Paths.get(separatorsToSystem(destination.toString())));
                            } else if (isWindowsPath) {
                                return ((SourceFile) tree).withSourcePath(Paths.get(separatorsToWindows(destination.toString())));
                            } else {
                                return ((SourceFile) tree).withSourcePath(Paths.get(separatorsToUnix(destination.toString())));
                            }
                        }
                    }
                }
                return super.visit(tree, ctx);
            }

            private @Nullable Path getFolderTarget(Path sourcePath, String destinationPattern) {
                String folder = folder();
                if (folder == null) {
                    return null;
                }
                String folderPrefix = folder;
                if (!folderPrefix.endsWith(""/**"")) {
                    if (folderPrefix.endsWith(""/"")) {
                        folderPrefix += ""**"";
                    } else {
                        folderPrefix += ""/**"";
                    }
                }

                Path currentFolder = sourcePath.getParent();
                if (PathUtils.matchesGlob(sourcePath, folderPrefix) || ""/**"".equals(folderPrefix)) {
                    String subFolders = currentFolder == null ? """" : separatorsToUnix(currentFolder.toString().substring(folder.length()));
                    if (subFolders.startsWith(""/"") || subFolders.startsWith(""\\"")) {
                        subFolders = subFolders.substring(1);
                    }
                    Path destination = null;
                    if (destinationPattern.startsWith(""../"")) {
                        destination = moveToRelativePath(Paths.get(folderPrefix.substring(0, folderPrefix.length() - 3)), destinationPattern);
                    } else if (!(subFolders.equals(destinationPattern.startsWith(""/"") ? destinationPattern.substring(1) : destinationPattern) ||
                            subFolders.startsWith(destinationPattern.startsWith(""/"") ? destinationPattern.substring(1) : destinationPattern + ""/""))) {
                        if (destinationPattern.startsWith(""/"")) {
                            destination = moveToAbsolutePath();
                        } else {
                            destination = Paths.get(folder, destinationPattern);
                        }
                    }
                    if (destination != null) {
                        return destination.resolve(subFolders);
                    } else {
                        return null;
                    }
                }
                return sourcePath;
            }

            private @Nullable Path getFilePatternTarget(Path sourcePath, String destinationPattern) {
                if (fileMatcher == null) {
                    return null;
                }
                if (sourcePath.getFileSystem().getPathMatcher(""glob:"" + fileMatcher).matches(sourcePath)) {
                    Path currentFolder = sourcePath.getParent();
                    if (destinationPattern.startsWith(""/"")) {
                        return moveToAbsolutePath();
                    } else if (destinationPattern.startsWith(""../"")) {
                        return moveToRelativePath(currentFolder, destinationPattern);
                    } else if (currentFolder != null && !currentFolder.endsWith(destinationPattern)) {
                        return currentFolder.resolve(destinationPattern);
                    } else if (currentFolder == null) {
                        return Paths.get(destinationPattern);
                    }
                }

                return sourcePath;
            }

            private Path moveToAbsolutePath() {
                return Paths.get(moveTo().substring(1));
            }

            private @Nullable Path moveToRelativePath(@Nullable Path sourcePath, String relativePath) {
                Path moveToSourcePath = sourcePath;
                String moveToPath = relativePath;
                while (moveToPath.startsWith(""../"")) {
                    moveToSourcePath = moveToSourcePath != null ? moveToSourcePath.getParent() : null;
                    if (moveToSourcePath == null) {
                        return null;
                    }
                    moveToPath = moveToPath.substring(3);
                }

                return moveToSourcePath != null ? moveToSourcePath.resolve(moveToPath) : null;
            }
        };
    }

    private @Nullable String folder() {
        if (StringUtils.isNullOrEmpty(this.folder)) {
            return null;
        }

        return separatorsToUnix(this.folder.startsWith(""/"") || this.folder.startsWith(""\\"") ? this.folder.substring(1) : this.folder);
    }

    private String moveTo() {
        return separatorsToUnix(this.moveTo);
    }
}
","{
  ""folder"": ""String field"",
  ""fileMatcher"": ""String field"",
  ""moveTo"": ""String field""
}"
Remove ignoral of files or directories from .gitignore,This recipe will remove a file or directory from the .gitignore file. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.jgit.ignore.FastIgnoreRule;
import org.openrewrite.jgit.ignore.IgnoreNode;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextVisitor;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.*;

import static java.util.Collections.*;
import static java.util.Comparator.comparingInt;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.lang3.StringUtils.join;
import static org.openrewrite.ExcludeFileFromGitignore.Repository;
import static org.openrewrite.PathUtils.separatorsToUnix;
import static org.openrewrite.jgit.ignore.IgnoreNode.MatchResult.*;

@Value
@EqualsAndHashCode(callSuper = false)
public class ExcludeFileFromGitignore extends ScanningRecipe<Repository> {

    @Option(displayName = ""Paths"", description = ""The paths to find and remove from the gitignore files."", example = ""/folder/file.txt"")
    List<String> paths;

    @Override
    public String getDisplayName() {
        return ""Remove ignoral of files or directories from .gitignore"";
    }

    @Override
    public String getDescription() {
        return ""This recipe will remove a file or directory from the .gitignore file. "" +
               ""If the file or directory is already in the .gitignore file, it will be removed or negated. "" +
               ""If the file or directory is not in the .gitignore file, no action will be taken."";
    }

    @Override
    public Repository getInitialValue(ExecutionContext ctx) {
        return new Repository();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Repository acc) {
        return Preconditions.check(new FindSourceFiles(""**/.gitignore""), new PlainTextVisitor<ExecutionContext>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                try {
                    acc.addGitignoreFile(text);
                } catch (IOException e) {
                    throw new RecipeException(""Failed to parse the .gitignore file"", e);
                }
                return super.visitText(text, ctx);
            }
        });
    }

    @Override
    public Collection<? extends SourceFile> generate(Repository acc, ExecutionContext ctx) {
        for (String path : paths) {
            acc.exclude(path);
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Repository acc) {
        return Preconditions.check(new FindSourceFiles(""**/.gitignore""), new PlainTextVisitor<ExecutionContext>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                CustomIgnoreNode ignoreNode = acc.rules.get(asGitignoreFileLocation(text));
                if (ignoreNode != null) {
                    String separator = text.getText().contains(""\r\n"") ? ""\r\n"" : ""\n"";
                    List<String> newRules = ignoreNode.getRules().stream().map(IgnoreRule::getText).collect(toList());
                    String[] currentContent = text.getText().split(separator);
                    text = text.withText(join(sortRules(currentContent, newRules), separator));
                }
                return text;
            }

            private List<String> sortRules(String[] originalRules, List<String> newRules) {
                LinkedList<String> results = new LinkedList<>();
                Arrays.stream(originalRules).filter(line -> {
                    if (StringUtils.isBlank(line) || line.startsWith(""#"")) {
                        return true;
                    }
                    return newRules.stream().anyMatch(line::equalsIgnoreCase);
                }).forEach(results::add);

                int resultsIndexCurrentlyAt = 0;
                for (String newRule : newRules) {
                    List<String> resultsSubList = results.subList(resultsIndexCurrentlyAt, results.size());
                    if (resultsSubList.stream().noneMatch(rule -> rule.equalsIgnoreCase(newRule))) {
                        if (resultsIndexCurrentlyAt >= results.size()) {
                            results.add(newRule);
                        } else {
                            results.add(resultsIndexCurrentlyAt, newRule);
                        }
                    } else {
                        resultsIndexCurrentlyAt += resultsSubList.indexOf(newRule);
                    }
                    resultsIndexCurrentlyAt++;
                }

                return distinctValuesStartingReversed(results);
            }

            private List<String> distinctValuesStartingReversed(List<String> list) {
                LinkedList<String> filteredList = new LinkedList<>();
                ListIterator<String> iterator = list.listIterator(list.size());

                while (iterator.hasPrevious()) {
                    String previous = iterator.previous();
                    if (StringUtils.isBlank(previous) || previous.startsWith(""#"") || !filteredList.contains(previous)) {
                        filteredList.addFirst(previous);
                    }
                }

                return filteredList;
            }
        });
    }

    public static class Repository {
        private final Map<String, CustomIgnoreNode> rules = new HashMap<>();

        public void exclude(String path) {
            path = separatorsToUnix(path);
            String normalizedPath = path.startsWith(""/"") ? path : ""/"" + path;
            List<String> impactingFiles = rules.keySet()
                    .stream()
                    .filter(k -> normalizedPath.toLowerCase().startsWith(k.toLowerCase()))
                    .sorted(comparingInt(String::length).reversed())
                    .collect(toList());

            for (String impactingFile : impactingFiles) {
                CustomIgnoreNode ignoreNode = rules.get(impactingFile);
                String nestedPath = normalizedPath.substring(impactingFile.length() - 1);

                while (IGNORED == ignoreNode.isIgnored(nestedPath)) {
                    List<IgnoreRule> existingRules = ignoreNode.getRules();
                    LinkedHashSet<FastIgnoreRule> remainingRules = new LinkedHashSet<>();
                    for (int i = existingRules.size() - 1; i > -1; i--) {
                        IgnoreRule rule = existingRules.get(i);
                        remainingRules.addAll(rule.negateIfNecessary(nestedPath));
                    }
                    ArrayList<FastIgnoreRule> ignoreRules = new ArrayList<>(remainingRules);
                    reverse(ignoreRules);
                    ignoreNode = new CustomIgnoreNode(ignoreRules, ignoreNode.getPath());
                    if (ignoreRules.size() == existingRules.size()) {
                        break;
                    }
                }
                rules.put(impactingFile, ignoreNode);

                if (CHECK_PARENT == ignoreNode.isIgnored(nestedPath)) {
                    continue;
                }
                // There is already an ignore rule for the path, so not needed to check parent rules.
                break;
            }
        }

        public void addGitignoreFile(PlainText text) throws IOException {
            CustomIgnoreNode ignoreNode = CustomIgnoreNode.of(text);
            rules.put(ignoreNode.path, ignoreNode);
        }
    }

    @Getter
    private static class CustomIgnoreNode {
        private final List<IgnoreRule> rules;
        private final String path;

        public CustomIgnoreNode(List<FastIgnoreRule> rules, String path) {
            this.rules = rules.stream().map(IgnoreRule::new).collect(toList());
            this.path = path;
        }

        static CustomIgnoreNode of(PlainText text) throws IOException {
            String gitignoreFileName = asGitignoreFileLocation(text);
            IgnoreNode ignoreNode = new IgnoreNode();
            ignoreNode.parse(gitignoreFileName, new ByteArrayInputStream(text.getText().getBytes()));

            return new CustomIgnoreNode(ignoreNode.getRules(), gitignoreFileName);
        }

        public IgnoreNode.MatchResult isIgnored(String path) {
            for (int i = rules.size() - 1; i > -1; i--) {
                IgnoreRule rule = rules.get(i);
                if (rule.isMatch(path)) {
                    if (rule.getResult()) {
                        return IGNORED;
                    } else {
                        return NOT_IGNORED;
                    }
                }
            }
            return CHECK_PARENT;
        }
    }

    private static class IgnoreRule {
        private final FastIgnoreRule rule;

        @Getter
        private final String text;

        public IgnoreRule(FastIgnoreRule rule) {
            this.rule = rule;
            this.text = rule.toString();
        }

        public boolean isMatch(String path) {
            return rule.isMatch(path, true, false) ||  rule.isMatch(path, true, true);
        }

        public boolean getResult() {
            return rule.getResult();
        }

        public List<FastIgnoreRule> negateIfNecessary(String nestedPath) {
            if (!isMatch(nestedPath) || !getResult()) {
                // If this rule has nothing to do with the path to remove, we keep it.
                // OR if this rule is a negation, we keep it.
                return singletonList(rule);
            } else if (text.equals(nestedPath)) {
                // If this rule is an exact match to the path to remove, we remove it.
                return emptyList();
            } else if (isMatch(nestedPath)) {
                if (text.contains(""*"")) {
                    return getWildcardRules(nestedPath);
                }
                if ((""/"" + text).equals(nestedPath)) {
                    // An entry not starting with a slash, but exact match otherwise needs to be negated using exact path as that leftover entry can match nested paths also.
                    return Arrays.asList(new FastIgnoreRule(""!"" + nestedPath), rule);
                }
                if (!rule.dirOnly()) {
                    // If the rule does not end with a slash, it's a matcher for both filenames and directories, so we must negate it with an exact path.
                    return Arrays.asList(new FastIgnoreRule(""!"" + nestedPath), rule);
                }
                return traversePaths(text, nestedPath, null, null);
            }
            // If we still have the rule, we keep it. --> not making changes to an unknown flow.
            return singletonList(rule);
        }

        @Override
        public String toString() {
            return text;
        }

        private List<FastIgnoreRule> getWildcardRules(String nestedPath) {
            if (!isMatch(nestedPath)) {
                return singletonList(rule);
            }
            if (text.startsWith(""!"")) {
                return singletonList(rule);
            }
            if (isWildcardedBetween(1, -1) || (splitRuleParts().length > 1 && isWildcardedBetween(0, 1) && isWildcardedBetween(-1, 0))) {
                // No support for wildcard in the middle of the path (yet?). So, we keep the rule.
                // No support for wildcards in both beginning and end.
                return singletonList(rule);
            }
            if (!hasOnlyOneWildcardGroup()) {
                // No support for multiple wildcard groups (yet?). So, we keep the rule.
                // No support for wildcards + text (yet?). So, we keep the rule.
                return singletonList(rule);
            }
            if (!isFullWildcard()) {
                return Arrays.asList(new FastIgnoreRule(""!"" + nestedPath), rule);
            }
            String wildcard = ""*"";
            if (text.contains(""**"")) {
                wildcard = ""**"";
            }
            if (isWildcardedBetween(0, 1)) {
                return traversePaths(text, nestedPath, null, (text.startsWith(""/"") ? ""/"" : """") + wildcard);
            }
            if (isWildcardedBetween(-1, 0)) {
                // If the wildcard is at the end of the path, we should negate the rule.
                return traversePaths(text, nestedPath, wildcard + (text.endsWith(""/"") ? ""/"" : """"), null);
            }
            // In any other case, we will keep the rule.
            return singletonList(rule);
        }

        private boolean isFullWildcard() {
            if (!text.contains(""*"")) {
                return false;
            }
            // only / or empty before and after the wildcard
            int begin = text.indexOf(""*"");
            int end = text.lastIndexOf(""*"");

            return (begin == 0 || text.charAt(begin - 1) == '/') && (end == text.length() - 1 || text.charAt(end + 1) == '/');
        }

        private boolean hasOnlyOneWildcardGroup() {
            if (!text.contains(""*"")) {
                return false;
            }
            int firstWildcard = text.indexOf(""*"");
            int lastWildcard = text.lastIndexOf(""*"");
            return firstWildcard == lastWildcard || lastWildcard - firstWildcard == 1;
        }

        private boolean isWildcardedBetween(int start, int end) {
            if (!text.contains(""*"")) {
                return false;
            }
            String[] parts = splitRuleParts();
            int startIdx = start;
            if (startIdx < 0) {
                startIdx = parts.length + start;
            }
            int endIdx = end;
            if (endIdx <= 0) {
                endIdx = parts.length + end;
            }
            for (int i = startIdx; i < endIdx; i++) {
                if (parts[i].contains(""*"")) {
                    return true;
                }
            }
            return false;
        }

        private String[] splitRuleParts() {
            String rulePath = text;
            if (rulePath.startsWith(""!"")) {
                rulePath = rulePath.substring(1);
            }
            if (rulePath.startsWith(""/"")) {
                rulePath = rulePath.substring(1);
            }
            if (rulePath.endsWith(""/"")) {
                rulePath = rulePath.substring(0, rulePath.length() - 1);
            }
            return rulePath.split(""/"");
        }

        private static List<FastIgnoreRule> traversePaths(String originalRule, String path, @Nullable String wildcardSuffix, @Nullable String wildcardPrefix) {
            String rule = originalRule;
            ArrayList<FastIgnoreRule> traversedRemainingRules = new ArrayList<>();
            if (wildcardSuffix != null && rule.endsWith(wildcardSuffix)) {
                rule = rule.substring(0, rule.length()-wildcardSuffix.length());
            }
            if (wildcardPrefix != null && rule.startsWith(wildcardPrefix)) {
                rule = path.substring(0, path.indexOf(rule.substring(wildcardPrefix.length()))) + rule.substring(wildcardPrefix.length());
                traversedRemainingRules.add(new FastIgnoreRule(originalRule + (originalRule.endsWith(""/"") ? ""*"" : ""/*"")));
                traversedRemainingRules.add(new FastIgnoreRule(""!"" + rule));
            }
            StringBuilder rulePath = new StringBuilder(rule);
            String pathToTraverse = path.substring(rule.length());

            if (originalRule.contains(""*"")) {
                if (pathToTraverse.isEmpty() && wildcardSuffix != null) {
                    return Arrays.asList(new FastIgnoreRule(""!"" + rule), new FastIgnoreRule(originalRule + (originalRule.endsWith(""/"") ? ""*"" : ""/*"")));
                } else if (pathToTraverse.isEmpty() && wildcardPrefix != null) {
                    return Arrays.asList(new FastIgnoreRule(""!"" + rule), new FastIgnoreRule(originalRule));
                }
            } else {
                if (pathToTraverse.replace(""/"", """").isEmpty()) {
                    return Arrays.asList(new FastIgnoreRule(""!"" + rule), new FastIgnoreRule(originalRule));
                }
            }
            String pathToSplit = pathToTraverse.startsWith(""/"") ? pathToTraverse.substring(1) : pathToTraverse;
            pathToSplit = pathToSplit.endsWith(""/"") ? pathToSplit.substring(0, pathToSplit.length() - 1) : pathToSplit;
            String[] splitPath = pathToSplit.split(""/"");
            for (int j = 0; j < splitPath.length; j++) {
                String s = splitPath[j];
                traversedRemainingRules.add(new FastIgnoreRule(rulePath + (wildcardSuffix != null ? wildcardSuffix : ""*"")));
                rulePath.append(s);
                traversedRemainingRules.add(new FastIgnoreRule(""!"" + rulePath + (j < splitPath.length - 1 || path.endsWith(""/"") ? ""/"" : """")));
                rulePath.append(""/"");
            }
            reverse(traversedRemainingRules);
            return traversedRemainingRules;
        }
    }

    private static String asGitignoreFileLocation(PlainText text) {
        String gitignoreFileName = separatorsToUnix(text.getSourcePath().toString());
        gitignoreFileName = gitignoreFileName.startsWith(""/"") ? gitignoreFileName : ""/"" + gitignoreFileName;
        return gitignoreFileName.substring(0, gitignoreFileName.lastIndexOf(""/"") + 1);
    }
}
",{}
Set file permission attributes,"Set a file's read, write and executable permission attributes.",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;

import java.nio.file.Path;
import java.nio.file.PathMatcher;

@Value
@EqualsAndHashCode(callSuper = false)
public class SetFilePermissions extends Recipe {
    @Option(displayName = ""File matcher"",
            description = ""Permissions will be applied to matching files. This is a glob expression."",
            example = ""**/gradlew.bat"")
    String fileMatcher;

    @Option(displayName = ""Readable"",
            description = ""File read permission."")
    Boolean isReadable;

    @Option(displayName = ""Writable"",
            description = ""File write permission."")
    Boolean isWritable;

    @Option(displayName = ""Executable"",
            description = ""Files executable permission."")
    Boolean isExecutable;

    @Override
    public String getDisplayName() {
        return ""Set file permission attributes"";
    }

    @Override
    public String getDescription() {
        return ""Set a file's read, write and executable permission attributes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    SourceFile sourceFile = (SourceFile) tree;
                    Path sourcePath = sourceFile.getSourcePath();
                    PathMatcher pathMatcher = sourcePath.getFileSystem().getPathMatcher(""glob:"" + fileMatcher);
                    if(pathMatcher.matches(sourcePath)) {
                        if (sourceFile.getFileAttributes() == null) {
                            sourceFile = sourceFile.withFileAttributes(new FileAttributes(null, null, null, isReadable, isWritable, isExecutable, 0));
                        } else {
                            FileAttributes fileAttributes = sourceFile.getFileAttributes();
                            sourceFile = sourceFile.withFileAttributes(fileAttributes.withReadable(isReadable).withWritable(isWritable).withExecutable(isExecutable));
                        }
                        return sourceFile;
                    }
                }
                return super.visit(tree, ctx);
            }
        };
    }
}
","{
  ""fileMatcher"": ""String field"",
  ""isReadable"": ""Boolean field"",
  ""isWritable"": ""Boolean field"",
  ""isExecutable"": ""Boolean field""
}"
List runtime classpath,A diagnostic utility which emits the runtime classpath to a data table.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import io.github.classgraph.ClassGraph;
import io.github.classgraph.Resource;
import io.github.classgraph.ResourceList;
import io.github.classgraph.ScanResult;
import org.openrewrite.table.ClasspathReport;

import java.net.URI;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.groupingBy;

public class ListRuntimeClasspath extends ScanningRecipe<Integer> {
    transient ClasspathReport report = new ClasspathReport(this);

    @Override
    public String getDisplayName() {
        return ""List runtime classpath"";
    }

    @Override
    public String getDescription() {
        return ""A diagnostic utility which emits the runtime classpath to a data table."";
    }

    @Override
    public Integer getInitialValue(ExecutionContext ctx) {
        return 0;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Integer acc) {
        return TreeVisitor.noop();
    }

    @Override
    public Collection<? extends SourceFile> generate(Integer acc, ExecutionContext ctx) {
        try (ScanResult result = new ClassGraph().scan()) {
            ResourceList resources = result.getResourcesWithExtension("".jar"");
            Map<String, List<Resource>> classpathEntriesWithJarResources = resources.stream()
                    .collect(groupingBy(it -> it.getClasspathElementURI().toString()));
            for (URI classPathUri : result.getClasspathURIs()) {
                List<Resource> jarResources = classpathEntriesWithJarResources.get(classPathUri.toString());
                if (jarResources == null || jarResources.isEmpty()) {
                    report.insertRow(ctx, new ClasspathReport.Row(classPathUri.toString(), """"));
                } else {
                    for (Resource r : jarResources) {
                        report.insertRow(ctx, new ClasspathReport.Row(classPathUri.toString(), r.getPath()));
                    }
                }
            }
        }
        return emptyList();
    }
}
",{}
Do nothing,"Default no-op test, does nothing.",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.config.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.RecipeIntrospectionUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.internal.lang.NullUtils;
import org.openrewrite.table.RecipeRunStats;
import org.openrewrite.table.SourcesFileErrors;
import org.openrewrite.table.SourcesFileResults;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Duration;
import java.util.*;

import static java.util.Collections.emptyList;
import static java.util.Collections.emptySet;
import static org.openrewrite.internal.RecipeIntrospectionUtils.dataTableDescriptorFromDataTable;

/**
 * Provides a formalized link list data structure of {@link Recipe recipes} and a {@link Recipe#run(LargeSourceSet, ExecutionContext)} method which will
 * apply each recipes {@link TreeVisitor visitor} visit method to a list of {@link SourceFile sourceFiles}
 * <p>
 * Requires a name, {@link TreeVisitor visitor}.
 * Optionally a subsequent Recipe can be linked via {@link #getRecipeList()}}
 * <p>
 * An {@link ExecutionContext} controls parallel execution and lifecycle while providing a message bus
 * for sharing state between recipes and their visitors
 * <p>
 * returns a list of {@link Result results} for each modified {@link SourceFile}
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = ""@c"")
@JsonPropertyOrder({""@c""}) // serialize type info first
public abstract class Recipe implements Cloneable {
    public static final String PANIC = ""__AHHH_PANIC!!!__"";

    @SuppressWarnings(""unused"")
    @JsonProperty(""@c"")
    public String getJacksonPolymorphicTypeTag() {
        return getClass().getName();
    }

    @Nullable
    private transient RecipeDescriptor descriptor;

    @Nullable
    private transient List<DataTableDescriptor> dataTables;

    public static Recipe noop() {
        return new Noop();
    }

    static class Noop extends Recipe {
        @Override
        public String getDisplayName() {
            return ""Do nothing"";
        }

        @Override
        public String getDescription() {
            return ""Default no-op test, does nothing."";
        }
    }

    /**
     * @return The maximum number of cycles this recipe is allowed to make changes in a recipe run.
     */
    @Incubating(since = ""8.0.0"")
    public int maxCycles() {
        return Integer.MAX_VALUE;
    }

    /**
     * A human-readable display name for the recipe, initial capped with no period.
     * For example, ""Find text"". The display name can be assumed to be rendered in
     * documentation and other places where markdown is understood, so it is possible
     * to use stylistic markers like backticks to indicate types. For example,
     * ""Find uses of `java.util.List`"".
     *
     * @return The display name.
     */
    @Language(""markdown"")
    public abstract @NlsRewrite.DisplayName String getDisplayName();

    /**
     * A human-readable display name for this recipe instance, including some descriptive
     * text about the recipe options that are supplied, if any. The name must be
     * initial capped with no period. For example, ""Find text 'hello world'"".
     * <br/>
     * For recipes with no options, by default this is equal to {@link #getDisplayName()}. For
     * recipes with options, the default implementation does its best to summarize those options
     * in a way that fits in a reasonable amount of characters.
     * <br/>
     * For consistency, when surrounding option descriptive text in quotes to visually differentiate
     * it from the text before it, use single ``.
     * <br/>
     * Override to provide meaningful recipe instance names for recipes with complex sets of options.
     *
     * @return A name that describes this recipe instance.
     */
    @Incubating(since = ""8.12.0"")
    @Language(""markdown"")
    public String getInstanceName() {
        try {
            @Language(""markdown"")
            String suffix = getInstanceNameSuffix();
            if (!StringUtils.isBlank(suffix)) {
                return getDisplayName() + "" "" + suffix;
            }

            List<OptionDescriptor> options = new ArrayList<>(getOptionDescriptors());
            options.removeIf(opt -> !opt.isRequired());
            if (options.isEmpty()) {
                return getDisplayName();
            }
            if (options.size() == 1) {
                try {
                    OptionDescriptor option = options.get(0);
                    String name = option.getName();
                    Field optionField = getClass().getDeclaredField(name);
                    optionField.setAccessible(true);
                    Object optionValue = optionField.get(this);
                    if (optionValue != null &&
                        !Iterable.class.isAssignableFrom(optionValue.getClass()) &&
                        !optionValue.getClass().isArray()) {
                        return String.format(""%s `%s`"", getDisplayName(), optionValue);
                    }
                } catch (NoSuchFieldException | IllegalAccessException ignore) {
                    // we tried...
                }
            }
        } catch (Throwable ignored) {
            // Just in case instance name suffix throws an exception because
            // of unpopulated options or something similar to this.
        }
        return getDisplayName();
    }

    /**
     * Since most instance names will be constructed with {@link #getDisplayName()} followed
     * by some further descriptive text about the recipe's options, this method provides a convenient
     * way to just specify the option descriptive text. When {@link #getInstanceName()} is overridden,
     * this method has no effect. Generally either override this method or {@link #getInstanceName()}
     * if you want to customize the instance name text.
     *
     * @return A suffix to append to the display name of a recipe.
     */
    public String getInstanceNameSuffix() {
        return """";
    }

    /**
     * A human-readable description for the recipe, consisting of one or more full
     * sentences ending with a period.
     * <p>
     * ""Find methods by pattern."" is an example. The description can be assumed to be rendered in
     * documentation and other places where markdown is understood, so it is possible
     * to use stylistic markers like backticks to indicate types. For example,
     * ""Find uses of `java.util.List`."".
     *
     * @return The display name.
     */
    @Language(""markdown"")
    public abstract @NlsRewrite.Description String getDescription();

    /**
     * A set of strings used for categorizing related recipes. For example
     * ""testing"", ""junit"", ""spring"". Any individual tag should consist of a
     * single word, all lowercase.
     *
     * @return The tags.
     */
    public Set<String> getTags() {
        return emptySet();
    }

    /**
     * @return An estimated effort were a developer to fix manually instead of using this recipe.
     */
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    public final RecipeDescriptor getDescriptor() {
        if (descriptor == null) {
            descriptor = createRecipeDescriptor();
        }
        return descriptor;
    }

    protected RecipeDescriptor createRecipeDescriptor() {
        List<OptionDescriptor> options = getOptionDescriptors();
        ArrayList<RecipeDescriptor> recipeList1 = new ArrayList<>();
        for (Recipe next : getRecipeList()) {
            recipeList1.add(next.getDescriptor());
        }
        recipeList1.trimToSize();
        URI recipeSource;
        try {
            recipeSource = getClass().getProtectionDomain().getCodeSource().getLocation().toURI();
        } catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }

        return new RecipeDescriptor(getName(), getDisplayName(), getInstanceName(), getDescription(), getTags(),
                getEstimatedEffortPerOccurrence(), options, recipeList1, getDataTableDescriptors(),
                getMaintainers(), getContributors(), getExamples(), recipeSource);
    }

    private List<OptionDescriptor> getOptionDescriptors() {
        Recipe recipe = this;
        if (this instanceof DelegatingRecipe) {
            recipe = ((DelegatingRecipe) this).getDelegate();
        }

        ArrayList<OptionDescriptor> options = new ArrayList<>();

        for (Field field : recipe.getClass().getDeclaredFields()) {
            Object value;
            try {
                field.setAccessible(true);
                value = field.get(recipe);
            } catch (IllegalAccessException e) {
                value = null;
            }
            Option option = field.getAnnotation(Option.class);
            //noinspection ConstantValue
            if (option != null) {
                options.add(new OptionDescriptor(field.getName(),
                        field.getType().getSimpleName(),
                        option.displayName(),
                        option.description(),
                        option.example().isEmpty() ? null : option.example(),
                        option.valid().length == 1 && option.valid()[0].isEmpty() ? null : Arrays.asList(option.valid()),
                        option.required(),
                        value));
            }
        }
        // Option annotations can be placed on fields, bean-style getters, or on the primary constructor
        for (Method method : recipe.getClass().getDeclaredMethods()) {
            if (method.getName().startsWith(""get"") && method.getParameterCount() == 0) {
                Option option = method.getAnnotation(Option.class);
                //noinspection ConstantValue
                if (option != null) {
                    options.add(new OptionDescriptor(StringUtils.uncapitalize(method.getName().substring(3)),
                            method.getReturnType().getSimpleName(),
                            option.displayName(),
                            option.description(),
                            option.example().isEmpty() ? null : option.example(),
                            option.valid().length == 1 && option.valid()[0].isEmpty() ? null : Arrays.asList(option.valid()),
                            option.required(),
                            null));
                }
            }
        }
        try {
            Constructor<?> c = RecipeIntrospectionUtils.getPrimaryConstructor(getClass());
            for (Parameter parameter : c.getParameters()) {
                Option option = parameter.getAnnotation(Option.class);
                //noinspection ConstantValue
                if (option != null) {
                    options.add(new OptionDescriptor(parameter.getName(),
                            parameter.getType().getSimpleName(),
                            option.displayName(),
                            option.description(),
                            option.example().isEmpty() ? null : option.example(),
                            option.valid().length == 1 && option.valid()[0].isEmpty() ? null : Arrays.asList(option.valid()),
                            option.required(),
                            null));
                }
            }
        } catch (RecipeIntrospectionException ignored) {
            // Some exotic form of recipe
        }

        options.trimToSize();
        return options;
    }

    private static final List<DataTableDescriptor> GLOBAL_DATA_TABLES = Arrays.asList(
            dataTableDescriptorFromDataTable(new SourcesFileResults(Recipe.noop())),
            dataTableDescriptorFromDataTable(new SourcesFileErrors(Recipe.noop())),
            dataTableDescriptorFromDataTable(new RecipeRunStats(Recipe.noop()))
    );

    public List<DataTableDescriptor> getDataTableDescriptors() {
        return ListUtils.concatAll(dataTables == null ? emptyList() : dataTables, GLOBAL_DATA_TABLES);
    }

    /**
     * @return a list of the organization(s) responsible for maintaining this recipe.
     */
    public List<Maintainer> getMaintainers() {
        return new ArrayList<>();
    }

    @Setter
    @Nullable
    protected List<Contributor> contributors;

    public List<Contributor> getContributors() {
        if (contributors == null) {
            return new ArrayList<>();
        }
        return contributors;
    }

    @Setter
    @Nullable
    protected transient List<RecipeExample> examples;

    public List<RecipeExample> getExamples() {
        if (examples == null) {
            return new ArrayList<>();
        }
        return examples;
    }

    /**
     * @return Determines if another cycle is run when this recipe makes a change. In some cases, like changing method declaration names,
     * a further cycle is needed to update method invocations of that declaration that were visited prior to the declaration change. But other
     * visitors never need to cause another cycle, such as those that format whitespace or add search markers. Note that even when this is false,
     * the recipe will still run on another cycle if any other recipe causes another cycle to run. But if every recipe reports no need to run
     * another cycle (or if there are no changes made in a cycle), then another will not run.
     */
    public boolean causesAnotherCycle() {
        return false;
    }

    /**
     * At the end of a recipe run, a {@link RecipeScheduler} will call this method to allow the
     * recipe to perform any cleanup or finalization tasks. This method is guaranteed to be called
     * only once per run.
     *
     * @param ctx The recipe run execution context.
     */
    @Incubating(since = ""8.48.0"")
    public void onComplete(ExecutionContext ctx) {
        if (this instanceof DelegatingRecipe) {
            ((DelegatingRecipe) this).getDelegate().onComplete(ctx);
        }
    }

    /**
     * A list of recipes that run, source file by source file,
     * after this recipe. This method is guaranteed to be called only once
     * per cycle.
     * <p>
     * When creating a recipe with a fixed recipe list, either override
     * this method or {@link #buildRecipeList(RecipeList)} but ideally not
     * both, as their default implementations are interconnected.
     *
     * @return The list of recipes to run.
     */
    public List<Recipe> getRecipeList() {
        RecipeList list = new RecipeList(getName());
        buildRecipeList(list);
        return list.getRecipes();
    }

    /**
     * Used to build up a recipe list programmatically. Using the
     * methods on {@link RecipeList}, the appearance of a recipe
     * that chains other recipes with options will be not strikingly
     * different from defining it in a recipe.yml.
     * <p>
     * Building, or at least starting to build, recipes for complex
     * migrations with this method is more amenable to AI coding assistants
     * since these assistants are primarily optimized for providing completion
     * assistance in a single file.
     * <p>
     * When creating a recipe with a fixed recipe list, either override
     * this method or {@link #getRecipeList()} but ideally not
     * both, as their default implementations are interconnected.
     *
     * @param recipes A recipe list used to build up a series of recipes
     *                in code in a way that looks fairly declarative and
     *                therefore is more amenable to AI code completion.
     */
    @SuppressWarnings(""unused"")
    public void buildRecipeList(RecipeList recipes) {
    }

    /**
     * A recipe can optionally encapsulate a visitor that performs operations on a set of source files. Subclasses
     * of the recipe may override this method to provide an instance of a visitor that will be used when the recipe
     * is executed.
     *
     * @return A tree visitor that will perform operations associated with the recipe.
     */
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return TreeVisitor.noop();
    }

    @SuppressWarnings(""UnusedReturnValue"")
    public <D extends DataTable<?>> D addDataTable(D dataTable) {
        if (dataTables == null) {
            dataTables = new ArrayList<>();
        }
        dataTables.add(dataTableDescriptorFromDataTable(dataTable));
        return dataTable;
    }

    public final RecipeRun run(LargeSourceSet before, ExecutionContext ctx) {
        return run(before, ctx, 3);
    }

    public final RecipeRun run(LargeSourceSet before, ExecutionContext ctx, int maxCycles) {
        return run(before, ctx, maxCycles, 1);
    }

    public final RecipeRun run(LargeSourceSet before, ExecutionContext ctx, int maxCycles, int minCycles) {
        return new RecipeScheduler().scheduleRun(this, before, ctx, maxCycles, minCycles);
    }

    @SuppressWarnings(""unused"")
    public Validated<Object> validate(ExecutionContext ctx) {
        Validated<Object> validated = validate();

        for (Recipe recipe : getRecipeList()) {
            validated = validated.and(recipe.validate(ctx));
        }
        return validated;
    }

    /**
     * The default implementation of validate on the recipe will look for package and field level annotations that
     * indicate a field is not-null. The annotations must have run-time retention and the simple name of the annotation
     * must match one of the common names defined in {@link NullUtils}
     *
     * @return A validated instance based using non-null/nullable annotations to determine which fields of the recipe are required.
     */
    public Validated<Object> validate() {
        Validated<Object> validated = Validated.none();
        Class<? extends Recipe> clazz = this.getClass();
        List<Field> requiredFields = NullUtils.findNonNullFields(clazz);
        for (Field field : requiredFields) {
            try {
                validated = validated.and(Validated.required(clazz.getSimpleName() + '.' + field.getName(), field.get(this)));
            } catch (IllegalAccessException e) {
                validated = Validated.invalid(field.getName(), null, ""Unable to access "" + clazz.getName() + ""."" + field.getName(), e);
            }
        }
        for (Recipe recipe : getRecipeList()) {
            validated = validated.and(recipe.validate());
        }
        return validated;
    }

    public final Collection<Validated<Object>> validateAll() {
        return validateAll(new InMemoryExecutionContext(), new ArrayList<>());
    }

    public Collection<Validated<Object>> validateAll(ExecutionContext ctx, Collection<Validated<Object>> acc) {
        acc.add(validate(ctx));
        for (Recipe recipe : getRecipeList()) {
            recipe.validateAll(ctx, acc);
        }
        return acc;
    }

    public String getName() {
        return getClass().getName();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Recipe recipe = (Recipe) o;
        return getName().equals(recipe.getName());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName());
    }

    @Override
    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    public interface DelegatingRecipe {
        Recipe getDelegate();
    }

    /**
     * @return A new recipe builder.
     */
    @Incubating(since = ""8.31.0"")
    public static Builder builder(@NlsRewrite.DisplayName @Language(""markdown"") String displayName,
                                  @NlsRewrite.Description @Language(""markdown"") String description) {
        return new Builder(displayName, description);
    }

    @Incubating(since = ""8.31.0"")
    @RequiredArgsConstructor
    @FieldDefaults(level = AccessLevel.PRIVATE)
    public static class Builder {
        @NlsRewrite.DisplayName
        @Language(""markdown"")
        final String displayName;

        @NlsRewrite.Description
        @Language(""markdown"")
        final String description;

        TreeVisitor<? extends Tree, ExecutionContext> visitor = TreeVisitor.noop();

        public Builder visitor(TreeVisitor<? extends Tree, ExecutionContext> visitor) {
            this.visitor = visitor;
            return this;
        }

        public Recipe build(String name) {
            return new Recipe() {
                @Override
                public String getName() {
                    return name;
                }

                @Override
                public String getDisplayName() {
                    return displayName;
                }

                @Override
                public String getDescription() {
                    return description;
                }

                @Override
                public TreeVisitor<?, ExecutionContext> getVisitor() {
                    return visitor;
                }
            };
        }
    }
}
",{}
Add entries to `.gitignore`,"Adds entries to the project's `.gitignore` file. If no `.gitignore` file exists, one will be created. ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.text.PlainText;
import org.openrewrite.text.PlainTextParser;
import org.openrewrite.text.PlainTextVisitor;

import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.openrewrite.internal.StringUtils.isBlank;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddToGitignore extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""Entries"",
            description = ""Multiline text containing gitignore entries to add, each on a separate line. Comments and blank lines are preserved."",
            example = ""*.tmp\n.DS_Store\ntarget/"")
    String entries;

    @Option(displayName = ""File pattern"",
            description = ""A glob pattern to match `.gitignore` files to update. Defaults to only the root `.gitignore` file. "" +
                    ""Use `**/.gitignore` to update all `.gitignore` files in the repository, or specify a specific path like `src/.gitignore`."",
            required = false,
            example = "".gitignore"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Add entries to `.gitignore`"";
    }

    @Override
    public String getDescription() {
        return ""Adds entries to the project's `.gitignore` file. If no `.gitignore` file exists, one will be created. "" +
                ""Existing entries that match will not be duplicated."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        String pattern = getEffectiveFilePattern();
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    String sourcePath = ((SourceFile) tree).getSourcePath().toString();
                    // Check if this source file matches our target pattern
                    if (sourcePath.endsWith("".gitignore"") && shouldNotCreate(sourcePath, pattern)) {
                        shouldCreate.set(false);
                    }
                }
                return tree;
            }

            private boolean shouldNotCreate(String sourcePath, String pattern) {
                return pattern.contains(""*"") || pattern.contains(""?"") || sourcePath.equals(pattern);
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            String pattern = getEffectiveFilePattern();
            // Extract the path from the pattern for simple cases
            String path = patternToPathToCreate(pattern);
            return PlainTextParser.builder().build()
                    .parse(entries)
                    .map(text -> (SourceFile) text.withSourcePath(Paths.get(path)))
                    .collect(toList());
        }
        return emptyList();
    }

    private String getEffectiveFilePattern() {
        return isBlank(filePattern) ? "".gitignore"" : filePattern;
    }

    private String patternToPathToCreate(String pattern) {
        // Extract a concrete path from the pattern for file generation
        if (!pattern.contains(""*"") && !pattern.contains(""?"")) {
            // It's already a concrete path
            return pattern;
        }
        if (""**/.gitignore"".equals(pattern)) {
            // Default to root for wildcard patterns
            return "".gitignore"";
        }
        if (pattern.endsWith(""/.gitignore"")) {
            // Specific directory pattern like ""src/.gitignore""
            return pattern;
        }
        // Default to root for complex patterns
        return "".gitignore"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        String pattern = getEffectiveFilePattern();
        // Use the pattern directly for FindSourceFiles
        return Preconditions.check(new FindSourceFiles(pattern), new PlainTextVisitor<ExecutionContext>() {
            @Override
            public PlainText visitText(PlainText text, ExecutionContext ctx) {
                return text.withText(mergeGitignoreEntries(text.getText(), entries));
            }

            private String mergeGitignoreEntries(String existing, String newEntries) {
                String separator = existing.contains(""\r\n"") ? ""\r\n"" : ""\n"";

                Set<String> existingRules = new LinkedHashSet<>();
                Set<String> existingWildcardPatterns = new LinkedHashSet<>();
                Set<String> existingComments = new LinkedHashSet<>();
                List<String> existingLines = new ArrayList<>();

                if (!StringUtils.isBlank(existing)) {
                    for (String line : existing.split(""\r?\n"")) {
                        existingLines.add(line);
                        String trimmed = line.trim();
                        if (!StringUtils.isBlank(trimmed)) {
                            if (trimmed.startsWith(""#"")) {
                                existingComments.add(trimmed);
                            } else {
                                existingRules.add(normalizeRule(trimmed));
                                // Track wildcard patterns and directory patterns for superfluous entry checking
                                if (trimmed.endsWith(""/"")) {
                                    existingWildcardPatterns.add(trimmed + ""**"");
                                } else if (trimmed.contains(""*"")) {
                                    existingWildcardPatterns.add(trimmed);
                                }
                            }
                        }
                    }
                }

                List<String> linesToAdd = new ArrayList<>();

                for (String entry : newEntries.split(""\r?\n"")) {
                    String trimmed = entry.trim();
                    if (StringUtils.isBlank(trimmed)) {
                        continue;
                    }

                    if (trimmed.startsWith(""#"")) {
                        if (existingComments.add(trimmed)) {
                            linesToAdd.add(entry);
                        }
                    } else if (!isRedundantEntry(trimmed, existingWildcardPatterns) && existingRules.add(normalizeRule(trimmed))) {
                        linesToAdd.add(entry);
                    }
                }

                if (linesToAdd.isEmpty()) {
                    return existing;
                }

                List<String> result = new ArrayList<>(existingLines);

                if (!existingLines.isEmpty() && !StringUtils.isBlank(existingLines.get(existingLines.size() - 1))) {
                    result.add("""");
                }

                result.addAll(linesToAdd);

                return String.join(separator, result);
            }

            private String normalizeRule(String rule) {
                String normalized = rule.trim();

                if (normalized.startsWith(""!"")) {
                    normalized = normalized.substring(1).trim();
                }
                if (normalized.endsWith(""/"")) {
                    normalized = normalized.substring(0, normalized.length() - 1);
                }
                if (normalized.startsWith(""/"")) {
                    normalized = normalized.substring(1);
                }

                return normalized;
            }

            private boolean isRedundantEntry(String entry, Set<String> existingWildcardPatterns) {
                // Check if this entry would be redundant given existing wildcard patterns
                for (String pattern : existingWildcardPatterns) {
                    if (PathUtils.matchesGlob(Paths.get(entry), pattern)) {
                        return true;
                    }
                }
                return false;
            }
        });
    }
}
","{
  ""entries"": ""String field""
}"
Find source files with `ParseExceptionResult` markers,This recipe explores parse failures after an LST is produced for classifying the types of ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.marker.BuildMetadata;
import org.openrewrite.marker.DeserializationError;
import org.openrewrite.marker.Markup;
import org.openrewrite.table.ParseFailures;

import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.Objects;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindParseFailures extends Recipe {

    @Option(displayName = ""Max snippet length"",
            description = ""When the failure occurs on a granular tree element, its source code will be included "" +
                          ""as a column in the data table up to this maximum snippet length."",
            required = false)
    @Nullable
    Integer maxSnippetLength;

    @Option(displayName = ""Parser type"",
            description = ""Only display failures from parsers with this simple name."",
            required = false,
            example = ""YamlParser"")
    @Nullable
    String parserType;

    @Option(example = ""RuntimeException"", displayName = ""Stack trace"",
            description = ""Only mark stack traces with a message containing this text."",
            required = false)
    @Nullable
    String stackTrace;

    @Option(displayName = ""Created after"",
            description = ""Only report on source files that were created after this date."",
            example = ""2025-01-01"",
            required = false)
    @Nullable
    String createdAfter;

    transient ParseFailures failures = new ParseFailures(this);

    @Override
    public String getDisplayName() {
        return ""Find source files with `ParseExceptionResult` markers"";
    }

    @Override
    public String getDescription() {
        return ""This recipe explores parse failures after an LST is produced for classifying the types of "" +
               ""failures that can occur and prioritizing fixes according to the most common problems."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""createdAfter"", ""Must be empty or a valid date of format yyyy-MM-dd"", createdAfter, date -> {
            if (date != null && !date.isEmpty()) {
                try {
                    LocalDate.parse(date);
                } catch (Exception e) {
                    return false;
                }
            }
            return true;
        }));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> precondition = new TreeVisitor<Tree, ExecutionContext>() {
            final long createdAfterEpoch = createdAfter == null ? -1L : LocalDate.parse(createdAfter).atStartOfDay().toInstant(ZoneOffset.UTC).toEpochMilli();

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                return createdAfterEpoch == -1L || tree != null && tree.getMarkers().findFirst(BuildMetadata.class)
                        .map(BuildMetadata::getMetadata)
                        .map(m -> m.get(""createdAt""))
                        .map(Long::parseLong)
                        .map(t -> t >= createdAfterEpoch)
                        .orElse(false) ? null : tree;
            }
        };
        return Preconditions.check(precondition, new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public Tree postVisit(Tree tree, ExecutionContext ctx) {
                return tree.getMarkers().findFirst(ParseExceptionResult.class)
                        .map(exceptionResult -> report(tree, exceptionResult, ctx))
                        .orElse(tree.getMarkers().findFirst(DeserializationError.class)
                                .map(error -> report(tree, error, ctx))
                                .orElse(tree)
                        );
            }

            private Tree report(Tree tree, DeserializationError error, ExecutionContext ctx) {
                if (stackTrace != null && !error.getDetail().contains(stackTrace)) {
                    return tree;
                }

                failures.insertRow(ctx, new ParseFailures.Row(
                        ""Unknown"",
                        (tree instanceof SourceFile ? (SourceFile) tree : getCursor().firstEnclosingOrThrow(SourceFile.class))
                                .getSourcePath().toString(),
                        ""DeserializationError"",
                        null,
                        null,
                        error.getDetail()
                ));

                return Markup.info(tree, error.getMessage());
            }

            private Tree report(Tree tree, ParseExceptionResult exceptionResult, ExecutionContext ctx) {
                if (parserType != null && !Objects.equals(exceptionResult.getParserType(), parserType)) {
                    return tree;
                } else if (stackTrace != null && !exceptionResult.getMessage().contains(stackTrace)) {
                    return tree;
                }

                String snippet = tree instanceof SourceFile ? null : tree.printTrimmed(getCursor().getParentTreeCursor());
                if (snippet != null && maxSnippetLength != null && snippet.length() > maxSnippetLength) {
                    snippet = snippet.substring(0, maxSnippetLength);
                }

                failures.insertRow(ctx, new ParseFailures.Row(
                        exceptionResult.getParserType(),
                        (tree instanceof SourceFile ? (SourceFile) tree : getCursor().firstEnclosingOrThrow(SourceFile.class))
                                .getSourcePath().toString(),
                        exceptionResult.getExceptionType(),
                        exceptionResult.getTreeType(),
                        snippet,
                        exceptionResult.getMessage()
                ));

                return Markup.info(tree, exceptionResult.getMessage());
            }
        });
    }
}
",{}
Rename a file,Rename a file while keeping it in the same directory.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;

import java.nio.file.Path;
import java.nio.file.PathMatcher;

@Value
@EqualsAndHashCode(callSuper = false)
public class RenameFile extends Recipe {
    @Option(displayName = ""File matcher"",
            description = ""Matching files will be renamed. This is a glob expression."",
            example = ""**/application-*.yml"")
    String fileMatcher;

    @Option(displayName = ""The renamed file name"",
            description = ""Just the file name without the folder path that precedes it."",
            example = ""application.yml"")
    String fileName;

    @Override
    public String getDisplayName() {
        return ""Rename a file"";
    }

    @Override
    public String getDescription() {
        return ""Rename a file while keeping it in the same directory."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    SourceFile sourceFile = (SourceFile) tree;
                    Path sourcePath = sourceFile.getSourcePath();
                    PathMatcher pathMatcher = sourcePath.getFileSystem().getPathMatcher(""glob:"" + fileMatcher);
                    if(pathMatcher.matches(sourcePath)) {
                        return ((SourceFile) tree).withSourcePath(sourcePath.resolveSibling(fileName).normalize());
                    }
                }
                return super.visit(tree, ctx);
            }
        };
    }
}
","{
  ""fileMatcher"": ""String field"",
  ""fileName"": ""String field""
}"
Is in repository,A search recipe which marks files that are in a repository with one of the supplied names. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.marker.GitProvenance;
import org.openrewrite.marker.SearchResult;

import java.util.Optional;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class IsInRepository extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Is in repository"";
    }

    @Override
    public String getDescription() {
        return ""A search recipe which marks files that are in a repository with one of the supplied names. "" +
               ""Intended for use as a precondition for other recipes being run over many different repositories."";
    }

    @Option(displayName = ""Allowed repositories"",
            description = ""The names of the repositories that are allowed to be searched. "" +
                          ""Determines repository name according to git metadata recorded in the `GitProvenance` marker."",
            example = ""rewrite"")
    Set<String> allowedRepositories;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree == null) {
                    return null;
                }
                Optional<GitProvenance> maybeGp = tree.getMarkers().findFirst(GitProvenance.class);
                if (maybeGp.isPresent()) {
                    GitProvenance gp = maybeGp.get();
                    if (allowedRepositories.contains(gp.getRepositoryName())) {
                        return SearchResult.found(tree);
                    }
                }
                return tree;
            }
        };
    }
}
",{}
Find deserialization errors,Produces a data table collecting all deserialization errors of serialized LSTs.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.marker.DeserializationError;
import org.openrewrite.marker.LstProvenance;
import org.openrewrite.marker.Markup;
import org.openrewrite.marker.OutdatedSerializer;
import org.openrewrite.table.DeserializationErrorTable;

import java.time.Instant;
import java.time.ZonedDateTime;
import java.util.Optional;

import static java.time.ZoneOffset.UTC;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDeserializationErrors extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find deserialization errors"";
    }

    @Override
    public String getDescription() {
        return ""Produces a data table collecting all deserialization errors of serialized LSTs."";
    }

    transient DeserializationErrorTable dataTable = new DeserializationErrorTable(this);

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree preVisit(Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                return tree.getMarkers().findFirst(DeserializationError.class)
                        .map(error -> {
                            Optional<OutdatedSerializer> outdatedSerializer = tree.getMarkers().findFirst(OutdatedSerializer.class);
                            Optional<LstProvenance> lstProvenance = tree.getMarkers().findFirst(LstProvenance.class);
                            dataTable.insertRow(ctx, new DeserializationErrorTable.Row(
                                    tree instanceof SourceFile ? ((SourceFile) tree).getSourcePath().toString() : null,
                                    error.getMessage(),
                                    error.getDetail(),
                                    outdatedSerializer.map(OutdatedSerializer::getLanguage).orElse(null),
                                    outdatedSerializer.map(OutdatedSerializer::getMinimumVersion).orElse(null),
                                    outdatedSerializer.map(OutdatedSerializer::getActualVersion)
                                            .orElseGet(() -> lstProvenance.map(LstProvenance::getBuildToolVersion).orElse(null)),
                                    lstProvenance.map(LstProvenance::getTimestampUtc).map(Instant::toEpochMilli).orElse(null),
                                    lstProvenance.map(LstProvenance::getTimestampUtc).map(ts -> ts.atZone(UTC)).map(ZonedDateTime::toString).orElse(null)
                            ));

                            return Markup.info(tree, error.getMessage());
                        })
                        .orElse(tree);
            }
        };
    }
}
",{}
Find files,Find files by source path. Paths are always interpreted as relative to the repository root.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;
import org.openrewrite.table.SourcesFiles;

import java.nio.file.Path;
import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Stream;


@Value
@EqualsAndHashCode(callSuper = false)
public class FindSourceFiles extends Recipe {
    transient SourcesFiles results = new SourcesFiles(this);

    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Find files"";
    }

    @Override
    public String getDescription() {
        return ""Find files by source path. Paths are always interpreted as relative to the repository root."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    SourceFile sourceFile = (SourceFile) tree;
                    Path sourcePath = sourceFile.getSourcePath();
                    if (matches(sourcePath)) {
                        results.insertRow(ctx, new SourcesFiles.Row(sourcePath.toString(),
                                tree.getClass().getSimpleName(), sourceFile instanceof Quark || sourceFile.getCharset() == null ? null : sourceFile.getCharset().toString()));
                        return SearchResult.found(sourceFile);
                    }
                }
                return tree;
            }

            String @Nullable[] filePatterns;

            private boolean matches(Path sourcePath) {
                if (filePatterns == null) {
                    filePatterns = Optional.ofNullable(filePattern)
                            .map(it -> it.split("";""))
                            .map(Arrays::stream)
                            .orElseGet(Stream::empty)
                            .map(String::trim)
                            .filter(StringUtils::isNotEmpty)
                            .map(FindSourceFiles::normalize)
                            .toArray(String[]::new);
                }
                return filePatterns.length == 0 || Arrays.stream(filePatterns).anyMatch(pattern -> PathUtils.matchesGlob(sourcePath, pattern));
            }
        };
    }

    private static String normalize(String filePattern) {
        if (filePattern.startsWith(""./"") || filePattern.startsWith("".\\"")) {
            return filePattern.substring(2);
        } else if (filePattern.startsWith(""/"") || filePattern.startsWith(""\\"")) {
            return filePattern.substring(1);
        }
        return filePattern;
    }

}
",{}
Find instances of type `Quark`,`Quark` source files are pointers to the existence of a file without capturing any of the contents of the file.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindQuarks extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Find instances of type `Quark`"";
    }

    @Override
    public String getDescription() {
        return ""`Quark` source files are pointers to the existence of a file without capturing any of the contents of the file."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark) {
                    return SearchResult.found(sourceFile);
                }
                return sourceFile;
            }
        };
    }
}
",{}
CompositeRecipe,A recipe that consists of a list of other recipes.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.Recipe;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * A recipe that exists only to wrap other recipes.
 * Anonymous recipe classes aren't serializable/deserializable so use this, or another named type, instead
 */
@RequiredArgsConstructor
public class CompositeRecipe extends Recipe {
    private final List<Recipe> recipeList;

    @Override
    public String getDisplayName() {
        return getName();
    }

    @Override
    public String getDescription() {
        return ""A recipe that consists of a list of other recipes."";
    }

    @Override
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return null;
    }

    @Override
    public List<Recipe> getRecipeList() {
        return recipeList;
    }

    @Override
    public List<DataTableDescriptor> getDataTableDescriptors() {
        List<DataTableDescriptor> dataTableDescriptors = null;
        for (Recipe recipe : getRecipeList()) {
            List<DataTableDescriptor> dtds = recipe.getDataTableDescriptors();
            if (!dtds.isEmpty()) {
                if (dataTableDescriptors == null) {
                    dataTableDescriptors = new ArrayList<>();
                }
                for (DataTableDescriptor dtd : dtds) {
                    if (!dataTableDescriptors.contains(dtd)) {
                        dataTableDescriptors.add(dtd);
                    }
                }
            }
        }
        return dataTableDescriptors == null ? super.getDataTableDescriptors() : dataTableDescriptors;
    }
}
",{}
Precondition bellwether,Evaluates a precondition and makes that result available to the preconditions of other recipes. ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.config;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.*;
import lombok.experimental.NonFinal;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;

import java.net.URI;
import java.time.Duration;
import java.util.*;
import java.util.function.Function;
import java.util.function.Supplier;

import static java.util.Collections.emptyList;
import static org.openrewrite.Validated.invalid;

@RequiredArgsConstructor
public class DeclarativeRecipe extends ScanningRecipe<DeclarativeRecipe.Accumulator> {
    @Getter
    private final String name;

    @Getter
    @Language(""markdown"")
    private final String displayName;

    @Getter
    @Language(""markdown"")
    @Nullable // in YAML the description is not always present
    private final String description;

    @Getter
    private final Set<String> tags;

    @Nullable
    private final Duration estimatedEffortPerOccurrence;

    private final URI source;

    private final boolean causesAnotherCycle;

    @Override
    public boolean causesAnotherCycle() {
        return causesAnotherCycle || super.causesAnotherCycle();
    }

    @Getter
    private final List<Maintainer> maintainers;

    private final List<Recipe> uninitializedRecipes = new ArrayList<>();

    @Setter
    private List<Recipe> recipeList = new ArrayList<>();

    private final List<Recipe> uninitializedPreconditions = new ArrayList<>();

    @Getter
    @Setter
    private List<Recipe> preconditions = new ArrayList<>();

    public void addPrecondition(Recipe recipe) {
        uninitializedPreconditions.add(recipe);
    }

    @JsonIgnore
    private Validated<Object> validation = Validated.none();

    @JsonIgnore
    private Validated<Object> initValidation = Validated.none();

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return estimatedEffortPerOccurrence == null ? Duration.ofMinutes(0) :
                estimatedEffortPerOccurrence;
    }

    public void initialize(Collection<Recipe> availableRecipes) {
        Map<String, Recipe> recipeMap = new HashMap<>();
        availableRecipes.forEach(r -> recipeMap.putIfAbsent(r.getName(), r));
        Set<String> initializingRecipes = new HashSet<>();
        initialize(uninitializedRecipes, recipeList, recipeMap::get, initializingRecipes);
        initialize(uninitializedPreconditions, preconditions, recipeMap::get, initializingRecipes);
    }

    @Deprecated
    public void initialize(Collection<Recipe> availableRecipes, Map<String, List<Contributor>> recipeToContributors) {
        this.initialize(availableRecipes);
    }

    public void initialize(Function<String, @Nullable Recipe> availableRecipes) {
        Set<String> initializingRecipes = new HashSet<>();
        initialize(uninitializedRecipes, recipeList, availableRecipes, initializingRecipes);
        initialize(uninitializedPreconditions, preconditions, availableRecipes, initializingRecipes);
    }

    @SuppressWarnings(""unused"")
    @Deprecated
    public void initialize(Function<String, @Nullable Recipe> availableRecipes, Map<String, List<Contributor>> recipeToContributors) {
        this.initialize(availableRecipes);
    }

    private void initialize(List<Recipe> uninitialized, List<Recipe> initialized, Function<String, @Nullable Recipe> availableRecipes, Set<String> initializingRecipes) {
        initialized.clear();
        for (int i = 0; i < uninitialized.size(); i++) {
            Recipe recipe = uninitialized.get(i);
            if (recipe instanceof LazyLoadedRecipe) {
                String recipeFqn = ((LazyLoadedRecipe) recipe).getRecipeFqn();
                Recipe subRecipe = availableRecipes.apply(recipeFqn);
                if (subRecipe != null) {
                    if (subRecipe instanceof DeclarativeRecipe) {
                        initializeDeclarativeRecipe((DeclarativeRecipe) subRecipe, recipeFqn, availableRecipes, initializingRecipes);
                    }
                    initialized.add(subRecipe);
                } else {
                    initValidation = initValidation.and(
                            invalid(name + "".recipeList"" +
                                    ""["" + i + ""] (in "" + source + "")"",
                                    recipeFqn,
                                    ""recipe '"" + recipeFqn + ""' does not exist."",
                                    null));
                }
            } else {
                if (recipe instanceof DeclarativeRecipe) {
                    initializeDeclarativeRecipe((DeclarativeRecipe) recipe, recipe.getName(), availableRecipes, initializingRecipes);
                }
                initialized.add(recipe);
            }
        }
    }

    private void initializeDeclarativeRecipe(DeclarativeRecipe declarativeRecipe, String recipeIdentifier,
                                              Function<String, @Nullable Recipe> availableRecipes, Set<String> initializingRecipes) {
        String recipeName = declarativeRecipe.getName();
        if (initializingRecipes.contains(recipeName)) {
            // Cycle detected - throw exception to fail fast
            String cycle = String.join("" -> "", initializingRecipes) + "" -> "" + recipeName;
            throw new RecipeIntrospectionException(
                    ""Recipe '"" + recipeIdentifier + ""' creates a cycle: "" + cycle);
        } else {
            initializingRecipes.add(recipeName);
            declarativeRecipe.initialize(declarativeRecipe.uninitializedRecipes, declarativeRecipe.recipeList, availableRecipes, initializingRecipes);
            declarativeRecipe.initialize(declarativeRecipe.uninitializedPreconditions, declarativeRecipe.preconditions, availableRecipes, initializingRecipes);
            initializingRecipes.remove(recipeName);
        }
    }

    @SuppressWarnings(""NotNullFieldNotInitialized"")
    @JsonIgnore
    private transient Accumulator accumulator;

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        Accumulator acc = new Accumulator();
        for (Recipe precondition : preconditions) {
            if (precondition instanceof ScanningRecipe && isScanningRequired(precondition)) {
                acc.recipeToAccumulator.put(precondition, ((ScanningRecipe<?>) precondition).getInitialValue(ctx));
            }
        }
        accumulator = acc;
        return acc;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @SuppressWarnings({""rawtypes"", ""unchecked""})
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                for (Recipe precondition : preconditions) {
                    if (precondition instanceof ScanningRecipe && isScanningRequired(precondition)) {
                        ScanningRecipe preconditionRecipe = (ScanningRecipe) precondition;
                        Object preconditionAcc = acc.recipeToAccumulator.get(precondition);
                        preconditionRecipe.getScanner(preconditionAcc)
                                .visit(tree, ctx);
                    }
                }
                return tree;
            }
        };
    }

    public static class Accumulator {
        Map<Recipe, Object> recipeToAccumulator = new HashMap<>();
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    @RequiredArgsConstructor
    static class PreconditionBellwether extends Recipe {

        @Override
        public String getDisplayName() {
            return ""Precondition bellwether"";
        }

        @Override
        public String getDescription() {
            return ""Evaluates a precondition and makes that result available to the preconditions of other recipes. "" +
                   ""\""bellwether\"", noun - One that serves as a leader or as a leading indicator of future trends."";
        }

        Supplier<TreeVisitor<?, ExecutionContext>> precondition;

        @NonFinal
        transient boolean preconditionApplicable;

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new TreeVisitor<Tree, ExecutionContext>() {
                final TreeVisitor<?, ExecutionContext> p = precondition.get();

                @Override
                public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                    return p.isAcceptable(sourceFile, ctx);
                }

                @Override
                public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                    Tree t = p.visit(tree, ctx);
                    preconditionApplicable = t != tree;
                    return tree;
                }
            };
        }
    }

    @EqualsAndHashCode(callSuper = false)
    @Value
    static class BellwetherDecoratedRecipe extends Recipe implements DelegatingRecipe {

        DeclarativeRecipe.PreconditionBellwether bellwether;
        Recipe delegate;

        @Override
        public String getName() {
            return delegate.getName();
        }

        @Override
        public String getDisplayName() {
            return delegate.getDisplayName();
        }

        @Override
        public String getDescription() {
            return delegate.getDescription();
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Preconditions.check(bellwether.isPreconditionApplicable(), delegate.getVisitor());
        }

        @Override
        public List<Recipe> getRecipeList() {
            return decorateWithPreconditionBellwether(bellwether, delegate.getRecipeList());
        }

        @Override
        public boolean causesAnotherCycle() {
            return delegate.causesAnotherCycle();
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    static class BellwetherDecoratedScanningRecipe<T> extends ScanningRecipe<T> implements DelegatingRecipe {

        DeclarativeRecipe.PreconditionBellwether bellwether;
        ScanningRecipe<T> delegate;

        @Override
        public String getName() {
            return delegate.getName();
        }

        @Override
        public String getDisplayName() {
            return delegate.getDisplayName();
        }

        @Override
        public String getDescription() {
            return delegate.getDescription();
        }

        @Override
        public T getInitialValue(ExecutionContext ctx) {
            return delegate.getInitialValue(ctx);
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getScanner(T acc) {
            return delegate.getScanner(acc);
        }

        @Override
        public Collection<? extends SourceFile> generate(T acc, ExecutionContext ctx) {
            return delegate.generate(acc, ctx);
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor(T acc) {
            return Preconditions.check(bellwether.isPreconditionApplicable(), delegate.getVisitor(acc));
        }

        @Override
        public boolean causesAnotherCycle() {
            return delegate.causesAnotherCycle();
        }

        @Override
        public List<Recipe> getRecipeList() {
            return decorateWithPreconditionBellwether(bellwether, delegate.getRecipeList());
        }
    }

    @Override
    public final List<Recipe> getRecipeList() {
        if (preconditions.isEmpty()) {
            return recipeList;
        }

        List<Supplier<TreeVisitor<?, ExecutionContext>>> andPreconditions = new ArrayList<>();
        for (Recipe precondition : preconditions) {
            andPreconditions.add(() -> orVisitors(precondition));
        }
        //noinspection unchecked
        PreconditionBellwether bellwether = new PreconditionBellwether(Preconditions.and(andPreconditions.toArray(new Supplier[]{})));
        List<Recipe> recipeListWithBellwether = new ArrayList<>(recipeList.size() + 1);
        recipeListWithBellwether.add(bellwether);
        recipeListWithBellwether.addAll(decorateWithPreconditionBellwether(bellwether, recipeList));
        return recipeListWithBellwether;
    }

    private TreeVisitor<?, ExecutionContext> orVisitors(Recipe recipe) {
        List<TreeVisitor<?, ExecutionContext>> conditions = new ArrayList<>();
        if (recipe instanceof ScanningRecipe) {
            //noinspection rawtypes
            ScanningRecipe scanning = (ScanningRecipe) recipe;
            //noinspection unchecked
            conditions.add(scanning.getVisitor(accumulator.recipeToAccumulator.get(scanning)));
        } else {
            conditions.add(recipe.getVisitor());
        }
        for (Recipe r : recipe.getRecipeList()) {
            conditions.add(orVisitors(r));
        }
        if (conditions.size() == 1) {
            return conditions.get(0);
        }
        //noinspection unchecked
        return Preconditions.or(conditions.toArray(new TreeVisitor[0]));
    }

    private static List<Recipe> decorateWithPreconditionBellwether(PreconditionBellwether bellwether, List<Recipe> recipeList) {
        List<Recipe> mappedRecipeList = new ArrayList<>(recipeList.size());
        for (Recipe recipe : recipeList) {
            if (recipe instanceof ScanningRecipe && isScanningRequired(recipe)) {
                mappedRecipeList.add(new BellwetherDecoratedScanningRecipe<>(bellwether, (ScanningRecipe<?>) recipe));
            } else {
                mappedRecipeList.add(new BellwetherDecoratedRecipe(bellwether, recipe));
            }
        }
        return mappedRecipeList;
    }

    private static boolean isScanningRequired(Recipe recipe) {
        if (recipe instanceof ScanningRecipe) {
            // DeclarativeRecipe is technically a ScanningRecipe, but it only needs the
            // scanning phase if it or one of its sub-recipes or preconditions is a ScanningRecipe
            if (recipe instanceof DeclarativeRecipe) {
                for (Recipe precondition : ((DeclarativeRecipe) recipe).getPreconditions()) {
                    if (isScanningRequired(precondition)) {
                        return true;
                    }
                }
            } else {
                return true;
            }
        }
        for (Recipe r : recipe.getRecipeList()) {
            if (isScanningRequired(r)) {
                return true;
            }
        }
        return false;
    }

    public void addUninitialized(Recipe recipe) {
        uninitializedRecipes.add(recipe);
    }

    public void addUninitialized(String recipeName) {
        uninitializedRecipes.add(new DeclarativeRecipe.LazyLoadedRecipe(recipeName));
    }

    public void addUninitializedPrecondition(Recipe recipe) {
        uninitializedPreconditions.add(recipe);
    }

    public void addUninitializedPrecondition(String recipeName) {
        uninitializedPreconditions.add(new DeclarativeRecipe.LazyLoadedRecipe(recipeName));
    }

    public void addValidation(Validated<Object> validated) {
        validation = validation.and(validated);
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = Validated.none();

        if (!uninitializedRecipes.isEmpty() && uninitializedRecipes.size() != recipeList.size()) {
            validated = validated.and(Validated.invalid(""initialization"", recipeList, ""DeclarativeRecipe must not contain uninitialized recipes. Be sure to call .initialize() on DeclarativeRecipe.""));
        }
        if (!uninitializedPreconditions.isEmpty() && uninitializedPreconditions.size() != preconditions.size()) {
            validated = validated.and(Validated.invalid(""initialization"", preconditions, ""DeclarativeRecipe must not contain uninitialized preconditions. Be sure to call .initialize() on DeclarativeRecipe.""));
        }

        return validated.and(validation)
                .and(initValidation == null ? Validated.none() : initValidation);
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class LazyLoadedRecipe extends Recipe {
        String recipeFqn;

        @Override
        public String getDisplayName() {
            return ""Lazy loaded recipe"";
        }

        @Override
        public String getDescription() {
            return ""Recipe that is loaded lazily."";
        }
    }

    @Override
    protected RecipeDescriptor createRecipeDescriptor() {
        List<RecipeDescriptor> recipeList = new ArrayList<>();
        for (Recipe childRecipe : getRecipeList()) {
            recipeList.add(childRecipe.getDescriptor());
        }
        return new RecipeDescriptor(getName(), getDisplayName(), getInstanceName(), getDescription() != null ? getDescription() : """",
                getTags(), getEstimatedEffortPerOccurrence(),
                emptyList(), recipeList, getDataTableDescriptors(), getMaintainers(), getContributors(),
                getExamples(), source);
    }

    @Override
    public List<Contributor> getContributors() {
        return emptyList();
    }

    @Override
    public List<DataTableDescriptor> getDataTableDescriptors() {
        List<DataTableDescriptor> dataTableDescriptors = null;
        for (Recipe recipe : getRecipeList()) {
            List<DataTableDescriptor> dtds = recipe.getDataTableDescriptors();
            if (!dtds.isEmpty()) {
                if (dataTableDescriptors == null) {
                    dataTableDescriptors = new ArrayList<>();
                }
                for (DataTableDescriptor dtd : dtds) {
                    if (!dataTableDescriptors.contains(dtd)) {
                        dataTableDescriptors.add(dtd);
                    }
                }
            }
        }
        return dataTableDescriptors == null ? super.getDataTableDescriptors() : dataTableDescriptors;
    }
}
",{}
Find committers on repositories,List the committers on a repository.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.GitProvenance;
import org.openrewrite.table.CommitsByDay;
import org.openrewrite.table.DistinctCommitters;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindCommitters extends ScanningRecipe<AtomicReference<GitProvenance>> {
    transient DistinctCommitters committers = new DistinctCommitters(this);
    transient CommitsByDay commitsByDay = new CommitsByDay(this);

    @Option(displayName = ""From date"",
            required = false,
            description = ""Optional. Take into account only commits since this date (inclusive). Default will be the entire history."",
            example = ""2023-01-01"")
    @Nullable
    String fromDate;

    @Override
    public String getDisplayName() {
        return ""Find committers on repositories"";
    }

    @Override
    public String getDescription() {
        return ""List the committers on a repository."";
    }

    @Override
    public int maxCycles() {
        // This recipe does not modify the LSTs and only requires the `GitProvenance` marker
        return 1;
    }

    @Override
    public AtomicReference<GitProvenance> getInitialValue(ExecutionContext ctx) {
        return new AtomicReference<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicReference<GitProvenance> acc) {
        return Preconditions.check(acc.get() == null, new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    SourceFile sourceFile = (SourceFile) tree;
                    sourceFile.getMarkers().findFirst(GitProvenance.class).ifPresent(provenance -> {
                        if (provenance.getCommitters() != null) {
                            acc.set(provenance);
                        }
                    });
                }
                return tree;
            }
        });
    }

    @Override
    public Collection<? extends SourceFile> generate(AtomicReference<GitProvenance> acc, ExecutionContext ctx) {
        GitProvenance gitProvenance = acc.get();
        if (gitProvenance != null) {
            LocalDate from = StringUtils.isBlank(fromDate) ? null : LocalDate.parse(fromDate);
            Collection<GitProvenance.Committer> committerList = findCommitters(gitProvenance, from);
            for (GitProvenance.Committer committer : committerList) {
                committers.insertRow(ctx, new DistinctCommitters.Row(
                        committer.getName(),
                        committer.getEmail(),
                        committer.getCommitsByDay().lastKey(),
                        committer.getCommitsByDay().values().stream().mapToInt(Integer::intValue).sum()
                ));
                committer.getCommitsByDay().forEach((day, commits) -> commitsByDay.insertRow(ctx, new CommitsByDay.Row(
                        committer.getName(),
                        committer.getEmail(),
                        day,
                        commits
                )));
            }
        }
        return emptyList();
    }

    public static Collection<GitProvenance.Committer> findCommitters(GitProvenance gitProvenance, @Nullable LocalDate from) {
        LocalDate cutOff = from == null ? null : from.minusDays(1);
        List<GitProvenance.Committer> committerList = new ArrayList<>();
        for (GitProvenance.Committer committer : requireNonNull(gitProvenance.getCommitters())) {
            if (cutOff == null || committer.getCommitsByDay().keySet().stream().anyMatch(day -> day.isAfter(cutOff))) {
                committerList.add(committer);
            }
        }
        return committerList;
    }
}
",{}
Find build metadata,Find source files with matching build metadata.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.BuildMetadata;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindBuildMetadata extends Recipe {

    @Option(displayName = ""Build metadata key"",
            description = ""The key to search for in the build metadata."",
            example = ""lstFormatVersion"")
    String key;

    @Option(displayName = ""Build metadata value"",
            description = ""The value to search for in the build metadata."",
            example = ""2"")
    String value;

    @Override
    public String getDisplayName() {
        return ""Find build metadata"";
    }

    @Override
    public String getDescription() {
        return ""Find source files with matching build metadata."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof SourceFile) {
                    for (BuildMetadata buildMetadata : tree.getMarkers().findAll(BuildMetadata.class)) {
                        if (buildMetadata.getMetadata().containsKey(key)) {
                            if (buildMetadata.getMetadata().get(key).equals(value)) {
                                return SearchResult.found(tree, ""Found build metadata"");
                            }
                        }
                    }
                }
                return tree;
            }
        };
    }
}
","{
  ""key"": ""String field"",
  ""value"": ""String field""
}"
Find parse to print inequality,OpenRewrite `Parser` implementations should produce `SourceFile` objects whose `printAll()` ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.search;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.InMemoryDiffEntry;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.table.ParseToPrintInequalities;
import org.openrewrite.tree.ParseError;

import static java.util.Collections.emptySet;

public class FindParseToPrintInequality extends Recipe {
    transient ParseToPrintInequalities inequalities = new ParseToPrintInequalities(this);

    @Override
    public String getDisplayName() {
        return ""Find parse to print inequality"";
    }

    @Override
    public String getDescription() {
        return ""OpenRewrite `Parser` implementations should produce `SourceFile` objects whose `printAll()` "" +
               ""method should be byte-for-byte equivalent with the original source file. When this isn't true, "" +
               ""recipes can still run on the `SourceFile` and even produce diffs, but the diffs would fail to "" +
               ""apply as a patch to the original source file. Most `Parser` use `Parser#requirePrintEqualsInput` "" +
               ""to produce a `ParseError` when they fail to produce a `SourceFile` that is print idempotent."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof ParseError) {
                    ParseError parseError = (ParseError) tree;
                    if (parseError.getErroneous() != null) {
                        try (InMemoryDiffEntry diffEntry = new InMemoryDiffEntry(
                                parseError.getSourcePath(),
                                parseError.getSourcePath(),
                                null,
                                parseError.getText(),
                                parseError.getErroneous().printAll(),
                                emptySet()
                        )) {
                            inequalities.insertRow(ctx, new ParseToPrintInequalities.Row(
                                    parseError.getSourcePath().toString(),
                                    diffEntry.getDiff(false)
                            ));
                        }
                        return SearchResult.found(parseError);
                    }
                }
                return super.visit(tree, ctx);
            }
        };
    }
}
",{}
Repository contains file,"Intended to be used primarily as a precondition for other recipes, this recipe checks if a repository ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;

import java.time.Duration;
import java.util.concurrent.atomic.AtomicBoolean;

@SuppressWarnings(""unused"")
@Value
@EqualsAndHashCode(callSuper = false)
public class RepositoryContainsFile extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""File pattern"",
            description = ""A glob expression representing a file path to search for (relative to the project root). Blank/null matches all."" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match."",
            required = false,
            example = "".github/workflows/*.yml"")
    @Nullable
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""Repository contains file"";
    }

    @Override
    public String getDescription() {
        return ""Intended to be used primarily as a precondition for other recipes, this recipe checks if a repository "" +
               ""contains a specific file or files matching a pattern. If present all files in the repository are marked "" +
               ""with a `SearchResult` marker. If you want to get only the matching file as a search result, use `FindSourceFiles` instead."";
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ZERO;
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (acc.get()) {
                    return tree;
                }
                Tree t = new FindSourceFiles(filePattern).getVisitor().visit(tree, ctx);
                if (t != tree) {
                    acc.set(true);
                }
                return tree;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean acc) {
        if (!acc.get()) {
            return TreeVisitor.noop();
        }
        //noinspection NullableProblems
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(Tree tree, ExecutionContext ctx) {
                if(tree.getMarkers().findFirst(SearchResult.class).isPresent()) {
                    return tree;
                }
                return tree.withMarkers(tree.getMarkers().add(new SearchResult(Tree.randomId(), ""Repository contains file matching pattern: "" + filePattern)));
            }
        };
    }
}
",{}
End of Line @ End of File (EOL @ EOF),Ensure that the file ends with the newline character.\n\n,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;

import static java.util.Objects.requireNonNull;

public class EndOfLineAtEndOfFile extends Recipe {

    @Override
    public String getDisplayName() {
        return ""End of Line @ End of File (EOL @ EOF)"";
    }

    @Override
    public String getDescription() {
        return ""Ensure that the file ends with the newline character.\n\n"" +
                ""*Note*: If this recipe modifies a file, it converts the file into plain text. "" +
                ""As such, this recipe should be run after any recipe that modifies the language-specific LST."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark || sourceFile instanceof Remote || sourceFile instanceof Binary) {
                    return sourceFile;
                }
                PlainText plainText = PlainTextParser.convert(sourceFile);
                boolean whitespaceContainsCRLF = plainText.getText().contains(""\r\n"");
                if (!plainText.getText().endsWith(""\n"")) {
                    if (whitespaceContainsCRLF) {
                        return plainText.withText(plainText.getText() + ""\r\n"");
                    } else {
                        return plainText.withText(plainText.getText() + '\n');
                    }
                }
                return sourceFile;
            }
        };
    }
}
",{}
Change text,Completely replaces the contents of the text file with other text. ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;

import java.util.Set;

import static java.util.Collections.singleton;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeText extends Recipe {
    @Option(displayName = ""Text after change"",
            description = ""The text file will have only this text after the change. The snippet provided here can be multiline."",
            example = ""Some text."")
    String toText;

    @Override
    public Set<String> getTags() {
        return singleton(""plain text"");
    }

    @Override
    public String getDisplayName() {
        return ""Change text"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return ""to `"" + toText + ""`"";
    }

    @Override
    public String getDescription() {
        return ""Completely replaces the contents of the text file with other text. "" +
               ""Use together with a `FindSourceFiles` precondition to limit which files are changed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark || sourceFile instanceof Remote || sourceFile instanceof Binary) {
                    return sourceFile;
                }
                PlainText plainText = PlainTextParser.convert(sourceFile);
                return plainText.withText(toText);
            }
        };
    }
}
","{
  ""toText"": ""String field""
}"
Create text file,Creates a new plain text file.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CreateTextFile extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""File contents"",
            description = ""Multiline text content for the file."",
            example = ""Some text."")
    String fileContents;

    @Option(displayName = ""Relative file path"",
            description = ""File path of new file."",
            example = ""foo/bar/baz.txt"")
    String relativeFileName;

    @Option(displayName = ""Overwrite existing file"",
            description = ""If there is an existing file, should it be overwritten."",
            required = false)
    @Nullable
    Boolean overwriteExisting;

    @Override
    public String getDisplayName() {
        return ""Create text file"";
    }

    @Override
    public String getDescription() {
        return ""Creates a new plain text file."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        return new CreateFileVisitor(Paths.get(relativeFileName), shouldCreate);
    }

    @Override
    public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            return PlainTextParser.builder().build().parse(fileContents)
                    .map(brandNewFile -> (SourceFile) brandNewFile.withSourcePath(Paths.get(relativeFileName)))
                    .collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
        Path path = Paths.get(relativeFileName);
        return new TreeVisitor<SourceFile, ExecutionContext>() {
            @Override
            public SourceFile visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (Boolean.TRUE.equals(overwriteExisting) && path.equals(sourceFile.getSourcePath())) {
                    if (sourceFile instanceof PlainText) {
                        return ((PlainText) sourceFile).withText(fileContents);
                    }
                    PlainText plainText = PlainText.builder()
                            .id(sourceFile.getId())
                            .sourcePath(sourceFile.getSourcePath())
                            .fileAttributes(sourceFile.getFileAttributes())
                            .charsetBomMarked(sourceFile.isCharsetBomMarked())
                            .text(fileContents)
                            .build();
                    if (sourceFile.getCharset() != null) {
                        return plainText.withCharset(sourceFile.getCharset());
                    }
                    return plainText;
                }
                return sourceFile;
            }
        };
    }
}
","{
  ""fileContents"": ""String field"",
  ""relativeFileName"": ""String field""
}"
Append to text file,"Appends or replaces content of an existing plain text file, or creates a new one if it doesn't already exist. ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class AppendToTextFile extends ScanningRecipe<AtomicBoolean> {
    @Option(displayName = ""Relative file name"",
            description = ""File name, using a relative path. If a non-plaintext file already exists at this location, then this recipe will do nothing."",
            example = ""foo/bar/baz.txt"")
    String relativeFileName;

    @Option(displayName = ""Content"",
            description = ""Multiline text content to be appended to the file."",
            example = ""Some text."")
    String content;

    @Option(displayName = ""Preamble"",
            description = ""If a new file is created, this content will be included at the beginning."",
            example = ""# File generated by OpenRewrite #"",
            required = false)
    @Nullable String preamble;

    @Option(displayName = ""Append newline"",
            description = ""Print a newline automatically after the content (and preamble). Default true."",
            required = false)
    @Nullable Boolean appendNewline;

    @Option(displayName = ""Existing file strategy"",
            description = ""Determines behavior if a file exists at this location prior to Rewrite execution.\n\n"" +
                          ""- `Continue`: append new content to existing file contents. If existing file is not plaintext, recipe does nothing.\n"" +
                          ""- `Replace`: remove existing content from file.\n"" +
                          ""- `Leave`: *(default)* do nothing. Existing file is fully preserved.\n\n"" +
                          ""Note: this only affects the first interaction with the specified file per Rewrite execution.\n"" +
                          ""Subsequent instances of this recipe in the same Rewrite execution will always append."",
            valid = {""Continue"", ""Replace"", ""Leave""},
            required = false)
    @Nullable Strategy existingFileStrategy;

    public enum Strategy {Continue, Replace, Leave}

    @Override
    public String getDisplayName() {
        return ""Append to text file"";
    }

    @Override
    public String getDescription() {
        return ""Appends or replaces content of an existing plain text file, or creates a new one if it doesn't already exist. "" +
               ""Please note that this recipes requires existing plain text files' format to be successfully parsable by OpenRewrite. "" +
               ""If a file is left unchanged, it might be parsed as a `Quark` rather than plain text. In such case, use the `plainTextMask` option. "" +
               ""See the [Gradle](https://docs.openrewrite.org/reference/gradle-plugin-configuration#configuring-the-rewrite-dsl) or "" +
               ""[Maven](https://openrewrite.github.io/rewrite-maven-plugin/run-mojo.html#plainTextMasks) plugin configuration page."";
    }

    @Override
    public int maxCycles() {
        return 1;
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(false);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean fileExists) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (!fileExists.get() && sourceFile.getSourcePath().toString().equals(Paths.get(relativeFileName).toString())) {
                    fileExists.set(true);
                }
                return sourceFile;
            }
        };
    }

    @Override
    public Collection<PlainText> generate(AtomicBoolean fileExists, Collection<SourceFile> generatedInThisCycle, ExecutionContext ctx) {
        String maybeNewline = !Boolean.FALSE.equals(appendNewline) ? ""\n"" : """";
        String content = this.content + maybeNewline;
        String preamble = this.preamble != null ? this.preamble + maybeNewline : """";

        boolean exists = fileExists.get();
        Path path = Paths.get(relativeFileName);
        if (!exists) {
            for (SourceFile generated : generatedInThisCycle) {
                if (generated.getSourcePath().toString().equals(path.toString())) {
                    exists = true;
                    break;
                }
            }
        }

        return exists ?
                emptyList() :
                singletonList(PlainText.builder()
                        .text(preamble + content)
                        .sourcePath(path)
                        .build());
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean fileExists) {
        return Preconditions.check(fileExists.get(), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile.getSourcePath().toString().equals(Paths.get(relativeFileName).toString())) {
                    String maybeNewline = !Boolean.FALSE.equals(appendNewline) ? ""\n"" : """";
                    String content = AppendToTextFile.this.content + maybeNewline;
                    String preamble = AppendToTextFile.this.preamble != null ? AppendToTextFile.this.preamble + maybeNewline : """";

                    PlainText existingPlainText = (PlainText) sourceFile;
                    switch (existingFileStrategy != null ? existingFileStrategy : Strategy.Leave) {
                        case Continue:
                            if (!maybeNewline.isEmpty() && !existingPlainText.getText().endsWith(maybeNewline)) {
                                content = maybeNewline + content;
                            }
                            return existingPlainText.withText(existingPlainText.getText() + content);
                        case Replace:
                            return existingPlainText.withText(preamble + content);
                    }
                }
                return sourceFile;
            }
        });
    }

}
","{
  ""relativeFileName"": ""String field"",
  ""content"": ""String field""
}"
Find text,"Textual search, optionally using Regular Expression (regex) to query.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.apache.commons.lang3.BooleanUtils;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;
import org.openrewrite.table.TextMatches;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class Find extends Recipe {
    transient TextMatches textMatches = new TextMatches(this);

    @Override
    public String getDisplayName() {
        return ""Find text"";
    }

    @Override
    public String getDescription() {
        return ""Textual search, optionally using Regular Expression (regex) to query."";
    }

    @Option(displayName = ""Find"",
            description = ""The text to find. This snippet can be multiline."",
            example = ""blacklist"")
    String find;

    @Option(displayName = ""Regex"",
            description = ""If true, `find` will be interpreted as a [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression). Default `false`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Case sensitive"",
            description = ""If `true` the search will be sensitive to case. Default `false`."",
            required = false)
    @Nullable
    Boolean caseSensitive;

    @Option(displayName = ""Regex multiline mode"",
            description = ""When performing a regex search setting this to `true` allows \""^\"" and \""$\"" to match the beginning and end of lines, respectively. "" +
                          ""When performing a regex search when this is `false` \""^\"" and \""$\"" will match only the beginning and ending of the entire source file, respectively."" +
                          ""Has no effect when not performing a regex search. Default `false`."",
            required = false)
    @Nullable
    Boolean multiline;

    @Option(displayName = ""Regex dot all"",
            description = ""When performing a regex search setting this to `true` allows \"".\"" to match line terminators."" +
                          ""Has no effect when not performing a regex search. Default `false`."",
            required = false)
    @Nullable
    Boolean dotAll;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match. "" +
                          ""When not set, all source files are searched."",
            required = false,
            example = ""**/*.java"")
    @Nullable
    String filePattern;

    @Option(displayName = ""Description"",
            description = ""Add the matched value(s) as description on the search result marker.  Default `false`."",
            required = false)
    @Nullable
    Boolean description;

    @Option(displayName = ""Context size for Datatable"",
            description = ""The number of characters to include in the datatable before and after the match. Default `0`, "" +
                    ""`-1` indicates that the whole text should be used."",
            required = false,
            example = ""50"")
    @Nullable
    Integer contextSize;

    @Override
    public String getInstanceName() {
        return String.format(""Find text `%s`"", find);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        TreeVisitor<?, ExecutionContext> visitor = new TreeVisitor<Tree, ExecutionContext>() {

            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark || sourceFile instanceof Remote || sourceFile instanceof Binary) {
                    return sourceFile;
                }
                PlainText plainText = PlainTextParser.convert(sourceFile);
                String searchStr = find;
                if (!Boolean.TRUE.equals(regex)) {
                    searchStr = Pattern.quote(searchStr);
                }
                int patternOptions = 0;
                if (!Boolean.TRUE.equals(caseSensitive)) {
                    patternOptions |= Pattern.CASE_INSENSITIVE;
                }
                if (Boolean.TRUE.equals(multiline)) {
                    patternOptions |= Pattern.MULTILINE;
                }
                if (Boolean.TRUE.equals(dotAll)) {
                    patternOptions |= Pattern.DOTALL;
                }
                Pattern pattern = Pattern.compile(searchStr, patternOptions);
                Matcher matcher = pattern.matcher(plainText.getText());
                String rawText = plainText.getText();
                if (!matcher.find()) {
                    return sourceFile;
                }

                String sourceFilePath = sourceFile.getSourcePath().toString();

                List<PlainText.Snippet> snippets = new ArrayList<>();
                int previousEnd = 0;

                int lastNewLineIndex = -1;
                int nextNewLineIndex = -1;
                boolean isFirstMatch = true;

                do {
                    int matchStart = matcher.start();
                    snippets.add(snippet(rawText.substring(previousEnd, matchStart)));
                    String text = rawText.substring(matchStart, matcher.end());
                    snippets.add(SearchResult.found(snippet(text), BooleanUtils.isTrue(description) ? text : null));
                    previousEnd = matcher.end();

                    // For the first match, search backwards
                    if (isFirstMatch) {
                        lastNewLineIndex = rawText.lastIndexOf('\n', matchStart);
                        nextNewLineIndex = rawText.indexOf('\n', lastNewLineIndex + 1);
                        isFirstMatch = false;
                    } else if (nextNewLineIndex != -1 && nextNewLineIndex < matchStart) {
                        // Advance lastNewLineIndex while before match start
                        while (nextNewLineIndex != -1 && nextNewLineIndex < matchStart) {
                            lastNewLineIndex = nextNewLineIndex;
                            nextNewLineIndex = rawText.indexOf('\n', lastNewLineIndex + 1);
                        }
                    }

                    int startLine = lastNewLineIndex + 1;
                    int endLine = nextNewLineIndex > matcher.end() ? nextNewLineIndex : rawText.indexOf('\n', matcher.end());
                    if (endLine == -1) {
                        endLine = rawText.length();
                    }

                    String context = truncateContext(endLine, startLine, matcher, matchStart, rawText);

                    textMatches.insertRow(ctx, new TextMatches.Row(sourceFilePath, context));
                } while (matcher.find());
                snippets.add(snippet(rawText.substring(previousEnd)));
                return plainText.withText("""").withSnippets(snippets);
            }

            private String truncateContext(int endLine, int startLine, Matcher matcher, int matchStart, String rawText) {
                String matchText = matcher.group();
                int contextLength = contextSize == null ? 0 : contextSize;
                int contextStart = contextLength == -1 ? startLine : matchStart - contextLength;
                int contextEnd = contextLength == -1 ? endLine : matchStart + matchText.length() + contextLength;

                StringBuilder sb = new StringBuilder();

                if (contextStart > startLine) {
                    sb.append(""..."");
                }

                sb.append(rawText, Math.max(contextStart, startLine), matchStart)
                        .append(""~~>"")
                        .append(rawText, matchStart, Math.min(contextEnd, endLine));

                if (contextEnd < endLine) {
                    sb.append(""..."");
                }

                return sb.toString();
            }
        };
        if (filePattern != null) {
            visitor = Preconditions.check(new FindSourceFiles(filePattern), visitor);
        }
        return visitor;
    }

    private static PlainText.Snippet snippet(String text) {
        return new PlainText.Snippet(Tree.randomId(), Markers.EMPTY, text);
    }

}
","{
  ""find"": ""String field""
}"
Find and replace,"Textual find and replace, optionally interpreting the search query as a Regular Expression (regex). ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.marker.AlreadyReplaced;
import org.openrewrite.marker.Marker;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;

import java.util.Objects;
import java.util.regex.Pattern;

import static java.util.Objects.requireNonNull;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindAndReplace extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find and replace"";
    }

    @Override
    public String getDescription() {
        return ""Textual find and replace, optionally interpreting the search query as a Regular Expression (regex). "" +
               ""When operating on source files that are language-specific Lossless Semantic "" +
               ""Tree, such as Java or XML, this operation converts the source file to plain text for the rest of the recipe run. "" +
               ""So if you are combining this recipe with language-specific recipes in a single recipe run put all the language-specific recipes before this recipe."";
    }

    @Option(displayName = ""Find"",
            description = ""The text to find (and replace). This snippet can be multiline."",
            example = ""blacklist"")
    String find;

    @Option(displayName = ""Replace"",
            description = ""The replacement text for `find`. This snippet can be multiline."",
            example = ""denylist"",
            required = false)
    @Nullable
    String replace;

    @Option(displayName = ""Regex"",
            description = ""Default false. If true, `find` will be interpreted as a [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression), and capture group contents will be available in `replace`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Case sensitive"",
            description = ""If `true` the search will be sensitive to case. Default `false`."",
            required = false)
    @Nullable
    Boolean caseSensitive;

    @Option(displayName = ""Regex multiline mode"",
            description = ""When performing a regex search setting this to `true` allows \""^\"" and \""$\"" to match the beginning and end of lines, respectively. "" +
                          ""When performing a regex search when this is `false` \""^\"" and \""$\"" will match only the beginning and ending of the entire source file, respectively."" +
                          ""Has no effect when not performing a regex search. Default `false`."",
            required = false)
    @Nullable
    Boolean multiline;

    @Option(displayName = ""Regex dot all"",
            description = ""When performing a regex search setting this to `true` allows \"".\"" to match line terminators."" +
                          ""Has no effect when not performing a regex search. Default `false`."",
            required = false)
    @Nullable
    Boolean dotAll;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match. "" +
                          ""When not set, all source files are searched."",
            required = false,
            example = ""**/*.java"")
    @Nullable
    String filePattern;

    @Option(displayName = ""Plaintext only"", description = ""Only alter files that are parsed as plaintext to prevent language-specific LST information loss. Defaults to false."",
            required = false)
    @Nullable
    Boolean plaintextOnly;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> visitor = new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark || sourceFile instanceof Remote || sourceFile instanceof Binary) {
                    return sourceFile;
                }
                for (Marker marker : sourceFile.getMarkers().getMarkers()) {
                    if (marker instanceof AlreadyReplaced) {
                        AlreadyReplaced alreadyReplaced = (AlreadyReplaced) marker;
                        if (Objects.equals(find, alreadyReplaced.getFind()) && Objects.equals(replace, alreadyReplaced.getReplace())) {
                            return sourceFile;
                        }
                    }
                }

                PlainText plainText = PlainTextParser.convert(sourceFile);
                String replacement = replace == null ? """" : replace;
                if (!Boolean.TRUE.equals(regex)) {
                    replacement = replacement.replace(""$"", ""\\$"");
                }

                String newText;
                if (!Boolean.TRUE.equals(regex) && Boolean.TRUE.equals(caseSensitive)) {
                    // optimize the case when doing case-sensitive string replacements
                    newText = plainText.getText().replace(find, replacement);
                } else {
                    int patternOptions = 0;
                    if (!Boolean.TRUE.equals(regex)) {
                        patternOptions |= Pattern.LITERAL;
                    }
                    if (!Boolean.TRUE.equals(caseSensitive)) {
                        patternOptions |= Pattern.CASE_INSENSITIVE;
                    }
                    if (Boolean.TRUE.equals(multiline)) {
                        patternOptions |= Pattern.MULTILINE;
                    }
                    if (Boolean.TRUE.equals(dotAll)) {
                        patternOptions |= Pattern.DOTALL;
                    }
                    Pattern pattern = Pattern.compile(find, patternOptions);
                    newText = pattern.matcher(plainText.getText()).replaceAll(replacement);
                }

                if (newText.equals(plainText.getText())) {
                    return sourceFile;
                }

                return plainText
                        .withText(newText)
                        .withMarkers(sourceFile.getMarkers().add(new AlreadyReplaced(randomId(), find, replace)));
            }
        };

        if (filePattern != null) {
            visitor = Preconditions.check(new FindSourceFiles(filePattern), visitor);
        }

        if (Boolean.TRUE.equals(plaintextOnly)) {
            visitor = Preconditions.check(new PlainTextVisitor<ExecutionContext>() {
                @Override
                public PlainText visitText(PlainText text, ExecutionContext ctx) {
                    return SearchResult.found(text);
                }
            }, visitor);
        }
        return visitor;
    }

}
",{}
Experimental find text with multiselect,"Search for text, treating all textual sources as plain text. ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.text;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.binary.Binary;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.quark.Quark;
import org.openrewrite.remote.Remote;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toSet;

@Incubating(since = ""8.2.0"")
@Value
@EqualsAndHashCode(callSuper = false)
public class FindMultiselect extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Experimental find text with multiselect"";
    }

    @Override
    public String getDescription() {
        return ""Search for text, treating all textual sources as plain text. "" +
               ""This version of the recipe exists to experiment with multiselect recipe options."";
    }

    @Option(displayName = ""Find"",
            description = ""The text to find. This snippet can be multiline."",
            example = ""blacklist"")
    String find;

    @Option(displayName = ""Regex"",
            description = ""If true, `find` will be interpreted as a Regular Expression. Default `false`."",
            required = false)
    @Nullable
    Boolean regex;

    @Option(displayName = ""Regex options"",
            description = ""Regex processing options. Multiple options may be specified. These options do nothing if `regex` mode is not enabled.\n"" +
                          ""* Case-sensitive - The search will be sensitive to letter case. "" +
                          ""* Multiline - Allows `^` and `$` to match the beginning and end of lines, respectively."" +
                          ""* Dot all - Allows `.` to match line terminators."",
            valid = {""Case-sensitive"", ""Multiline"", ""Dot all""},
            required = false)
    @Nullable
    Set<String> regexOptions;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match. "" +
                          ""When not set, all source files are searched. "",
            required = false,
            example = ""**/*.java"")
    @Nullable
    String filePattern;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Boolean caseSensitive;
        Boolean multiline;
        Boolean dotAll;
        if (regexOptions != null) {
            Set<String> lowerCaseOptions = regexOptions.stream()
                    .map(String::toLowerCase)
                    .collect(toSet());
            caseSensitive = lowerCaseOptions.contains(""Case-sensitive"");
            multiline = lowerCaseOptions.contains(""Multiline"");
            dotAll = lowerCaseOptions.contains(""Dot all"");
        } else {
            caseSensitive = null;
            multiline = null;
            dotAll = null;
        }

        TreeVisitor<?, ExecutionContext> visitor = new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                if (sourceFile instanceof Quark || sourceFile instanceof Remote || sourceFile instanceof Binary) {
                    return sourceFile;
                }
                PlainText plainText = PlainTextParser.convert(sourceFile);
                String searchStr = find;
                if (!Boolean.TRUE.equals(regex)) {
                    searchStr = Pattern.quote(searchStr);
                }
                int patternOptions = 0;
                if (!Boolean.TRUE.equals(caseSensitive)) {
                    patternOptions |= Pattern.CASE_INSENSITIVE;
                }
                if (Boolean.TRUE.equals(multiline)) {
                    patternOptions |= Pattern.MULTILINE;
                }
                if (Boolean.TRUE.equals(dotAll)) {
                    patternOptions |= Pattern.DOTALL;
                }
                Pattern pattern = Pattern.compile(searchStr, patternOptions);
                Matcher matcher = pattern.matcher(plainText.getText());
                String rawText = plainText.getText();
                if (!matcher.find()) {
                    return sourceFile;
                }
                matcher.reset();
                List<PlainText.Snippet> snippets = new ArrayList<>();
                int previousEnd = 0;
                while (matcher.find()) {
                    int matchStart = matcher.start();
                    snippets.add(snippet(rawText.substring(previousEnd, matchStart)));
                    snippets.add(SearchResult.found(snippet(rawText.substring(matchStart, matcher.end()))));
                    previousEnd = matcher.end();
                }
                snippets.add(snippet(rawText.substring(previousEnd)));
                return plainText.withText("""").withSnippets(snippets);
            }
        };
        //noinspection DuplicatedCode
        if (filePattern != null) {
            //noinspection unchecked
            TreeVisitor<?, ExecutionContext> check = Preconditions.or(Arrays.stream(filePattern.split("";""))
                    .map(FindSourceFiles::new)
                    .map(Recipe::getVisitor)
                    .toArray(TreeVisitor[]::new));

            visitor = Preconditions.check(check, visitor);
        }
        return visitor;
    }


    private static PlainText.Snippet snippet(String text) {
        return new PlainText.Snippet(Tree.randomId(), Markers.EMPTY, text);
    }
}
","{
  ""find"": ""String field""
}"
RpcRecipe,,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.rpc;

import lombok.RequiredArgsConstructor;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.config.OptionDescriptor;
import org.openrewrite.config.RecipeDescriptor;
import org.openrewrite.config.RecipeExample;

import java.time.Duration;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;


@RequiredArgsConstructor
public class RpcRecipe extends ScanningRecipe<Integer> {
    private final transient RewriteRpc rpc;
    private transient @Nullable List<Recipe> recipeList;

    /**
     * The ID that the remote is using to refer to this recipe.
     */
    private final String remoteId;

    private final RecipeDescriptor descriptor;
    private final String editVisitor;
    private final @Nullable TreeVisitor<?, ExecutionContext> editPreconditionVisitor;
    private final @Nullable String scanVisitor;
    private final @Nullable TreeVisitor<?, ExecutionContext> scanPreconditionVisitor;

    @Override
    public String getName() {
        return descriptor.getName();
    }

    @Override
    public String getDisplayName() {
        return descriptor.getDisplayName();
    }

    @Override
    public String getDescription() {
        return descriptor.getDescription();
    }

    @Override
    public Set<String> getTags() {
        return descriptor.getTags();
    }

    @Override
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return descriptor.getEstimatedEffortPerOccurrence();
    }

    @Override
    public List<RecipeExample> getExamples() {
        return descriptor.getExamples();
    }

    @Override
    public List<Contributor> getContributors() {
        // This is deprecated in RecipeDescriptor
        return emptyList();
    }

    @Override
    public List<Maintainer> getMaintainers() {
        return descriptor.getMaintainers();
    }

    @Override
    public Integer getInitialValue(ExecutionContext ctx) {
        return 0;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Integer acc) {
        return scanVisitor == null ? TreeVisitor.noop() : Preconditions.check(scanPreconditionVisitor, new RpcVisitor(rpc, scanVisitor));
    }

    @Override
    public Collection<? extends SourceFile> generate(Integer acc, ExecutionContext ctx) {
        return rpc.generate(remoteId, ctx);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Integer acc) {
        return Preconditions.check(editPreconditionVisitor, new RpcVisitor(rpc, editVisitor));
    }

    @Override
    public synchronized List<Recipe> getRecipeList() {
        if (recipeList == null) {
            recipeList = descriptor.getRecipeList().stream()
                    .map(r -> rpc.prepareRecipe(r.getName(), r.getOptions().stream()
                            .filter(opt -> opt.getValue() != null)
                            .collect(toMap(OptionDescriptor::getName, OptionDescriptor::getValue))))
                    .collect(toList());
        }
        return recipeList;
    }

    @Override
    public void onComplete(ExecutionContext ctx) {
        // This will merge data tables from the remote into the local context.
        //
        // When multiple recipes ran on the same RPC peer, they will all have been
        // adding to the same ExecutionContext instance on that peer, and so really
        // a CHANGE will only be returned for the first of any recipes on that peer.
        //
        // It doesn't matter which one added data table entries, because they all share
        // the same view of the data tables.
        String id = ctx.getMessage(""org.openrewrite.rpc.id"");
        if (id != null) {
            rpc.getObject(id);
        }
    }
}
",{}
Remove trailing whitespace,Remove any extra trailing whitespace from the end of each line.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.format.RemoveTrailingWhitespaceVisitor;

public class RemoveTrailingWhitespace extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove trailing whitespace"";
    }

    @Override
    public String getDescription() {
        return ""Remove any extra trailing whitespace from the end of each line."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveTrailingWhitespaceVisitor<>();
    }
}
",{}
Change XML tag value,Alters the value of XML tags matching the provided expression. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.AlreadyReplaced;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.tree.Xml;

import java.util.regex.Pattern;

import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeTagValue extends Recipe {

    @Option(displayName = ""Element name"",
            description = ""The name of the element whose value is to be changed. Interpreted as an XPath Expression."",
            example = ""/settings/servers/server/username"")
    String elementName;

    @Option(displayName = ""Old value"",
            description = ""The old value of the tag. Interpreted as pattern if regex is enabled."",
            required = false,
            example = ""user"")
    @Nullable
    String oldValue;

    @Option(displayName = ""New value"",
            description = ""The new value for the tag. Supports capture groups when regex is enabled. "" +
                    ""If literal $,\\ characters are needed in newValue, with regex true, then it should be escaped."",
            example = ""user"")
    String newValue;

    @Option(displayName = ""Regex"",
            description = ""Default false. If true, `oldValue` will be interpreted as a [Regular Expression](https://en.wikipedia.org/wiki/Regular_expression), and capture group contents will be available in `newValue`."",
            required = false)
    @Nullable
    Boolean regex;

    @Override
    public String getDisplayName() {
        return ""Change XML tag value"";
    }

    @Override
    public String getDescription() {
        return ""Alters the value of XML tags matching the provided expression. "" +
                ""When regex is enabled the replacement happens only for text nodes provided the pattern matches."";
    }

    @Override
    public Validated<Object> validate(ExecutionContext ctx) {
        //noinspection ConstantValue
        return super.validate(ctx).and(Validated.test(""regex"", ""Regex usage requires an `oldValue`"", regex,
                value -> value == null || oldValue != null && !oldValue.equals(newValue)));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlVisitor<ExecutionContext>() {
            private final XPathMatcher xPathMatcher = new XPathMatcher(elementName);

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (xPathMatcher.matches(getCursor())) {
                    if (Boolean.TRUE.equals(regex) && oldValue != null) {
                        doAfterVisit(new RegexReplaceVisitor<>(tag, oldValue, newValue));
                    } else if (oldValue == null || oldValue.equals(tag.getValue().orElse(null))) {
                        doAfterVisit(new ChangeTagValueVisitor<>(tag, newValue));
                    }
                }
                return super.visitTag(tag, ctx);
            }
        };
    }

    /**
     * This visitor finds and replaces text within a specified XML tag.
     * It supports both literal and regular expression replacements.
     * Use {@link ChangeTagValueVisitor} if you only wish change the value, irrespective of current data.
     *
     * @param <P>
     */
    @Value
    @EqualsAndHashCode(callSuper = false)
    static class RegexReplaceVisitor<P> extends XmlVisitor<P> {

        Xml.Tag scope;
        String oldValue;
        String newValue;

        @Override
        public Xml visitTag(Xml.Tag tag, P p) {
            Xml.Tag t = (Xml.Tag) super.visitTag(tag, p);
            if (scope.isScope(t) &&
                    t.getContent() != null &&
                    t.getContent().size() == 1 &&
                    t.getContent().get(0) instanceof Xml.CharData) {
                return updateUsingRegex(t, (Xml.CharData) t.getContent().get(0));
            }
            return t;
        }

        private Xml.Tag updateUsingRegex(Xml.Tag t, Xml.CharData content) {
            String text = content.getText();
            if (Pattern.compile(oldValue).matcher(text).find()) {
                Markers oldMarkers = content.getMarkers();
                if (oldMarkers
                        .findAll(AlreadyReplaced.class)
                        .stream()
                        .noneMatch(m -> oldValue.equals(m.getFind()) && newValue.equals(m.getReplace()))) {
                    return t.withContent(singletonList(content
                            .withText(text.replaceAll(oldValue, newValue))
                            .withMarkers(oldMarkers.add(new AlreadyReplaced(randomId(), oldValue, newValue)))));
                }
            }
            return t;
        }
    }
}
","{
  ""elementName"": ""String field"",
  ""newValue"": ""String field""
}"
XSLT transformation,Apply the specified XSLT transformation on matching files. ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.Arrays;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
@Incubating(since = ""8.30.0"")
public class XsltTransformation extends Recipe {

    @Nullable
    @Language(""xml"")
    @Option(displayName = ""XSLT Configuration transformation"",
            description = ""The transformation to be applied."",
            example = ""<xsl:stylesheet ...>...</xsl:stylesheet>"",
            required = false)
    String xslt;

    @Nullable
    @Option(displayName = ""XSLT Configuration transformation classpath resource"",
            description = ""Recipe transformation provided as a classpath resource."",
            example = ""/changePlugin.xslt"",
            required = false)
    String xsltResource;

    @Option(displayName = ""File pattern"",
            description = ""A glob expression that can be used to constrain which directories or source files should be searched. "" +
                          ""Multiple patterns may be specified, separated by a semicolon `;`. "" +
                          ""If multiple patterns are supplied any of the patterns matching will be interpreted as a match."",
            example = ""**/*.xml"")
    String filePattern;

    @Override
    public String getDisplayName() {
        return ""XSLT transformation"";
    }

    @Override
    public String getDescription() {
        return ""Apply the specified XSLT transformation on matching files. "" +
               ""Note that there are no format matching guarantees when running this recipe."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> visitor = new XsltTransformationVisitor(loadResource(xslt, xsltResource));

        @SuppressWarnings(""unchecked"")
        TreeVisitor<?, ExecutionContext> check = Preconditions.or(Arrays.stream(filePattern.split("";""))
                .map(FindSourceFiles::new)
                .map(FindSourceFiles::getVisitor)
                .toArray(TreeVisitor[]::new));

        return Preconditions.check(check, visitor);
    }

    @Override
    public Validated<Object> validate() {
        return super.validate()
                .and(Validated.test(""xslt"", ""set either xslt or xsltResource, but not both"",
                        xslt, s -> StringUtils.isBlank(s) != StringUtils.isBlank(xsltResource) &&
                                   !StringUtils.isBlank(loadResource(xslt, xsltResource))));
    }

    private static String loadResource(@Nullable String xslt, @Nullable String xsltResource) {
        if (StringUtils.isBlank(xsltResource)) {
            return requireNonNull(xslt);
        }
        try (InputStream is = XsltTransformation.class.getResourceAsStream(xsltResource)) {
            assert is != null;
            return StringUtils.readFully(is, Charset.defaultCharset());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
","{
  ""xslt"": ""String field"",
  ""xsltResource"": ""String field"",
  ""filePattern"": ""String field""
}"
Add or update child tag,Adds or updates a child element below the parent(s) matching the provided `parentXPath` expression. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddOrUpdateChildTag extends Recipe {

    @Option(displayName = ""Parent XPath"",
            description = ""XPath identifying the parent to which a child tag must be added"",
            example = ""/project//plugin//configuration"")
    @Language(""xpath"")
    String parentXPath;

    @Option(displayName = ""New child tag"",
            description = ""The XML of the new child to add or update on the parent tag."",
            example = ""<skip>true</skip>"")
    @Language(""xml"")
    String newChildTag;

    @Option(displayName = ""Replace existing child"",
            description = ""Set to `false` to not replace the child tag if it already exists. Defaults to true."",
            required = false)
    @Nullable
    Boolean replaceExisting;

    @Override
    public String getDisplayName() {
        return ""Add or update child tag"";
    }

    @Override
    public String getDescription() {
        return ""Adds or updates a child element below the parent(s) matching the provided `parentXPath` expression. "" +
               ""If a child with the same name already exists, it will be replaced by default. Otherwise, a new child will be added. "" +
               ""This ensures idempotent behaviour."";
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate()
                .and(Validated.notBlank(""parentXPath"", parentXPath))
                .and(Validated.notBlank(""newChildTag"", newChildTag));
        try {
            Xml.Tag.build(newChildTag);
        } catch (Exception e) {
            validated = validated.and(Validated.invalid(""newChildTag"", newChildTag, ""Invalid XML for child tag"", e));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlVisitor<ExecutionContext>() {
            private final XPathMatcher xPathMatcher = new XPathMatcher(parentXPath);

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (xPathMatcher.matches(getCursor())) {
                    Xml.Tag newChild = Xml.Tag.build(newChildTag);
                    if (replaceExisting == null || replaceExisting || !tag.getChild(newChild.getName()).isPresent()) {
                        return AddOrUpdateChild.addOrUpdateChild(tag, newChild, getCursor().getParentOrThrow());
                    }
                }
                return super.visitTag(tag, ctx);
            }
        };
    }
}
",{}
Change XML attribute of a specific resource version,Alters XML Attribute value within specified element of a specific resource versions.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.trait.Namespaced;
import org.openrewrite.xml.tree.Xml;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.stream.Collectors.toMap;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeNamespaceValue extends Recipe {
    private static final String XMLNS_PREFIX = ""xmlns"";
    private static final String VERSION_PREFIX = ""version"";
    private static final String SCHEMA_LOCATION_MATCH_PATTERN = ""(?m)(.*)(%s)(\\s+)(.*)"";
    private static final String SCHEMA_LOCATION_REPLACEMENT_PATTERN = ""$1%s$3%s"";

    @Override
    public String getDisplayName() {
        return ""Change XML attribute of a specific resource version"";
    }

    @Override
    public String getDescription() {
        return ""Alters XML Attribute value within specified element of a specific resource versions."";
    }

    @Nullable
    @Option(displayName = ""Element name"",
            description = ""The name of the element whose attribute's value is to be changed. Interpreted as an XPath Expression."",
            example = ""property"",
            required = false)
    String elementName;

    @Nullable
    @Option(displayName = ""Old value"",
            description = ""Only change the property value if it matches the configured `oldValue`."",
            example = ""newfoo.bar.attribute.value.string"",
            required = false)
    String oldValue;

    @Option(displayName = ""New value"",
            description = ""The new value to be used for the namespace."",
            example = ""newfoo.bar.attribute.value.string"")
    String newValue;

    @Nullable
    @Option(displayName = ""Resource version"",
            description = ""The version of resource to change"",
            example = ""1.1"",
            required = false)
    String versionMatcher;

    @Nullable
    @Option(displayName = ""Search all namespaces"",
            description = ""Specify whether evaluate all namespaces. Defaults to true"",
            example = ""true"",
            required = false)
    Boolean searchAllNamespaces;

    @Nullable
    @Option(displayName = ""New Resource version"",
            description = ""The new version of the resource"",
            example = ""2.0"")
    String newVersion;

    @Option(displayName = ""Schema location"",
            description = ""The new value to be used for the namespace schema location."",
            example = ""newfoo.bar.attribute.value.string"",
            required = false)
    @Nullable
    String newSchemaLocation;

    public static final String XML_SCHEMA_INSTANCE_PREFIX = ""xsi"";
    public static final String XML_SCHEMA_INSTANCE_URI = ""http://www.w3.org/2001/XMLSchema-instance"";

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        XPathMatcher elementNameMatcher = elementName != null ? new XPathMatcher(elementName) : null;
        return new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document d = super.visitDocument(document, ctx);
                if (d != document) {
                    d = d.withRoot(addOrUpdateSchemaLocation(d.getRoot()));
                }
                return d;
            }

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);

                if (matchesElementName(getCursor()) && matchesVersion(t)) {
                    t = t.withAttributes(ListUtils.map(t.getAttributes(), this::maybeReplaceNamespaceAttribute));
                    t = t.withAttributes(ListUtils.map(t.getAttributes(), this::maybeReplaceVersionAttribute));
                }

                return t;
            }

            private boolean matchesElementName(Cursor cursor) {
                return elementNameMatcher == null || elementNameMatcher.matches(cursor);
            }

            private boolean matchesVersion(Xml.Tag tag) {
                if (versionMatcher == null) {
                    return true;
                }
                for (Xml.Attribute attribute : tag.getAttributes()) {
                    if (isVersionAttribute(attribute) && isVersionMatch(attribute)) {
                        return true;
                    }
                }
                return false;
            }

            private Xml.Attribute maybeReplaceNamespaceAttribute(Xml.Attribute attribute) {
                if (isXmlnsAttribute(attribute) && isOldValue(attribute)) {
                    return attribute.withValue(
                            new Xml.Attribute.Value(attribute.getId(),
                                    """",
                                    attribute.getMarkers(),
                                    attribute.getValue().getQuote(),
                                    newValue));
                }
                return attribute;
            }

            private Xml.Attribute maybeReplaceVersionAttribute(Xml.Attribute attribute) {
                if (isVersionAttribute(attribute) && newVersion != null) {
                    return attribute.withValue(
                            new Xml.Attribute.Value(attribute.getId(),
                                    """",
                                    attribute.getMarkers(),
                                    attribute.getValue().getQuote(),
                                    newVersion));
                }
                return attribute;
            }

            private boolean isXmlnsAttribute(Xml.Attribute attribute) {
                boolean searchAll = searchAllNamespaces == null || Boolean.TRUE.equals(searchAllNamespaces);
                return searchAll && attribute.getKeyAsString().startsWith(XMLNS_PREFIX) ||
                       !searchAll && XMLNS_PREFIX.equals(attribute.getKeyAsString());
            }

            private boolean isVersionAttribute(Xml.Attribute attribute) {
                return attribute.getKeyAsString().startsWith(VERSION_PREFIX);
            }

            private boolean isOldValue(Xml.Attribute attribute) {
                return oldValue == null || attribute.getValueAsString().equals(oldValue);
            }

            private boolean isVersionMatch(Xml.Attribute attribute) {
                if (versionMatcher == null) {
                    return true;
                }
                String[] versions = versionMatcher.split("","");
                double dversion = Double.parseDouble(attribute.getValueAsString());
                for (String splitVersion : versions) {
                    boolean checkGreaterThan = false;
                    double dversionExpected;
                    if (splitVersion.endsWith(""+"")) {
                        splitVersion = splitVersion.substring(0, splitVersion.length() - 1);
                        checkGreaterThan = true;
                    }
                    try {
                        dversionExpected = Double.parseDouble(splitVersion);
                    } catch (NumberFormatException e) {
                        return false;
                    }
                    if (!checkGreaterThan && dversionExpected == dversion || checkGreaterThan && dversionExpected <= dversion) {
                        return true;
                    }
                }
                return false;
            }

            private Xml.Tag addOrUpdateSchemaLocation(Xml.Tag root) {
                if (StringUtils.isBlank(newSchemaLocation)) {
                    return root;
                }
                Xml.Tag newRoot = maybeAddNamespace(root);
                Namespaced n = new Namespaced(new Cursor(null, newRoot));
                Optional<Xml.Attribute> maybeSchemaLocation = maybeGetSchemaLocation(n);
                if (maybeSchemaLocation.isPresent() && oldValue != null) {
                    newRoot = updateSchemaLocation(newRoot, maybeSchemaLocation.get());
                } else if (!maybeSchemaLocation.isPresent()) {
                    newRoot = addSchemaLocation(newRoot);
                }
                return newRoot;
            }

            private Optional<Xml.Attribute> maybeGetSchemaLocation(Namespaced n) {
                Map<String, String> namespaces = n.getNamespaces();
                for (Xml.Attribute attribute : n.getAttributes()) {
                    String attributeNamespace = namespaces.get(Namespaced.extractNamespacePrefix(attribute.getKeyAsString()));
                    if(XML_SCHEMA_INSTANCE_URI.equals(attributeNamespace) &&
                       attribute.getKeyAsString().endsWith(""schemaLocation"")) {
                        return Optional.of(attribute);
                    }
                }

                return Optional.empty();
            }
            private Xml.Tag maybeAddNamespace(Xml.Tag root) {
                Namespaced n = new Namespaced(new Cursor(null, root));
                Map<String, String> namespaces = n.getNamespaces();
                if (namespaces.containsValue(newValue) && !namespaces.containsValue(XML_SCHEMA_INSTANCE_URI)) {
                    Map<String, String> newNamespaces = new LinkedHashMap<>(namespaces);
                    newNamespaces.put(XML_SCHEMA_INSTANCE_PREFIX, XML_SCHEMA_INSTANCE_URI);
                    root = withNamespaces(root, newNamespaces);
                }
                return root;
            }

            public Xml.Tag withNamespaces(Xml.Tag tag, Map<String, String> namespaces) {
                List<Xml.Attribute> attributes = tag.getAttributes();
                if (attributes.isEmpty()) {
                    for (Map.Entry<String, String> ns : namespaces.entrySet()) {
                        String key = Namespaced.getAttributeNameForPrefix(ns.getKey());
                        attributes = ListUtils.concat(attributes, new Xml.Attribute(
                                randomId(),
                                """",
                                Markers.EMPTY,
                                new Xml.Ident(
                                        randomId(),
                                        """",
                                        Markers.EMPTY,
                                        key
                                ),
                                """",
                                new Xml.Attribute.Value(
                                        randomId(),
                                        """",
                                        Markers.EMPTY,
                                        Xml.Attribute.Value.Quote.Double, ns.getValue()
                                )
                        ));
                    }
                } else {
                    Map<String, Xml.Attribute> attributeByKey = attributes.stream()
                            .collect(toMap(
                                    Xml.Attribute::getKeyAsString,
                                    a -> a
                            ));

                    for (Map.Entry<String, String> ns : namespaces.entrySet()) {
                        String key = Namespaced.getAttributeNameForPrefix(ns.getKey());
                        if (attributeByKey.containsKey(key)) {
                            Xml.Attribute attribute = attributeByKey.get(key);
                            if (!ns.getValue().equals(attribute.getValueAsString())) {
                                ListUtils.map(attributes, a -> a.getKeyAsString().equals(key) ?
                                        attribute.withValue(new Xml.Attribute.Value(randomId(), """", Markers.EMPTY, Xml.Attribute.Value.Quote.Double, ns.getValue())) :
                                        a
                                );
                            }
                        } else {
                            attributes = ListUtils.concat(attributes, new Xml.Attribute(
                                    randomId(),
                                    "" "",
                                    Markers.EMPTY,
                                    new Xml.Ident(
                                            randomId(),
                                            """",
                                            Markers.EMPTY,
                                            key
                                    ),
                                    """",
                                    new Xml.Attribute.Value(
                                            randomId(),
                                            """",
                                            Markers.EMPTY,
                                            Xml.Attribute.Value.Quote.Double, ns.getValue()
                                    )
                            ));
                        }
                    }
                }
                return tag.withAttributes(attributes);
            }

            private Xml.Tag updateSchemaLocation(Xml.Tag newRoot, Xml.Attribute attribute) {
                if(oldValue == null) {
                    return newRoot;
                }
                String oldSchemaLocation = attribute.getValueAsString();
                Matcher pattern = Pattern.compile(String.format(SCHEMA_LOCATION_MATCH_PATTERN, Pattern.quote(oldValue)))
                        .matcher(oldSchemaLocation);
                if (pattern.find()) {
                    String newSchemaLocationValue = pattern.replaceFirst(
                            String.format(SCHEMA_LOCATION_REPLACEMENT_PATTERN, newValue, newSchemaLocation)
                    );
                    Xml.Attribute newAttribute = attribute.withValue(attribute.getValue().withValue(newSchemaLocationValue));
                    newRoot = newRoot.withAttributes(ListUtils.map(newRoot.getAttributes(), a -> a == attribute ? newAttribute : a));
                }
                return newRoot;
            }

            private Xml.Tag addSchemaLocation(Xml.Tag newRoot) {
                return newRoot.withAttributes(
                        ListUtils.concat(
                                newRoot.getAttributes(),
                                new Xml.Attribute(
                                        randomId(),
                                        "" "",
                                        Markers.EMPTY,
                                        new Xml.Ident(
                                                randomId(),
                                                """",
                                                Markers.EMPTY,
                                                String.format(""%s:schemaLocation"", XML_SCHEMA_INSTANCE_PREFIX)
                                        ),
                                        """",
                                        new Xml.Attribute.Value(
                                                randomId(),
                                                """",
                                                Markers.EMPTY,
                                                Xml.Attribute.Value.Quote.Double,
                                                String.format(""%s %s"", newValue, newSchemaLocation)
                                        )
                                )
                        )
                );
            }
        };
    }
}
","{
  ""elementName"": ""String field"",
  ""oldValue"": ""String field"",
  ""newValue"": ""String field"",
  ""versionMatcher"": ""String field"",
  ""searchAllNamespaces"": ""Boolean field"",
  ""newVersion"": ""String field""
}"
Remove empty XML Tag,"Removes XML tags that do not have attributes or children, including self closing tags.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.tree.Xml;

public class RemoveEmptyXmlTags extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove empty XML Tag"";
    }

    @Override
    public String getDescription() {
        return ""Removes XML tags that do not have attributes or children, including self closing tags."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                //noinspection ConstantValue
                if (t != null && (t.getContent() == null || t.getContent().isEmpty()) && t.getAttributes().isEmpty()) {
                    doAfterVisit(new RemoveContentVisitor<>(t, true, true));
                }
                return t;
            }
        };
    }
}
",{}
Add new XML attribute for an Element,Add new XML attribute with value on a specified element.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.tree.Xml;

import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddTagAttribute extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Add new XML attribute for an Element"";
    }

    @Override
    public String getDescription() {
        return ""Add new XML attribute with value on a specified element."";
    }

    @Option(displayName = ""Element name"",
            description = ""The name of the element whose attribute's value is to be added. Interpreted as an XPath expression."",
            example = ""//beans/bean"")
    String elementName;

    @Option(displayName = ""Attribute name"",
            description = ""The name of the new attribute."",
            example = ""attribute-name"")
    String attributeName;

    @Option(displayName = ""New value"",
            description = ""The new value to be used for key specified by `attributeName`."",
            example = ""value-to-add"")
    String newValue;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (!new XPathMatcher(elementName).matches(getCursor())) {
                    return t;
                }

                for (Xml.Attribute attr : t.getAttributes()) {
                    if (attributeName.equals(attr.getKeyAsString())) {
                        return t;
                    }
                }

                Xml.Ident name = new Xml.Ident(randomId(), """", Markers.EMPTY, attributeName);
                Xml.Attribute.Value value = new Xml.Attribute.Value(randomId(), """", Markers.EMPTY, Xml.Attribute.Value.Quote.Double, newValue);
                return t.withAttributes(ListUtils.concat(t.getAttributes(),
                        new Xml.Attribute(randomId(), "" "", Markers.EMPTY, name, """", value)));
            }
        };
    }
}
","{
  ""elementName"": ""String field"",
  ""attributeName"": ""String field"",
  ""newValue"": ""String field""
}"
Change XML attribute,Alters XML attribute value on a specified element.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.xml.tree.Xml;

import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeTagAttribute extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Change XML attribute"";
    }

    @Override
    public String getDescription() {
        return ""Alters XML attribute value on a specified element."";
    }

    @Option(displayName = ""Element name"",
            description = ""The name of the element whose attribute's value is to be changed. Interpreted as an XPath expression."",
            example = ""property"")
    String elementName;

    @Option(displayName = ""Attribute name"",
            description = ""The name of the attribute whose value is to be changed."",
            example = ""name"")
    String attributeName;

    @Option(displayName = ""New value"",
            description = ""The new value to be used for key specified by `attributeName`, Set to null if you want to remove the attribute."",
            example = ""newfoo.bar.attribute.value.string"")
    @Nullable
    String newValue;

    @Option(displayName = ""Old value"",
            example = ""foo.bar.attribute.value.string"",
            required = false,
            description = ""Only change the property value if it matches the configured `oldValue`."")
    @Nullable
    String oldValue;

    @Option(displayName = ""Regex"",
            description = ""Default false. If true, `oldValue` will be interpreted as a Regular Expression, and capture group contents will be available in `newValue`."",
            required = false)
    @Nullable
    Boolean regex;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlVisitor<ExecutionContext>() {
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (new XPathMatcher(elementName).matches(getCursor())) {
                    t = t.withAttributes(ListUtils.map(t.getAttributes(), this::visitChosenElementAttribute));
                }
                return t;
            }

            public  Xml.@Nullable Attribute visitChosenElementAttribute(Xml.Attribute attribute) {
                if (!attribute.getKeyAsString().equals(attributeName)) {
                    return attribute;
                }

                String stringValue = attribute.getValueAsString();
                if (oldValue != null) {
                    if (Boolean.TRUE.equals(regex) && !Pattern.matches(oldValue, stringValue)) {
                        return attribute;
                    }
                    if ((regex == null || Boolean.FALSE.equals(regex)) && !stringValue.startsWith(oldValue)) {
                        return attribute;
                    }
                }

                if (newValue == null) {
                    //noinspection DataFlowIssue
                    return null;
                }

                String changedValue = oldValue != null ?
                        (Boolean.TRUE.equals(regex) ? stringValue.replaceAll(oldValue, newValue) : stringValue.replace(oldValue, newValue)) :
                        newValue;

                // Check if the value is already set to the desired value (idempotency)
                if (stringValue.equals(changedValue)) {
                    return attribute;
                }

                return attribute.withValue(
                        new Xml.Attribute.Value(attribute.getId(),
                                """",
                                attribute.getMarkers(),
                                attribute.getValue().getQuote(),
                                changedValue));
            }
        };
    }
}
","{
  ""elementName"": ""String field"",
  ""attributeName"": ""String field""
}"
Create XML file,Create a new XML file.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.xml.tree.Xml;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CreateXmlFile extends ScanningRecipe<AtomicBoolean> {

    @Option(displayName = ""Relative file path"",
            description = ""File path of new file."",
            example = ""foo/bar/baz.xml"")
    String relativeFileName;

    @Language(""xml"")
    @Option(displayName = ""File contents"",
            description = ""Multiline text content for the file."",
            example = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
                      ""<root>\n"" +
                      ""    <child>1</child>"" +
                      ""</root>"",
            required = false)
    @Nullable
    String fileContents;

    @Option(displayName = ""Overwrite existing file"",
            description = ""If there is an existing file, should it be overwritten."",
            required = false)
    @Nullable
    Boolean overwriteExisting;

    @Override
    public String getDisplayName() {
        return ""Create XML file"";
    }

    @Override
    public String getDescription() {
        return ""Create a new XML file."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        return new CreateFileVisitor(Paths.get(relativeFileName), shouldCreate);
    }

    @Override
    public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            return XmlParser.builder().build().parse(fileContents == null ? """" : fileContents)
                    .map(brandNewFile -> (SourceFile) brandNewFile.withSourcePath(Paths.get(relativeFileName)))
                    .collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
        Path path = Paths.get(relativeFileName);
        return new XmlVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                if (Boolean.TRUE.equals(overwriteExisting) && path.equals(document.getSourcePath())) {
                    if (StringUtils.isBlank(fileContents)) {
                        return document.withProlog(null).withRoot(null);
                    }
                    Optional<SourceFile> sourceFiles = XmlParser.builder().build()
                            .parse(fileContents)
                            .findFirst();
                    if (sourceFiles.isPresent()) {
                        SourceFile sourceFile = sourceFiles.get();
                        if (sourceFile instanceof Xml.Document) {
                            Xml.Document newXmlDocument = (Xml.Document) sourceFile;
                            return document
                                    .withProlog(newXmlDocument.getProlog())
                                    .withRoot(newXmlDocument.getRoot());
                        }
                    }
                }
                return document;
            }
        };
    }
}
","{
  ""relativeFileName"": ""String field""
}"
Remove XML tag,Removes XML tags matching the provided expression.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveXmlTag extends Recipe {

    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find matching tags."",
            example = ""/project/dependencies/dependency"")
    String xPath;

    @Option(displayName = ""File matcher"",
            description = ""If provided only matching files will be modified. This is a glob expression."",
            required = false,
            example = ""'**/application-*.xml'"")
    @Nullable
    String fileMatcher;

    @Override
    public String getDisplayName() {
        return ""Remove XML tag"";
    }

    @Override
    public String getDescription() {
        return ""Removes XML tags matching the provided expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new FindSourceFiles(fileMatcher), new XmlIsoVisitor<ExecutionContext>() {
            private final XPathMatcher xPathMatcher = new XPathMatcher(xPath);

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                if (xPathMatcher.matches(getCursor())) {
                    doAfterVisit(new RemoveContentVisitor<>(tag, true, true));
                }
                return super.visitTag(tag, ctx);
            }
        });
    }
}
","{
  ""xPath"": ""String field""
}"
Change XML tag name,Alters the name of XML tags matching the provided expression.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.xml.tree.Xml;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeTagName extends Recipe {
    @Option(displayName = ""Element name"",
            description = ""The name of the element whose attribute's value is to be changed. Interpreted as an XPath expression."",
            example = ""/settings/servers/server/username"")
    String elementName;

    @Option(displayName = ""New name"",
            description = ""The new name for the tag."",
            example = ""user"")
    String newName;

    @Override
    public String getDisplayName() {
        return ""Change XML tag name"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", elementName, newName);
    }

    @Override
    public String getDescription() {
        return ""Alters the name of XML tags matching the provided expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlIsoVisitor<ExecutionContext>() {
            private final XPathMatcher xPathMatcher = new XPathMatcher(elementName);

            @Override
            public Xml.Tag visitTag(final Xml.Tag tag, final ExecutionContext ctx) {
                if (xPathMatcher.matches(getCursor())) {
                    return tag.withName(newName);
                }
                return super.visitTag(tag, ctx);
            }
        };
    }
}
","{
  ""elementName"": ""String field"",
  ""newName"": ""String field""
}"
Add a comment to an XML tag,Adds a comment as the first element in an XML tag.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.util.ArrayList;
import java.util.List;

import static org.openrewrite.Tree.randomId;

@Incubating(since = ""7.24.0"")
@Value
@EqualsAndHashCode(callSuper = false)
public class AddCommentToXmlTag extends Recipe {

    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find matching tags."",
            example = ""/project/dependencies/dependency"")
    String xPath;

    @Option(displayName = ""Comment text"",
            description = ""The text to add as a comment.."",
            example = ""This is excluded due to CVE <X> and will be removed when we upgrade the next version is available."")
    String commentText;

    @Override
    public String getDisplayName() {
        return ""Add a comment to an XML tag"";
    }

    @Override
    public String getDescription() {
        return ""Adds a comment as the first element in an XML tag."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlVisitor<ExecutionContext>() {
            final XPathMatcher matcher = new XPathMatcher(xPath);

            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (matcher.matches(getCursor())) {
                    if (tag.getContent() != null) {
                        List<Content> contents = new ArrayList<>(tag.getContent());
                        boolean containsComment = contents.stream()
                                .anyMatch(c -> c instanceof Xml.Comment &&
                                        commentText.equals(((Xml.Comment) c).getText()));
                        if (!containsComment) {
                            int insertPos = 0;
                            Xml.Comment customComment = new Xml.Comment(randomId(),
                                    contents.get(insertPos).getPrefix(),
                                    Markers.EMPTY,
                                    commentText);
                            contents.add(insertPos, customComment);
                            t = t.withContent(contents);
                        }
                    }
                }
                return t;
            }
        };
    }
}
","{
  ""xPath"": ""String field"",
  ""commentText"": ""String field""
}"
Add date bounds to OWASP suppressions,Adds an expiration date to all OWASP suppressions in order to ensure that they are periodically reviewed. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.security;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.marker.Markers;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import java.time.LocalDate;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddOwaspDateBoundSuppressions extends Recipe {

    @Option(displayName = ""Until date"",
            required = false,
            description = ""Optional. The date to add to the suppression. Default will be 30 days from today."",
            example = ""2023-01-01"")
    @Nullable
    String untilDate;

    @Override
    public String getDisplayName() {
        return ""Add date bounds to OWASP suppressions"";
    }

    @Override
    public String getDescription() {
        return ""Adds an expiration date to all OWASP suppressions in order to ensure that they are periodically reviewed. "" +
               ""For use with the OWASP `dependency-check` tool. "" +
               ""More details: https://jeremylong.github.io/DependencyCheck/general/suppression.html."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""untilDate"", ""Must be empty or a valid date of format yyyy-MM-dd"", untilDate, date -> {
            if (date != null && !date.isEmpty()) {
                try {
                    LocalDate.parse(date);
                } catch (Exception e) {
                    return false;
                }
            }
            return true;
        }));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsOwaspSuppressionsFile(), new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (new XPathMatcher(""/suppressions/suppress"").matches(getCursor())) {
                    boolean hasUntil = false;
                    List<Xml.Attribute> attributes = t.getAttributes();
                    for (Xml.Attribute attribute : attributes) {
                        if (""until"".equals(attribute.getKeyAsString())) {
                            hasUntil = true;
                        }
                    }
                    if (!hasUntil) {
                        String date = (untilDate != null && !untilDate.isEmpty()) ? untilDate : LocalDate.now().plusDays(30).toString();
                        return t.withAttributes(ListUtils.concat(attributes, autoFormat(new Xml.Attribute(Tree.randomId(), """", Markers.EMPTY,
                                new Xml.Ident(Tree.randomId(), """", Markers.EMPTY, ""until""),
                                """",
                                autoFormat(new Xml.Attribute.Value(Tree.randomId(), """", Markers.EMPTY,
                                        Xml.Attribute.Value.Quote.Double,
                                        date + ""Z""), ctx)), ctx)));
                    }
                }
                return t;
            }
        });
    }
}
",{}
Update OWASP suppression date bounds,Updates the expiration date for OWASP suppressions having a matching cve tag. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.security;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import java.time.LocalDate;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class UpdateOwaspSuppressionDate extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Update OWASP suppression date bounds"";
    }

    @Override
    public String getDescription() {
        return ""Updates the expiration date for OWASP suppressions having a matching cve tag. "" +
               ""For use with the OWASP `dependency-check` tool. "" +
               ""More details: https://jeremylong.github.io/DependencyCheck/general/suppression.html."";
    }

    @Option(displayName = ""CVE List"",
            description = ""Update suppressions having any of the specified CVE tags."",
            example = ""CVE-2022-1234"")
    List<String> cveList;

    @Option(displayName = ""Until date"",
            required = false,
            description = ""Optional. The date to add to the suppression. Default will be 30 days from today."",
            example = ""2023-01-01"")
    @Nullable
    String untilDate;

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""untilDate"", ""Must be empty or a valid date of format yyyy-MM-dd"", untilDate, date -> {
            if (date != null && !date.isEmpty()) {
                try {
                    LocalDate.parse(date);
                } catch (Exception e) {
                    return false;
                }
            }
            return true;
        }));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsOwaspSuppressionsFile(), new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (new XPathMatcher(""/suppressions/suppress"").matches(getCursor())) {
                    boolean hasCve = false;
                    List<Xml.Tag> cveTags = t.getChildren(""cve"");
                    for (Xml.Tag xml : cveTags) {
                        String cveNum = xml.getValue().orElse("""");
                        for (String cve : cveList) {
                            if (!StringUtils.isNullOrEmpty(cve) && cve.equals(cveNum)) {
                                hasCve = true;
                                break;
                            }
                        }
                    }
                    if (hasCve) {
                        String date = (untilDate != null && !untilDate.isEmpty()) ? untilDate : LocalDate.now().plusDays(30).toString();
                        final String zuluDate = date + ""Z"";
                        t = t.withAttributes(ListUtils.map(t.getAttributes(), attr -> {
                            if (""until"".equals(attr.getKeyAsString())) {
                                if (!zuluDate.equals(attr.getValueAsString())) {
                                    attr = attr.withValue(attr.getValue().withValue(zuluDate));
                                }
                            }
                            return attr;
                        }));
                    }
                }
                return t;
            }
        });
    }
}
",{}
Remove out-of-date OWASP suppressions,"Remove all OWASP suppressions with a suppression end date in the past, as these are no longer valid. ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.security;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Content;
import org.openrewrite.xml.tree.Xml;

import java.time.LocalDate;
import java.time.format.DateTimeParseException;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveOwaspSuppressions extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove out-of-date OWASP suppressions"";
    }

    @Option(displayName = ""Until date"",
            required = false,
            description = ""Suppressions will be removed if they expired before the provided date. Default will be yesterday."",
            example = ""2023-01-01"")
    @Nullable
    String cutOffDate;

    @Override
    public String getDescription() {
        return ""Remove all OWASP suppressions with a suppression end date in the past, as these are no longer valid. "" +
                ""For use with the OWASP `dependency-check` tool. "" +
                ""More details on OWASP suppression files can be found [here](https://jeremylong.github.io/DependencyCheck/general/suppression.html)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new IsOwaspSuppressionsFile(), new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Tag visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = super.visitTag(tag, ctx);
                if (!new XPathMatcher(""/suppressions"").matches(getCursor()) || t.getContent() == null) {
                    return t;
                }
                return t.withContent(ListUtils.map(t.getContent(), c -> isPastDueSuppression(c) ? null : c));
            }

            private boolean isPastDueSuppression(Content content) {
                if (content instanceof Xml.Tag) {
                    Xml.Tag child = (Xml.Tag) content;
                    if (""suppress"".equals(child.getName())) {
                        for (Xml.Attribute attribute : child.getAttributes()) {
                            if (""until"".equals(attribute.getKeyAsString())) {
                                String maybeDate = attribute.getValueAsString();
                                if (maybeDate.endsWith(""Z"")) {
                                    maybeDate = maybeDate.substring(0, maybeDate.length() - 1);
                                }
                                try {
                                    LocalDate maxDate = LocalDate.now().minusDays(1);
                                    if (cutOffDate != null) {
                                        maxDate = LocalDate.parse(cutOffDate);
                                    }
                                    LocalDate date = LocalDate.parse(maybeDate);
                                    if (date.isBefore(maxDate)) {
                                        return true;
                                    }
                                } catch (DateTimeParseException e) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return false;
            }
        });
    }
}
",{}
Find OWASP vulnerability suppression XML files,These files are used to suppress false positives in OWASP [Dependency Check](https://jeremylong.github.io/DependencyCheck).,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.security;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

public class IsOwaspSuppressionsFile extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find OWASP vulnerability suppression XML files"";
    }

    @Override
    public String getDescription() {
        return ""These files are used to suppress false positives in OWASP [Dependency Check](https://jeremylong.github.io/DependencyCheck)."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new XmlIsoVisitor<ExecutionContext>() {
            @Override
            public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
                Xml.Document doc = super.visitDocument(document, ctx);
                if (doc.getRoot() == null) {
                    return doc;
                }
                Xml.Tag root = doc.getRoot();

                if (!""suppressions"".equals(root.getName())) {
                    return doc;
                }

                // check that root xmlns matches
                boolean isOwaspSuppressionFile = false;
                for (Xml.Attribute attribute : root.getAttributes()) {
                    if (""xmlns"".equals(attribute.getKeyAsString())) {
                        if (attribute.getValueAsString().matches(""https://jeremylong.github.io/DependencyCheck/dependency-suppression(.*?).xsd"")) {
                            isOwaspSuppressionFile = true;
                        }
                    }
                }
                if (isOwaspSuppressionFile) {
                    return doc.withRoot(SearchResult.found(doc.getRoot()));
                }
                return doc;
            }
        };
    }
}
",{}
XML style Auto-detection debug,Runs XML Autodetect and records the results in data tables and search markers. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.style;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.SourceFile;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.xml.XmlVisitor;
import org.openrewrite.xml.table.XmlStyleReport;
import org.openrewrite.xml.tree.Xml;

import java.util.Collection;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

public class AutodetectDebug extends ScanningRecipe<AutodetectDebug.Accumulator> {

    private final transient XmlStyleReport report = new XmlStyleReport(this);

    @Override
    public String getDisplayName() {
        return ""XML style Auto-detection debug"";
    }

    @Override
    public String getDescription() {
        return ""Runs XML Autodetect and records the results in data tables and search markers. "" +
               ""A debugging tool for figuring out why XML documents get styled the way they do."";
    }

    public static class Accumulator {
        Autodetect.Detector overallDetector = new Autodetect.Detector();

        @Nullable
        private TabsAndIndentsStyle overallProjectStyle;
        TabsAndIndentsStyle overallProjectStyle() {
            if(overallProjectStyle == null) {
                overallProjectStyle = requireNonNull(overallDetector.build().getStyle(TabsAndIndentsStyle.class));
            }
            return overallProjectStyle;
        }
    }

    @Override
    public AutodetectDebug.Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AutodetectDebug.Accumulator acc) {
        return new XmlVisitor<ExecutionContext>() {
            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                acc.overallDetector.sample(document);
                return document;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(AutodetectDebug.Accumulator acc, ExecutionContext ctx) {
        TabsAndIndentsStyle tis = acc.overallProjectStyle();

        report.insertRow(ctx, new XmlStyleReport.Row(
                ""Overall Project Style"",
                tis.getUseTabCharacter(),
                tis.getIndentSize(),
                tis.getTabSize(),
                tis.getContinuationIndentSize(),
                -1,
                -1,
                -1,
                -1,
                -1,
                -1
        ));
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(Accumulator acc) {
        return new XmlVisitor<ExecutionContext>() {

            @SuppressWarnings(""NotNullFieldNotInitialized"")
            TabsAndIndentsStyle currentDocumentStyle;
            int tagPrefixesCounted;
            int tagIndentsMatchingOwnStyle;
            int tagIndentsMatchingProjectStyle;
            int attributePrefixesCounted;
            int attributeIndentsMatchingOwnStyle;
            int attributeIndentsMatchingProjectStyle;

            @Override
            public Xml visitDocument(Xml.Document document, ExecutionContext ctx) {
                Autodetect.Detector detector = new Autodetect.Detector();
                detector.sample(document);
                currentDocumentStyle = requireNonNull(detector.build().getStyle(TabsAndIndentsStyle.class));
                super.visitDocument(document, ctx);

                report.insertRow(ctx, new XmlStyleReport.Row(
                        document.getSourcePath().toString(),
                        currentDocumentStyle.getUseTabCharacter(),
                        currentDocumentStyle.getIndentSize(),
                        currentDocumentStyle.getTabSize(),
                        currentDocumentStyle.getContinuationIndentSize(),
                        tagPrefixesCounted,
                        tagIndentsMatchingOwnStyle,
                        tagIndentsMatchingProjectStyle,
                        attributePrefixesCounted,
                        attributeIndentsMatchingOwnStyle,
                        attributeIndentsMatchingProjectStyle
                ));

                return document;
            }

            int depth = 0;
            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                // Depth 0 the expected prefix is always """" for all styles
                if (depth > 0) {
                    tagPrefixesCounted++;
                    if (indentMatchesStyle(tag.getPrefix(), depth, currentDocumentStyle)) {
                        tagIndentsMatchingOwnStyle++;
                    }
                    if (indentMatchesStyle(tag.getPrefix(), depth, acc.overallProjectStyle())) {
                        tagIndentsMatchingProjectStyle++;
                    }
                }

                // Attributes have the same depth as their parent tag
                ListUtils.map(tag.getAttributes(), a -> visitAndCast(a, ctx));

                depth++;
                ListUtils.map(tag.getContent(), a -> visitAndCast(a, ctx));
                depth--;
                return tag;
            }

            @Override
            public Xml visitAttribute(Xml.Attribute attribute, ExecutionContext ctx) {
                // Only attributes with newlines in their prefix are continuation indented
                if (attribute.getPrefix().contains(""\n"")) {
                    attributePrefixesCounted++;
                    if (continuationIndentMatchesStyle(attribute.getPrefix(), depth, currentDocumentStyle)) {
                        attributeIndentsMatchingOwnStyle++;
                    }
                    if (continuationIndentMatchesStyle(attribute.getPrefix(), depth, acc.overallProjectStyle())) {
                        attributeIndentsMatchingProjectStyle++;
                    }
                }
                return attribute;
            }
        };
    }

    private static boolean indentMatchesStyle(String prefix, int depth, TabsAndIndentsStyle s) {
        String lastLineOfPrefix = prefix.substring(prefix.lastIndexOf(""\n"") + 1);
        String expectedPrefix = (s.getUseTabCharacter()) ?
                StringUtils.repeat(""\t"", depth) :
                StringUtils.repeat("" "", s.getIndentSize() * depth);
        return lastLineOfPrefix.equals(expectedPrefix);
    }

    private static boolean continuationIndentMatchesStyle(String prefix, int depth, TabsAndIndentsStyle s) {
        String lastLineOfPrefix = prefix.substring(prefix.lastIndexOf(""\n"") + 1);
        String expectedPrefix = (s.getUseTabCharacter()) ?
                StringUtils.repeat(""\t"", depth) + StringUtils.repeat(""\t"", s.getContinuationIndentSize()) :
                StringUtils.repeat("" "", s.getIndentSize() * depth) + StringUtils.repeat("" "", s.getContinuationIndentSize());
        return lastLineOfPrefix.equals(expectedPrefix);
    }
}
",{}
Find XML namespace prefixes,"Find XML namespace prefixes, optionally restricting the search by a XPath expression.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.xml.trait.Namespaced;
import org.openrewrite.xml.tree.Xml;

import java.util.LinkedHashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindNamespacePrefix extends Recipe {

    @Option(displayName = ""Namespace prefix"",
            description = ""The Namespace Prefix to find."",
            example = ""http://www.w3.org/2001/XMLSchema-instance"")
    String namespacePrefix;

    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find namespace URIs."",
            example = ""/dependencies/dependency"",
            required = false)
    @Nullable
    String xPath;

    @Override
    public String getDisplayName() {
        return ""Find XML namespace prefixes"";
    }

    @Override
    public String getDescription() {
        return ""Find XML namespace prefixes, optionally restricting the search by a XPath expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Namespaced.matcher()
                .xPath(xPath)
                .prefix(namespacePrefix)
                .asVisitor(n -> n.getTree() instanceof Xml.Tag ?
                        SearchResult.found(n.getTree()) :
                        n.getTree());
    }

    public static Set<Xml.Tag> find(Xml x, String namespacePrefix, @Nullable String xPath) {
        Set<Xml.Tag> ts = new LinkedHashSet<>();
        Namespaced.matcher()
                .xPath(xPath)
                .prefix(namespacePrefix)
                .asVisitor(n ->
                {
                    if (n.getTree() instanceof Xml.Tag) {
                        ts.add((Xml.Tag) n.getTree());
                    }
                    return n.getTree();
                }).visit(x, 0);
        return ts;
    }
}
","{
  ""namespacePrefix"": ""String field""
}"
Find XML namespace URIs,"Find XML namespace URIs, optionally restricting the search by a XPath expression.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.xml.trait.Namespaced;
import org.openrewrite.xml.tree.Xml;

import java.util.LinkedHashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class HasNamespaceUri extends Recipe {

    @Option(displayName = ""Namespace URI"",
            description = ""The Namespace URI to find."",
            example = ""http://www.w3.org/2001/XMLSchema-instance"")
    String namespaceUri;

    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find namespace URIs."",
            example = ""/dependencies/dependency"",
            required = false)
    @Nullable
    String xPath;

    @Override
    public String getDisplayName() {
        return ""Find XML namespace URIs"";
    }

    @Override
    public String getDescription() {
        return ""Find XML namespace URIs, optionally restricting the search by a XPath expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Namespaced.matcher()
                .xPath(xPath)
                .uri(namespaceUri)
                .asVisitor(n -> n.getTree() instanceof Xml.Tag ?
                        SearchResult.found(n.getTree()) :
                        n.getTree());
    }

    public static Set<Xml.Tag> find(Xml x, String namespaceUri, @Nullable String xPath) {
        Set<Xml.Tag> ts = new LinkedHashSet<>();
        Namespaced.matcher()
                .xPath(xPath)
                .uri(namespaceUri)
                .asVisitor(n ->
                {
                    if (n.getTree() instanceof Xml.Tag) {
                        ts.add((Xml.Tag) n.getTree());
                    }
                    return n.getTree();
                }).visit(x, 0);
        return ts;
    }
}
","{
  ""namespaceUri"": ""String field""
}"
Find files without Namespace URI,"Find XML root elements that do not have a specific Namespace URI, optionally restricting the search by an XPath expression.",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

import static org.openrewrite.Preconditions.not;

@Value
@EqualsAndHashCode(callSuper = false)
public class DoesNotUseNamespaceUri extends Recipe {

    @Option(displayName = ""Namespace URI"",
            description = ""The Namespace URI to check."",
            example = ""http://www.w3.org/2001/XMLSchema-instance"")
    String namespaceUri;

    @Override
    public String getDisplayName() {
        return ""Find files without Namespace URI"";
    }

    @Override
    public String getDescription() {
        return ""Find XML root elements that do not have a specific Namespace URI, optionally restricting the search by an XPath expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
            return not(new HasNamespaceUri(namespaceUri, null).getVisitor());
    }
}
","{
  ""namespaceUri"": ""String field""
}"
Find XML tags,Find XML tags by XPath expression.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.xml.XPathMatcher;
import org.openrewrite.xml.XmlVisitor;
import org.openrewrite.xml.tree.Xml;

import java.util.HashSet;
import java.util.Set;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindTags extends Recipe {
    @Option(displayName = ""XPath"",
            description = ""An XPath expression used to find matching tags."",
            example = ""//dependencies/dependency"")
    String xPath;

    @Override
    public String getDisplayName() {
        return ""Find XML tags"";
    }

    @Override
    public String getDescription() {
        return ""Find XML tags by XPath expression."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        XPathMatcher matcher = new XPathMatcher(xPath);
        return new XmlVisitor<ExecutionContext>() {

            @Override
            public Xml visitTag(Xml.Tag tag, ExecutionContext ctx) {
                Xml.Tag t = (Xml.Tag) super.visitTag(tag, ctx);
                if (matcher.matches(getCursor())) {
                    t = SearchResult.found(t);
                }
                return t;
            }
        };
    }

    public static Set<Xml.Tag> find(Xml x, String xPath) {
        XPathMatcher matcher = new XPathMatcher(xPath);
        Set<Xml.Tag> ts = new HashSet<>();
        new XmlVisitor<Set<Xml.Tag>>() {
            @Override
            public Xml visitTag(Xml.Tag tag, Set<Xml.Tag> ts) {
                if (matcher.matches(getCursor())) {
                    ts.add(tag);
                }
                return super.visitTag(tag, ts);
            }
        }.visit(x, ts);
        return ts;
    }

    /**
     * Returns <code>null</code> if there is not exactly one tag matching this xPath
     */
    @SuppressWarnings(""unused"")
    @Incubating(since = ""7.33.0"")
    public static Xml.@Nullable Tag findSingle(Xml x, String xPath) {
        final Set<Xml.Tag> tags = find(x, xPath);
        if (tags.size() != 1) {
            return null;
        }
        for (final Xml.Tag tag : tags) {
            return tag;
        }
        return null;
    }
}
","{
  ""xPath"": ""String field""
}"
Normalize line breaks,Consistently use either Windows style (CRLF) or Linux style (LF) line breaks. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.style.GeneralFormatStyle;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.tree.Xml;

import static org.openrewrite.xml.format.AutodetectGeneralFormatStyle.autodetectGeneralFormatStyle;

public class NormalizeLineBreaks extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Normalize line breaks"";
    }

    @Override
    public String getDescription() {
        return ""Consistently use either Windows style (CRLF) or Linux style (LF) line breaks. "" +
                ""If no `GeneralFormatStyle` is specified this will use whichever style of line endings are more common."";
    }

    @Override
    public LineBreaksFromCompilationUnitStyle getVisitor() {
        return new LineBreaksFromCompilationUnitStyle();
    }

    private static class LineBreaksFromCompilationUnitStyle extends XmlIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
            GeneralFormatStyle generalFormatStyle = document.getStyle(GeneralFormatStyle.class);
            if (generalFormatStyle == null) {
                generalFormatStyle = autodetectGeneralFormatStyle(document);
            }

            doAfterVisit(new NormalizeLineBreaksVisitor<>(generalFormatStyle));
            return document;
        }
    }
}
",{}
Normalize format,Move whitespace to the outermost LST element possible.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;

/**
 * Ensures that whitespace is on the outermost AST element possible.
 */
public class NormalizeFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Normalize format"";
    }

    @Override
    public String getDescription() {
        return ""Move whitespace to the outermost LST element possible."";
    }

    @Override
    public NormalizeFormatVisitor<ExecutionContext> getVisitor() {
        return new NormalizeFormatVisitor<>();
    }
}
",{}
Blank lines,Add line breaks at appropriate places between XML syntax elements.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;

public class LineBreaks extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Blank lines"";
    }

    @Override
    public String getDescription() {
        return ""Add line breaks at appropriate places between XML syntax elements."";
    }

    @Override
    public LineBreaksVisitor<ExecutionContext> getVisitor() {
        return new LineBreaksVisitor<>();
    }
}
",{}
Normalize to tabs or spaces,Consistently use either tabs or spaces in indentation.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.style.Style;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.style.TabsAndIndentsStyle;
import org.openrewrite.xml.tree.Xml;

public class NormalizeTabsOrSpaces extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Normalize to tabs or spaces"";
    }

    @Override
    public String getDescription() {
        return ""Consistently use either tabs or spaces in indentation."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends XmlIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
            TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, document, () -> TabsAndIndentsStyle.DEFAULT);
            return (Xml.Document) new NormalizeTabsOrSpacesVisitor<>(style).visitNonNull(document, ctx);
        }
    }
}
",{}
Tabs and indents,Format tabs and indents in XML code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.style.Style;
import org.openrewrite.xml.XmlIsoVisitor;
import org.openrewrite.xml.style.TabsAndIndentsStyle;
import org.openrewrite.xml.tree.Xml;

public class TabsAndIndents extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Tabs and indents"";
    }

    @Override
    public String getDescription() {
        return ""Format tabs and indents in XML code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends XmlIsoVisitor<ExecutionContext> {
        @Override
        public Xml.Document visitDocument(Xml.Document document, ExecutionContext ctx) {
            TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, document, () -> TabsAndIndentsStyle.DEFAULT);
            return (Xml.Document) new TabsAndIndentsVisitor<>(style).visitNonNull(document, ctx);
        }
    }
}
",{}
Format XML,Indents XML using the most common indentation size and tabs or space choice in use in the file.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.xml.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;

public class AutoFormat extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Format XML"";
    }

    @Override
    public String getDescription() {
        return ""Indents XML using the most common indentation size and tabs or space choice in use in the file."";
    }

    @Override
    public AutoFormatVisitor<ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>();
    }

}
",{}
Randomize tree IDs,Scramble the IDs. This was intended as a utility to test _en masse_ ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class RandomizeId extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Randomize tree IDs"";
    }

    @Override
    public String getDescription() {
        return ""Scramble the IDs. This was intended as a utility to test _en masse_ "" +
                ""different techniques for UUID generation and compare their relative performance "" +
                ""outside a microbenchmark."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RandomizeIdVisitor<>();
    }
}
",{}
Remove method invocations,Remove method invocations if syntactically safe.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;

import static java.util.Collections.singletonList;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveMethodInvocations extends Recipe {
    @Option(displayName = ""Method pattern"",
            description = ""A pattern to match method invocations for removal. "" + MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.lang.StringBuilder append(java.lang.String)"")
    String methodPattern;

    @Override
    public String getDisplayName() {
        return ""Remove method invocations"";
    }

    @Override
    public String getDescription() {
        return ""Remove method invocations if syntactically safe."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(methodPattern),
                new RemoveMethodInvocationsVisitor(singletonList(methodPattern)));
    }
}
",{}
Order imports,"Groups and orders import statements. If a [style has been defined](https://docs.openrewrite.org/concepts-and-explanations/styles), this recipe will order the imports ",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.internal.FormatFirstClassPrefix;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.style.ImportLayoutStyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JRightPadded;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.style.Style;

import java.util.List;
import java.util.Optional;

import static java.util.Collections.emptyList;

/**
 * This recipe will group and order the imports for a compilation unit using the rules defined by an {@link ImportLayoutStyle}.
 * If a style has not been defined, this recipe will use the default import layout style that is modelled after
 * IntelliJ's default import settings.
 * <p>
 * The @{link {@link OrderImports#removeUnused}} flag (which is defaulted to true) can be used to also remove any
 * imports that are not referenced within the compilation unit.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class OrderImports extends Recipe {

    @Option(displayName = ""Remove unused"",
            description = ""Remove unnecessary imports."",
            required = false)
    @Nullable
    Boolean removeUnused;

    @Override
    public String getDisplayName() {
        return ""Order imports"";
    }

    @Override
    public String getDescription() {
        return ""Groups and orders import statements. If a [style has been defined](https://docs.openrewrite.org/concepts-and-explanations/styles), this recipe will order the imports "" +
                ""according to that style. If no style is detected, this recipe will default to ordering imports in "" +
                ""the same way that IntelliJ IDEA does."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                ImportLayoutStyle layoutStyle = Optional.ofNullable(Style.from(ImportLayoutStyle.class, cu))
                        .orElse(IntelliJ.importLayout());

                Optional<JavaSourceSet> sourceSet = cu.getMarkers().findFirst(JavaSourceSet.class);
                List<JavaType.FullyQualified> classpath = emptyList();
                if (sourceSet.isPresent()) {
                    classpath = sourceSet.get().getClasspath();
                }

                List<JRightPadded<J.Import>> orderedImports = layoutStyle.orderImports(cu.getPadding().getImports(), classpath);

                boolean changed = false;
                if (orderedImports.size() != cu.getImports().size()) {
                    cu = cu.getPadding().withImports(orderedImports);
                    changed = true;
                } else {
                    for (int i = 0; i < orderedImports.size(); i++) {
                        if (orderedImports.get(i) != cu.getPadding().getImports().get(i)) {
                            cu = cu.getPadding().withImports(orderedImports);
                            changed = true;
                            break;
                        }
                    }
                }

                if (Boolean.TRUE.equals(removeUnused)) {
                    doAfterVisit(new RemoveUnusedImports().getVisitor());
                } else if (changed) {
                    doAfterVisit(new FormatFirstClassPrefix<>());
                }

                return cu;
            }
        };
    }
}
",{}
Change type in String literals,Change a given type to another when used in a String literal.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeTypeInStringLiteral extends Recipe {

    @Option(displayName = ""Old fully-qualified type name"",
            description = ""Fully-qualified class name of the original type."",
            example = ""org.junit.Assume"")
    String oldFullyQualifiedTypeName;

    @Option(displayName = ""New fully-qualified type name"",
            description = ""Fully-qualified class name of the replacement type, or the name of a primitive such as \""int\"". The `OuterClassName$NestedClassName` naming convention should be used for nested classes."",
            example = ""org.junit.jupiter.api.Assumptions"")
    String newFullyQualifiedTypeName;

    @Override
    public String getDisplayName() {
        return ""Change type in String literals"";
    }


    @Override
    public Validated<Object> validate() {
        return Validated.none()
                .and(Validated.notBlank(""oldPackageName"", oldFullyQualifiedTypeName))
                .and(Validated.required(""newPackageName"", newFullyQualifiedTypeName));
    }

    @Override
    public String getDescription() {
        return ""Change a given type to another when used in a String literal."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        final Pattern stringLiteralPattern = Pattern.compile(""\\b"" + oldFullyQualifiedTypeName + ""\\b"");
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitLiteral(J.Literal literal, ExecutionContext ctx) {
                J.Literal lit = literal;
                if (literal.getType() == JavaType.Primitive.String && lit.getValue() != null) {
                    Matcher matcher = stringLiteralPattern.matcher((String) lit.getValue());
                    if (matcher.find()) {
                        lit = lit.withValue(matcher.replaceAll(newFullyQualifiedTypeName))
                                .withValueSource(stringLiteralPattern.matcher(lit.getValueSource()).replaceAll(newFullyQualifiedTypeName));
                    }
                }
                return super.visitLiteral(lit, ctx);
            }
        };
    }
}
","{
  ""oldFullyQualifiedTypeName"": ""String field"",
  ""newFullyQualifiedTypeName"": ""String field""
}"
Change type,Change a given type to another.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.trait.Reference;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeType extends Recipe {

    @Option(displayName = ""Old fully-qualified type name"",
            description = ""Fully-qualified class name of the original type."",
            example = ""org.junit.Assume"")
    String oldFullyQualifiedTypeName;

    @Option(displayName = ""New fully-qualified type name"",
            description = ""Fully-qualified class name of the replacement type, or the name of a primitive such as \""int\"". The `OuterClassName$NestedClassName` naming convention should be used for nested classes."",
            example = ""org.junit.jupiter.api.Assumptions"")
    String newFullyQualifiedTypeName;

    @Option(displayName = ""Ignore type definition"",
            description = ""When set to `true` the definition of the old type will be left untouched. "" +
                    ""This is useful when you're replacing usage of a class but don't want to rename it."",
            required = false)
    @Nullable
    Boolean ignoreDefinition;

    @Override
    public String getDisplayName() {
        return ""Change type"";
    }

    @Override
    public String getInstanceNameSuffix() {
        // Defensively guard against null values when recipes are first classloaded. This
        // is a temporary workaround until releases of workers/CLI that include the defensive
        // coding in Recipe.
        //noinspection ConstantValue
        if (oldFullyQualifiedTypeName == null || newFullyQualifiedTypeName == null) {
            return getDisplayName();
        }

        String oldShort = oldFullyQualifiedTypeName.substring(oldFullyQualifiedTypeName.lastIndexOf('.') + 1);
        String newShort = newFullyQualifiedTypeName.substring(newFullyQualifiedTypeName.lastIndexOf('.') + 1);
        if (oldShort.equals(newShort)) {
            return String.format(""`%s` to `%s`"",
                    oldFullyQualifiedTypeName,
                    newFullyQualifiedTypeName);
        } else {
            return String.format(""`%s` to `%s`"",
                    oldShort, newShort);
        }
    }

    @Override
    public String getDescription() {
        return ""Change a given type to another."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> condition = new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree preVisit(@Nullable Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) tree;
                    if (!Boolean.TRUE.equals(ignoreDefinition) && containsClassDefinition(cu, oldFullyQualifiedTypeName)) {
                        return SearchResult.found(cu);
                    }
                    return new UsesType<>(oldFullyQualifiedTypeName, true).visitNonNull(cu, ctx);
                } else if (tree instanceof SourceFileWithReferences) {
                    SourceFileWithReferences cu = (SourceFileWithReferences) tree;
                    return new UsesType<>(oldFullyQualifiedTypeName, true).visitNonNull(cu, ctx);
                }
                return tree;
            }
        };

        return Preconditions.check(condition, new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof JavaSourceFile || sourceFile instanceof SourceFileWithReferences;
            }

            @Override
            public @Nullable Tree preVisit(@Nullable Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof J) {
                    return new JavaChangeTypeVisitor(oldFullyQualifiedTypeName, newFullyQualifiedTypeName, ignoreDefinition).visit(tree, ctx, requireNonNull(getCursor().getParent()));
                } else if (tree instanceof SourceFileWithReferences) {
                    SourceFileWithReferences sourceFile = (SourceFileWithReferences) tree;
                    SourceFileWithReferences.References references = sourceFile.getReferences();
                    TypeMatcher matcher = new TypeMatcher(oldFullyQualifiedTypeName);
                    Map<Tree, Reference> matches = new HashMap<>();
                    for (Reference ref : references.findMatches(matcher)) {
                        matches.put(ref.getTree(), ref);
                    }
                    return new ReferenceChangeTypeVisitor(matches, matcher.createRenamer(newFullyQualifiedTypeName)).visit(tree, ctx, requireNonNull(getCursor().getParent()));
                }
                return tree;
            }
        });
    }

    private static class JavaChangeTypeVisitor extends JavaVisitor<ExecutionContext> {
        private final JavaType.Class originalType;
        private final JavaType targetType;


        private J.@Nullable Identifier importAlias;

        @Nullable
        private final Boolean ignoreDefinition;

        private final Map<JavaType, JavaType> oldNameToChangedType = new IdentityHashMap<>();
        private final Set<String> topLevelClassnames = new HashSet<>();

        private JavaChangeTypeVisitor(String oldFullyQualifiedTypeName, String newFullyQualifiedTypeName, @Nullable Boolean ignoreDefinition) {
            this.originalType = JavaType.ShallowClass.build(oldFullyQualifiedTypeName);
            this.targetType = JavaType.buildType(newFullyQualifiedTypeName);
            this.ignoreDefinition = ignoreDefinition;
            importAlias = null;
        }

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) tree;
                if (!Boolean.TRUE.equals(ignoreDefinition)) {
                    JavaType.FullyQualified fq = TypeUtils.asFullyQualified(targetType);
                    if (fq != null) {
                        ChangeClassDefinition changeClassDefinition = new ChangeClassDefinition(originalType.getFullyQualifiedName(), fq.getFullyQualifiedName());
                        cu = (JavaSourceFile) changeClassDefinition.visitNonNull(cu, ctx);
                    }
                }
                return super.visit(cu, ctx);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = (J.ClassDeclaration) super.visitClassDeclaration(classDecl, ctx);
            if (cd.getType() != null) {
                topLevelClassnames.add(getTopLevelClassName(cd.getType()).getFullyQualifiedName());
            }
            return cd;
        }

        @Override
        public J visitImport(J.Import import_, ExecutionContext ctx) {
            // Collect alias import information here
            // If there is an existing import with an alias, we need to add a target import with an alias accordingly.
            // If there is an existing import without an alias, we need to add a target import with an alias accordingly.
            if (hasSameFQN(import_, originalType)) {
                if (import_.getAlias() != null) {
                    importAlias = import_.getAlias();
                }
            }

            // visitCompilationUnit() handles changing the imports.
            // If we call super.visitImport() then visitFieldAccess() will change the imports before AddImport/RemoveImport see them.
            // visitFieldAccess() doesn't have the import-specific formatting logic that AddImport/RemoveImport do.
            return import_;
        }

        @Override
        public @Nullable JavaType visitType(@Nullable JavaType javaType, ExecutionContext ctx) {
            return updateType(javaType);
        }

        private void addImport(JavaType.FullyQualified owningClass) {
            if (importAlias != null) {
                maybeAddImport(owningClass.getPackageName(), owningClass.getClassName(), null, importAlias.getSimpleName(), true);
            }

            maybeAddImport(owningClass.getPackageName(), owningClass.getClassName(), null, null, true);
        }

        @Override
        public @Nullable J postVisit(J tree, ExecutionContext ctx) {
            J j = super.postVisit(tree, ctx);
            if (j instanceof J.ArrayType) {
                J.ArrayType arrayType = (J.ArrayType) j;
                JavaType type = updateType(arrayType.getType());
                j = arrayType.withType(type);
            } else if (j instanceof J.MethodDeclaration) {
                J.MethodDeclaration method = (J.MethodDeclaration) j;
                JavaType.Method mt = updateType(method.getMethodType());
                j = method.withMethodType(mt)
                        .withName(method.getName().withType(mt));
            } else if (j instanceof J.MethodInvocation) {
                J.MethodInvocation method = (J.MethodInvocation) j;
                JavaType.Method mt = updateType(method.getMethodType());
                j = method.withMethodType(mt)
                        .withName(method.getName().withType(mt));
            } else if (j instanceof J.NewClass) {
                J.NewClass n = (J.NewClass) j;
                j = n.withConstructorType(updateType(n.getConstructorType()));
            } else if (tree instanceof TypedTree) {
                j = ((TypedTree) tree).withType(updateType(((TypedTree) tree).getType()));
            } else if (tree instanceof JavaSourceFile) {
                JavaSourceFile sf = (JavaSourceFile) tree;
                if (targetType instanceof JavaType.FullyQualified) {
                    for (J.Import anImport : sf.getImports()) {
                        if (anImport.isStatic()) {
                            continue;
                        }

                        JavaType maybeType = anImport.getQualid().getType();
                        if (maybeType instanceof JavaType.FullyQualified) {
                            JavaType.FullyQualified type = (JavaType.FullyQualified) maybeType;
                            if (originalType.getFullyQualifiedName().equals(type.getFullyQualifiedName())) {
                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getFullyQualifiedName()).visitNonNull(sf, ctx, getCursor().getParentOrThrow());
                            } else if (originalType.getOwningClass() != null && originalType.getOwningClass().getFullyQualifiedName().equals(type.getFullyQualifiedName())) {
                                sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(originalType.getOwningClass().getFullyQualifiedName()).visitNonNull(sf, ctx, getCursor().getParentOrThrow());
                            }
                        }
                    }
                }

                JavaType.FullyQualified fullyQualifiedTarget = TypeUtils.asFullyQualified(targetType);
                if (fullyQualifiedTarget != null) {
                    JavaType.FullyQualified owningClass = fullyQualifiedTarget.getOwningClass();
                    if (!topLevelClassnames.contains(getTopLevelClassName(fullyQualifiedTarget).getFullyQualifiedName())) {
                        if (hasNoConflictingImport(sf)) {
                            if (owningClass != null && !""java.lang"".equals(fullyQualifiedTarget.getPackageName())) {
                                addImport(owningClass);
                            }
                            if (!""java.lang"".equals(fullyQualifiedTarget.getPackageName())) {
                                addImport(fullyQualifiedTarget);
                            }
                        }
                    }
                }

                j = sf.withImports(ListUtils.map(sf.getImports(), i -> {
                    Cursor cursor = getCursor();
                    setCursor(new Cursor(cursor, i));
                    try {
                        return visitAndCast(i, ctx, super::visitImport);
                    } finally {
                        setCursor(cursor);
                    }
                }));
            }

            return j;
        }

        @Override
        public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            if (fieldAccess.isFullyQualifiedClassReference(originalType.getFullyQualifiedName())) {
                if (targetType instanceof JavaType.FullyQualified) {
                    J.FieldAccess fa = (J.FieldAccess) updateOuterClassTypes(TypeTree.build(((JavaType.FullyQualified) targetType).getFullyQualifiedName())
                            .withPrefix(fieldAccess.getPrefix()));
                    if (getCursor().firstEnclosing(J.Import.class) == null) {
                        // don't shorten qualified names in imports
                        fa = fa.withName(fa.getName().withType(targetType));
                        doAfterVisit(ShortenFullyQualifiedTypeReferences.modifyOnly(fa));
                    }
                    return fa;
                } else if (targetType instanceof JavaType.Primitive) {
                    return new J.Primitive(
                            fieldAccess.getId(),
                            fieldAccess.getPrefix(),
                            Markers.EMPTY,
                            (JavaType.Primitive) targetType
                    );
                }
            } else {
                StringBuilder maybeClass = new StringBuilder();
                for (Expression target = fieldAccess; target != null; ) {
                    if (target instanceof J.FieldAccess) {
                        J.FieldAccess fa = (J.FieldAccess) target;
                        maybeClass.insert(0, fa.getSimpleName()).insert(0, '.');
                        target = fa.getTarget();
                    } else if (target instanceof J.Identifier) {
                        maybeClass.insert(0, ((J.Identifier) target).getSimpleName());
                        target = null;
                    } else {
                        maybeClass = new StringBuilder(""__NOT_IT__"");
                        break;
                    }
                }
                JavaType.Class oldType = JavaType.ShallowClass.build(originalType.getFullyQualifiedName());
                if (maybeClass.toString().equals(oldType.getClassName())) {
                    maybeRemoveImport(oldType.getOwningClass());
                    Expression e = updateOuterClassTypes(TypeTree.build(((JavaType.FullyQualified) targetType).getClassName())
                            .withPrefix(fieldAccess.getPrefix()));
                    // If a FieldAccess like Map.Entry has been replaced with an Identifier, ensure that identifier has the correct type
                    if (e instanceof J.Identifier && e.getType() == null) {
                        J.Identifier i = (J.Identifier) e;
                        e = i.withType(targetType);
                    }
                    return e;
                } else if (maybeClass.toString().equals(oldType.getFullyQualifiedName().replace('$', '.'))) {
                    maybeRemoveImport(oldType.getOwningClass());
                    return updateOuterClassTypes(TypeTree.build(((JavaType.FullyQualified) targetType).getFullyQualifiedName())
                            .withPrefix(fieldAccess.getPrefix()));
                }
            }
            return super.visitFieldAccess(fieldAccess, ctx);
        }

        @Override
        public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {
            // Do not modify the identifier if it's on a inner class definition.
            if (Boolean.TRUE.equals(ignoreDefinition) && getCursor().getParent() != null &&
                    getCursor().getParent().getValue() instanceof J.ClassDeclaration) {
                return super.visitIdentifier(ident, ctx);
            }
            // if the ident's type is equal to the type we're looking for, and the classname of the type we're looking for is equal to the ident's string representation
            // Then transform it, otherwise leave it alone
            if (TypeUtils.isOfClassType(ident.getType(), originalType.getFullyQualifiedName())) {
                String className = originalType.getClassName();
                JavaType.FullyQualified iType = TypeUtils.asFullyQualified(ident.getType());
                if (iType != null && iType.getOwningClass() != null) {
                    className = originalType.getFullyQualifiedName().substring(iType.getOwningClass().getFullyQualifiedName().length() + 1);
                }

                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);
                if (ident.getSimpleName().equals(className)) {
                    if (targetType instanceof JavaType.FullyQualified) {
                        if (((JavaType.FullyQualified) targetType).getOwningClass() != null) {
                            return updateOuterClassTypes(TypeTree.build(((JavaType.FullyQualified) targetType).getClassName())
                                    .withType(null)
                                    .withPrefix(ident.getPrefix()));
                        } else {
                            if (hasNoConflictingImport(sf)) {
                                ident = ident.withSimpleName(((JavaType.FullyQualified) targetType).getClassName());
                            } else {
                                ident = ident.withSimpleName(((JavaType.FullyQualified) targetType).getFullyQualifiedName());
                            }
                        }
                    } else if (targetType instanceof JavaType.Primitive) {
                        ident = ident.withSimpleName(((JavaType.Primitive) targetType).getKeyword());
                    }
                }

                // Recreate any static imports as needed
                if (sf != null) {
                    for (J.Import anImport : sf.getImports()) {
                        if (anImport.isStatic() && anImport.getQualid().getTarget().getType() != null) {
                            JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(anImport.getQualid().getTarget().getType());
                            if (fqn != null && TypeUtils.isOfClassType(fqn, originalType.getFullyQualifiedName()) &&
                                    ident.getSimpleName().equals(anImport.getQualid().getSimpleName())) {
                                JavaType.FullyQualified targetFqn = (JavaType.FullyQualified) targetType;
                                maybeAddImport((targetFqn).getFullyQualifiedName(), ident.getSimpleName());
                                break;
                            }
                        }
                    }
                }
            }
            ident = ident.withType(updateType(ident.getType()));
            return visitAndCast(ident, ctx, super::visitIdentifier);
        }

        @Override
        public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            if (method.getMethodType() != null && method.getMethodType().hasFlags(Flag.Static)) {
                if (method.getMethodType().getDeclaringType().isAssignableFrom(originalType)) {
                    JavaSourceFile cu = getCursor().firstEnclosingOrThrow(JavaSourceFile.class);

                    for (J.Import anImport : cu.getImports()) {
                        if (anImport.isStatic() && anImport.getQualid().getTarget().getType() != null) {
                            JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(anImport.getQualid().getTarget().getType());
                            if (fqn != null && TypeUtils.isOfClassType(fqn, originalType.getFullyQualifiedName()) &&
                                    method.getSimpleName().equals(anImport.getQualid().getSimpleName())) {
                                JavaType.FullyQualified targetFqn = (JavaType.FullyQualified) targetType;

                                addImport(targetFqn);
                                maybeAddImport((targetFqn).getFullyQualifiedName(), method.getName().getSimpleName());
                                break;
                            }
                        }
                    }
                }
            }
            return super.visitMethodInvocation(method, ctx);
        }

        private Expression updateOuterClassTypes(Expression typeTree) {
            if (typeTree instanceof J.FieldAccess) {
                JavaType.FullyQualified type = (JavaType.FullyQualified) targetType;

                if (type.getOwningClass() == null) {
                    // just a performance shortcut when this isn't an inner class
                    return typeTree.withType(updateType(targetType));
                }

                Stack<Expression> typeStack = new Stack<>();
                typeStack.push(typeTree);

                Stack<JavaType.FullyQualified> attrStack = new Stack<>();
                attrStack.push(type);

                for (Expression t = ((J.FieldAccess) typeTree).getTarget(); ; ) {
                    typeStack.push(t);
                    if (t instanceof J.FieldAccess) {
                        if (Character.isUpperCase(((J.FieldAccess) t).getSimpleName().charAt(0))) {
                            if (attrStack.peek().getOwningClass() != null) {
                                attrStack.push(attrStack.peek().getOwningClass());
                            }
                        }
                        t = ((J.FieldAccess) t).getTarget();
                    } else if (t instanceof J.Identifier) {
                        if (Character.isUpperCase(((J.Identifier) t).getSimpleName().charAt(0))) {
                            if (attrStack.peek().getOwningClass() != null) {
                                attrStack.push(attrStack.peek().getOwningClass());
                            }
                        }
                        break;
                    }
                }

                Expression attributed = null;
                for (Expression e = typeStack.pop(); ; e = typeStack.pop()) {
                    if (e instanceof J.Identifier) {
                        if (attrStack.size() == typeStack.size() + 1) {
                            attributed = ((J.Identifier) e).withType(attrStack.pop());
                        } else {
                            attributed = e;
                        }
                    } else if (e instanceof J.FieldAccess) {
                        if (attrStack.size() == typeStack.size() + 1) {
                            attributed = ((J.FieldAccess) e).withTarget(attributed)
                                    .withType(attrStack.pop());
                        } else {
                            attributed = ((J.FieldAccess) e).withTarget(attributed);
                        }
                    }
                    if (typeStack.isEmpty()) {
                        break;
                    }
                }

                assert attributed != null;
                return attributed;
            }
            return typeTree;
        }

        private @Nullable JavaType updateType(@Nullable JavaType oldType) {
            if (oldType == null || oldType instanceof JavaType.Unknown) {
                return oldType;
            }

            JavaType type = oldNameToChangedType.get(oldType);
            if (type != null) {
                return type;
            }

            if (oldType instanceof JavaType.Parameterized) {
                JavaType.Parameterized pt = (JavaType.Parameterized) oldType;
                pt = pt.withTypeParameters(ListUtils.map(pt.getTypeParameters(), tp -> {
                    if (tp instanceof JavaType.FullyQualified) {
                        JavaType.FullyQualified tpFq = (JavaType.FullyQualified) tp;
                        if (isTargetFullyQualifiedType(tpFq)) {
                            return updateType(tpFq);
                        }
                    }
                    return tp;
                }));

                if (isTargetFullyQualifiedType(pt)) {
                    pt = pt.withType((JavaType.FullyQualified) updateType(pt.getType()));
                }
                oldNameToChangedType.put(oldType, pt);
                oldNameToChangedType.put(pt, pt);
                return pt;
            } else if (oldType instanceof JavaType.FullyQualified) {
                JavaType.FullyQualified original = TypeUtils.asFullyQualified(oldType);
                if (isTargetFullyQualifiedType(original)) {
                    oldNameToChangedType.put(oldType, targetType);
                    return targetType;
                }
            } else if (oldType instanceof JavaType.GenericTypeVariable) {
                JavaType.GenericTypeVariable gtv = (JavaType.GenericTypeVariable) oldType;
                gtv = gtv.withBounds(ListUtils.map(gtv.getBounds(), b -> {
                    if (b instanceof JavaType.FullyQualified && isTargetFullyQualifiedType((JavaType.FullyQualified) b)) {
                        return updateType(b);
                    }
                    return b;
                }));

                oldNameToChangedType.put(oldType, gtv);
                oldNameToChangedType.put(gtv, gtv);
                return gtv;
            } else if (oldType instanceof JavaType.Variable) {
                JavaType.Variable variable = (JavaType.Variable) oldType;
                variable = variable.withOwner(updateType(variable.getOwner()));
                variable = variable.withType(updateType(variable.getType()));
                oldNameToChangedType.put(oldType, variable);
                oldNameToChangedType.put(variable, variable);
                return variable;
            } else if (oldType instanceof JavaType.Array) {
                JavaType.Array array = (JavaType.Array) oldType;
                array = array.withElemType(updateType(array.getElemType()));
                oldNameToChangedType.put(oldType, array);
                oldNameToChangedType.put(array, array);
                return array;
            }

            return oldType;
        }

        private JavaType.@Nullable Method updateType(JavaType.@Nullable Method oldMethodType) {
            if (oldMethodType != null) {
                JavaType.Method method = (JavaType.Method) oldNameToChangedType.get(oldMethodType);
                if (method != null) {
                    return method;
                }

                method = oldMethodType;
                method = method.withDeclaringType((JavaType.FullyQualified) updateType(method.getDeclaringType()))
                        .withReturnType(updateType(method.getReturnType()))
                        .withParameterTypes(ListUtils.map(method.getParameterTypes(), this::updateType));
                oldNameToChangedType.put(oldMethodType, method);
                oldNameToChangedType.put(method, method);
                return method;
            }
            return null;
        }

        private boolean isTargetFullyQualifiedType(JavaType.@Nullable FullyQualified fq) {
            return fq != null && TypeUtils.isOfClassType(fq, originalType.getFullyQualifiedName()) && targetType instanceof JavaType.FullyQualified;
        }

        private boolean hasNoConflictingImport(@Nullable JavaSourceFile sf) {
            JavaType.FullyQualified oldType = TypeUtils.asFullyQualified(originalType);
            JavaType.FullyQualified newType = TypeUtils.asFullyQualified(targetType);
            if (sf == null || oldType == null || newType == null) {
                return true; // No way to be sure so we retain previous behaviour
            }
            for (J.Import anImport : sf.getImports()) {
                JavaType.FullyQualified currType = TypeUtils.asFullyQualified(anImport.getQualid().getType());
                if (currType != null &&
                        !TypeUtils.isOfType(currType, oldType) &&
                        !TypeUtils.isOfType(currType, newType) &&
                        currType.getClassName().equals(newType.getClassName())) {
                    return false;
                }
            }
            return true;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class ReferenceChangeTypeVisitor extends TreeVisitor<Tree, ExecutionContext> {
        Map<Tree, Reference> matches;
        Reference.Renamer renamer;

        @Override
        public Tree postVisit(Tree tree, ExecutionContext ctx) {
            Reference reference = matches.get(tree);
            if (reference != null && reference.supportsRename()) {
                return reference.rename(renamer, getCursor(), ctx);
            }
            return tree;
        }
    }

    private static class ChangeClassDefinition extends JavaIsoVisitor<ExecutionContext> {
        private final JavaType.Class originalType;
        private final JavaType.Class targetType;
        private final MethodMatcher originalConstructor;

        private ChangeClassDefinition(String oldFullyQualifiedTypeName, String newFullyQualifiedTypeName) {
            this.originalType = JavaType.ShallowClass.build(oldFullyQualifiedTypeName);
            this.targetType = JavaType.ShallowClass.build(newFullyQualifiedTypeName);
            this.originalConstructor = new MethodMatcher(oldFullyQualifiedTypeName + ""<constructor>(..)"");
        }

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) tree;
                for (J.ClassDeclaration declaration : cu.getClasses()) {
                    // Check the class name instead of source path, as it might differ
                    String fqn = declaration.getType().getFullyQualifiedName();
                    if (fqn.equals(originalType.getFullyQualifiedName())) {
                        getCursor().putMessage(""UPDATE_PACKAGE"", true);
                        break;
                    }
                }

                String oldPath = cu.getSourcePath().toString().replace('\\', '/');
                // The old FQN must exist in the path.
                String oldFqn = fqnToPath(originalType.getFullyQualifiedName());
                String newFqn = fqnToPath(targetType.getFullyQualifiedName());

                Path newPath = Paths.get(oldPath.replaceFirst(oldFqn, newFqn));
                if (updatePath(cu, oldPath, newPath.toString())) {
                    cu = cu.withSourcePath(newPath);
                }
                return super.visit(cu, ctx);
            }
            return super.visit(tree, ctx);
        }

        private String fqnToPath(String fullyQualifiedName) {
            int index = fullyQualifiedName.indexOf(""$"");
            String topLevelClassName = index == -1 ? fullyQualifiedName : fullyQualifiedName.substring(0, index);
            return topLevelClassName.replace('.', '/');
        }

        private boolean updatePath(JavaSourceFile sf, String oldPath, String newPath) {
            return !oldPath.equals(newPath) && sf.getClasses().stream()
                    .anyMatch(o -> !o.hasModifier(J.Modifier.Type.Private) &&
                            o.getType() != null && !o.getType().getFullyQualifiedName().contains(""$"") &&
                            TypeUtils.isOfClassType(o.getType(), getTopLevelClassName(originalType).getFullyQualifiedName()));
        }

        @Override
        public J.@Nullable Package visitPackage(J.Package pkg, ExecutionContext ctx) {
            Boolean updatePackage = getCursor().pollNearestMessage(""UPDATE_PACKAGE"");
            if (updatePackage != null && updatePackage) {
                String original = pkg.getExpression().printTrimmed(getCursor()).replaceAll(""\\s"", """");
                if (original.equals(originalType.getPackageName())) {
                    JavaType.FullyQualified fq = TypeUtils.asFullyQualified(targetType);
                    if (fq != null) {
                        if (fq.getPackageName().isEmpty()) {
                            getCursor().putMessageOnFirstEnclosing(J.CompilationUnit.class, ""UPDATE_PREFIX"", true);
                            //noinspection DataFlowIssue
                            return null;
                        } else {
                            String newPkg = targetType.getPackageName();
                            return JavaTemplate.builder(newPkg).contextSensitive().build().apply(getCursor(), pkg.getCoordinates().replace());
                        }
                    }
                }
            }
            //noinspection ConstantConditions
            return pkg;
        }

        @Override
        public J.Import visitImport(J.Import _import, ExecutionContext ctx) {
            Boolean updatePrefix = getCursor().pollNearestMessage(""UPDATE_PREFIX"");
            if (updatePrefix != null && updatePrefix) {
                _import = _import.withPrefix(Space.EMPTY);
            }
            return super.visitImport(_import, ctx);
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            Boolean updatePrefix = getCursor().pollNearestMessage(""UPDATE_PREFIX"");
            if (updatePrefix != null && updatePrefix) {
                cd = cd.withPrefix(Space.EMPTY);
            }

            if (TypeUtils.isOfClassType(classDecl.getType(), originalType.getFullyQualifiedName())) {
                String newClassName = getNewClassName(targetType);
                cd = cd.withName(cd.getName().withSimpleName(newClassName));
                cd = cd.withType(updateType(cd.getType()));
            }
            return cd;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            if (method.isConstructor() && originalConstructor.matches(method.getMethodType())) {
                method = method.withName(method.getName().withSimpleName(targetType.getClassName()));
                method = method.withMethodType(updateType(method.getMethodType()));
            }
            return super.visitMethodDeclaration(method, ctx);
        }

        private String getNewClassName(JavaType.FullyQualified fq) {
            return fq.getOwningClass() == null ? fq.getClassName() :
                    fq.getFullyQualifiedName().substring(fq.getOwningClass().getFullyQualifiedName().length() + 1);
        }

        private JavaType updateType(@Nullable JavaType oldType) {
            if (oldType instanceof JavaType.FullyQualified) {
                JavaType.FullyQualified original = TypeUtils.asFullyQualified(oldType);
                if (isTargetFullyQualifiedType(original)) {
                    return targetType;
                }
            }

            //noinspection ConstantConditions
            return oldType;
        }

        private JavaType.@Nullable Method updateType(JavaType.@Nullable Method mt) {
            if (mt != null) {
                return mt.withDeclaringType((JavaType.FullyQualified) updateType(mt.getDeclaringType()))
                        .withReturnType(updateType(mt.getReturnType()))
                        .withParameterTypes(ListUtils.map(mt.getParameterTypes(), this::updateType));
            }
            return null;
        }

        private boolean isTargetFullyQualifiedType(JavaType.@Nullable FullyQualified fq) {
            return fq != null && TypeUtils.isOfClassType(fq, originalType.getFullyQualifiedName());
        }
    }

    public static boolean containsClassDefinition(JavaSourceFile sourceFile, String fullyQualifiedTypeName) {
        AtomicBoolean found = new AtomicBoolean(false);
        JavaIsoVisitor<AtomicBoolean> visitor = new JavaIsoVisitor<AtomicBoolean>() {

            @Override
            public @Nullable J visit(@Nullable Tree tree, AtomicBoolean found) {
                if (found.get()) {
                    return (J) tree;
                }
                return super.visit(tree, found);
            }

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, AtomicBoolean found) {
                if (found.get()) {
                    return classDecl;
                }

                if (classDecl.getType() != null && TypeUtils.isOfClassType(classDecl.getType(), fullyQualifiedTypeName)) {
                    found.set(true);
                    return classDecl;
                }
                return super.visitClassDeclaration(classDecl, found);
            }
        };
        visitor.visit(sourceFile, found);
        return found.get();
    }

    public static JavaType.FullyQualified getTopLevelClassName(JavaType.FullyQualified classType) {
        if (classType.getOwningClass() == null || TypeUtils.fullyQualifiedNamesAreEqual(classType.getFullyQualifiedName(),
                classType.getOwningClass().getFullyQualifiedName())) {
            return classType;
        }
        return getTopLevelClassName(classType.getOwningClass());
    }

    private static boolean hasSameFQN(J.Import import_, JavaType targetType) {
        JavaType.FullyQualified type = TypeUtils.asFullyQualified(targetType);
        String fqn = type != null ? type.getFullyQualifiedName() : null;

        JavaType.FullyQualified curType = TypeUtils.asFullyQualified(Optional.ofNullable(import_.getQualid()).map(J.FieldAccess::getType).orElse(null));
        String curFqn = curType != null ? curType.getFullyQualifiedName() : null;

        return fqn != null && fqn.equals(curFqn);
    }
}
","{
  ""oldFullyQualifiedTypeName"": ""String field"",
  ""newFullyQualifiedTypeName"": ""String field""
}"
Add method parameter to a method declaration,Adds a new method parameter to an existing method declaration.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.DeclaresType;
import org.openrewrite.java.service.ImportService;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.marker.SearchResult;

import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddMethodParameter extends Recipe {

    /**
     * A method pattern that is used to find matching method declarations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = ""A method pattern that is used to find the method declarations to modify."",
            example = ""com.yourorg.A foo(int, int)"")
    String methodPattern;

    @Option(displayName = ""Parameter type"",
            description = ""The type of the parameter that gets added."",
            example = ""java.lang.String"")
    String parameterType;

    @Option(displayName = ""Parameter name"",
            description = ""The name of the parameter that gets added."",
            example = ""name"")
    String parameterName;

    @Option(displayName = ""Parameter index"",
            description = ""A zero-based index that indicates the position at which the parameter will be added. At the end by default."",
            example = ""0"",
            required = false)
    @Nullable
    Integer parameterIndex;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s %s` in methods `%s`"", parameterType, parameterName, methodPattern);
    }

    @Override
    public String getDisplayName() {
        return ""Add method parameter to a method declaration"";
    }

    @Override
    public String getDescription() {
        return ""Adds a new method parameter to an existing method declaration."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        int idx = methodPattern.indexOf('#');
        idx = idx == -1 ? methodPattern.indexOf(' ') : idx;
        boolean typePattern = idx != -1 && methodPattern.lastIndexOf('*', idx) != -1;
        return Preconditions.check(typePattern ? new DeclaresMatchingType(methodPattern.substring(0, idx)) : new DeclaresType<>(methodPattern.substring(0, idx)), new AddNullMethodArgumentVisitor(methodPattern));
    }

    private class AddNullMethodArgumentVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        public AddNullMethodArgumentVisitor(String methodPattern) {
            this.methodMatcher = new MethodMatcher(methodPattern);
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            method = super.visitMethodDeclaration(method, ctx);
            J.ClassDeclaration enclosing = getCursor().firstEnclosing(J.ClassDeclaration.class);
            if (enclosing != null && methodMatcher.matches(method, enclosing)) {
                for (Statement parameter : method.getParameters()) {
                    if (parameter instanceof J.VariableDeclarations && ((J.VariableDeclarations) parameter).getVariables().get(0).getSimpleName().equals(parameterName)) {
                        return method;
                    }
                }
                J.VariableDeclarations parameter = createParameter(method);
                method = autoFormat(addParameter(method, parameter), parameter, ctx, getCursor().getParentTreeCursor());
            }
            return method;
        }

        private J.MethodDeclaration addParameter(J.MethodDeclaration method, J.VariableDeclarations parameter) {
            List<Statement> originalParameters = method.getParameters();
            if (method.getParameters().isEmpty() || method.getParameters().size() == 1 && method.getParameters().get(0) instanceof J.Empty) {
                originalParameters = new ArrayList<>();
            } else {
                if (parameterIndex == null || parameterIndex != 0) {
                    parameter = parameter.withPrefix(Space.SINGLE_SPACE);
                } else {
                    originalParameters = ListUtils.mapFirst(originalParameters, p -> p.getPrefix().isEmpty() ? p.withPrefix(Space.SINGLE_SPACE) : p);
                }
            }

            if (parameterIndex == null) {
                method = method.withParameters(ListUtils.concat(originalParameters, parameter));
            } else {
                method = method.withParameters(ListUtils.insert(originalParameters, parameter, parameterIndex));
            }

            if (parameter.getTypeExpression() != null && !(parameter.getTypeExpression() instanceof J.Identifier || parameter.getTypeExpression() instanceof J.Primitive)) {
                doAfterVisit(service(ImportService.class).shortenFullyQualifiedTypeReferencesIn(parameter.getTypeExpression()));
            }
            return method;
        }

        private J.VariableDeclarations createParameter(J.MethodDeclaration method) {
            TypeTree typeTree = createTypeTree(parameterType);

            return new J.VariableDeclarations(
                    randomId(),
                    Space.EMPTY,
                    Markers.EMPTY,
                    emptyList(),
                    emptyList(),
                    typeTree,
                    null,
                    singletonList(
                            new JRightPadded<>(
                                    new J.VariableDeclarations.NamedVariable(
                                            randomId(),
                                            Space.EMPTY,
                                            Markers.EMPTY,
                                            new J.Identifier(
                                                    randomId(),
                                                    Space.EMPTY,
                                                    Markers.EMPTY,
                                                    emptyList(),
                                                    parameterName,
                                                    typeTree.getType(),
                                                    new JavaType.Variable(
                                                            null,
                                                            0,
                                                            parameterName,
                                                            method.getMethodType(),
                                                            typeTree.getType(),
                                                            null
                                                    )
                                            ),
                                            emptyList(),
                                            null,
                                            null
                                    ),
                                    Space.EMPTY,
                                    Markers.EMPTY
                            )
                    )
            );
        }

        private TypeTree createTypeTree(String typeName) {
            int arrayIndex = typeName.lastIndexOf('[');
            if (arrayIndex != -1) {
                TypeTree elementType = createTypeTree(typeName.substring(0, arrayIndex));
                return new J.ArrayType(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        elementType,
                        null,
                        JLeftPadded.build(Space.EMPTY),
                        new JavaType.Array(null, elementType.getType(), null)
                );
            }
            int genericsIndex = typeName.indexOf('<');
            if (genericsIndex != -1) {
                TypeTree rawType = createTypeTree(typeName.substring(0, genericsIndex));
                List<JRightPadded<Expression>> typeParameters = new ArrayList<>();
                for (String typeParam : typeName.substring(genericsIndex + 1, typeName.lastIndexOf('>')).split("","")) {
                    typeParameters.add(JRightPadded.build((Expression) createTypeTree(typeParam.trim())));
                }
                return new J.ParameterizedType(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        rawType,
                        JContainer.build(Space.EMPTY, typeParameters, Markers.EMPTY),
                        new JavaType.Parameterized(null, (JavaType.FullyQualified) rawType.getType(), null)
                );
            }
            JavaType.Primitive type = JavaType.Primitive.fromKeyword(typeName);
            if (type != null) {
                return new J.Primitive(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        type
                );
            }
            if (""?"".equals(typeName)) {
                return new J.Wildcard(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        null,
                        null
                );
            }
            if (typeName.startsWith(""?"") && typeName.contains(""extends"")) {
                return new J.Wildcard(
                        randomId(),
                        Space.EMPTY,
                        Markers.EMPTY,
                        new JLeftPadded<>(Space.SINGLE_SPACE, J.Wildcard.Bound.Extends, Markers.EMPTY),
                        createTypeTree(typeName.substring(typeName.indexOf(""extends"") + ""extends"".length() + 1).trim()).withPrefix(Space.SINGLE_SPACE)
                );
            }
            if (typeName.indexOf('.') == -1) {
                String javaLangType = TypeUtils.findQualifiedJavaLangTypeName(typeName);
                if (javaLangType != null) {
                    return new J.Identifier(
                            randomId(),
                            Space.EMPTY,
                            Markers.EMPTY,
                            emptyList(),
                            typeName,
                            JavaType.buildType(javaLangType),
                            null
                    );
                }
            }
            TypeTree typeTree = TypeTree.build(typeName);
            // somehow the type attribution is incomplete, but `ChangeType` relies on this
            if (typeTree instanceof J.FieldAccess) {
                typeTree = ((J.FieldAccess) typeTree).withName(((J.FieldAccess) typeTree).getName().withType(typeTree.getType()));
            } else if (typeTree.getType() == null) {
                typeTree = ((J.Identifier) typeTree).withType(JavaType.ShallowClass.build(typeName));
            }
            return typeTree;
        }
    }

    private static class DeclaresMatchingType extends JavaIsoVisitor<ExecutionContext> {
        private final TypeMatcher typeMatcher;

        public DeclaresMatchingType(String type) {
            this.typeMatcher = new TypeMatcher(type);
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            if (classDecl.getType() != null && typeMatcher.matches(classDecl.getType())) {
                return SearchResult.found(classDecl);
            }
            return super.visitClassDeclaration(classDecl, ctx);
        }
    }
}
","{
  ""parameterType"": ""String field"",
  ""parameterName"": ""String field""
}"
Replace method invocation with constant,Replace all method invocations matching the method pattern with the specified constant.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.trait.MethodAccess;
import org.openrewrite.java.tree.Expression;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceMethodInvocationWithConstant extends Recipe {

    @Option(displayName = ""Method pattern"",
            description = ""A pattern to match method invocations to replace. "" + MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.lang.StringBuilder append(java.lang.String)"")
    String methodPattern;

    @Option(displayName = ""Replacement"",
            description = ""The constant to replace the method invocation with."",
            example = ""null"")
    String replacement;

    @Override
    public String getDisplayName() {
        return ""Replace method invocation with constant"";
    }

    @Override
    public String getDescription() {
        return ""Replace all method invocations matching the method pattern with the specified constant."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesMethod<>(methodPattern),
                new MethodAccess.Matcher(methodPattern)
                        .asVisitor(ma ->
                                JavaTemplate.apply(replacement, ma.getCursor(),
                                        ((Expression) ma.getCursor().getValue()).getCoordinates().replace())));
    }
}
","{
  ""replacement"": ""String field""
}"
Remove unused imports,Remove imports for types that are not referenced. As a precaution against incorrect changes no imports ,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.style.ImportLayoutStyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;
import org.openrewrite.style.Style;

import java.time.Duration;
import java.util.*;
import java.util.stream.Stream;

import static java.util.Collections.emptySet;
import static java.util.Collections.singleton;
import static java.util.stream.Collectors.toSet;
import static org.openrewrite.java.style.ImportLayoutStyle.isPackageAlwaysFolded;
import static org.openrewrite.java.tree.TypeUtils.fullyQualifiedNamesAreEqual;
import static org.openrewrite.java.tree.TypeUtils.toFullyQualifiedName;

/**
 * This recipe will remove any imports for types that are not referenced within the compilation unit. This recipe
 * is aware of the import layout style and will correctly handle unfolding of wildcard imports if the import counts
 * drop below the configured values.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveUnusedImports extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Remove unused imports"";
    }

    @Override
    public String getDescription() {
        return ""Remove imports for types that are not referenced. As a precaution against incorrect changes no imports "" +
               ""will be removed from any source where unknown types are referenced. The most common cause of unknown "" +
               ""types is the use of annotation processors not supported by OpenRewrite, such as lombok."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S1128"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new NoMissingTypes(), new RemoveUnusedImportsVisitor());
    }

    private static class RemoveUnusedImportsVisitor extends JavaIsoVisitor<ExecutionContext> {

        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            ImportLayoutStyle layoutStyle = Optional.ofNullable(Style.from(ImportLayoutStyle.class, cu))
                    .orElse(IntelliJ.importLayout());
            String sourcePackage = cu.getPackageDeclaration() == null ? """" :
                    cu.getPackageDeclaration().getExpression().printTrimmed(getCursor()).replaceAll(""\\s"", """");
            Map<String, TreeSet<String>> methodsAndFieldsByTypeName = new HashMap<>();
            Map<String, Set<JavaType.FullyQualified>> typesByPackage = new HashMap<>();

            // Collect all unqualified type references upfront for efficiency
            Set<String> unqualifiedTypeNames = collectUnqualifiedTypeNames(cu);

            for (JavaType.Method method : cu.getTypesInUse().getUsedMethods()) {
                if (method.hasFlags(Flag.Static)) {
                    methodsAndFieldsByTypeName.computeIfAbsent(method.getDeclaringType().getFullyQualifiedName(), t -> new TreeSet<>())
                            .add(method.getName());
                }
            }

            for (JavaType.Variable variable : cu.getTypesInUse().getVariables()) {
                JavaType.FullyQualified fq = TypeUtils.asFullyQualified(variable.getOwner());
                if (fq != null && !""class"".equals(variable.getName())) {
                    methodsAndFieldsByTypeName.computeIfAbsent(fq.getFullyQualifiedName(), f -> new TreeSet<>())
                            .add(variable.getName());
                }
            }

            for (JavaType javaType : cu.getTypesInUse().getTypesInUse()) {
                if (javaType instanceof JavaType.Parameterized) {
                    JavaType.Parameterized parameterized = (JavaType.Parameterized) javaType;
                    typesByPackage.computeIfAbsent(parameterized.getType().getPackageName(), f -> new HashSet<>())
                            .add(parameterized.getType());
                    for (JavaType typeParameter : parameterized.getTypeParameters()) {
                        JavaType.FullyQualified fq = TypeUtils.asFullyQualified(typeParameter);
                        if (fq != null) {
                            typesByPackage.computeIfAbsent(
                                    fq.getOwningClass() == null ?
                                            fq.getPackageName() :
                                            toFullyQualifiedName(fq.getOwningClass().getFullyQualifiedName()),
                                    f -> new HashSet<>()).add(fq);
                        }
                    }
                } else if (javaType instanceof JavaType.FullyQualified) {
                    JavaType.FullyQualified fq = (JavaType.FullyQualified) javaType;
                    typesByPackage.computeIfAbsent(
                            fq.getOwningClass() == null ?
                                    fq.getPackageName() :
                                    toFullyQualifiedName(fq.getOwningClass().getFullyQualifiedName()),
                            f -> new HashSet<>()).add(fq);
                }
            }

            boolean changed = false;

            // the key is a list because a star import may get replaced with multiple unfolded imports
            List<ImportUsage> importUsage = new ArrayList<>(cu.getPadding().getImports().size());
            for (JRightPadded<J.Import> anImport : cu.getPadding().getImports()) {
                // assume initially that all imports are unused
                ImportUsage singleUsage = new ImportUsage();
                singleUsage.imports.add(anImport);
                importUsage.add(singleUsage);
            }

            // whenever an import statement is found to be used and not already in use it should be marked true
            Set<String> checkedImports = new HashSet<>();
            Set<String> usedWildcardImports = new HashSet<>();
            Set<String> usedStaticWildcardImports = new HashSet<>();
            for (ImportUsage anImport : importUsage) {
                J.Import elem = anImport.imports.get(0).getElement();
                J.FieldAccess qualid = elem.getQualid();
                J.Identifier name = qualid.getName();

                if (checkedImports.contains(elem.toString())) {
                    anImport.used = false;
                    changed = true;
                } else if (elem.isStatic()) {
                    String outerType = elem.getTypeName();
                    SortedSet<String> methodsAndFields = methodsAndFieldsByTypeName.get(outerType);

                    // some class names are not handled properly by `getTypeName()`
                    // see https://github.com/openrewrite/rewrite/issues/1698 for more detail
                    String target = qualid.getTarget().toString();
                    String modifiedTarget = methodsAndFieldsByTypeName.keySet().stream()
                            .filter((fqn) -> fullyQualifiedNamesAreEqual(target, fqn))
                            .findFirst()
                            .orElse(target);
                    SortedSet<String> targetMethodsAndFields = methodsAndFieldsByTypeName.get(modifiedTarget);

                    Set<JavaType.FullyQualified> staticClasses = null;
                    for (JavaType.FullyQualified maybeStatic : typesByPackage.getOrDefault(target, emptySet())) {
                        if (maybeStatic.getOwningClass() != null && outerType.startsWith(maybeStatic.getOwningClass().getFullyQualifiedName())) {
                            if (staticClasses == null) {
                                staticClasses = new HashSet<>();
                            }
                            staticClasses.add(maybeStatic);
                        }
                    }

                    if (methodsAndFields == null && targetMethodsAndFields == null && staticClasses == null) {
                        anImport.used = false;
                        changed = true;
                    } else if (""*"".equals(qualid.getSimpleName())) {
                        if (isPackageAlwaysFolded(layoutStyle.getPackagesToFold(), elem)) {
                            anImport.used = true;
                            usedStaticWildcardImports.add(elem.getTypeName());
                        } else if (((methodsAndFields == null ? 0 : methodsAndFields.size()) +
                                (staticClasses == null ? 0 : staticClasses.size())) < layoutStyle.getNameCountToUseStarImport()) {
                            // replacing the star with a series of unfolded imports
                            anImport.imports.clear();

                            // add each unfolded import
                            if (methodsAndFields != null) {
                                for (String method : methodsAndFields) {
                                    anImport.imports.add(new JRightPadded<>(elem
                                            .withQualid(qualid.withName(name.withSimpleName(method)))
                                            .withPrefix(Space.format(""\n"")), Space.EMPTY, Markers.EMPTY));
                                }
                            }

                            if (staticClasses != null) {
                                for (JavaType.FullyQualified fqn : staticClasses) {
                                    anImport.imports.add(new JRightPadded<>(elem
                                            .withQualid(qualid.withName(name.withSimpleName(fqn.getClassName().contains(""."") ? fqn.getClassName().substring(fqn.getClassName().lastIndexOf(""."") + 1) : fqn.getClassName())))
                                            .withPrefix(Space.format(""\n"")), Space.EMPTY, Markers.EMPTY));
                                }
                            }

                            // move whatever the original prefix of the star import was to the first unfolded import
                            anImport.imports.set(0, anImport.imports.get(0).withElement(anImport.imports.get(0)
                                    .getElement().withPrefix(elem.getPrefix())));

                            changed = true;
                        } else {
                            usedStaticWildcardImports.add(elem.getTypeName());
                        }
                    } else if (staticClasses != null && staticClasses.stream().anyMatch(c -> elem.getTypeName().equals(c.getFullyQualifiedName())) ||
                            (methodsAndFields != null && methodsAndFields.contains(qualid.getSimpleName())) ||
                            (targetMethodsAndFields != null && targetMethodsAndFields.contains(qualid.getSimpleName()))) {
                        anImport.used = true;
                    } else {
                        anImport.used = false;
                        changed = true;
                    }
                } else {
                    String target = qualid.getTarget().toString();
                    Set<JavaType.FullyQualified> types = typesByPackage.getOrDefault(target, new HashSet<>());
                    Set<JavaType.FullyQualified> typesByFullyQualifiedClassPath = typesByPackage.getOrDefault(toFullyQualifiedName(target), new HashSet<>());
                    Set<String> topLevelTypeNames = Stream.concat(types.stream(), typesByFullyQualifiedClassPath.stream())
                            .filter(fq -> fq.getOwningClass() == null)
                            .map(JavaType.FullyQualified::getFullyQualifiedName)
                            .collect(toSet());
                    Set<JavaType.FullyQualified> combinedTypes = Stream.concat(types.stream(), typesByFullyQualifiedClassPath.stream())
                            .filter(fq -> fq.getOwningClass() == null || !topLevelTypeNames.contains(fq.getOwningClass().getFullyQualifiedName()))
                            .collect(toSet());
                    JavaType.FullyQualified qualidType = TypeUtils.asFullyQualified(elem.getQualid().getType());
                    if (combinedTypes.isEmpty() || sourcePackage.equals(elem.getPackageName()) && qualidType != null && !qualidType.getFullyQualifiedName().contains(""$"")) {
                        anImport.used = false;
                        changed = true;
                    } else if (""*"".equals(elem.getQualid().getSimpleName())) {
                        if (isPackageAlwaysFolded(layoutStyle.getPackagesToFold(), elem)) {
                            anImport.used = true;
                            usedWildcardImports.add(elem.getPackageName());
                        } else if (combinedTypes.size() < layoutStyle.getClassCountToUseStarImport()) {
                            // replacing the star with a series of unfolded imports
                            anImport.imports.clear();

                            // add each unfolded import, but only for types that are used unqualified
                            combinedTypes.stream()
                                    .filter(fqType -> unqualifiedTypeNames.contains(fqType.getFullyQualifiedName()))
                                    .map(JavaType.FullyQualified::getClassName)
                                    .sorted()
                                    .distinct()
                                    .forEach(type -> anImport.imports.add(new JRightPadded<>(elem
                                            .withQualid(qualid.withName(name.withSimpleName(type.substring(type.lastIndexOf('.') + 1))))
                                            .withPrefix(Space.format(""\n"")), Space.EMPTY, Markers.EMPTY))
                                    );

                            // move whatever the original prefix of the star import was to the first unfolded import
                            if (!anImport.imports.isEmpty()) {
                                anImport.imports.set(0, anImport.imports.get(0).withElement(anImport.imports.get(0)
                                        .getElement().withPrefix(elem.getPrefix())));
                                changed = true;
                            } else {
                                // No types are used unqualified, so remove the wildcard import entirely
                                anImport.used = false;
                                changed = true;
                            }
                        } else {
                            usedWildcardImports.add(target);
                        }
                    } else if (combinedTypes.stream().noneMatch(c -> {
                        if (""*"".equals(elem.getQualid().getSimpleName())) {
                            return elem.getPackageName().equals(c.getPackageName());
                        }
                        return fullyQualifiedNamesAreEqual(c.getFullyQualifiedName(), elem.getTypeName());
                    })) {
                        anImport.used = false;
                        changed = true;
                    }
                }
                checkedImports.add(elem.toString());
            }

            // Do not use direct imports that are imported by a wildcard import
            Set<String> ambiguousStaticImportNames = getAmbiguousStaticImportNames(cu);
            for (ImportUsage anImport : importUsage) {
                if (anImport.imports.isEmpty()) {
                    continue; // Skip import usages that have been completely removed
                }
                J.Import elem = anImport.imports.get(0).getElement();
                if (!""*"".equals(elem.getQualid().getSimpleName())) {
                    if (elem.isStatic()) {
                        if (usedStaticWildcardImports.contains(elem.getTypeName()) &&
                                !ambiguousStaticImportNames.contains(elem.getQualid().getSimpleName())) {
                            anImport.used = false;
                            changed = true;
                        }
                    } else {
                        if (usedWildcardImports.size() == 1 && usedWildcardImports.contains(elem.getPackageName()) && !elem.getTypeName().contains(""$"") && !conflictsWithJavaLang(elem)) {
                            anImport.used = false;
                            changed = true;
                        }
                    }
                }
            }

            if (changed) {
                List<JRightPadded<J.Import>> imports = new ArrayList<>();
                Space lastUnusedImportSpace = null;
                for (ImportUsage anImportGroup : importUsage) {
                    if (anImportGroup.used) {
                        List<JRightPadded<J.Import>> importGroup = anImportGroup.imports;
                        for (int i = 0; i < importGroup.size(); i++) {
                            JRightPadded<J.Import> anImport = importGroup.get(i);
                            if (i == 0 && lastUnusedImportSpace != null && anImport.getElement().getPrefix().getLastWhitespace()
                                    .chars().filter(c -> c == '\n').count() <= 1) {
                                anImport = anImport.withElement(anImport.getElement().withPrefix(lastUnusedImportSpace));
                            }
                            imports.add(anImport);
                        }
                        lastUnusedImportSpace = null;
                    } else if (lastUnusedImportSpace == null && !anImportGroup.imports.isEmpty()) {
                        lastUnusedImportSpace = anImportGroup.imports.get(0).getElement().getPrefix();
                    }
                }

                cu = cu.getPadding().withImports(imports);
                if (cu.getImports().isEmpty() && !cu.getClasses().isEmpty()) {
                    cu = autoFormat(cu, cu.getClasses().get(0).getName(), ctx, getCursor().getParentOrThrow());
                }
            }

            return cu;
        }

        private static Set<String> getAmbiguousStaticImportNames(J.CompilationUnit cu) {
            Set<String> typesWithWildcardImport = new HashSet<>();
            for (J.Import elem : cu.getImports()) {
                if (""*"".equals(elem.getQualid().getSimpleName())) {
                    typesWithWildcardImport.add(elem.getTypeName());
                }
            }
            Set<JavaType.FullyQualified> qualifiedTypes = new HashSet<>();
            for (JavaType.Variable variable : cu.getTypesInUse().getVariables()) {
                JavaType.FullyQualified fq = TypeUtils.asFullyQualified(variable.getOwner());
                if (fq != null && typesWithWildcardImport.contains(fq.getFullyQualifiedName())) {
                    qualifiedTypes.add(fq);
                }
            }
            Set<String> seen = new HashSet<>();
            Set<String> ambiguous = new HashSet<>();
            for (JavaType.FullyQualified fq : qualifiedTypes) {
                for (JavaType.Variable member : fq.getMembers()) {
                    if (!seen.add(member.getName())) {
                        ambiguous.add(member.getName());
                    }
                }
            }
            return ambiguous;
        }

        private static final Set<String> JAVA_LANG_CLASS_NAMES = new HashSet<>(Arrays.asList(
                ""AbstractMethodError"",
                ""Appendable"",
                ""ArithmeticException"",
                ""ArrayIndexOutOfBoundsException"",
                ""ArrayStoreException"",
                ""AssertionError"",
                ""AutoCloseable"",
                ""Boolean"",
                ""BootstrapMethodError"",
                ""Byte"",
                ""Character"",
                ""CharSequence"",
                ""Class"",
                ""ClassCastException"",
                ""ClassCircularityError"",
                ""ClassFormatError"",
                ""ClassLoader"",
                ""ClassNotFoundException"",
                ""ClassValue"",
                ""Cloneable"",
                ""CloneNotSupportedException"",
                ""Comparable"",
                ""Deprecated"",
                ""Double"",
                ""Enum"",
                ""EnumConstantNotPresentException"",
                ""Error"",
                ""Exception"",
                ""ExceptionInInitializerError"",
                ""Float"",
                ""FunctionalInterface"",
                ""IllegalAccessError"",
                ""IllegalAccessException"",
                ""IllegalArgumentException"",
                ""IllegalCallerException"",
                ""IllegalMonitorStateException"",
                ""IllegalStateException"",
                ""IllegalThreadStateException"",
                ""IncompatibleClassChangeError"",
                ""IndexOutOfBoundsException"",
                ""InheritableThreadLocal"",
                ""InstantiationError"",
                ""InstantiationException"",
                ""Integer"",
                ""InternalError"",
                ""InterruptedException"",
                ""Iterable"",
                ""LayerInstantiationException"",
                ""LinkageError"",
                ""Long"",
                ""MatchException"",
                ""Math"",
                ""Module"",
                ""ModuleLayer"",
                ""NegativeArraySizeException"",
                ""NoClassDefFoundError"",
                ""NoSuchFieldError"",
                ""NoSuchFieldException"",
                ""NoSuchMethodError"",
                ""NoSuchMethodException"",
                ""NullPointerException"",
                ""Number"",
                ""NumberFormatException"",
                ""Object"",
                ""OutOfMemoryError"",
                ""Override"",
                ""Package"",
                ""Process"",
                ""ProcessBuilder"",
                ""ProcessHandle"",
                ""Readable"",
                ""Record"",
                ""ReflectiveOperationException"",
                ""Runnable"",
                ""Runtime"",
                ""RuntimeException"",
                ""RuntimePermission"",
                ""SafeVarargs"",
                ""ScopedValue"",
                ""SecurityException"",
                ""SecurityManager"",
                ""Short"",
                ""StackOverflowError"",
                ""StackTraceElement"",
                ""StackWalker"",
                ""StrictMath"",
                ""String"",
                ""StringBuffer"",
                ""StringBuilder"",
                ""StringIndexOutOfBoundsException"",
                ""StringTemplate"",
                ""SuppressWarnings"",
                ""System"",
                ""Thread"",
                ""ThreadDeath"",
                ""ThreadGroup"",
                ""ThreadLocal"",
                ""Throwable"",
                ""TypeNotPresentException"",
                ""UnknownError"",
                ""UnsatisfiedLinkError"",
                ""UnsupportedClassVersionError"",
                ""UnsupportedOperationException"",
                ""VerifyError"",
                ""VirtualMachineError"",
                ""Void"",
                ""WrongThreadException""
        ));

        private static boolean conflictsWithJavaLang(J.Import elem) {
            return JAVA_LANG_CLASS_NAMES.contains(elem.getClassName());
        }

        /**
         * Collect all fully qualified names of types that are used in unqualified form.
         * This is more efficient than checking each type individually during wildcard unfolding.
         *
         * @return a set of fully qualified type names that have unqualified references.
         */
        private Set<String> collectUnqualifiedTypeNames(J.CompilationUnit cu) {
            return new JavaIsoVisitor<Set<String>>() {
                @Override
                public J.Identifier visitIdentifier(J.Identifier identifier, Set<String> unqualifiedTypeNames) {
                    JavaType type = identifier.getType();
                    // Check for unqualified type references (not field references)
                    if (type instanceof JavaType.FullyQualified && identifier.getFieldType() == null) {
                        // Check if this identifier is part of a fully qualified reference
                        // If it's part of a J.FieldAccess chain, it's qualified
                        if (!isPartOfQualifiedReference(identifier)) {
                            unqualifiedTypeNames.add(((JavaType.FullyQualified) type).getFullyQualifiedName());
                        }
                    }
                    return identifier;
                }

                @Override
                public J.Import visitImport(J.Import import_, Set<String> unqualifiedTypeNames) {
                    // Don't traverse into import statements
                    return import_;
                }

                private boolean isPartOfQualifiedReference(J.Identifier identifier) {
                    // Walk up the cursor to see if this identifier is part of a J.FieldAccess chain
                    Cursor cursor = getCursor();
                    while (cursor != null) {
                        Object value = cursor.getValue();
                        // This identifier is the name part of a field access
                        // Check if the target is a package/class reference (not a field)
                        if (value instanceof J.FieldAccess &&
                                ((J.FieldAccess) value).getName() == identifier &&
                                ((J.FieldAccess) value).getTarget() instanceof J.FieldAccess &&
                                ((J.FieldAccess) value).getTarget().getType() instanceof JavaType.FullyQualified) {
                            return true; // This is a qualified reference
                        }
                        cursor = cursor.getParent();
                    }
                    return false;
                }
            }.reduce(cu, new HashSet<>());
        }
    }

    private static class ImportUsage {
        final List<JRightPadded<J.Import>> imports = new ArrayList<>();
        boolean used = true;
    }
}
",{}
Change method access level,"Change the access level (public, protected, private, package private) of a method.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeMethodAccessLevel extends Recipe {

    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""org.mockito.Matchers anyVararg()"")
    String methodPattern;

    @Option(displayName = ""New access level"",
            description = ""New method access level to apply to the method."",
            example = ""public"",
            valid = {""private"", ""protected"", ""package"", ""public""})
    String newAccessLevel;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", methodPattern, newAccessLevel);
    }

    @Override
    public String getDisplayName() {
        return ""Change method access level"";
    }

    @Override
    public String getDescription() {
        return ""Change the access level (public, protected, private, package private) of a method."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate()
                .and(Validated.test(""newAccessLevel"", ""Must be one of 'private', 'protected', 'package', 'public'"",
                        newAccessLevel, level -> ""private"".equals(level) || ""protected"".equals(level) || ""package"".equals(level) || ""public"".equals(level)))
                .and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        J.Modifier.Type type;
        switch (newAccessLevel) {
            case ""public"":
                type = J.Modifier.Type.Public;
                break;
            case ""protected"":
                type = J.Modifier.Type.Protected;
                break;
            case ""private"":
                type = J.Modifier.Type.Private;
                break;
            default:
                type = null;
        }

        return Preconditions.check(new DeclaresMethod<>(methodPattern, matchOverrides),
                new ChangeMethodAccessLevelVisitor<>(new MethodMatcher(methodPattern, matchOverrides), type));
    }
}
","{
  ""newAccessLevel"": ""String field""
}"
Inline methods annotated with `@InlineMe`,"Apply inlinings as defined by Error Prone's [`@InlineMe` annotation](https://errorprone.info/docs/inlineme), ",Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.Cursor;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.tree.*;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.String.format;
import static java.util.Collections.emptySet;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;

public class InlineMethodCalls extends Recipe {

    private static final String INLINE_ME = ""InlineMe"";

    @Override
    public String getDisplayName() {
        return ""Inline methods annotated with `@InlineMe`"";
    }

    @Override
    public String getDescription() {
        return ""Apply inlinings as defined by Error Prone's [`@InlineMe` annotation](https://errorprone.info/docs/inlineme), "" +
                ""or compatible annotations. Uses the template and method arguments to replace method calls. "" +
                ""Supports both methods invocations and constructor calls, with optional new imports."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        // XXX Preconditions can not yet pick up the `@InlineMe` annotation on methods used
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                InlineMeValues values = findInlineMeValues(mi.getMethodType());
                if (values == null) {
                    return mi;
                }
                Template template = values.template(mi);
                if (template == null) {
                    return mi;
                }
                removeAndAddImports(method, values.getImports(), values.getStaticImports());
                J replacement = JavaTemplate.builder(template.getString())
                        .contextSensitive()
                        .imports(values.getImports().toArray(new String[0]))
                        .staticImports(values.getStaticImports().toArray(new String[0]))
                        .javaParser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()))
                        .build()
                        .apply(updateCursor(mi), mi.getCoordinates().replace(), template.getParameters());
                return avoidMethodSelfReferences(mi, replacement);
            }

            @Override
            public J visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J.NewClass nc = (J.NewClass) super.visitNewClass(newClass, ctx);
                InlineMeValues values = findInlineMeValues(nc.getConstructorType());
                if (values == null) {
                    return nc;
                }
                Template template = values.template(nc);
                if (template == null) {
                    return nc;
                }
                removeAndAddImports(newClass, values.getImports(), values.getStaticImports());
                J replacement = JavaTemplate.builder(template.getString())
                        .contextSensitive()
                        .imports(values.getImports().toArray(new String[0]))
                        .staticImports(values.getStaticImports().toArray(new String[0]))
                        .javaParser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()))
                        .build()
                        .apply(updateCursor(nc), nc.getCoordinates().replace(), template.getParameters());
                return avoidMethodSelfReferences(nc, replacement);
            }

            private @Nullable InlineMeValues findInlineMeValues(JavaType.@Nullable Method methodType) {
                if (methodType == null) {
                    return null;
                }
                List<String> parameterNames = methodType.getParameterNames();
                if (!parameterNames.isEmpty() && ""arg0"".equals(parameterNames.get(0))) {
                    return null; // We need `-parameters` before we're able to substitute parameters in the template
                }

                List<JavaType.FullyQualified> annotations = methodType.getAnnotations();
                for (JavaType.FullyQualified annotation : annotations) {
                    if (INLINE_ME.equals(annotation.getClassName())) {
                        return InlineMeValues.parse((JavaType.Annotation) annotation);
                    }
                }
                return null;
            }

            private void removeAndAddImports(MethodCall method, Set<String> templateImports, Set<String> templateStaticImports) {
                Set<String> originalImports = findOriginalImports(method);

                // Remove regular and static imports that are no longer needed
                for (String originalImport : originalImports) {
                    if (!templateImports.contains(originalImport) &&
                            !templateStaticImports.contains(originalImport)) {
                        maybeRemoveImport(originalImport);
                    }
                }

                // Add new regular imports needed by the template
                for (String importStr : templateImports) {
                    if (!originalImports.contains(importStr)) {
                        maybeAddImport(importStr);
                    }
                }

                // Add new static imports needed by the template
                for (String staticImport : templateStaticImports) {
                    if (!originalImports.contains(staticImport)) {
                        int lastDot = staticImport.lastIndexOf('.');
                        if (0 < lastDot) {
                            maybeAddImport(
                                    staticImport.substring(0, lastDot),
                                    staticImport.substring(lastDot + 1));
                        }
                    }
                }
            }

            private Set<String> findOriginalImports(MethodCall method) {
                // Collect all regular and static imports used in the original method call
                return new JavaVisitor<Set<String>>() {
                    @Override
                    public @Nullable JavaType visitType(@Nullable JavaType javaType, Set<String> strings) {
                        JavaType jt = super.visitType(javaType, strings);
                        if (jt instanceof JavaType.FullyQualified) {
                            strings.add(((JavaType.FullyQualified) jt).getFullyQualifiedName());
                        }
                        return jt;
                    }

                    @Override
                    public J visitMethodInvocation(J.MethodInvocation methodInvocation, Set<String> staticImports) {
                        J.MethodInvocation mi = (J.MethodInvocation) super.visitMethodInvocation(methodInvocation, staticImports);
                        // Check if this is a static method invocation without a select (meaning it might be statically imported)
                        JavaType.Method methodType = mi.getMethodType();
                        if (mi.getSelect() == null && methodType != null && methodType.hasFlags(Flag.Static)) {
                            staticImports.add(format(""%s.%s"",
                                    methodType.getDeclaringType().getFullyQualifiedName(),
                                    methodType.getName()));
                        }
                        return mi;
                    }

                    @Override
                    public J visitIdentifier(J.Identifier identifier, Set<String> staticImports) {
                        J.Identifier id = (J.Identifier) super.visitIdentifier(identifier, staticImports);
                        // Check if this is a static field reference
                        JavaType.Variable fieldType = id.getFieldType();
                        if (fieldType != null && fieldType.hasFlags(Flag.Static)) {
                            if (fieldType.getOwner() instanceof JavaType.FullyQualified) {
                                staticImports.add(format(""%s.%s"",
                                        ((JavaType.FullyQualified) fieldType.getOwner()).getFullyQualifiedName(),
                                        fieldType.getName()));
                            }
                        }
                        return id;
                    }
                }.reduce(method, new HashSet<>());
            }

            private J avoidMethodSelfReferences(MethodCall original, J replacement) {
                JavaType.Method replacementMethodType = replacement instanceof MethodCall ?
                        ((MethodCall) replacement).getMethodType() : null;
                if (replacementMethodType == null) {
                    return replacement;
                }

                Cursor cursor = getCursor();
                while ((cursor = cursor.getParent()) != null) {
                    Object value = cursor.getValue();

                    JavaType.Method cursorMethodType;
                    if (value instanceof MethodCall) {
                        cursorMethodType = ((MethodCall) value).getMethodType();
                    } else if (value instanceof J.MethodDeclaration) {
                        cursorMethodType = ((J.MethodDeclaration) value).getMethodType();
                    } else {
                        continue;
                    }
                    if (TypeUtils.isOfType(replacementMethodType, cursorMethodType)) {
                        return original;
                    }
                }
                return replacement;
            }
        };
    }

    @Value
    private static class InlineMeValues {
        private static final Pattern TEMPLATE_IDENTIFIER = Pattern.compile(""#\\{(\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*):any\\(.*?\\)}"");

        @Getter(AccessLevel.NONE)
        String replacement;

        Set<String> imports;
        Set<String> staticImports;

        static InlineMeValues parse(JavaType.Annotation annotation) {
            Map<String, Object> collect = annotation.getValues().stream().collect(toMap(
                    e -> ((JavaType.Method) e.getElement()).getName(),
                    JavaType.Annotation.ElementValue::getValue
            ));
            // Parse imports and static imports from the annotation values
            return new InlineMeValues(
                    (String) collect.get(""replacement""),
                    parseImports(collect.get(""imports"")),
                    parseImports(collect.get(""staticImports"")));
        }

        private static Set<String> parseImports(@Nullable Object importsValue) {
            if (importsValue instanceof List) {
                return ((List<?>) importsValue).stream()
                        .map(Object::toString)
                        .collect(toSet());
            }
            return emptySet();
        }

        @Nullable
        Template template(MethodCall original) {
            JavaType.Method methodType = original.getMethodType();
            if (methodType == null) {
                return null;
            }
            String templateString = createTemplateString(original, replacement, methodType);
            List<Object> parameters = createParameters(templateString, original);
            return new Template(templateString, parameters.toArray(new Object[0]));
        }

        private static String createTemplateString(MethodCall original, String replacement, JavaType.Method methodType) {
            String templateString;
            if (original instanceof J.NewClass && replacement.startsWith(""this("")) {
                // For constructor-to-constructor replacement, replace ""this"" with ""new ClassName""
                templateString = ""new "" + methodType.getDeclaringType().getClassName() + replacement.substring(4);
            } else if (original instanceof J.MethodInvocation &&
                    ((J.MethodInvocation) original).getSelect() == null &&
                    replacement.startsWith(""this."")) {
                templateString = replacement.substring(5);
            } else {
                templateString = replacement.replaceAll(""\\bthis\\b"", ""#{this:any()}"");
            }
            List<String> originalParameterNames = methodType.getParameterNames();
            for (String parameterName : originalParameterNames) {
                // Replace parameter names with their values in the templateString
                templateString = templateString
                        .replaceFirst(format(""\\b%s\\b"", parameterName), format(""#{%s:any()}"", parameterName))
                        .replaceAll(format(""(?<!\\{)\\b%s\\b"", parameterName), format(""#{%s}"", parameterName));
            }
            return templateString;
        }

        private static List<Object> createParameters(String templateString, MethodCall original) {
            Map<String, Expression> lookup = new HashMap<>();
            if (original instanceof J.MethodInvocation) {
                Expression select = ((J.MethodInvocation) original).getSelect();
                if (select != null) {
                    lookup.put(""this"", select);
                }
            }
            List<String> originalParameterNames = requireNonNull(original.getMethodType()).getParameterNames();
            for (int i = 0; i < originalParameterNames.size(); i++) {
                String originalName = originalParameterNames.get(i);
                Expression originalValue = original.getArguments().get(i);
                lookup.put(originalName, originalValue);
            }
            List<Object> parameters = new ArrayList<>();
            Matcher matcher = TEMPLATE_IDENTIFIER.matcher(templateString);
            while (matcher.find()) {
                Expression o = lookup.get(matcher.group(1));
                if (o != null) {
                    parameters.add(o);
                }
            }
            return parameters;
        }
    }

    @Value
    private static class Template {
        String string;
        Object[] parameters;
    }
}
",{}
Add a literal method argument,Add a literal `String` or `int` argument to method invocations.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.apache.commons.lang3.StringUtils;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;

import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.tree.JavaType.Primitive;

/**
 * This recipe finds method invocations matching a method pattern and uses a zero-based argument index to determine
 * which argument is added with a literal value.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class AddLiteralMethodArgument extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""com.yourorg.A foo(int, int)"")
    String methodPattern;

    /**
     * A zero-based index that indicates which argument will be added as null to the method invocation.
     */
    @Option(displayName = ""Argument index"",
            description = ""A zero-based index that indicates which argument will be added as null to the method invocation."",
            example = ""0"")
    int argumentIndex;

    @Option(displayName = ""Literal"",
            description = ""The literal value that we add the argument for."",
            example = ""abc"")
    Object literal;

    @Option(displayName = ""Parameter type"",
            description = ""The type of the parameter that we add the argument for. Defaults to `String`."",
            required = false,
            example = ""String"",
            valid = {""String"", ""int"", ""short"", ""long"", ""float"", ""double"", ""boolean"", ""char""})
    @Nullable
    String primitiveType;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""%d in methods `%s`"", argumentIndex, methodPattern);
    }

    @Override
    public String getDisplayName() {
        return ""Add a literal method argument"";
    }

    @Override
    public String getDescription() {
        return ""Add a literal `String` or `int` argument to method invocations."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(methodPattern), new AddLiteralMethodArgumentVisitor(new MethodMatcher(methodPattern)));
    }

    private class AddLiteralMethodArgumentVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        public AddLiteralMethodArgumentVisitor(MethodMatcher methodMatcher) {
            this.methodMatcher = methodMatcher;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            return (J.MethodInvocation) visitMethodCall(m);
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass n = super.visitNewClass(newClass, ctx);
            return (J.NewClass) visitMethodCall(n);
        }

        private MethodCall visitMethodCall(MethodCall methodCall) {
            MethodCall m = methodCall;
            List<Expression> originalArgs = m.getArguments();
            if (methodMatcher.matches(m) && (long) originalArgs.size() >= argumentIndex) {
                List<Expression> args = new ArrayList<>(originalArgs);

                if (args.size() == 1 && args.get(0) instanceof J.Empty) {
                    args.remove(0);
                }
                JavaType.Primitive primitive;
                String valueSource;
                if (StringUtils.isBlank(primitiveType) || ""string"".equalsIgnoreCase(primitiveType)) {
                    primitive = Primitive.String;
                    valueSource = String.format(""\""%s\"""", getLiteral());
                } else if(""char"".equalsIgnoreCase(primitiveType)){
                    primitive = Primitive.Char;
                    valueSource = String.format(""'%s'"", getLiteral());
                }else {
                    primitive = Primitive.fromKeyword(primitiveType.toLowerCase());
                    valueSource = String.valueOf(getLiteral());
                }

                Expression literal = new J.Literal(randomId(), args.isEmpty() ? Space.EMPTY : Space.SINGLE_SPACE, Markers.EMPTY, getLiteral(), valueSource, null, primitive);
                m = m.withArguments(ListUtils.insert(args, literal, argumentIndex));

                JavaType.Method methodType = m.getMethodType();
                if (methodType != null) {
                    m = m.withMethodType(methodType
                            .withParameterNames(ListUtils.insert(methodType.getParameterNames(), ""arg"" + argumentIndex, argumentIndex))
                            .withParameterTypes(ListUtils.insert(methodType.getParameterTypes(), primitive, argumentIndex)));
                    if (m instanceof J.MethodInvocation && ((J.MethodInvocation) m).getName().getType() != null) {
                        m = ((J.MethodInvocation) m).withName(((J.MethodInvocation) m).getName().withType(m.getMethodType()));
                    }
                }
            }
            return m;
        }

    }
}
","{
  ""argumentIndex"": ""int field"",
  ""literal"": ""Object field""
}"
Create Java class,"Create a new, empty Java class.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class CreateEmptyJavaClass extends ScanningRecipe<AtomicBoolean> {

    @JsonIgnore
    private static final String NEW_CLASS_TEMPLATE = ""package %s;\n\n%sclass %s {\n}"";

    @Option(displayName = ""Source root"",
            description = ""The source root of the new class file."",
            example = ""src/main/java"")
    String sourceRoot;

    @Option(displayName = ""Package name"",
            description = ""The package of the new class."",
            example = ""org.openrewrite.example"")
    String packageName;

    @Option(displayName = ""Modifier"",
            description = ""The class modifier."",
            valid = {""public"", ""private"", ""protected"", ""package-private""},
            example = ""public"")
    String modifier;

    @Option(displayName = ""Class name"",
            description = ""File path of new file."",
            example = ""ExampleClass"")
    String className;

    @Option(displayName = ""Overwrite existing file"",
            description = ""If there is an existing file, should it be overwritten."",
            required = false)
    @Nullable
    Boolean overwriteExisting;

    @Option(displayName = ""Relative directory path"",
            description = ""Directory path of new class."",
            required = false,
            example = ""foo/bar"")
    @Nullable
    String relativePath;

    @Override
    public String getDisplayName() {
        return ""Create Java class"";
    }

    @Override
    public String getDescription() {
        return ""Create a new, empty Java class."";
    }

    @Override
    public AtomicBoolean getInitialValue(ExecutionContext ctx) {
        return new AtomicBoolean(true);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicBoolean shouldCreate) {
        return new CreateFileVisitor(getSourcePath(), shouldCreate);
    }

    @Override
    public Collection<SourceFile> generate(AtomicBoolean shouldCreate, ExecutionContext ctx) {
        if (shouldCreate.get()) {
            return createEmptyClass().collect(toList());
        }
        return emptyList();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicBoolean created) {
        Path path = getSourcePath();
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                if ((created.get() || Boolean.TRUE.equals(overwriteExisting)) && path.equals(cu.getSourcePath())) {
                    Optional<SourceFile> sourceFile = createEmptyClass().findFirst();
                    if (sourceFile.isPresent() && sourceFile.get() instanceof J.CompilationUnit) {
                        J.CompilationUnit newCu = (J.CompilationUnit) sourceFile.get();
                        return cu.withClasses(newCu.getClasses()).withSourcePath(path);
                    }
                }

                return cu;
            }
        };
    }

    private Stream<SourceFile> createEmptyClass() {
        String packageModifier = ""package-private"".equals(modifier) ? """" : modifier + "" "";
        return JavaParser.fromJavaVersion().build()
                .parse(String.format(CreateEmptyJavaClass.NEW_CLASS_TEMPLATE, packageName, packageModifier, className))
                .map(brandNewFile -> brandNewFile.withSourcePath(getSourcePath()));
    }

    @SuppressWarnings(""java:S1075"")
    private Path getSourcePath() {
        String path = relativePath;
        if (path == null) {
            path = """";
        }

        if (!path.isEmpty() && !path.endsWith(""/"")) {
            path += ""/"";
        }

        return Paths.get(String.format(
                ""%s%s/%s/%s.java"",
                path,
                sourceRoot,
                packageName.replace('.', '/'),
                className));
    }
}
","{
  ""sourceRoot"": ""String field"",
  ""packageName"": ""String field"",
  ""modifier"": ""String field"",
  ""className"": ""String field""
}"
Replace `String` literal,Replace the value of a complete `String` literal.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceStringLiteralValue extends Recipe {

    @Option(displayName = ""Old literal `String` value"",
            description = ""The `String` value to replace."",
            example = ""apple"")
    String oldLiteralValue;

    @Option(displayName = ""New literal `String` value"",
            description = ""The `String` value to replace with."",
            example = ""orange"")
    String newLiteralValue;

    @Override
    public String getDisplayName() {
        return ""Replace `String` literal"";
    }

    @Override
    public String getDescription() {
        return ""Replace the value of a complete `String` literal."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Literal visitLiteral(J.Literal literal, ExecutionContext ctx) {
                J.Literal lit = super.visitLiteral(literal, ctx);
                if (lit.getType() == JavaType.Primitive.String &&
                    oldLiteralValue.equals(lit.getValue())) {
                    return lit
                            .withValue(newLiteralValue)
                            .withValueSource('""' + newLiteralValue + '""');
                }
                return lit;
            }
        };
    }

}
","{
  ""oldLiteralValue"": ""String field"",
  ""newLiteralValue"": ""String field""
}"
Change method target to variable,Change method invocations to method calls on a variable.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Flag;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

import java.util.LinkedHashSet;
import java.util.Set;

import static java.util.Collections.emptyList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeMethodTargetToVariable extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""org.mycorp.A method(..)"")
    String methodPattern;

    @Option(displayName = ""Variable name"",
            description = ""Name of variable to use as target for the modified method invocation."",
            example = ""foo"")
    String variableName;

    @Option(displayName = ""Variable type"",
            description = ""Type attribution to use for the return type of the modified method invocation."",
            example = ""java.lang.String"")
    String variableType;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Change method target to variable"";
    }

    @Override
    public String getDescription() {
        return ""Change method invocations to method calls on a variable."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(
                new UsesMethod<>(methodPattern, matchOverrides),
                new ChangeMethodTargetToVariableVisitor(
                        new MethodMatcher(methodPattern, matchOverrides),
                        JavaType.ShallowClass.build(variableType)
                )
        );
    }

    private class ChangeMethodTargetToVariableVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;
        private final JavaType.Class variableType;

        private ChangeMethodTargetToVariableVisitor(MethodMatcher methodMatcher, JavaType.Class variableType) {
            this.methodMatcher = methodMatcher;
            this.variableType = variableType;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (methodMatcher.matches(m)) {

                JavaType.Method methodType = null;
                if (m.getMethodType() != null) {
                    maybeRemoveImport(m.getMethodType().getDeclaringType());

                    Set<Flag> flags = new LinkedHashSet<>(m.getMethodType().getFlags());
                    flags.remove(Flag.Static);
                    methodType = m.getMethodType().withDeclaringType(this.variableType).withFlags(flags);
                }

                m = m.withSelect(new J.Identifier(randomId(),
                        m.getSelect() == null ?
                                Space.EMPTY :
                                m.getSelect().getPrefix(),
                        Markers.EMPTY,
                        emptyList(),
                        variableName,
                        this.variableType,
                        null)
                ).withMethodType(methodType)
                        .withName(m.getName().withType(methodType));
            }
            return m;
        }
    }
}
","{
  ""variableName"": ""String field"",
  ""variableType"": ""String field""
}"
Replace constant with another constant,"Replace a constant with another constant, adding/removing import on class if needed.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.*;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceConstantWithAnotherConstant extends Recipe {

    @Option(displayName = ""Fully qualified name of the constant to replace"",
            example = ""org.springframework.http.MediaType.APPLICATION_JSON_VALUE"")
    String existingFullyQualifiedConstantName;

    @Option(displayName = ""Fully qualified name of the constant to use in place of existing constant"",
            example = ""org.springframework.http.MediaType.APPLICATION_JSON_VALUE"")
    String fullyQualifiedConstantName;

    @Override
    public String getDisplayName() {
        return ""Replace constant with another constant"";
    }

    @Override
    public String getDescription() {
        return ""Replace a constant with another constant, adding/removing import on class if needed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(existingFullyQualifiedConstantName.substring(0, existingFullyQualifiedConstantName.lastIndexOf('.')), false),
                new ReplaceConstantWithAnotherConstantVisitor(existingFullyQualifiedConstantName, fullyQualifiedConstantName));
    }

    private static class ReplaceConstantWithAnotherConstantVisitor extends JavaVisitor<ExecutionContext> {

        private final String existingOwningType;
        private final String constantName;
        private final JavaType.FullyQualified existingOwningTypeFqn;
        private final JavaType.FullyQualified newOwningType;
        private final JavaType.FullyQualified newTargetType;
        private final String newConstantName;

        public ReplaceConstantWithAnotherConstantVisitor(String existingFullyQualifiedConstantName, String fullyQualifiedConstantName) {
            this.existingOwningType = existingFullyQualifiedConstantName.substring(0, existingFullyQualifiedConstantName.lastIndexOf('.'));
            this.constantName = existingFullyQualifiedConstantName.substring(existingFullyQualifiedConstantName.lastIndexOf('.') + 1);
            this.existingOwningTypeFqn = JavaType.ShallowClass.build(existingOwningType);
            this.newOwningType = JavaType.ShallowClass.build(fullyQualifiedConstantName.substring(0, fullyQualifiedConstantName.lastIndexOf('.')));
            this.newTargetType = JavaType.ShallowClass.build(fullyQualifiedConstantName);
            this.newConstantName = fullyQualifiedConstantName.substring(fullyQualifiedConstantName.lastIndexOf('.') + 1);
        }

        @Override
        public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            JavaType.Variable fieldType = fieldAccess.getName().getFieldType();
            if (isConstant(fieldType)) {
                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);
                return replaceFieldAccess(fieldAccess, fieldType, hasNoConflictingImport(sf));
            }
            return super.visitFieldAccess(fieldAccess, ctx);
        }

        @Override
        public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {
            JavaType.Variable fieldType = ident.getFieldType();
            if (isConstant(fieldType)) {
                JavaSourceFile sf = getCursor().firstEnclosing(JavaSourceFile.class);
                return replaceFieldAccess(ident, fieldType, hasNoConflictingImport(sf));
            }
            return super.visitIdentifier(ident, ctx);
        }

        private J replaceFieldAccess(Expression expression, JavaType.Variable fieldType, boolean hasNoConflictingImport) {
            JavaType owner = fieldType.getOwner();
            while (owner instanceof JavaType.FullyQualified) {
                maybeRemoveImport(((JavaType.FullyQualified) owner).getFullyQualifiedName());
                owner = ((JavaType.FullyQualified) owner).getOwningClass();
            }

            if (expression instanceof J.Identifier) {
                String realName = hasNoConflictingImport ? newConstantName : newTargetType.getFullyQualifiedName();
                if (hasNoConflictingImport) {
                    maybeAddImport(newOwningType.getFullyQualifiedName(), newConstantName, false);
                }
                J.Identifier identifier = (J.Identifier) expression;
                return identifier
                        .withSimpleName(realName)
                        .withFieldType(fieldType.withOwner(newOwningType).withName(realName));
            } else if (expression instanceof J.FieldAccess) {
                if (hasNoConflictingImport) {
                    maybeAddImport(newOwningType.getFullyQualifiedName(), false);
                }
                J.FieldAccess fieldAccess = (J.FieldAccess) expression;
                Expression target = fieldAccess.getTarget();
                J.Identifier name = fieldAccess.getName();
                String realName = hasNoConflictingImport ? newOwningType.getClassName() : newOwningType.getFullyQualifiedName();
                if (target instanceof J.Identifier) {
                    target = ((J.Identifier) target).withType(newOwningType).withSimpleName(realName);
                    name = name
                            .withFieldType(fieldType.withOwner(newOwningType).withName(newConstantName))
                            .withSimpleName(newConstantName);
                } else {
                    target = (((J.FieldAccess) target).getName()).withType(newOwningType).withSimpleName(realName);
                    name = name
                            .withFieldType(fieldType.withOwner(newOwningType).withName(newConstantName))
                            .withSimpleName(newConstantName);
                }
                return fieldAccess
                        .withTarget(target)
                        .withName(name);
            }
            return expression;
        }

        private boolean isConstant(JavaType.@Nullable Variable varType) {
            return varType != null && TypeUtils.isOfClassType(varType.getOwner(), existingOwningType) &&
                    varType.getName().equals(constantName);
        }

        private boolean hasNoConflictingImport(@Nullable JavaSourceFile sf) {
            return hasNoConflictingImport(sf, newOwningType) && hasNoConflictingImport(sf, newTargetType);
        }

        private boolean hasNoConflictingImport(@Nullable JavaSourceFile sf, JavaType.FullyQualified targetType) {
            if (sf == null || targetType == null) {
                return true;
            }

            for (J.Import anImport : sf.getImports()) {
                if (anImport.isStatic()) {
                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(anImport.getQualid().getTarget().getType());
                    if (anImport.getQualid().getSimpleName().equals(newConstantName) && !TypeUtils.isOfClassType(fqn, newOwningType.getFullyQualifiedName())) {
                        if (!anImport.getQualid().getSimpleName().equals(constantName) || !TypeUtils.isOfClassType(fqn, existingOwningTypeFqn.getFullyQualifiedName())) {
                            return false;
                        }
                    }
                } else {
                    JavaType.FullyQualified currType = TypeUtils.asFullyQualified(anImport.getQualid().getType());
                    if (currType != null &&
                            !TypeUtils.isOfType(currType, targetType) &&
                            currType.getClassName().equals(targetType.getClassName())) {
                        return false;
                    }
                }

            }
            return true;
        }
    }
}
","{
  ""existingFullyQualifiedConstantName"": ""String field"",
  ""fullyQualifiedConstantName"": ""String field""
}"
Transform calls to `Objects.isNull(..)` and `Objects.nonNull(..)`,Replace calls to `Objects.isNull(..)` and `Objects.nonNull(..)` with a simple null check. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import org.openrewrite.*;
import org.openrewrite.java.cleanup.SimplifyBooleanExpressionVisitor;
import org.openrewrite.java.cleanup.UnnecessaryParenthesesVisitor;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

public class RemoveObjectsIsNull extends Recipe {
    private static final MethodMatcher IS_NULL = new MethodMatcher(""java.util.Objects isNull(..)"");
    private static final MethodMatcher NON_NULL = new MethodMatcher(""java.util.Objects nonNull(..)"");

    @Override
    public String getDisplayName() {
        return ""Transform calls to `Objects.isNull(..)` and `Objects.nonNull(..)`"";
    }

    @Override
    public String getDescription() {
        return ""Replace calls to `Objects.isNull(..)` and `Objects.nonNull(..)` with a simple null check. "" +
               ""Using these methods outside of stream predicates is not idiomatic."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(Preconditions.or(new UsesMethod<>(IS_NULL), new UsesMethod<>(NON_NULL)), new JavaVisitor<ExecutionContext>() {
            @Override
            public Expression visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = (J.MethodInvocation) super.visitMethodInvocation(method, ctx);
                if (IS_NULL.matches(m)) {
                    return replace(m, ""(#{any()}) == null"", ctx);
                } else if (NON_NULL.matches(m)) {
                    return replace(m, ""(#{any()}) != null"", ctx);
                }
                return m;
            }

            private Expression replace(J.MethodInvocation m, String pattern, ExecutionContext ctx) {
                maybeRemoveImport(""java.util.Objects"");
                maybeRemoveImport(""java.util.Objects."" + m.getSimpleName());

                // Upcasted primitives are never null; simplify logic for use in SimplifyConstantIfBranchExecution
                JavaType type = m.getArguments().get(0).getType();
                if (type instanceof JavaType.Primitive && JavaType.Primitive.String != type) {
                    boolean replacementValue = NON_NULL.matches(m);
                    return new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY, replacementValue, String.valueOf(replacementValue), null, JavaType.Primitive.Boolean);
                }

                // Replace the method invocation with a simple null check
                Cursor parentTreeCursor = getCursor().getParentTreeCursor();
                if (!(parentTreeCursor.getValue() instanceof J.ControlParentheses) &&
                    !(parentTreeCursor.getValue() instanceof J.Parentheses)) {
                    pattern = '(' + pattern + ')';
                }
                parentTreeCursor.putMessage(""SIMPLIFY_BOOLEAN_EXPRESSION"", true);
                parentTreeCursor.putMessage(""REMOVE_UNNECESSARY_PARENTHESES"", true);
                return JavaTemplate.apply(pattern, getCursor(), m.getCoordinates().replace(), m.getArguments().get(0));
            }

            @Override
            public J postVisit(J tree, ExecutionContext ctx) {
                J j = super.postVisit(tree, ctx);
                if (Boolean.TRUE.equals(getCursor().pollMessage(""SIMPLIFY_BOOLEAN_EXPRESSION""))) {
                    j = new SimplifyBooleanExpressionVisitor().visit(j, ctx, getCursor().getParentOrThrow());
                }
                if (Boolean.TRUE.equals(getCursor().pollMessage(""REMOVE_UNNECESSARY_PARENTHESES""))) {
                    j = new UnnecessaryParenthesesVisitor<>().visit(j, ctx, getCursor().getParentOrThrow());
                }
                return j;
            }
        });
    }
}
",{}
Reorder method arguments,Reorder method arguments into the specified order.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.ArrayList;
import java.util.List;

import static java.util.Arrays.asList;
import static java.util.Objects.requireNonNull;

/**
 * This recipe finds method invocations matching the given method pattern and reorders the arguments based on the ordered
 * array of parameter names.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class ReorderMethodArguments extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""com.yourorg.A foo(String, Integer, Integer)"")
    String methodPattern;

    /**
     * An array of parameter names that indicates the new order in which those arguments should be arranged.
     */
    @Option(displayName = ""New parameter names"",
            description = ""An array of parameter names that indicates the new order in which those arguments should be arranged."",
            example = ""[foo, bar, baz]"")
    String[] newParameterNames;

    /**
     * If the original method signature is not type-attributed, this is an optional list that indicates the original order
     * in which the arguments were arranged.
     */
    @Option(displayName = ""Old parameter names"",
            description = ""If the original method signature is not type-attributed, this is an optional list that indicates the original order in which the arguments were arranged."",
            required = false,
            example = ""[baz, bar, foo]"")
    String @Nullable [] oldParameterNames;

    @Option(displayName = ""Ignore type definition"",
            description = ""When set to `true` the definition of the old type will be left untouched. "" +
                    ""This is useful when you're replacing usage of a class but don't want to rename it."",
            required = false)
    @Nullable
    Boolean ignoreDefinition;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @JsonPOJOBuilder(withPrefix = """")
    public static class Builder {
    }

    @Override
    public String getDisplayName() {
        return ""Reorder method arguments"";
    }

    @Override
    public String getDescription() {
        return ""Reorder method arguments into the specified order."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new JavaVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    if (Boolean.TRUE.equals(ignoreDefinition)) {
                        J j = new DeclaresMethod<>(methodPattern, true).visitNonNull(cu, ctx);
                        if (cu != j) {
                            return cu;
                        }
                    }
                    return new UsesMethod<>(methodPattern).visitNonNull(cu, ctx);
                }
                return super.visit(tree, ctx);
            }
        }, new ReorderMethodArgumentsVisitor(new MethodMatcher(methodPattern, matchOverrides)));
    }

    private class ReorderMethodArgumentsVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        private ReorderMethodArgumentsVisitor(MethodMatcher methodMatcher) {
            this.methodMatcher = methodMatcher;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            return (J.MethodInvocation) visitMethodCall(super.visitMethodInvocation(method, ctx));
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            return (J.NewClass) visitMethodCall(super.visitNewClass(newClass, ctx));
        }

        private MethodCall visitMethodCall(MethodCall m) {
            if (methodMatcher.matches(m) && m.getMethodType() != null) {
                @SuppressWarnings(""ConstantConditions"") List<String> paramNames =
                        oldParameterNames == null || oldParameterNames.length == 0 ?
                                m.getMethodType().getParameterNames() :
                                asList(oldParameterNames);

                List<JRightPadded<Expression>> originalArgs = getPaddedArguments(m);

                int resolvedParamCount = m.getMethodType().getParameterTypes().size();

                int i = 0;
                List<JRightPadded<Expression>> reordered = new ArrayList<>(originalArgs.size());
                List<String> reorderedNames = new ArrayList<>(originalArgs.size());
                List<JavaType> reorderedTypes = new ArrayList<>(originalArgs.size());
                List<Space> formattings = new ArrayList<>(originalArgs.size());
                List<Space> rightFormattings = new ArrayList<>(originalArgs.size());

                for (String name : newParameterNames) {
                    int fromPos = paramNames.indexOf(name);
                    if (originalArgs.size() > resolvedParamCount && fromPos == resolvedParamCount - 1) {
                        // this is a varargs argument
                        List<JRightPadded<Expression>> varargs = originalArgs.subList(fromPos, originalArgs.size());
                        reordered.addAll(varargs);
                        for (int j = 0; j < varargs.size(); j++) {
                            reorderedNames.add(name + j);
                            reorderedTypes.add(varargs.get(j).getElement().getType());
                        }
                        for (JRightPadded<Expression> exp : originalArgs.subList(i, (i++) + varargs.size())) {
                            formattings.add(exp.getElement().getPrefix());
                            rightFormattings.add(exp.getAfter());
                        }
                    } else if (fromPos >= 0 && originalArgs.size() > fromPos) {
                        JRightPadded<Expression> originalArg = originalArgs.get(fromPos);
                        reordered.add(originalArg);
                        reorderedNames.add(name);
                        reorderedTypes.add(originalArg.getElement().getType());
                        formattings.add(originalArgs.get(i).getElement().getPrefix());
                        rightFormattings.add(originalArgs.get(i++).getAfter());
                    }
                }

                boolean changed = false;
                i = 0;
                for (JRightPadded<Expression> expression : reordered) {
                    final int index = i;
                    reordered.set(i, expression
                            .map(e -> e.withPrefix(formattings.get(index)))
                            .withAfter(rightFormattings.get(index)));
                    if (reordered.get(i) != originalArgs.get(i)) {
                        changed = true;
                    }
                    i++;
                }

                if (changed) {
                    JavaType.Method mt = m.getMethodType()
                            .withParameterNames(reorderedNames)
                            .withParameterTypes(reorderedTypes);
                    m = withPaddedArguments(m, reordered)
                            .withMethodType(mt);
                    if (m instanceof J.MethodInvocation && ((J.MethodInvocation) m).getName().getType() != null) {
                        m = ((J.MethodInvocation) m).withName(((J.MethodInvocation) m).getName().withType(mt));
                    }
                }
            }
            return m;
        }

        private List<JRightPadded<Expression>> getPaddedArguments(MethodCall m) {
            if (m instanceof J.MethodInvocation) {
                return ((J.MethodInvocation) m).getPadding().getArguments().getPadding().getElements();
            } else if (m instanceof J.NewClass) {
                return ((J.NewClass) m).getPadding().getArguments().getPadding().getElements();
            } else {
                throw new IllegalArgumentException(""Unknown MethodCall type"");
            }
        }

        private MethodCall withPaddedArguments(MethodCall m, List<JRightPadded<Expression>> reordered) {
            if (m instanceof J.MethodInvocation) {
                J.MethodInvocation mi = (J.MethodInvocation) m;
                return mi.getPadding().withArguments(
                        mi.getPadding().getArguments().getPadding().withElements(reordered)
                );
            } else if (m instanceof J.NewClass) {
                J.NewClass nc = (J.NewClass) m;
                return nc.getPadding().withArguments(
                        nc.getPadding().getArguments().getPadding().withElements(reordered)
                );
            } else {
                throw new IllegalArgumentException(""Unknown MethodCall type"");
            }
        }
    }
}
",{}
Simplify a call chain,Simplify `a.b().c()` to `a.d()`.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import java.util.List;

import static java.util.Collections.reverse;
import static java.util.stream.Collectors.toList;

@Value
@EqualsAndHashCode(callSuper = false)
public class SimplifyMethodChain extends Recipe {
    @Option(displayName = ""Method pattern chain"",
            description = ""A list of method patterns that are called in sequence"",
            example = ""['java.util.Map keySet()', 'java.util.Set contains(..)']"")
    List<String> methodPatternChain;

    @Option(displayName = ""New method name"",
            description = ""The method name that will replace the existing name. The new method name target is assumed to have the same arguments as the last method in the chain."",
            example = ""containsKey"")
    String newMethodName;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false,
            example = ""false"")
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Simplify a call chain"";
    }

    @Override
    public String getDescription() {
        return ""Simplify `a.b().c()` to `a.d()`."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(""methodPatternChain"",
                ""Requires more than one pattern"",
                methodPatternChain, c -> c != null && c.size() > 1));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        List<MethodMatcher> matchers = methodPatternChain.stream()
                .map(matcher -> new MethodMatcher(matcher, matchOverrides))
                .collect(toList());
        reverse(matchers);

        return Preconditions.check(new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                for (String method : methodPatternChain) {
                    doAfterVisit(new UsesMethod<>(method, matchOverrides));
                }
                return cu;
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);

                Expression select = m;
                for (MethodMatcher matcher : matchers) {
                    if (!(select instanceof J.MethodInvocation) || !matcher.matches((J.MethodInvocation) select)) {
                        return m;
                    }
                    select = m.getSelect();
                }

                if (select instanceof J.MethodInvocation) {
                    assert m.getMethodType() != null;
                    JavaType.Method mt = m.getMethodType().withName(newMethodName);
                    return m.withSelect(((J.MethodInvocation) select).getSelect())
                            .withName(m.getName().withSimpleName(newMethodName).withType(mt))
                            .withMethodType(mt);
                }

                return m;
            }
        });
    }
}
","{
  ""newMethodName"": ""String field""
}"
Change static field access to static method access,Migrate accesses to a static field to invocations of a static method.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.apache.commons.lang3.StringUtils;
import org.intellij.lang.annotations.Language;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesField;
import org.openrewrite.java.tree.*;

@EqualsAndHashCode(callSuper = false)
@Value
public class ChangeStaticFieldToMethod extends Recipe {

    @Option(displayName = ""Old class name"",
            description = ""The fully qualified name of the class containing the field to replace."",
            example = ""java.util.Collections"")
    String oldClassName;

    @Option(displayName = ""Old field name"",
            description = ""The simple name of the static field to replace."",
            example = ""EMPTY_LIST"")
    String oldFieldName;

    @Option(displayName = ""New class name"",
            description = ""The fully qualified name of the class containing the method to use. Leave empty to keep the same class."",
            example = ""java.util.List"",
            required = false)
    @Nullable
    String newClassName;

    @Option(displayName = ""New field target"",
            description = ""An optional method target that can be used to specify a static field within the new class."",
            example = ""OK_RESPONSE"",
            required = false)
    @Nullable
    String newTarget;

    @Option(displayName = ""New method name"",
            description = ""The simple name of the method to use. The method must be static and have no arguments."",
            example = ""of"")
    String newMethodName;

    @Override
    public String getInstanceNameSuffix() {
        String shortType = oldClassName.substring(oldClassName.lastIndexOf('.') + 1);
        return String.format(""`%s#%s` to `%s`"",
                shortType, oldFieldName, newMethodName);
    }

    @Override
    public String getDisplayName() {
        return ""Change static field access to static method access"";
    }

    @Override
    public String getDescription() {
        return ""Migrate accesses to a static field to invocations of a static method."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesField<>(oldClassName, oldFieldName), new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (TypeUtils.isOfClassType(classDecl.getType(), oldClassName)) {
                    // Don't modify the class that declares the static field being replaced
                    return classDecl;
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }

            @Override
            public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                if (getCursor().firstEnclosing(J.Import.class) == null &&
                        TypeUtils.isOfClassType(fieldAccess.getTarget().getType(), oldClassName) &&
                        fieldAccess.getSimpleName().equals(oldFieldName)) {
                    return useNewMethod(fieldAccess, fieldAccess.getCoordinates().replace());
                }
                return super.visitFieldAccess(fieldAccess, ctx);
            }

            @Override
            public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {
                JavaType.Variable varType = ident.getFieldType();
                if (varType != null &&
                        TypeUtils.isOfClassType(varType.getOwner(), oldClassName) &&
                        varType.getName().equals(oldFieldName)) {
                    return useNewMethod(ident, ident.getCoordinates().replace());
                }
                return ident;
            }

            private J useNewMethod(TypeTree tree, JavaCoordinates coordinates) {
                String newClass = newClassName == null ? oldClassName : newClassName;
                maybeRemoveImport(oldClassName);
                maybeAddImport(newClass);
                return makeNewMethod(newClass).apply(getCursor(), coordinates);
            }

            @NonNull
            private JavaTemplate makeNewMethod(String newClass) {

                String packageName = StringUtils.substringBeforeLast(newClass, ""."");
                String simpleClassName = StringUtils.substringAfterLast(newClass, ""."");

                String methodInvocationTemplate = simpleClassName + (newTarget != null ? ""."" + newTarget + ""."" : ""."") + newMethodName + ""()"";

                @Language(""java"") String methodStub;
                if (newTarget == null) {
                    methodStub = ""package "" + packageName + "";"" +
                                 "" public class "" + simpleClassName + "" {"" +
                                 "" public static void "" + newMethodName + ""() { return null; }"" +
                                 "" }"";
                } else {
                    methodStub = ""package "" + packageName + "";"" +
                                 "" public class Target {"" +
                                 "" public static void "" + newMethodName + ""() { return null; }"" +
                                 "" }"" +
                                 "" public class "" + simpleClassName + "" {public static Target "" + newTarget + "";}"";
                }
                return JavaTemplate
                        .builder(methodInvocationTemplate)
                        .contextSensitive()
                        .javaParser(JavaParser.fromJavaVersion().dependsOn(methodStub))
                        .imports(newClass)
                        .build();
            }
        });
    }
}
","{
  ""oldClassName"": ""String field"",
  ""oldFieldName"": ""String field"",
  ""newMethodName"": ""String field""
}"
Add comment to method invocations,Add a comment to method invocations in a Java source file.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.MethodCall;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.marker.Markers;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddCommentToMethodInvocations extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add comment to method invocations"";
    }

    @Override
    public String getDescription() {
        return ""Add a comment to method invocations in a Java source file."";
    }

    @Option(displayName = ""Comment"",
            description = ""The comment to add."",
            example = ""This is a comment."")
    String comment;

    @Option(displayName = ""Method pattern"",
            description = ""A pattern to match methods to add the comment to. "" + MethodMatcher.METHOD_PATTERN_INVOCATIONS_DESCRIPTION,
            example = ""java.util.List add*(..)"")
    String methodPattern;

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = new MethodMatcher(methodPattern);
        return Preconditions.check(new UsesMethod<>(methodMatcher), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                return handleMethodCallComment(m, ctx);
            }

            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J.NewClass nc = super.visitNewClass(newClass, ctx);
                return handleMethodCallComment(nc, ctx);
            }

            private <T extends MethodCall> T handleMethodCallComment(T t, ExecutionContext ctx) {
                if (methodMatcher.matches(t)) {
                    String prefixWhitespace = t.getPrefix().getWhitespace();
                    String newCommentText = comment.trim()
                            /* First Line * Second Line */
                            .replaceAll(""\\R"", "" * "")
                            // Prevent closing the comment early
                            .replace(""*/"", ""*"");
                    if (doesNotHaveComment(newCommentText, t.getComments())) {
                        TextComment textComment = new TextComment(true, "" "" + newCommentText + "" "", prefixWhitespace, Markers.EMPTY);
                        return t.withComments(ListUtils.concat(t.getComments(), textComment));
                    }
                }
                return t;
            }

            private boolean doesNotHaveComment(String lookFor, List<Comment> comments) {
                for (Comment c : comments) {
                    if (c instanceof TextComment &&
                            lookFor.trim().equals(((TextComment) c).getText().trim())) {
                        return false;
                    }
                }
                return true;
            }
        });
    }
}
","{
  ""comment"": ""String field""
}"
Add comment to import statement,Add a comment to an import statement in a Java source file.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.marker.Markers;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.System.lineSeparator;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddCommentToImport extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add comment to import statement"";
    }

    @Override
    public String getDescription() {
        return ""Add a comment to an import statement in a Java source file."";
    }

    @Option(displayName = ""Comment"",
            description = ""The comment to add."",
            example = ""This is a comment."")
    String comment;

    @Option(displayName = ""Type pattern"",
            description = ""A type pattern that is used to find matching imports uses."",
            example = ""org.springframework..*"")
    String typePattern;

    @Override
    public String getInstanceNameSuffix() {
        return ""matching `"" + typePattern + ""`"";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TypeMatcher typeMatcher = new TypeMatcher(typePattern);
        return new JavaIsoVisitor<ExecutionContext>() {
            private boolean foundImport = false;

            @Override
            public J.Import visitImport(J.Import anImport, ExecutionContext ctx) {
                if (foundImport) {
                    return anImport;
                }
                if (typeMatcher.matchesPackage(anImport.getTypeName())) {
                    foundImport = true;
                    String prefixWhitespace = anImport.getPrefix().getWhitespace();
                    Matcher newlineMatcher = Pattern.compile(""\\R"").matcher(comment.trim());
                    String newCommentText = comment.trim()
                            .replaceAll(""\\R"", prefixWhitespace + "" * "")
                            .replace(""*/"", ""*"");
                    String formattedCommentText = newlineMatcher.find() ? lineSeparator() + "" * "" + newCommentText + lineSeparator() + "" "" : "" "" + newCommentText + "" "";
                    if (doesNotHaveComment(formattedCommentText, anImport.getComments())) {
                        TextComment textComment = new TextComment(true, formattedCommentText, prefixWhitespace, Markers.EMPTY);
                        return autoFormat(anImport.withComments(ListUtils.concat(anImport.getComments(), textComment)), ctx);
                    }
                }
                return super.visitImport(anImport, ctx);
            }

            private boolean doesNotHaveComment(String lookFor, List<Comment> comments) {
                for (Comment c : comments) {
                    if (c instanceof TextComment &&
                            lookFor.trim().equals(((TextComment) c).getText().trim())) {
                        return false;
                    }
                }
                return true;
            }
        };
    }
}
","{
  ""comment"": ""String field"",
  ""typePattern"": ""String field""
}"
Delete method argument,Delete an argument from method invocations.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singletonList;
import static org.openrewrite.Tree.randomId;

/**
 * This recipe finds method invocations matching a method pattern and uses a zero-based argument index to determine
 * which argument is removed.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class DeleteMethodArgument extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""com.yourorg.A foo(int, int)"")
    String methodPattern;

    /**
     * A zero-based index that indicates which argument will be removed from the method invocation.
     */
    @Option(displayName = ""Argument index"",
            description = ""A zero-based index that indicates which argument will be removed from the method invocation."",
            example = ""0"")
    int argumentIndex;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""%d in methods `%s`"", argumentIndex, methodPattern);
    }

    @Override
    public String getDisplayName() {
        return ""Delete method argument"";
    }

    @Override
    public String getDescription() {
        return ""Delete an argument from method invocations."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = new MethodMatcher(methodPattern);
        return Preconditions.check(new UsesMethod<>(methodMatcher), new DeleteMethodArgumentVisitor(methodMatcher));
    }

    @RequiredArgsConstructor
    private class DeleteMethodArgumentVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            return (J.MethodInvocation) visitMethodCall(m);
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass n = super.visitNewClass(newClass, ctx);
            return (J.NewClass) visitMethodCall(n);
        }

        private MethodCall visitMethodCall(MethodCall methodCall) {
            MethodCall m = methodCall;
            List<Expression> originalArgs = m.getArguments();
            if (methodMatcher.matches(m) && originalArgs.stream()
                    .filter(a -> !(a instanceof J.Empty))
                    .count() >= argumentIndex + 1) {
                List<Expression> args = new ArrayList<>(originalArgs);

                Expression removed = args.remove(argumentIndex);
                if (args.isEmpty()) {
                    args = singletonList(new J.Empty(randomId(), Space.EMPTY, Markers.EMPTY));
                } else if (argumentIndex == 0) {
                    args.set(0, args.get(0).withPrefix(removed.getPrefix()));
                }
                m = m.withArguments(args);

                // Remove imports of types used in the removed argument
                new JavaIsoVisitor<Set<String>>() {
                    @Override
                    public @Nullable JavaType visitType(@Nullable JavaType javaType, Set<String> types) {
                        if (javaType instanceof JavaType.Class) {
                            JavaType.Class type = (JavaType.Class) javaType;
                            if (!""java.lang"".equals(type.getPackageName())) {
                                types.add(type.getFullyQualifiedName());
                            }
                        } else if (javaType instanceof JavaType.Variable) {
                            JavaType.Variable variable = (JavaType.Variable) javaType;
                            if (variable.hasFlags(Flag.Static) && variable.getOwner() instanceof JavaType.Class) {
                                JavaType.Class owner = (JavaType.Class) variable.getOwner();
                                types.add(owner.getFullyQualifiedName() + ""."" + variable.getName());
                            }
                        }
                        return super.visitType(javaType, types);
                    }

                    @Override
                    public J.MethodInvocation visitMethodInvocation(J.MethodInvocation mi, Set<String> strings) {
                        if (mi.getMethodType() != null && mi.getMethodType().hasFlags(Flag.Static) && mi.getSelect() == null) {
                            JavaType.FullyQualified receiverType = mi.getMethodType().getDeclaringType();
                            strings.add(receiverType.getFullyQualifiedName() + ""."" + mi.getSimpleName());
                        }
                        return super.visitMethodInvocation(mi, strings);
                    }
                }.reduce(removed, new HashSet<>()).forEach(this::maybeRemoveImport);

                // Update the method types
                JavaType.Method methodType = m.getMethodType();
                if (methodType != null) {
                    List<String> parameterNames = new ArrayList<>(methodType.getParameterNames());
                    parameterNames.remove(argumentIndex);
                    List<JavaType> parameterTypes = new ArrayList<>(methodType.getParameterTypes());
                    parameterTypes.remove(argumentIndex);

                    m = m.withMethodType(methodType
                            .withParameterNames(parameterNames)
                            .withParameterTypes(parameterTypes));
                    if (m instanceof J.MethodInvocation && ((J.MethodInvocation) m).getName().getType() != null) {
                        m = ((J.MethodInvocation) m).withName(((J.MethodInvocation) m).getName().withType(m.getMethodType()));
                    }
                }
            }
            return m;
        }
    }
}
","{
  ""argumentIndex"": ""int field""
}"
Remove interface implementations,Removes `implements` clauses from classes implementing the specified interface. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import static java.util.stream.Collectors.toList;
import static org.openrewrite.java.tree.TypeUtils.isOfClassType;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveImplements extends Recipe {

    private static final AnnotationMatcher OVERRIDE_MATCHER = new AnnotationMatcher(""java.lang.Override"");

    @Override
    public String getDisplayName() {
        return ""Remove interface implementations"";
    }

    @Override
    public String getDescription() {
        return ""Removes `implements` clauses from classes implementing the specified interface. "" +
               ""Removes `@Overrides` annotations from methods which no longer override anything."";
    }

    @Option(displayName = ""Interface type"",
            description = ""The fully qualified name of the interface to remove."",
            example = ""java.io.Serializable"")
    String interfaceType;

    @Option(displayName = ""Filter"",
            description = ""Only apply the interface removal to classes with fully qualified names that begin with this filter. "" +
                          ""`null` or empty matches all classes."",
            example = ""com.yourorg."",
            required = false)
    @Nullable
    String filter;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDeclaration, ExecutionContext ctx) {
                if (!(classDeclaration.getType() instanceof JavaType.Class) || classDeclaration.getImplements() == null) {
                    return super.visitClassDeclaration(classDeclaration, ctx);
                }
                JavaType.Class cdt = (JavaType.Class) classDeclaration.getType();
                if ((filter == null || cdt.getFullyQualifiedName().startsWith(filter)) && cdt.getInterfaces().stream().anyMatch(it -> isOfClassType(it, interfaceType))) {
                    return SearchResult.found(classDeclaration, """");
                }
                return super.visitClassDeclaration(classDeclaration, ctx);
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Nullable
            AnnotationService annotationService;

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration cd, ExecutionContext ctx) {
                if (annotationService == null) {
                     annotationService = service(AnnotationService.class);
                }
                if (!(cd.getType() instanceof JavaType.Class) || cd.getImplements() == null) {
                    return super.visitClassDeclaration(cd, ctx);
                }
                JavaType.Class cdt = (JavaType.Class) cd.getType();
                if ((filter == null || cdt.getFullyQualifiedName().startsWith(filter)) && cdt.getInterfaces().stream().anyMatch(it -> isOfClassType(it, interfaceType))) {
                    cd = cd.withImplements(cd.getImplements().stream()
                            .filter(implement -> !isOfClassType(implement.getType(), interfaceType))
                            .collect(toList()));
                    cdt = cdt.withInterfaces(cdt.getInterfaces().stream()
                            .filter(it -> !isOfClassType(it, interfaceType))
                            .collect(toList()));
                    cd = cd.withType(cdt);
                    maybeRemoveImport(interfaceType);
                    getCursor().putMessage(cdt.getFullyQualifiedName(), cdt);
                }
                return super.visitClassDeclaration(cd, ctx);
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration md, ExecutionContext ctx) {
                if (md.getMethodType() == null) {
                    return super.visitMethodDeclaration(md, ctx);
                }
                Object maybeClassType = getCursor().getNearestMessage(md.getMethodType().getDeclaringType().getFullyQualifiedName());
                if (!(maybeClassType instanceof JavaType.Class)) {
                    return super.visitMethodDeclaration(md, ctx);
                }
                JavaType.Class cdt = (JavaType.Class) maybeClassType;
                JavaType.Method mt = md.getMethodType().withDeclaringType(cdt);
                md = md.withMethodType(mt);
                if (md.getName().getType() != null) {
                    md = md.withName(md.getName().withType(mt));
                }
                updateCursor(md);
                assert annotationService != null;
                if (!annotationService.matches(getCursor(), OVERRIDE_MATCHER) || TypeUtils.isOverride(md.getMethodType())) {
                    return super.visitMethodDeclaration(md, ctx);
                }
                md = (J.MethodDeclaration) new RemoveAnnotation(""@java.lang.Override"").getVisitor().visitNonNull(md, ctx, getCursor().getParentOrThrow());
                return super.visitMethodDeclaration(md, ctx);
            }
        });
    }
}
","{
  ""interfaceType"": ""String field""
}"
Add imports for fully qualified references to types,Any fully qualified references to Java types will be replaced with corresponding simple ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.SourceFile;
import org.openrewrite.Tree;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.internal.DefaultJavaTypeSignatureBuilder;
import org.openrewrite.java.service.ImportService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import static org.openrewrite.java.tree.TypeUtils.isWellFormedType;

public class ShortenFullyQualifiedTypeReferences extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Add imports for fully qualified references to types"";
    }

    @Override
    public String getDescription() {
        return ""Any fully qualified references to Java types will be replaced with corresponding simple "" +
               ""names and import statements, provided that it doesn't result in "" +
               ""any conflicts with other imports or types declared in the local compilation unit."";
    }

    @Override
    public @Nullable Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(2);
    }

    @Override
    public JavaVisitor<ExecutionContext> getVisitor() {
        // This wrapper is necessary so that the ""correct"" implementation is used when this recipe is used declaratively
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    return ((JavaSourceFile) tree).service(ImportService.class).shortenFullyQualifiedTypeReferencesIn((J) tree).visit(tree, ctx);
                }
                return (J) tree;
            }
        };
    }

    /**
     * Returns a visitor which replaces all fully qualified references in the given subtree with simple names and adds
     * corresponding import statements.
     * <p>
     * For compatibility with other Java-based languages it is recommended to use this as a service via
     * {@link ImportService#shortenFullyQualifiedTypeReferencesIn(J)}, as that will dispatch to the correct
     * implementation for the language.
     *
     * @see ImportService#shortenFullyQualifiedTypeReferencesIn(J)
     * @see JavaVisitor#service(Class)
     */
    public static <J2 extends J> JavaVisitor<ExecutionContext> modifyOnly(J2 subtree) {
        return getVisitor(subtree);
    }

    private static JavaVisitor<ExecutionContext> getVisitor(@Nullable J scope) {
        return new JavaVisitor<ExecutionContext>() {
            final Map<String, JavaType> usedTypes = new HashMap<>();
            final JavaTypeSignatureBuilder signatureBuilder = new DefaultJavaTypeSignatureBuilder();

            boolean modify = scope == null;

            private void ensureInitialized() {
                if (!usedTypes.isEmpty()) {
                    return;
                }
                SourceFile sourceFile = getCursor().firstEnclosing(SourceFile.class);
                if (sourceFile instanceof JavaSourceFile) {
                    JavaIsoVisitor<Map<String, JavaType>> typeCollector = new JavaIsoVisitor<Map<String, JavaType>>() {
                        @Override
                        public J.Import visitImport(J.Import import_, Map<String, JavaType> types) {
                            if (!import_.isStatic() && isWellFormedType(import_.getQualid().getType())) {
                                types.put(import_.getQualid().getSimpleName(), import_.getQualid().getType());
                            }
                            return import_;
                        }

                        @Override
                        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Map<String, JavaType> types) {
                            if (fieldAccess.getTarget() instanceof J.Identifier) {
                                visitIdentifier((J.Identifier) fieldAccess.getTarget(), types);
                            } else if (fieldAccess.getTarget() instanceof J.FieldAccess) {
                                visitFieldAccess((J.FieldAccess) fieldAccess.getTarget(), types);
                            }
                            return fieldAccess;
                        }

                        @Override
                        public J.TypeParameter visitTypeParameter(J.TypeParameter typeParam, Map<String, JavaType> types) {
                            // using `null` since we don't have access to the type here
                            types.put(((J.Identifier) typeParam.getName()).getSimpleName(), null);
                            return typeParam;
                        }

                        @Override
                        public J.Identifier visitIdentifier(J.Identifier identifier, Map<String, JavaType> types) {
                            JavaType type = identifier.getType();
                            if (type instanceof JavaType.FullyQualified && identifier.getFieldType() == null) {
                                types.put(identifier.getSimpleName(), type);
                            }
                            return identifier;
                        }
                    };
                    typeCollector.visit(sourceFile, usedTypes);
                }
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                @SuppressWarnings(""DataFlowIssue"")
                boolean subtreeRoot = !modify && (scope.equals(tree) || scope.isScope(tree));
                if (subtreeRoot) {
                    modify = true;
                }
                try {
                    return super.visit(tree, ctx);
                } finally {
                    if (subtreeRoot) {
                        modify = false;
                    }
                }
            }

            @Override
            public J visitImport(J.Import import_, ExecutionContext ctx) {
                // stop recursion
                return import_;
            }

            @Override
            public Space visitSpace(Space space, Space.Location loc, ExecutionContext ctx) {
                // stop recursion into Javadoc comments
                return space;
            }

            @Override
            public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                if (!modify) {
                    return super.visitFieldAccess(fieldAccess, ctx);
                }

                JavaType type = fieldAccess.getType();
                if (fieldAccess.getName().getFieldType() == null && type instanceof JavaType.Class && ((JavaType.Class) type).getOwningClass() == null) {
                    ensureInitialized();

                    String simpleName = fieldAccess.getSimpleName();
                    JavaType usedType = usedTypes.get(simpleName);
                    if (type == usedType || signatureBuilder.signature(type).equals(signatureBuilder.signature(usedType))) {
                        return !fieldAccess.getPrefix().isEmpty() ? fieldAccess.getName().withPrefix(fieldAccess.getPrefix()) : fieldAccess.getName();
                    } else if (!usedTypes.containsKey(simpleName)) {
                        String fullyQualifiedName = ((JavaType.FullyQualified) type).getFullyQualifiedName();
                        if (!fullyQualifiedName.startsWith(""java.lang."")) {
                            maybeAddImport(fullyQualifiedName);
                            usedTypes.put(simpleName, type);
                            if (!fieldAccess.getName().getAnnotations().isEmpty()) {
                                return fieldAccess.getName().withAnnotations(ListUtils.map(fieldAccess.getName().getAnnotations(), (i, a) -> {
                                    if (i == 0) {
                                        return a.withPrefix(fieldAccess.getPrefix());
                                    }
                                    return a;
                                }));
                            }
                            return fieldAccess.getName().withPrefix(fieldAccess.getPrefix());
                        }
                    }
                }
                return super.visitFieldAccess(fieldAccess, ctx);
            }
        };
    }
}
",{}
Replace constant with literal value,Replace a named constant with a literal value when you wish to remove the old constant. A `String` literal must include escaped quotes.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceConstant extends Recipe {
    @Option(displayName = ""Owning type of the constant"",
            description = ""The target type in which the constant to be replaced is defined."",
            example = ""com.google.common.base.Charsets"")
    String owningType;

    @Option(displayName = ""Constant name"",
            description = ""The name of the constant field to replace."",
            example = ""UTF_8"")
    String constantName;

    @Option(displayName = ""Literal value"",
            description = ""The literal value to replace."",
            example = ""UTF_8"")
    String literalValue;

    @Override
    public String getDisplayName() {
        return ""Replace constant with literal value"";
    }

    @Override
    public String getDescription() {
        return ""Replace a named constant with a literal value when you wish to remove the old constant. A `String` literal must include escaped quotes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaVisitor<ExecutionContext> replacementVisitor = new JavaVisitor<ExecutionContext>() {
            J.@Nullable Literal literal;

            @Override
            public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                if (isConstant(fieldAccess.getName().getFieldType())) {
                    maybeRemoveImport(owningType);
                    return buildLiteral().withPrefix(fieldAccess.getPrefix());
                }
                return super.visitFieldAccess(fieldAccess, ctx);
            }

            @Override
            public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {
                if (isConstant(ident.getFieldType()) && !isVariableDeclaration()) {
                    maybeRemoveImport(owningType);
                    return buildLiteral().withPrefix(ident.getPrefix());
                }
                return super.visitIdentifier(ident, ctx);
            }

            private boolean isConstant(JavaType.@Nullable Variable varType) {
                return varType != null && TypeUtils.isOfClassType(varType.getOwner(), owningType) &&
                        varType.getName().equals(constantName);
            }

            private boolean isVariableDeclaration() {
                Cursor maybeVariable = getCursor().dropParentUntil(is -> is instanceof J.VariableDeclarations || is instanceof J.CompilationUnit);
                if (!(maybeVariable.getValue() instanceof J.VariableDeclarations)) {
                    return false;
                }
                JavaType.Variable variableType = ((J.VariableDeclarations) maybeVariable.getValue()).getVariables().get(0).getVariableType();
                if (variableType == null) {
                    return true;
                }

                JavaType.FullyQualified ownerFqn = TypeUtils.asFullyQualified(variableType.getOwner());
                if (ownerFqn == null) {
                    return true;
                }

                return constantName.equals(((J.VariableDeclarations) maybeVariable.getValue()).getVariables().get(0).getSimpleName()) &&
                        owningType.equals(ownerFqn.getFullyQualifiedName());
            }

            private J.Literal buildLiteral() {
                if (literal == null) {
                    JavaParser parser = JavaParser.fromJavaVersion().build();
                    J.CompilationUnit result = parser.parse(""class $ { Object o = "" + literalValue + ""; }"")
                            .findFirst()
                            .map(J.CompilationUnit.class::cast)
                            .orElseThrow(() -> new IllegalStateException(""Expected to have one parsed compilation unit.""));

                    J j = ((J.VariableDeclarations) result.getClasses().get(0).getBody().getStatements().get(0)).getVariables().get(0).getInitializer();
                    if (!(j instanceof J.Literal)) {
                        throw new IllegalArgumentException(""Unknown literal type for literal value: "" + literalValue);
                    }

                    J.Literal parsedLiteral = (J.Literal) j;
                    literal = parsedLiteral.withId(Tree.randomId());
                }
                return literal;
            }
        };
        return Preconditions.check(
                new UsesType<>(owningType, true),
                replacementVisitor
        );
    }
}
","{
  ""owningType"": ""String field"",
  ""constantName"": ""String field"",
  ""literalValue"": ""String field""
}"
Change method invocation return type,Changes the return type of a method invocation.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.Markers;

import static java.util.Collections.emptyList;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeMethodInvocationReturnType extends Recipe {

    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""org.mockito.Matchers anyVararg()"")
    String methodPattern;

    @Option(displayName = ""New method invocation return type"",
            description = ""The fully qualified new return type of method invocation."",
            example = ""long"")
    String newReturnType;

    @Override
    public String getDisplayName() {
        return ""Change method invocation return type"";
    }

    @Override
    public String getDescription() {
        return ""Changes the return type of a method invocation."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            private final MethodMatcher methodMatcher = new MethodMatcher(methodPattern, false);

            private boolean methodUpdated;

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                JavaType.Method type = m.getMethodType();
                if (methodMatcher.matches(method) && type != null && !newReturnType.equals(type.getReturnType().toString())) {
                    type = type.withReturnType(JavaType.buildType(newReturnType));
                    m = m.withMethodType(type);
                    if (m.getName().getType() != null) {
                        m = m.withName(m.getName().withType(type));
                    }
                    methodUpdated = true;
                }
                return m;
            }

            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                methodUpdated = false;
                JavaType.FullyQualified originalType = multiVariable.getTypeAsFullyQualified();
                J.VariableDeclarations mv = super.visitVariableDeclarations(multiVariable, ctx);

                if (methodUpdated) {
                    JavaType newType = JavaType.buildType(newReturnType);
                    JavaType.FullyQualified newFieldType = TypeUtils.asFullyQualified(newType);

                    maybeAddImport(newFieldType);
                    maybeRemoveImport(originalType);

                    mv = mv.withTypeExpression(mv.getTypeExpression() == null ?
                            null :
                            new J.Identifier(mv.getTypeExpression().getId(),
                                    mv.getTypeExpression().getPrefix(),
                                    Markers.EMPTY,
                                    emptyList(),
                                    newReturnType.substring(newReturnType.lastIndexOf('.') + 1),
                                    newType,
                                    null
                            )
                    );

                    mv = mv.withVariables(ListUtils.map(mv.getVariables(), var -> {
                        JavaType.FullyQualified varType = TypeUtils.asFullyQualified(var.getType());
                        if (varType != null && !varType.equals(newType)) {
                            return var.withType(newType).withName(var.getName().withType(newType));
                        }
                        return var;
                    }));
                }

                return mv;
            }
        };
    }
}
","{
  ""newReturnType"": ""String field""
}"
Rename package name,"A recipe that will rename a package name in package statements, imports, and fully-qualified types.",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.trait.Reference;

import java.nio.file.Paths;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;

import static java.util.Objects.requireNonNull;

/**
 * A recipe that will rename a package name in package statements, imports, and fully-qualified types (see: NOTE).
 * <p>
 * NOTE: Does not currently transform all possible type references, and accomplishing this would be non-trivial.
 * For example, a method invocation select might refer to field `A a` whose type has now changed to `A2`, and so the type
 * on the select should change as well. But how do we identify the set of all method selects which refer to `a`? Suppose
 * it were prefixed like `this.a`, or `MyClass.this.a`, or indirectly via a separate method call like `getA()` where `getA()`
 * is defined on the super class.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePackage extends Recipe {
    @Option(displayName = ""Old package name"",
            description = ""The package name to replace."",
            example = ""com.yourorg.foo"")
    String oldPackageName;

    @Option(displayName = ""New package name"",
            description = ""New package name to replace the old package name with."",
            example = ""com.yourorg.bar"")
    String newPackageName;

    @With
    @Option(displayName = ""Recursive"",
            description = ""Recursively change subpackage names"",
            required = false)
    @Nullable
    Boolean recursive;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldPackageName, newPackageName);
    }

    @Override
    public String getDisplayName() {
        return ""Rename package name"";
    }

    @Override
    public String getDescription() {
        return ""A recipe that will rename a package name in package statements, imports, and fully-qualified types."";
    }

    @Override
    public Validated<Object> validate() {
        return Validated.none()
                .and(Validated.notBlank(""oldPackageName"", oldPackageName))
                .and(Validated.required(""newPackageName"", newPackageName));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> condition = new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree preVisit(@Nullable Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) tree;
                    if (cu.getPackageDeclaration() != null) {
                        String original = cu.getPackageDeclaration().getExpression()
                                .printTrimmed(getCursor()).replaceAll(""\\s"", """");
                        if (original.startsWith(oldPackageName)) {
                            return SearchResult.found(cu);
                        }
                    }
                    boolean recursive = Boolean.TRUE.equals(ChangePackage.this.recursive);
                    String recursivePackageNamePrefix = oldPackageName + ""."";
                    for (J.Import anImport : cu.getImports()) {
                        String importedPackage = anImport.getPackageName();
                        if (importedPackage.equals(oldPackageName) || recursive && importedPackage.startsWith(recursivePackageNamePrefix)) {
                            return SearchResult.found(cu);
                        }
                    }
                    for (JavaType type : cu.getTypesInUse().getTypesInUse()) {
                        if (type instanceof JavaType.FullyQualified) {
                            String packageName = ((JavaType.FullyQualified) type).getPackageName();
                            if (packageName.equals(oldPackageName) || recursive && packageName.startsWith(recursivePackageNamePrefix)) {
                                return SearchResult.found(cu);
                            }
                        }
                    }
                } else if (tree instanceof SourceFileWithReferences) {
                    SourceFileWithReferences cu = (SourceFileWithReferences) tree;
                    boolean recursive = Boolean.TRUE.equals(ChangePackage.this.recursive);
                    String recursivePackageNamePrefix = oldPackageName + ""."";
                    for (Reference ref : cu.getReferences().getReferences()) {
                        if (ref.getValue().equals(oldPackageName) || recursive && ref.getValue().startsWith(recursivePackageNamePrefix)) {
                            return SearchResult.found(cu);
                        }
                    }
                }
                return tree;
            }
        };

        return Preconditions.check(condition, new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof JavaSourceFile || sourceFile instanceof SourceFileWithReferences;
            }

            @Override
            public @Nullable Tree preVisit(@Nullable Tree tree, ExecutionContext ctx) {
                stopAfterPreVisit();
                if (tree instanceof JavaSourceFile) {
                    return new JavaChangePackageVisitor().visit(tree, ctx, requireNonNull(getCursor().getParent()));
                } else if (tree instanceof SourceFileWithReferences) {
                    SourceFileWithReferences sourceFile = (SourceFileWithReferences) tree;
                    SourceFileWithReferences.References references = sourceFile.getReferences();
                    boolean recursive = Boolean.TRUE.equals(ChangePackage.this.recursive);
                    PackageMatcher matcher = new PackageMatcher(oldPackageName, recursive);
                    Map<Tree, Reference> matches = new HashMap<>();
                    for (Reference ref : references.findMatches(matcher)) {
                        matches.put(ref.getTree(), ref);
                    }
                    return new ReferenceChangePackageVisitor(matches, matcher.createRenamer(newPackageName)).visit(tree, ctx, requireNonNull(getCursor().getParent()));
                }
                return tree;
            }
        });
    }

    private class JavaChangePackageVisitor extends JavaVisitor<ExecutionContext> {
        private static final String RENAME_TO_KEY = ""renameTo"";
        private static final String RENAME_FROM_KEY = ""renameFrom"";

        private final Map<JavaType, JavaType> oldNameToChangedType = new IdentityHashMap<>();
        private final JavaType.Class newPackageType = JavaType.ShallowClass.build(newPackageName);

        @Override
        public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J f = super.visitFieldAccess(fieldAccess, ctx);

            if (((J.FieldAccess) f).isFullyQualifiedClassReference(oldPackageName)) {
                Cursor parent = getCursor().getParent();
                if (parent != null &&
                    // Ensure the parent isn't a J.FieldAccess OR the parent doesn't match the target package name.
                    (!(parent.getValue() instanceof J.FieldAccess) ||
                     (!(((J.FieldAccess) parent.getValue()).isFullyQualifiedClassReference(newPackageName))))) {

                    f = TypeTree.build(((JavaType.FullyQualified) newPackageType).getFullyQualifiedName())
                            .withPrefix(f.getPrefix());
                }
            }
            return f;
        }

        @Override
        public J visitPackage(J.Package pkg, ExecutionContext ctx) {
            String original = pkg.getExpression().printTrimmed(getCursor()).replaceAll(""\\s"", """");
            getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, RENAME_FROM_KEY, original);

            pkg = pkg.withAnnotations(ListUtils.map(pkg.getAnnotations(), a -> visitAndCast(a, ctx)));

            if (original.equals(oldPackageName)) {
                getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, RENAME_TO_KEY, newPackageName);

                if (!newPackageName.isEmpty()) {
                    pkg = JavaTemplate.builder(newPackageName).contextSensitive().build().apply(getCursor(), pkg.getCoordinates().replace());
                } else {
                    // Covers unlikely scenario where the package is removed.
                    getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, ""UPDATE_PREFIX"", true);
                    pkg = null;
                }
            } else if (isTargetRecursivePackageName(original)) {
                String changingTo = getNewPackageName(original);
                getCursor().putMessageOnFirstEnclosing(JavaSourceFile.class, RENAME_TO_KEY, changingTo);
                pkg = JavaTemplate.builder(changingTo)
                        .contextSensitive()
                        .build()
                        .apply(getCursor(), pkg.getCoordinates().replace());
            }
            //noinspection ConstantConditions
            return pkg;
        }

        @Override
        public J visitImport(J.Import _import, ExecutionContext ctx) {
            // Polls message before calling super to change the prefix of the first import if applicable.
            Boolean updatePrefix = getCursor().pollNearestMessage(""UPDATE_PREFIX"");
            if (updatePrefix != null && updatePrefix) {
                _import = _import.withPrefix(Space.EMPTY);
            }
            return super.visitImport(_import, ctx);
        }

        @Override
        public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J c = super.visitClassDeclaration(classDecl, ctx);

            Boolean updatePrefix = getCursor().pollNearestMessage(""UPDATE_PREFIX"");
            if (updatePrefix != null && updatePrefix) {
                c = c.withPrefix(Space.EMPTY);
            }
            return c;
        }

        @Override
        public @Nullable JavaType visitType(@Nullable JavaType javaType, ExecutionContext ctx) {
            return updateType(javaType);
        }

        @Override
        public J postVisit(J tree, ExecutionContext ctx) {
            J j = super.postVisit(tree, ctx);
            if (j instanceof J.MethodDeclaration) {
                J.MethodDeclaration m = (J.MethodDeclaration) j;
                JavaType.Method mt = updateType(m.getMethodType());
                return m.withMethodType(mt).withName(m.getName().withType(mt));
            } else if (j instanceof J.MethodInvocation) {
                J.MethodInvocation m = (J.MethodInvocation) j;
                JavaType.Method mt = updateType(m.getMethodType());
                return m.withMethodType(mt).withName(m.getName().withType(mt));
            } else if (j instanceof J.NewClass) {
                J.NewClass n = (J.NewClass) j;
                return n.withConstructorType(updateType(n.getConstructorType()));
            } else if (j instanceof TypedTree) {
                return ((TypedTree) j).withType(updateType(((TypedTree) j).getType()));
            } else if (j instanceof JavaSourceFile) {
                JavaSourceFile sf = (JavaSourceFile) j;

                String changingTo = getCursor().getNearestMessage(RENAME_TO_KEY);
                if (changingTo != null) {
                    String path = ((SourceFile) sf).getSourcePath().toString().replace('\\', '/');
                    String changingFrom = getCursor().getMessage(RENAME_FROM_KEY);
                    assert changingFrom != null;
                    sf = ((SourceFile) sf).withSourcePath(Paths.get(path.replaceFirst(
                            changingFrom.replace('.', '/'),
                            changingTo.replace('.', '/')
                    )));

                    for (J.Import anImport : sf.getImports()) {
                        if (anImport.getPackageName().equals(changingTo) && !anImport.isStatic()) {
                            sf = (JavaSourceFile) new RemoveImport<ExecutionContext>(anImport.getTypeName(), true)
                                    .visitNonNull(sf, ctx, getCursor().getParentTreeCursor());
                        }
                    }
                }

                j = sf;
            }
            //noinspection DataFlowIssue
            return j;
        }

        private @Nullable JavaType updateType(@Nullable JavaType oldType) {
            if (oldType == null || oldType instanceof JavaType.Unknown) {
                return oldType;
            }

            JavaType type = oldNameToChangedType.get(oldType);
            if (type != null) {
                return type;
            }

            if (oldType instanceof JavaType.Parameterized) {
                JavaType.Parameterized pt = (JavaType.Parameterized) oldType;
                pt = pt.withTypeParameters(ListUtils.map(pt.getTypeParameters(), tp -> {
                    if (tp instanceof JavaType.FullyQualified) {
                        JavaType.FullyQualified tpFq = (JavaType.FullyQualified) tp;
                        if (isTargetFullyQualifiedType(tpFq)) {
                            return updateType(tpFq);
                        }
                    }
                    return tp;
                }));

                if (isTargetFullyQualifiedType(pt)) {
                    //noinspection DataFlowIssue
                    pt = pt.withType((JavaType.FullyQualified) updateType(pt.getType()));
                }

                oldNameToChangedType.put(oldType, pt);
                return pt;
            } else if (oldType instanceof JavaType.FullyQualified) {
                JavaType.FullyQualified original = TypeUtils.asFullyQualified(oldType);
                if (isTargetFullyQualifiedType(original)) {
                    JavaType.FullyQualified fq = TypeUtils.asFullyQualified(JavaType.buildType(getNewPackageName(original.getPackageName()) + ""."" + original.getClassName()));
                    //noinspection DataFlowIssue
                    oldNameToChangedType.put(oldType, fq);
                    oldNameToChangedType.put(fq, fq);
                    return fq;
                }
            } else if (oldType instanceof JavaType.GenericTypeVariable) {
                JavaType.GenericTypeVariable gtv = (JavaType.GenericTypeVariable) oldType;
                gtv = gtv.withBounds(ListUtils.map(gtv.getBounds(), b -> {
                    if (b instanceof JavaType.FullyQualified && isTargetFullyQualifiedType((JavaType.FullyQualified) b)) {
                        return updateType(b);
                    }
                    return b;
                }));

                oldNameToChangedType.put(oldType, gtv);
                oldNameToChangedType.put(gtv, gtv);
                return gtv;
            } else if (oldType instanceof JavaType.Variable) {
                JavaType.Variable variable = (JavaType.Variable) oldType;
                variable = variable.withOwner(updateType(variable.getOwner()));
                //noinspection DataFlowIssue
                variable = variable.withType(updateType(variable.getType()));
                oldNameToChangedType.put(oldType, variable);
                oldNameToChangedType.put(variable, variable);
                return variable;
            } else if (oldType instanceof JavaType.Array) {
                JavaType.Array array = (JavaType.Array) oldType;
                //noinspection DataFlowIssue
                array = array.withElemType(updateType(array.getElemType()));
                oldNameToChangedType.put(oldType, array);
                oldNameToChangedType.put(array, array);
                return array;
            }
            return oldType;
        }

        private JavaType.@Nullable Method updateType(JavaType.@Nullable Method oldMethodType) {
            if (oldMethodType != null) {
                JavaType.Method method = (JavaType.Method) oldNameToChangedType.get(oldMethodType);
                if (method != null) {
                    return method;
                }

                method = oldMethodType;
                //noinspection DataFlowIssue
                method = method.withDeclaringType((JavaType.FullyQualified) updateType(method.getDeclaringType()))
                        .withReturnType(updateType(method.getReturnType()))
                        .withParameterTypes(ListUtils.map(method.getParameterTypes(), this::updateType));
                oldNameToChangedType.put(oldMethodType, method);
                oldNameToChangedType.put(method, method);
                return method;
            }
            return null;
        }

        private String getNewPackageName(String packageName) {
            return (recursive == null || recursive) && !newPackageName.endsWith(packageName.substring(oldPackageName.length())) ?
                    newPackageName + packageName.substring(oldPackageName.length()) : newPackageName;
        }

        private boolean isTargetFullyQualifiedType(JavaType.@Nullable FullyQualified fq) {
            return fq != null &&
                   (fq.getPackageName().equals(oldPackageName) && !fq.getClassName().isEmpty() ||
                    isTargetRecursivePackageName(fq.getPackageName()));
        }

        private boolean isTargetRecursivePackageName(String packageName) {
            return (recursive == null || recursive) &&
                   packageName.startsWith(oldPackageName + ""."") &&
                   !packageName.startsWith(newPackageName);
        }

    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class ReferenceChangePackageVisitor extends TreeVisitor<Tree, ExecutionContext> {
        Map<Tree, Reference> matches;
        Reference.Renamer renamer;

        @Override
        public Tree postVisit(Tree tree, ExecutionContext ctx) {
            Reference reference = matches.get(tree);
            if (reference != null && reference.supportsRename()) {
                return reference.rename(renamer, getCursor(), ctx);
            }
            return tree;
        }
    }

}
","{
  ""oldPackageName"": ""String field"",
  ""newPackageName"": ""String field""
}"
Remove static import,"Removes static imports and replaces them with qualified references. For example, `emptyList()` becomes `Collections.emptyList()`.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.*;
import lombok.experimental.FieldDefaults;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;

import static java.util.Collections.emptyList;

@ToString
@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
@Getter
@RequiredArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class NoStaticImport extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.util.Collections emptyList()"")
    String methodPattern;

    @Override
    public String getDisplayName() {
        return ""Remove static import"";
    }

    @Override
    public String getDescription() {
        return ""Removes static imports and replaces them with qualified references. For example, `emptyList()` becomes `Collections.emptyList()`."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(methodPattern), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                MethodMatcher methodMatcher = new MethodMatcher(methodPattern);
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (methodMatcher.matches(m) && m.getSelect() == null && m.getMethodType() != null) {
                    // Do not replace calls to super() in constructors
                    if (""super"".equals(m.getName().getSimpleName())) {
                        return m;
                    }

                    JavaType.FullyQualified receiverType = m.getMethodType().getDeclaringType();
                    RemoveImport<ExecutionContext> op = new RemoveImport<>(receiverType.getFullyQualifiedName() + ""."" + method.getSimpleName(), true);
                    if (!getAfterVisit().contains(op)) {
                        doAfterVisit(op);
                    }

                    J.ClassDeclaration enclosingClass = getCursor().firstEnclosing(J.ClassDeclaration.class);
                    // Do not replace if method is in java.lang.Object
                    if (""java.lang.Object"".equals(receiverType.getFullyQualifiedName()) ||
                            // Do not replace when we can not determine the enclosing class, such as in build.gradle files
                            enclosingClass == null || enclosingClass.getType() == null ||
                            // Do not replace if receiverType is the same as surrounding class
                            enclosingClass.getType().equals(receiverType) ||
                            // Do not replace if method is in a wrapping outer class; not looking up more than one level
                            enclosingClass.getType().getOwningClass() != null && enclosingClass.getType().getOwningClass().equals(receiverType) ||
                            // Do not replace if class extends receiverType
                            enclosingClass.getType().getSupertype() != null && enclosingClass.getType().getSupertype().equals(receiverType)

                    ) {
                        return m;
                    }

                    // Change method invocation to use fully qualified name
                    maybeAddImport(receiverType.getFullyQualifiedName());
                    m = m.withSelect(new J.Identifier(Tree.randomId(),
                            Space.EMPTY,
                            Markers.EMPTY,
                            emptyList(),
                            receiverType.getClassName(),
                            receiverType,
                            null));
                }
                return m;
            }
        });
    }
}
",{}
Change annotation attribute name,Some annotations accept arguments. This recipe renames an existing attribute.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JLeftPadded;
import org.openrewrite.marker.Markers;

import static java.util.Collections.emptyList;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.tree.Space.EMPTY;
import static org.openrewrite.java.tree.Space.SINGLE_SPACE;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeAnnotationAttributeName extends Recipe {

    @Option(displayName = ""Annotation Type"",
            description = ""The fully qualified name of the annotation."",
            example = ""org.junit.Test"")
    String annotationType;

    @Option(displayName = ""Old attribute name"",
            description = ""The name of attribute to change."",
            example = ""timeout"")
    String oldAttributeName;

    @Option(displayName = ""New attribute name"",
            description = ""The new attribute name to use."",
            example = ""waitFor"")
    String newAttributeName;

    @Override
    public String getDisplayName() {
        return ""Change annotation attribute name"";
    }

    @Override
    public String getInstanceNameSuffix() {
        String shortType = annotationType.substring(annotationType.lastIndexOf('.') + 1);
        return String.format(""`@%s(%s)` to `@%s(%s)`"",
                shortType, oldAttributeName,
                shortType, newAttributeName);
    }

    @Override
    public String getDescription() {
        return ""Some annotations accept arguments. This recipe renames an existing attribute."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(annotationType, false), new JavaIsoVisitor<ExecutionContext>() {
            private final AnnotationMatcher annotationMatcher = new AnnotationMatcher('@' + annotationType);

            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                J.Annotation a = super.visitAnnotation(annotation, ctx);
                if (!annotationMatcher.matches(a)) {
                    return a;
                }
                return a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                    if (arg instanceof J.Assignment) {
                        if (!oldAttributeName.equals(newAttributeName)) {
                            J.Assignment assignment = (J.Assignment) arg;
                            J.Identifier variable = (J.Identifier) assignment.getVariable();
                            if (oldAttributeName.equals(variable.getSimpleName())) {
                                return assignment.withVariable(variable.withSimpleName(newAttributeName));
                            }
                        }
                    } else if (""value"".equals(oldAttributeName) && !(arg instanceof J.Empty)) {
                        J.Identifier name = new J.Identifier(randomId(), arg.getPrefix(), Markers.EMPTY, emptyList(), newAttributeName, arg.getType(), null);
                        return new J.Assignment(randomId(), EMPTY, arg.getMarkers(), name, new JLeftPadded<>(SINGLE_SPACE, arg.withPrefix(SINGLE_SPACE), Markers.EMPTY), arg.getType());
                    }
                    return arg;
                }));
            }
        });
    }
}
","{
  ""annotationType"": ""String field"",
  ""oldAttributeName"": ""String field"",
  ""newAttributeName"": ""String field""
}"
Add a `null` method argument,Add a `null` argument to method invocations.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.ArrayList;
import java.util.List;

import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.tree.Space.EMPTY;

/**
 * This recipe finds method invocations matching a method pattern and uses a zero-based argument index to determine
 * which argument is added with a null value.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class AddNullMethodArgument extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""com.yourorg.A foo(int, int)"")
    String methodPattern;

    /**
     * A zero-based index that indicates which argument will be added as null to the method invocation.
     */
    @Option(displayName = ""Argument index"",
            description = ""A zero-based index that indicates which argument will be added as null to the method invocation."",
            example = ""0"")
    int argumentIndex;

    @Option(displayName = ""Parameter type"",
            description = ""The type of the parameter that we add the argument for."",
            example = ""java.lang.String"")
    String parameterType;

    @Option(displayName = ""Parameter name"",
            description = ""The name of the parameter that we add the argument for."",
            required = false,
            example = ""name"")
    @Nullable String parameterName;

    @Option(displayName = ""Explicit cast"",
            description = ""Explicitly cast the argument to the parameter type. Useful if the method is overridden with another type."",
            required = false,
            example = ""true"")
    @Nullable Boolean explicitCast;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""%d in methods `%s`"", argumentIndex, methodPattern);
    }

    @Override
    public String getDisplayName() {
        return ""Add a `null` method argument"";
    }

    @Override
    public String getDescription() {
        return ""Add a `null` argument to method invocations."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(methodPattern), new AddNullMethodArgumentVisitor(new MethodMatcher(methodPattern)));
    }

    private class AddNullMethodArgumentVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;

        public AddNullMethodArgumentVisitor(MethodMatcher methodMatcher) {
            this.methodMatcher = methodMatcher;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            return (J.MethodInvocation) visitMethodCall(m);
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass n = super.visitNewClass(newClass, ctx);
            return (J.NewClass) visitMethodCall(n);
        }

        private MethodCall visitMethodCall(MethodCall methodCall) {
            MethodCall m = methodCall;
            List<Expression> originalArgs = m.getArguments();
            if (methodMatcher.matches(m) && (long) originalArgs.size() >= argumentIndex) {
                List<Expression> args = new ArrayList<>(originalArgs);

                if (args.size() == 1 && args.get(0) instanceof J.Empty) {
                    args.remove(0);
                }

                Expression nullLiteral = new J.Literal(randomId(), args.isEmpty() ? Space.EMPTY : Space.SINGLE_SPACE, Markers.EMPTY, ""null"", ""null"", null, JavaType.Primitive.Null);
                if (explicitCast == Boolean.TRUE) {
                    nullLiteral = new J.TypeCast(randomId(), Space.SINGLE_SPACE, Markers.EMPTY,
                            new J.ControlParentheses<>(randomId(), EMPTY, Markers.EMPTY,
                                    new JRightPadded<>(TypeTree.build(parameterType), EMPTY, Markers.EMPTY)),
                            nullLiteral);
                }
                m = m.withArguments(ListUtils.insert(args, nullLiteral, argumentIndex));

                JavaType.Method methodType = m.getMethodType();
                if (methodType != null) {
                    m = m.withMethodType(methodType
                            .withParameterNames(ListUtils.insert(methodType.getParameterNames(),
                                    parameterName == null ? ""arg"" + argumentIndex : parameterName, argumentIndex))
                            .withParameterTypes(ListUtils.insert(methodType.getParameterTypes(),
                                    JavaType.buildType(parameterType), argumentIndex)));
                    if (m instanceof J.MethodInvocation && ((J.MethodInvocation) m).getName().getType() != null) {
                        m = ((J.MethodInvocation) m).withName(((J.MethodInvocation) m).getName().withType(m.getMethodType()));
                    }
                }
            }
            return m;
        }

    }
}
","{
  ""argumentIndex"": ""int field"",
  ""parameterType"": ""String field""
}"
Add license header,Adds license headers to Java source files when missing. Does not override existing license headers.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.PropertyPlaceholderHelper;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.marker.Markers;

import java.util.Calendar;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddLicenseHeader extends Recipe {
    /**
     * A method pattern that is used to find matching method declarations/invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""License text"",
            description = ""The license header text without the block comment. May contain ${CURRENT_YEAR} property."",
            example = ""Copyright ${CURRENT_YEAR} the original author or authors..."")
    String licenseText;

    @Override
    public String getDisplayName() {
        return ""Add license header"";
    }

    @Override
    public String getDescription() {
        return ""Adds license headers to Java source files when missing. Does not override existing license headers."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    if (cu.getComments().isEmpty()) {
                        PropertyPlaceholderHelper propertyPlaceholderHelper = new PropertyPlaceholderHelper(""${"", ""}"", null);
                        String formattedLicenseText = ""\n * "" + propertyPlaceholderHelper.replacePlaceholders(licenseText,
                                k -> {
                                    if (""CURRENT_YEAR"".equals(k)) {
                                        return Integer.toString(Calendar.getInstance().get(Calendar.YEAR));
                                    }
                                    return System.getProperty(k);
                                }).replace(""\n"", ""\n * "") + ""\n "";

                        cu = cu.withComments(singletonList(
                                new TextComment(true, formattedLicenseText, ""\n"", Markers.EMPTY)
                        ));
                    }
                    return super.visit(cu, ctx);
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J.Import visitImport(J.Import _import, ExecutionContext ctx) {
                // short circuit everything else
                return _import;
            }

            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                // short circuit everything else
                return classDecl;
            }
        };
    }
}
","{
  ""licenseText"": ""String field""
}"
Use static import,"Removes unnecessary receiver types from static method invocations. For example, `Collections.emptyList()` becomes `emptyList()`.",Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.*;
import lombok.experimental.FieldDefaults;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Flag;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Javadoc;

@ToString
@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)
@Getter
@RequiredArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class UseStaticImport extends Recipe {

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.util.Collections emptyList()"")
    String methodPattern;

    @Override
    public String getDisplayName() {
        return ""Use static import"";
    }

    @Override
    public String getDescription() {
        return ""Removes unnecessary receiver types from static method invocations. For example, `Collections.emptyList()` becomes `emptyList()`."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TreeVisitor<?, ExecutionContext> preconditions = new UsesMethod<>(methodPattern);
        if (!methodPattern.contains("" *("")) {
            int indexSpace = Math.max(methodPattern.indexOf(' '), methodPattern.indexOf('#'));
            int indexBrace = methodPattern.indexOf('(', indexSpace);
            String methodNameMatcher = methodPattern.substring(indexSpace, indexBrace);
            preconditions = Preconditions.and(preconditions,
                    Preconditions.not(new DeclaresMethod<>(""*..* "" + methodNameMatcher + ""(..)"")));
        }
        return Preconditions.check(preconditions, new UseStaticImportVisitor());
    }

    private class UseStaticImportVisitor extends JavaIsoVisitor<ExecutionContext> {
        final MethodMatcher methodMatcher = new MethodMatcher(methodPattern);

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (methodMatcher.matches(m)) {
                if (m.getTypeParameters() != null && !m.getTypeParameters().isEmpty()) {
                    return m;
                }

                if (m.getMethodType() == null ||
                        !m.getMethodType().hasFlags(Flag.Static) ||
                        hasConflictingImport(m.getMethodType().getDeclaringType().getFullyQualifiedName(), m.getSimpleName(), getCursor()) ||
                        hasConflictingMethod(m.getSimpleName(), getCursor())) {
                    return m;
                }

                JavaType.FullyQualified receiverType = m.getMethodType().getDeclaringType();
                maybeRemoveImport(receiverType);
                maybeAddImport(receiverType.getFullyQualifiedName(), m.getSimpleName(), false);

                if (m.getSelect() != null) {
                    return m.withSelect(null).withName(m.getName().withPrefix(m.getSelect().getPrefix()));
                }
            }
            return m;
        }

        @Override
        protected JavadocVisitor<ExecutionContext> getJavadocVisitor() {
            return new JavadocVisitor<ExecutionContext>(this) {
                /**
                 * Do not visit the method referenced from the Javadoc.
                 * Otherwise, the Javadoc method reference would eventually be refactored to static import, which is not valid for Javadoc.
                 */
                @Override
                public Javadoc visitReference(Javadoc.Reference reference, ExecutionContext ctx) {
                    return reference;
                }
            };
        }
    }

    private static boolean hasConflictingImport(String typeName, String methodName, Cursor cursor) {
        J.CompilationUnit cu = cursor.firstEnclosing(J.CompilationUnit.class);
        if (cu != null) {
            for (J.Import imp : cu.getImports()) {
                if (imp.isStatic() &&
                        methodName.equals(imp.getQualid().getSimpleName()) &&
                        !typeName.equals(imp.getTypeName())) {
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean hasConflictingMethod(String methodName, Cursor cursor) {
        Cursor cdCursor = cursor.dropParentUntil(it -> it instanceof J.ClassDeclaration || it == Cursor.ROOT_VALUE);
        Object maybeCd = cdCursor.getValue();
        if (!(maybeCd instanceof J.ClassDeclaration)) {
            return false;
        }
        return hasConflictingMethod(methodName, ((J.ClassDeclaration) maybeCd).getType()) ||
                hasConflictingMethod(methodName, cdCursor);
    }

    private static boolean hasConflictingMethod(String methodName, JavaType.@Nullable FullyQualified ct) {
        if (ct == null) {
            return false;
        }
        for (JavaType.Method method : ct.getMethods()) {
            if (method.getName().equals(methodName)) {
                return true;
            }
        }
        if (hasConflictingMethod(methodName, ct.getSupertype())) {
            return true;
        }
        for (JavaType.FullyQualified intf : ct.getInterfaces()) {
            if (hasConflictingMethod(methodName, intf)) {
                return true;
            }
        }
        return false;
    }
}
",{}
Simplify single-element annotation,This recipe will remove the attribute `value` on single-element annotations. ,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;

import java.util.List;

public class SimplifySingleElementAnnotation extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Simplify single-element annotation"";
    }

    @Override
    public String getDescription() {
        return ""This recipe will remove the attribute `value` on single-element annotations. "" +
                ""According to JLS, a _single-element annotation_, is a shorthand designed for use with single-element annotation types."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new SimplifySingleElementAnnotationVisitor(null);
    }

    public static <J2 extends J> TreeVisitor<?, ExecutionContext> modifyOnly(J2 scope) {
        return new SimplifySingleElementAnnotationVisitor(scope);
    }

    @Value
    private static class SimplifySingleElementAnnotationVisitor extends JavaIsoVisitor<ExecutionContext> {
        @Nullable
        J scope;

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext executionContext) {
            J.Annotation an = super.visitAnnotation(annotation, executionContext);
            if (an.getArguments() != null &&
                    an.getArguments().size() == 1 &&
                    (scope == null || an.equals(scope))) {
                return an.withArguments(ListUtils.mapFirst(an.getArguments(), v -> {
                    if (v instanceof J.Assignment &&
                            ((J.Assignment) v).getVariable() instanceof J.Identifier &&
                            ""value"".equals(((J.Identifier) ((J.Assignment) v).getVariable()).getSimpleName())) {
                        Expression assignment = ((J.Assignment) v).getAssignment();
                        if (assignment instanceof J.NewArray) {
                            J.NewArray na = (J.NewArray) assignment;
                            List<Expression> initializer = na.getInitializer();
                            if (initializer != null && initializer.size() == 1 && !(initializer.get(0) instanceof J.Empty)) {
                                return initializer.get(0).withPrefix(Space.EMPTY);
                            }
                        }
                        return assignment.withPrefix(Space.EMPTY);
                    }
                    return v;
                }));
            }
            return an;
        }
    }
}
",{}
Demonstrate rendering of `Markup` markers,Tooling may decide to elide or display differently markup of different levels.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.Markup;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class RecipeMarkupDemonstration extends Recipe {

    @Option(displayName = ""Level"",
            description = ""The `Markup#Level` to add."",
            valid = {""debug"", ""info"", ""warning"", ""error""})
    String level;

    @Override
    public String getDisplayName() {
        return ""Demonstrate rendering of `Markup` markers"";
    }

    @Override
    public String getDescription() {
        return ""Tooling may decide to elide or display differently markup of different levels."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                SourceFile sourceFile = (SourceFile) requireNonNull(tree);
                switch (level) {
                    case ""info"":
                        return Markup.info(sourceFile, ""This is an info message."");
                    case ""warning"":
                        return Markup.warn(sourceFile, new IllegalStateException(""This is a warning message.""));
                    case ""error"":
                        return Markup.error(sourceFile, new IllegalStateException(""This is an error message.""));
                    case ""debug"":
                    default:
                        return Markup.debug(sourceFile, ""This is a debug message."");
                }
            }
        };
    }
}
","{
  ""level"": ""String field""
}"
Replace String literal with constant,"Replace String literal with constant, adding import on class if needed.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.experimental.NonFinal;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;

import java.lang.reflect.Field;
import java.util.Objects;

import static org.openrewrite.Validated.invalid;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceStringLiteralWithConstant extends Recipe {

    private static final String CONSTANT_FQN_PARAM = ""fullyQualifiedConstantName"";

    @Option(displayName = ""String literal value to replace"",
            description = ""The literal that is to be replaced. If not configured, the value of the specified constant will be used by default."",
            example = ""application/json"",
            required = false)
    @Nullable
    @NonFinal
    String literalValue;

    @Option(displayName = ""Fully qualified name of the constant to use in place of String literal"", example = ""org.springframework.http.MediaType.APPLICATION_JSON_VALUE"")
    @Nullable
    String fullyQualifiedConstantName;

    @Override
    public String getDisplayName() {
        return ""Replace String literal with constant"";
    }

    @Override
    public String getDescription() {
        return ""Replace String literal with constant, adding import on class if needed."";
    }

    public @Nullable String getLiteralValue() {
        if (this.literalValue == null && this.fullyQualifiedConstantName != null) {
            try {
                this.literalValue = (String) getConstantValueByFullyQualifiedName(this.fullyQualifiedConstantName);
            } catch (ClassNotFoundException | IllegalAccessException | NoSuchFieldException e) {
                // Failed to retrieve unspecified value; field might be missing in this version of the class
                return null;
            }
        }
        return this.literalValue;
    }

    @Override
    public Validated<Object> validate() {
        Validated<Object> result = super.validate();
        if (StringUtils.isBlank(fullyQualifiedConstantName)) {
            return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""The constant's fully qualified name may not be empty or blank.""));
        }
        if (StringUtils.isBlank(literalValue)) {
            try {
                Object constantValue = getConstantValueByFullyQualifiedName(fullyQualifiedConstantName);
                if (constantValue == null) {
                    return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""Provided constant should not be null.""));
                }
                if (!(constantValue instanceof String)) {
                    // currently, we only support string literals, also see visitor implementation
                    return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""Unsupported type of constant provided. Only literals can be replaced.""));
                }
                return result;
            } catch (ClassNotFoundException e) {
                return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""No class for specified name was found.""));
            } catch (NoSuchFieldException e) {
                return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""No field with specified name was found.""));
            } catch (IllegalAccessException e) {
                return result.and(invalid(CONSTANT_FQN_PARAM, fullyQualifiedConstantName, ""Unable to access specified field.""));
            }
        }
        return result;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        String value = getLiteralValue();
        if (value == null) {
            return TreeVisitor.noop();
        } else {
            assert fullyQualifiedConstantName != null : ""Validation should have failed if constant name is null"";
            return new ReplaceStringLiteralVisitor(value, fullyQualifiedConstantName);
        }
    }

    private static class ReplaceStringLiteralVisitor extends JavaVisitor<ExecutionContext> {

        private final String literalValue;
        private final String owningType;
        private final String template;

        public ReplaceStringLiteralVisitor(String literalValue, String fullyQualifiedConstantName) {
            this.literalValue = literalValue;
            this.owningType = fullyQualifiedConstantName.substring(0, fullyQualifiedConstantName.lastIndexOf('.'));
            this.template = fullyQualifiedConstantName.substring(owningType.lastIndexOf('.') + 1);
        }

        @Override
        public J visitLiteral(J.Literal literal, ExecutionContext ctx) {
            // Only handle String literals
            if (!TypeUtils.isString(literal.getType()) ||
                !Objects.equals(literalValue, literal.getValue())) {
                return super.visitLiteral(literal, ctx);
            }

            // Prevent changing constant definition
            J.ClassDeclaration classDeclaration = getCursor().firstEnclosing(J.ClassDeclaration.class);
            if (classDeclaration != null &&
                classDeclaration.getType() != null &&
                owningType.equals(classDeclaration.getType().getFullyQualifiedName())) {
                return super.visitLiteral(literal, ctx);
            }

            maybeAddImport(owningType, false);
            return JavaTemplate.builder(template)
                    .imports(owningType)
                    .build()
                    .apply(getCursor(), literal.getCoordinates().replace())
                    .withPrefix(literal.getPrefix());
        }
    }

    private static @Nullable Object getConstantValueByFullyQualifiedName(String fullyQualifiedConstantName) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException {
        String owningType = fullyQualifiedConstantName.substring(0, fullyQualifiedConstantName.lastIndexOf('.'));
        String constantName = fullyQualifiedConstantName.substring(fullyQualifiedConstantName.lastIndexOf('.') + 1);
        Field constantField = Class.forName(owningType).getField(constantName);
        return constantField.get(null);
    }
}
",{}
Remove annotation attribute,Some annotations accept arguments. This recipe removes an existing attribute.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.J;

import java.util.concurrent.atomic.AtomicBoolean;

@Value
@EqualsAndHashCode(callSuper = false)
public class RemoveAnnotationAttribute extends Recipe {

    @Option(displayName = ""Annotation Type"",
            description = ""The fully qualified name of the annotation."",
            example = ""org.junit.Test"")
    String annotationType;

    @Option(displayName = ""Attribute name"",
            description = ""The name of attribute to remove."",
            example = ""timeout"")
    String attributeName;

    @Override
    public String getDisplayName() {
        return ""Remove annotation attribute"";
    }

    @Override
    public String getInstanceNameSuffix() {
        String shortType = annotationType.substring(annotationType.lastIndexOf('.') + 1);
        return String.format(""`@%s(%s)`"", shortType, attributeName);
    }

    @Override
    public String getDescription() {
        return ""Some annotations accept arguments. This recipe removes an existing attribute."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(annotationType, false), new JavaIsoVisitor<ExecutionContext>() {
            private final AnnotationMatcher annotationMatcher = new AnnotationMatcher(annotationType);

            @Override
            public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                J.Annotation a = super.visitAnnotation(annotation, ctx);
                if (!annotationMatcher.matches(a)) {
                    return a;
                }

                AtomicBoolean didPassFirstAttribute = new AtomicBoolean(false);
                AtomicBoolean shouldTrimNextPrefix = new AtomicBoolean(false);
                J.Annotation withoutAttribute = a.withArguments(ListUtils.map(a.getArguments(), arg -> {
                    try {
                        if (arg instanceof J.Assignment) {
                            J.Assignment assignment = (J.Assignment) arg;
                            J.Identifier variable = (J.Identifier) assignment.getVariable();
                            if (attributeName.equals(variable.getSimpleName())) {
                                if (!didPassFirstAttribute.get()) {
                                    shouldTrimNextPrefix.set(true);
                                }
                                return null;
                            }
                        } else if (""value"".equals(attributeName)) {
                            if (!didPassFirstAttribute.get()) {
                                shouldTrimNextPrefix.set(true);
                            }
                            return null;
                        }

                        if (shouldTrimNextPrefix.get()) {
                            shouldTrimNextPrefix.set(false);
                            return arg.withPrefix(arg.getPrefix().withWhitespace(""""));
                        }
                    } finally {
                        didPassFirstAttribute.set(true);
                    }

                    return arg;
                }));
                if (a != withoutAttribute &&
                        withoutAttribute.getArguments() != null &&
                        withoutAttribute.getArguments().size() == 1) {
                    doAfterVisit(SimplifySingleElementAnnotation.modifyOnly(withoutAttribute));
                }
                return withoutAttribute;
            }
        });
    }
}
","{
  ""annotationType"": ""String field"",
  ""attributeName"": ""String field""
}"
Change method name,Rename a method.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;

import java.util.function.Predicate;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeMethodName extends Recipe {

    private static final String VALID_JAVA_METHOD_PATTERN = ""^\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*$"";
    private static final Predicate<String> IS_NOT_RESERVED_KEYWORD = s -> !JavaKeywordUtils.isReservedKeyword(s);
    private static final Predicate<String> IS_NOT_RESERVED_LITERAL = s -> !JavaKeywordUtils.isReservedLiteral(s);
    private static final Predicate<String> IS_VALID_METHOD_PATTERN = s -> s.matches(VALID_JAVA_METHOD_PATTERN);
    private static final Predicate<String> IS_VALID_METHOD_NAME = IS_NOT_RESERVED_KEYWORD
          .and(IS_NOT_RESERVED_LITERAL)
          .and(IS_VALID_METHOD_PATTERN);

    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""org.mockito.Matchers anyVararg()"")
    String methodPattern;

    @Option(displayName = ""New method name"",
            description = ""The method name that will replace the existing name."",
            example = ""any"")
    String newMethodName;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Option(displayName = ""Ignore type definition"",
            description = ""When set to `true` the definition of the old type will be left untouched. "" +
                          ""This is useful when you're replacing usage of a class but don't want to rename it."",
            required = false)
    @Nullable
    Boolean ignoreDefinition;

    @Override
    public String getDisplayName() {
        return ""Change method name"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", methodPattern, newMethodName);
    }

    @Override
    public String getDescription() {
        return ""Rename a method."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate()
              .and(MethodMatcher.validate(methodPattern))
              .and(Validated.test(""newMethodName"",
                    ""should not be a Java Reserved Keyword."",
                    newMethodName,
                    IS_NOT_RESERVED_KEYWORD))
              .and(Validated.test(""newMethodName"",
                    ""should not be a Java Reserved Literal."",
                    newMethodName,
                    IS_NOT_RESERVED_LITERAL))
              .and(Validated.test(""newMethodName"",
                    ""should be a valid Java method name."",
                    newMethodName,
                    IS_VALID_METHOD_PATTERN));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        JavaIsoVisitor<ExecutionContext> condition = new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) tree;
                    if (Boolean.TRUE.equals(ignoreDefinition)) {
                        J j = new DeclaresMethod<>(methodPattern, matchOverrides).visitNonNull(cu, ctx);
                        if (cu != j) {
                            return cu;
                        }
                    } else {
                        cu = (JavaSourceFile) new DeclaresMethod<>(methodPattern, matchOverrides).visitNonNull(cu, ctx);
                        if (cu != tree) {
                            return cu;
                        }
                    }
                    return new UsesMethod<>(methodPattern, matchOverrides).visitNonNull(cu, ctx);
                }
                return super.visit(tree, ctx);
            }
        };

        return Preconditions.check(condition, new JavaIsoVisitor<ExecutionContext>() {
            private final MethodMatcher methodMatcher = new MethodMatcher(methodPattern, matchOverrides);

            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                if (IS_VALID_METHOD_NAME.test(newMethodName)) {
                    return super.isAcceptable(sourceFile, ctx);
                }
                return false;
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);

                J.NewClass newClass = getCursor().firstEnclosing(J.NewClass.class);
                J.ClassDeclaration classDecl = getCursor().firstEnclosing(J.ClassDeclaration.class);
                boolean methodMatches = newClass != null && methodMatcher.matches(method, newClass) ||
                                        classDecl != null && methodMatcher.matches(method, classDecl);
                if (methodMatches) {
                    JavaType.Method type = m.getMethodType();
                    if (type != null) {
                        type = type.withName(newMethodName);
                    }
                    m = m.withName(m.getName().withSimpleName(newMethodName).withType(type))
                            .withMethodType(type);
                }
                return m;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (methodMatcher.matches(method) && !method.getSimpleName().equals(newMethodName)) {
                    JavaType.Method type = m.getMethodType();
                    if (type != null) {
                        type = type.withName(newMethodName);
                    }
                    m = m.withName(m.getName().withSimpleName(newMethodName).withType(type))
                            .withMethodType(type);
                }
                return m;
            }

            @Override
            public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
                J.MemberReference m = super.visitMemberReference(memberRef, ctx);
                if (methodMatcher.matches(m.getMethodType()) && !m.getReference().getSimpleName().equals(newMethodName)) {
                    JavaType.Method type = m.getMethodType();
                    if (type != null) {
                        type = type.withName(newMethodName);
                    }
                    m = m.withReference(m.getReference().withSimpleName(newMethodName)).withMethodType(type);
                }
                return m;
            }

            /**
             * The only time field access should be relevant to changing method names is static imports.
             * This exists to turn
             * import static com.abc.B.static1;
             * into
             * import static com.abc.B.static2;
             */
            @Override
            public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                J.FieldAccess f = super.visitFieldAccess(fieldAccess, ctx);
                if (getCursor().getParentTreeCursor().getValue() instanceof J.Import && methodMatcher.isFullyQualifiedClassReference(f)) {
                    Expression target = f.getTarget();
                    if (target instanceof J.FieldAccess) {
                        String className = target.printTrimmed(getCursor());
                        String fullyQualified = className + ""."" + newMethodName;
                        return TypeTree.build(fullyQualified)
                                .withPrefix(f.getPrefix());
                    }
                }
                return f;
            }
        });
    }
}
","{
  ""newMethodName"": ""String field""
}"
Update source positions,Calculate start position and length for every LST element.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Range;

import java.util.IdentityHashMap;
import java.util.Map;

import static org.openrewrite.Tree.randomId;

@Incubating(since = ""7.18.0"")
public class UpdateSourcePositions extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Update source positions"";
    }

    @Override
    public String getDescription() {
        return ""Calculate start position and length for every LST element."";
    }

    @Override
    public @Nullable TreeVisitor<?, ExecutionContext> getVisitor() {
        Map<Tree, Range> positionMap = new IdentityHashMap<>();
        PositionPrintOutputCapture ppoc = new PositionPrintOutputCapture();

        JavaPrinter<ExecutionContext> printer = new JavaPrinter<ExecutionContext>() {
            final JavaPrinter<ExecutionContext> spacePrinter = new JavaPrinter<>();

            @Override
            public @Nullable J visit(@Nullable Tree tree, PrintOutputCapture<ExecutionContext> outputCapture) {
                if (tree == null) {
                    return null;
                }

                J t = (J) tree;

                PositionPrintOutputCapture prefix = new PositionPrintOutputCapture(ppoc.pos, ppoc.line, ppoc.column);
                spacePrinter.visitSpace(t.getPrefix(), Space.Location.ANY, prefix);

                Range.Position startPosition = new Range.Position(prefix.pos, prefix.line, prefix.column);
                t = super.visit(tree, outputCapture);
                Range.Position endPosition = new Range.Position(ppoc.pos, ppoc.line, ppoc.column);
                positionMap.put(t, new Range(randomId(), startPosition, endPosition));

                return t;
            }
        };

        return new JavaVisitor<ExecutionContext>() {
            boolean firstVisit = true;

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree == null) {
                    return null;
                }
                if (firstVisit) {
                    tree = printer.visitNonNull(tree, ppoc);
                    firstVisit = false;
                }

                Range range = positionMap.get(tree);
                if (range != null) {
                    J t = tree.withMarkers(tree.getMarkers().add(range));
                    return super.visit(t, ctx);
                }
                return super.visit(tree, ctx);
            }
        };
    }

    private static class PositionPrintOutputCapture extends PrintOutputCapture<ExecutionContext> {
        int pos = 0;
        int line = 1;
        int column = 0;
        private boolean lineBoundary;

        public PositionPrintOutputCapture() {
            super(new InMemoryExecutionContext());
        }

        public PositionPrintOutputCapture(int pos, int line, int column) {
            this();
            this.pos = pos;
            this.line = line;
            this.column = column;
        }

        @Override
        public PrintOutputCapture<ExecutionContext> append(char c) {
            pos++;
            if (lineBoundary) {
                line++;
                column = 0;
                lineBoundary = false;
            } else {
                column++;
            }
            if (c == '\n') {
                lineBoundary = true;
            }
            return this;
        }

        @Override
        public PrintOutputCapture<ExecutionContext> append(@Nullable String text) {
            if (text != null) {
                if (lineBoundary) {
                    line++;
                    column = 0;
                    lineBoundary = false;
                }
                int length = text.length();
                pos += length;
                int numberOfLines = 0;
                int indexOfLastNewLine = -1;
                for (int i = 0; i < length; i++) {
                    if (text.charAt(i) == '\n') {
                        indexOfLastNewLine = i;
                        numberOfLines++;
                    }
                }
                if (numberOfLines > 0) {
                    line += numberOfLines;
                    column = length - indexOfLastNewLine;
                } else {
                    column += length;
                }
            }
            return this;
        }
    }
}
",{}
Remove annotation,Remove matching annotations wherever they occur.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.Option;
import org.openrewrite.Recipe;

@EqualsAndHashCode(callSuper = false)
@Value
public class RemoveAnnotation extends Recipe {
    @Option(displayName = ""Annotation pattern"",
            description = ""An annotation pattern, expressed as a method pattern."",
            example = ""@java.lang.SuppressWarnings(\""deprecation\"")"")
    String annotationPattern;

    @Override
    public String getDisplayName() {
        return ""Remove annotation"";
    }

    @Override
    public String getDescription() {
        return ""Remove matching annotations wherever they occur."";
    }

    @Override
    public RemoveAnnotationVisitor  getVisitor() {
        return new RemoveAnnotationVisitor(new AnnotationMatcher(annotationPattern));
    }
}
",{}
Rename package name in String literals,A recipe that will rename a package name in String literals.,Java,"/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangePackageInStringLiteral extends Recipe {
    @Option(displayName = ""Old package name"",
            description = ""The package name to replace."",
            example = ""com.yourorg.foo"")
    String oldPackageName;

    @Option(displayName = ""New package name"",
            description = ""New package name to replace the old package name with."",
            example = ""com.yourorg.bar"")
    String newPackageName;

    @Override
    public String getInstanceNameSuffix() {
        return String.format(""`%s` to `%s`"", oldPackageName, newPackageName);
    }

    @Override
    public String getDisplayName() {
        return ""Rename package name in String literals"";
    }

    @Override
    public String getDescription() {
        return ""A recipe that will rename a package name in String literals."";
    }

    @Override
    public Validated<Object> validate() {
        return Validated.none()
                .and(Validated.notBlank(""oldPackageName"", oldPackageName))
                .and(Validated.required(""newPackageName"", newPackageName));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Pattern stringLiteralPattern = Pattern.compile(""\\b"" + oldPackageName + ""\\b"");
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitLiteral(J.Literal literal, ExecutionContext ctx) {
                J.Literal lit = literal;
                if (lit.getValue() instanceof String) {
                    Matcher matcher = stringLiteralPattern.matcher((String) lit.getValue());
                    if (matcher.find()) {
                        lit = lit.withValue(matcher.replaceAll(newPackageName))
                                .withValueSource(stringLiteralPattern.matcher(lit.getValueSource()).replaceAll(newPackageName));
                    }
                }
                return super.visitLiteral(lit, ctx);
            }
        };
    }
}
","{
  ""oldPackageName"": ""String field"",
  ""newPackageName"": ""String field""
}"
Change method target to static,Change method invocations to static method calls.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import com.fasterxml.jackson.annotation.JsonCreator;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.util.LinkedHashSet;
import java.util.Set;

import static java.util.Collections.emptyList;
import static org.openrewrite.Tree.randomId;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChangeMethodTargetToStatic extends Recipe {

    /**
     * See {@link  MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = ""The original method call may or may not be a static method invocation. "" + MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""com.google.common.collect.ImmutableSet of(..)"")
    String methodPattern;

    @Option(displayName = ""Fully-qualified target type name"",
            description = ""A fully-qualified class name of the type upon which the static method is defined."",
            example = ""java.util.Set"")
    String fullyQualifiedTargetTypeName;

    @Option(displayName = ""Return type after change"",
            description = ""Sometimes changing the target type also changes the return type. In the Guava example, changing from `ImmutableSet#of(..)` to `Set#of(..)` widens the return type from Guava's `ImmutableSet` to just `java.util.Set`."",
            example = ""java.util.Set"",
            required = false)
    @Nullable
    String returnType;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Option(displayName = ""Match unknown types"",
            description = ""When enabled, include method invocations which appear to match if full type information is missing. "" +
                          ""Using matchUnknownTypes can improve recipe resiliency for an AST with missing type information, but "" +
                          ""also increases the risk of false-positive matches on unrelated method invocations."",
            required = false)
    @Nullable
    Boolean matchUnknownTypes;

    @InlineMe(replacement = ""this(methodPattern, fullyQualifiedTargetTypeName, returnType, matchOverrides, false)"")
    public ChangeMethodTargetToStatic(String methodPattern, String fullyQualifiedTargetTypeName,
                                      @Nullable String returnType, @Nullable Boolean matchOverrides) {
        this(methodPattern, fullyQualifiedTargetTypeName, returnType, matchOverrides, false);
    }

    @JsonCreator
    public ChangeMethodTargetToStatic(String methodPattern, String fullyQualifiedTargetTypeName, @Nullable String returnType, @Nullable Boolean matchOverrides, @Nullable Boolean matchUnknownTypes) {
        this.methodPattern = methodPattern;
        this.fullyQualifiedTargetTypeName = fullyQualifiedTargetTypeName;
        this.returnType = returnType;
        this.matchOverrides = matchOverrides;
        this.matchUnknownTypes = matchUnknownTypes;
    }

    @Override
    public String getDisplayName() {
        return ""Change method target to static"";
    }

    @Override
    public String getDescription() {
        return ""Change method invocations to static method calls."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        boolean matchUnknown = Boolean.TRUE.equals(matchUnknownTypes);
        ChangeMethodTargetToStaticVisitor visitor = new ChangeMethodTargetToStaticVisitor(new MethodMatcher(methodPattern, matchOverrides), matchUnknown);
        return matchUnknown ? visitor : Preconditions.check(new UsesMethod<>(methodPattern, matchOverrides), visitor);
    }

    private class ChangeMethodTargetToStaticVisitor extends JavaIsoVisitor<ExecutionContext> {
        private final MethodMatcher methodMatcher;
        private final boolean matchUnknownTypes;
        private final JavaType.FullyQualified classType = JavaType.ShallowClass.build(fullyQualifiedTargetTypeName);

        public ChangeMethodTargetToStaticVisitor(MethodMatcher methodMatcher, boolean matchUnknownTypes) {
            this.methodMatcher = methodMatcher;
            this.matchUnknownTypes = matchUnknownTypes;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            Expression select = method.getSelect();
            boolean isStatic = method.getMethodType() != null && method.getMethodType().hasFlags(Flag.Static);
            boolean isSameReceiverType = select != null && TypeUtils.isOfClassType(select.getType(), fullyQualifiedTargetTypeName);
            boolean calledOnTargetType = select instanceof J.Identifier && ((J.Identifier) select).getFieldType() == null;
            if ((!isStatic || !isSameReceiverType || !calledOnTargetType) &&
                methodMatcher.matches(method, matchUnknownTypes)) {
                JavaType.Method transformedType = null;
                if (method.getMethodType() != null) {
                    maybeRemoveImport(method.getMethodType().getDeclaringType());
                    transformedType = method.getMethodType().withDeclaringType(classType);
                    if (!method.getMethodType().hasFlags(Flag.Static)) {
                        Set<Flag> flags = new LinkedHashSet<>(method.getMethodType().getFlags());
                        flags.add(Flag.Static);
                        transformedType = transformedType.withFlags(flags);
                    }
                    if (returnType != null) {
                        JavaType returnTypeType = JavaType.ShallowClass.build(returnType);
                        transformedType = transformedType.withReturnType(returnTypeType);
                    }
                }
                if (m.getSelect() == null) {
                    maybeAddImport(fullyQualifiedTargetTypeName, m.getSimpleName(), !matchUnknownTypes);
                } else {
                    maybeAddImport(fullyQualifiedTargetTypeName, !matchUnknownTypes);
                    m = method.withSelect(
                            new J.Identifier(randomId(),
                                    select == null ?
                                            Space.EMPTY :
                                            select.getPrefix(),
                                    Markers.EMPTY,
                                    emptyList(),
                                    classType.getClassName(),
                                    classType,
                                    null
                            )
                    );
                }
                m = m.withMethodType(transformedType)
                        .withName(m.getName().withType(transformedType));
            }
            return m;
        }
    }
}
","{
  ""fullyQualifiedTargetTypeName"": ""String field""
}"
Add comment to method declarations,Add a comment to method declarations in a Java source file.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.search.DeclaresMethod;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TextComment;
import org.openrewrite.marker.Markers;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This recipe adds a comment to method declarations in a Java source file. The comment can be a single line or a multiline comment.
 * <p>
 * The {@link AddCommentToMethod#comment} must be supplied and is the comment to add.
 * <p>
 * The {@link AddCommentToMethod#methodPattern} is a pattern to match methods to add the comment to.
 * <p>
 * The {@link AddCommentToMethod#isMultiline} is an optional flag (defaulted to false) to indicate if the comment is a multiline comment.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class AddCommentToMethod extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add comment to method declarations"";
    }

    @Override
    public String getDescription() {
        return ""Add a comment to method declarations in a Java source file."";
    }

    @Option(displayName = ""Comment"",
            description = ""The comment to add."",
            example = ""This is a comment."")
    String comment;

    @Option(displayName = ""Method pattern"",
            description = ""A pattern to match methods to add the comment to. "" + MethodMatcher.METHOD_PATTERN_DECLARATIONS_DESCRIPTION,
            example = ""java.util.List add*(..)"")
    String methodPattern;

    @Option(displayName = ""Multiline"",
            description = ""Comments use by default single line // but they can use multiline /* */."",
            required = false)
    @Nullable
    Boolean isMultiline;

    private static final Pattern NEWLINE = Pattern.compile(""\\R"");

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = new MethodMatcher(methodPattern);
        return Preconditions.check(new DeclaresMethod<>(methodMatcher), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration m = super.visitMethodDeclaration(method, ctx);
                J.ClassDeclaration cd = getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class);

                if (methodMatcher.matches(m, cd)) {
                    String methodPrefixWhitespace = m.getPrefix().getWhitespace();

                    boolean createMultiline = Boolean.TRUE.equals(isMultiline);
                    Matcher matcher = NEWLINE.matcher(comment);
                    String newCommentText = matcher.find() ? matcher.replaceAll(createMultiline ? methodPrefixWhitespace: "" "") : comment;

                    if (doesNotHaveComment(newCommentText, m.getComments())) {
                        TextComment textComment = new TextComment(createMultiline, newCommentText, methodPrefixWhitespace, Markers.EMPTY);
                        return m.withComments(ListUtils.concat(m.getComments(), textComment));
                    }
                }
                return m;
            }

            private boolean doesNotHaveComment(String lookFor, List<Comment> comments) {
                for (Comment c : comments) {
                    if (c instanceof TextComment &&
                        lookFor.equals(((TextComment) c).getText())) {
                        return false;
                    }
                }
                return true;
            }
        });
    }
}
","{
  ""comment"": ""String field""
}"
Replace annotation,Replace an Annotation with another one if the annotation pattern matches. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.service.ImportService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaCoordinates;
import org.openrewrite.java.tree.TypeUtils;

@Value
@EqualsAndHashCode(callSuper = false)
public class ReplaceAnnotation extends Recipe {

    @Option(displayName = ""Annotation to replace"",
            description = ""An annotation matcher, expressed as a method pattern to replace."",
            example = ""@org.jetbrains.annotations.NotNull(\""Test\"")"")
    String annotationPatternToReplace;

    @Option(displayName = ""Annotation template to insert"",
            description = ""An annotation template to add instead of original one, will be parsed with `JavaTemplate`."",
            example = ""@org.jetbrains.annotations.NotNull(\""Null not permitted\"")"")
    String annotationTemplateToInsert;

    @Option(displayName = ""Classpath resource"",
            description = ""If the annotation's type is defined by a jar within the META-INF/rewrite/classpath directory provide its name here "" +
                    ""so that it can be loaded. "" +
                    ""When this parameter is not passed the runtime classpath of the recipe is provided to the parser producing the new annotation. "" +
                    ""This is necessary when the annotation is not on the runtime classpath of the recipe and isn't in the Java standard library."",
            example = ""annotations"",
            required = false)
    @Nullable
    String classpathResourceName;

    @Override
    public String getDisplayName() {
        return ""Replace annotation"";
    }

    @Override
    public String getDescription() {
        return ""Replace an Annotation with another one if the annotation pattern matches. "" +
               ""Only fixed parameters can be set in the replacement."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                JavaTemplate.Builder templateBuilder = JavaTemplate.builder(annotationTemplateToInsert);
                if (classpathResourceName == null) {
                    templateBuilder.javaParser(JavaParser.fromJavaVersion().classpath(JavaParser.runtimeClasspath()));
                } else {
                    templateBuilder.javaParser(JavaParser.fromJavaVersion().classpathFromResources(ctx, classpathResourceName));
                }
                return new ReplaceAnnotationVisitor(new AnnotationMatcher(annotationPatternToReplace), templateBuilder.build())
                        .visit(tree, ctx);
            }
        };
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    public static class ReplaceAnnotationVisitor extends JavaIsoVisitor<ExecutionContext> {
        AnnotationMatcher matcher;
        JavaTemplate replacement;

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = super.visitAnnotation(annotation, ctx);

            if (!matcher.matches(a)) {
                return a;
            }

            maybeRemoveImport(TypeUtils.asFullyQualified(a.getType()));
            JavaCoordinates replaceCoordinate = a.getCoordinates().replace();
            a = replacement.apply(getCursor(), replaceCoordinate);
            doAfterVisit(service(ImportService.class).shortenFullyQualifiedTypeReferencesIn(a));
            return a;
        }
    }
}
",{}
Add or update annotation attribute,"Some annotations accept arguments. This recipe sets an existing argument to the specified value, ",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.Contract;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.search.UsesType;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;

import java.util.*;

import static java.lang.Boolean.TRUE;
import static java.util.Collections.*;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.tree.Space.SINGLE_SPACE;
import static org.openrewrite.marker.Markers.EMPTY;

@Value
@EqualsAndHashCode(callSuper = false)
public class AddOrUpdateAnnotationAttribute extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Add or update annotation attribute"";
    }

    @Override
    public String getDescription() {
        return ""Some annotations accept arguments. This recipe sets an existing argument to the specified value, "" +
                ""or adds the argument if it is not already set."";
    }

    @Option(displayName = ""Annotation type"",
            description = ""The fully qualified name of the annotation."",
            example = ""org.junit.Test"")
    String annotationType;

    @Option(displayName = ""Attribute name"",
            description = ""The name of attribute to change. If omitted defaults to 'value'."",
            required = false,
            example = ""timeout"")
    @Nullable
    String attributeName;

    @Option(displayName = ""Attribute value"",
            description = ""The value to set the attribute to. If the attribute is an array, provide values separated by comma to add multiple attributes at once. Set to `null` to remove the attribute."",
            required = false,
            example = ""500"")
    @Nullable
    String attributeValue;

    @Option(displayName = ""Old Attribute value"",
            description = ""The current value of the attribute, this can be used to filter where the change is applied. Set to `null` for wildcard behavior."",
            required = false,
            example = ""400"")
    @Nullable
    String oldAttributeValue;

    @Option(displayName = ""Add only"",
            description = ""If `true`, disables upgrading existing annotation attribute values, thus the recipe will only add the attribute if it does not already exist. "" +
                    ""If omitted or `false`, the recipe adds the attribute if missing or updates its value if present."",
            required = false)
    @Nullable
    Boolean addOnly;

    @Option(displayName = ""Append array"",
            description = ""If the attribute is an array and attribute is present, setting this option to `true` will append the value(s). Duplicate values will not be added. "" +
                    ""If omitted or `false`, the recipe will replace the existing value(s) with the new value(s)."",
            required = false)
    @Nullable
    Boolean appendArray;

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesType<>(annotationType, false), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Annotation visitAnnotation(J.Annotation original, ExecutionContext ctx) {
                J.Annotation a = super.visitAnnotation(original, ctx);
                if (!TypeUtils.isOfClassType(a.getType(), annotationType) ||
                        !(a.getType() instanceof JavaType.ShallowClass || findMethod(a, attributeName()).isPresent())) {
                    return a;
                }

                String newAttributeValue;
                if (attributeValue != null && attributeValue.endsWith("".class"") && StringUtils.countOccurrences(attributeValue, ""."") > 1) {
                    maybeAddImport(attributeValue.substring(0, attributeValue.length() - 6));
                    newAttributeValue = attributeValue;
                } else {
                    newAttributeValue = maybeQuoteStringArgument(a, attributeValue);
                }
                List<Expression> currentArgs = a.getArguments();

                // ADD the value when the annotation has no arguments, e.g. @Foo` to @Foo(name=""new"")
                if (currentArgs == null || currentArgs.isEmpty() || currentArgs.get(0) instanceof J.Empty) {
                    if (newAttributeValue == null || oldAttributeValue != null) {
                        return a;
                    }
                    if (""value"".equals(attributeName())) {
                        return JavaTemplate.apply(""#{}"", getCursor(), a.getCoordinates().replaceArguments(), newAttributeValue);
                    }
                    String attrVal = newAttributeValue.contains("","") && attributeIsArray(a) ? getAttributeValuesAsString() : newAttributeValue;
                    return JavaTemplate.apply(""#{} = #{}"", getCursor(), a.getCoordinates().replaceArguments(), attributeName, attrVal);
                }

                // UPDATE the value when the annotation has arguments, e.g. @Foo(name=""old"") to `@Foo(name=""new"")
                if (!TRUE.equals(addOnly)) {
                    final J.Annotation finalA = a;
                    a = a.withArguments(ListUtils.map(currentArgs, it -> {
                        if (it instanceof J.Assignment) {
                            return update((J.Assignment) it, finalA, newAttributeValue);
                        } else if (it instanceof J.Literal) {
                            return update((J.Literal) it, finalA, newAttributeValue);
                        } else if (it instanceof J.FieldAccess) {
                            return update((J.FieldAccess) it, finalA, newAttributeValue);
                        } else if (it instanceof J.NewArray) {
                            return update((J.NewArray) it, finalA, newAttributeValue);
                        }
                        return it;
                    }));
                }

                // ADD the value into the argument list when there was no existing value to update and no requirements on a pre-existing old value, e.g. @Foo(name=""old"") to @Foo(value=""new"", name=""old"")
                if (oldAttributeValue == null && newAttributeValue != null && !attributeNameOrValIsAlreadyPresent(a.getArguments(), getAttributeValues())) {
                    J.Assignment as = createAnnotationAssignment(a, attributeName(), newAttributeValue);
                    List<Expression> args = a.getArguments();
                    // Case for existing attribute: `@Foo(""q"")` -> @Foo(value = ""q"")
                    if (args.size() == 1 && !(args.get(0) instanceof J.Assignment)) {
                        args = singletonList(createAnnotationAssignment(a, ""value"", a.getArguments().get(0)));
                    }
                    a = a.withArguments(ListUtils.concat(as, args));
                }

                if (original != a) {
                    doAfterVisit(new SimplifySingleElementAnnotation().getVisitor());
                }
                return maybeAutoFormat(original, a, ctx);
            }

            private @Nullable Expression update(J.Assignment as, J.Annotation annotation, @Nullable String newAttributeValue) {
                J.Identifier var_ = (J.Identifier) as.getVariable();
                if ((attributeName == null && !""value"".equals(var_.getSimpleName())) ||
                        (attributeName != null && !attributeName.equals(var_.getSimpleName()))) {
                    return as;
                }
                if (newAttributeValue == null) {
                    return null;
                }
                Expression exp = as.getAssignment();
                if (exp instanceof J.NewArray) {
                    List<Expression> initializerList = requireNonNull(((J.NewArray) exp).getInitializer());
                    return as.withAssignment(((J.NewArray) exp)
                            .withInitializer(updateInitializer(annotation, initializerList, getAttributeValues())));
                }
                if (exp instanceof J.Literal) {
                    if (!valueMatches(exp, oldAttributeValue) || newAttributeValue.equals(((J.Literal) exp).getValueSource())) {
                        return as;
                    }
                    return as.withAssignment(createAnnotationLiteral(annotation, newAttributeValue));
                }
                if (exp instanceof J.FieldAccess) {
                    if (oldAttributeValue != null) {
                        return as;
                    }
                    if (isFullyQualifiedClass() && getFullyQualifiedClass(newAttributeValue).equals(exp.toString())) {
                        return as;
                    }
                    //noinspection ConstantConditions
                    return JavaTemplate.<J.Annotation>apply(""#{} = #{}"", getCursor(), as.getCoordinates().replace(), var_.getSimpleName(), newAttributeValue)
                            .getArguments().get(annotation.getArguments().indexOf(as));
                }
                return as;
            }

            private @Nullable Expression update(J.Literal literal, J.Annotation annotation, @Nullable String newAttributeValue) {
                // The only way anything except an assignment can appear is if there's an implicit assignment to ""value""
                if (""value"".equals(attributeName())) {
                    if (newAttributeValue == null) {
                        return null;
                    }
                    if (!valueMatches(literal, oldAttributeValue) || newAttributeValue.equals(literal.getValueSource())) {
                        return literal;
                    }
                    return createAnnotationLiteral(annotation, newAttributeValue);
                }
                if (oldAttributeValue == null && newAttributeValue != null) {
                    // Without an oldAttributeValue and an attributeName not matching `value` we want to add an extra argument to the annotation.
                    // Make the attribute name explicit, before we add the new value below
                    return createAnnotationAssignment(annotation, ""value"", literal);
                }
                return literal;
            }

            private @Nullable Expression update(J.FieldAccess fieldAccess, J.Annotation annotation, @Nullable String newAttributeValue) {
                // The only way anything except an assignment can appear is if there's an implicit assignment to ""value""
                if (""value"".equals(attributeName())) {
                    if (newAttributeValue == null) {
                        return null;
                    }
                    if (isFullyQualifiedClass() && getFullyQualifiedClass(newAttributeValue).equals(fieldAccess.toString())) {
                        return fieldAccess;
                    }
                    if (!valueMatches(fieldAccess, oldAttributeValue) || newAttributeValue.equals(fieldAccess.toString())) {
                        return fieldAccess;
                    }
                    String attrVal = newAttributeValue.contains("","") && attributeIsArray(annotation) ?
                            getAttributeValues().stream().map(String::valueOf).collect(joining("","", ""{"", ""}"")) :
                            newAttributeValue;
                    //noinspection ConstantConditions
                    return JavaTemplate.<J.Annotation>apply(""#{}"", getCursor(), annotation.getCoordinates().replaceArguments(), attrVal)
                            .getArguments().get(0);
                }
                // Make the attribute name explicit, before we add the new value below
                return createAnnotationAssignment(annotation, ""value"", fieldAccess);
            }

            private @Nullable Expression update(J.NewArray arrayValue, J.Annotation annotation, @Nullable String newAttributeValue) {
                if (newAttributeValue == null) {
                    return null;
                }
                if (attributeName != null && !""value"".equals(attributeValue)) {
                    return isAnnotationWithOnlyValueMethod(annotation) ? arrayValue : createAnnotationAssignment(annotation, ""value"", arrayValue);
                }
                return arrayValue.withInitializer(updateInitializer(annotation, requireNonNull(arrayValue.getInitializer()), getAttributeValues()));
            }

            private Expression createAnnotationLiteral(J.Annotation annotation, String newAttributeValue) {
                String attrVal = newAttributeValue.contains("","") && attributeIsArray(annotation) ? getAttributeValuesAsString() : newAttributeValue;
                //noinspection ConstantConditions
                return JavaTemplate.<J.Annotation>apply(""#{}"", getCursor(), annotation.getCoordinates().replaceArguments(), attrVal)
                        .getArguments().get(0);
            }

            private J.Assignment createAnnotationAssignment(J.Annotation annotation, String name, @Nullable Object parameter) {
                //noinspection ConstantConditions
                return (J.Assignment) JavaTemplate.<J.Annotation>apply(name + "" = "" + (parameter instanceof J ? ""#{any()}"" : ""#{}""), getCursor(), annotation.getCoordinates().replaceArguments(), parameter)
                        .getArguments().get(0);
            }
        });
    }

    private boolean isFullyQualifiedClass() {
        return attributeValue != null && attributeValue.endsWith("".class"") && StringUtils.countOccurrences(attributeValue, ""."") > 1;
    }

    private static String getFullyQualifiedClass(String fqn) {
        String withoutClassSuffix = fqn.substring(0, fqn.length() - 6);
        return withoutClassSuffix.substring(withoutClassSuffix.lastIndexOf('.') + 1) + "".class"";
    }

    private String attributeName() {
        return attributeName == null ? ""value"" : attributeName;
    }

    private List<Expression> updateInitializer(J.Annotation annotation, List<Expression> initializerList, List<String> attributeList) {
        // If `oldAttributeValue` is defined, replace the old value with the new value(s). Ignore the `appendArray` option in this case.
        if (oldAttributeValue != null) {
            return ListUtils.flatMap(initializerList, it -> {
                if (it instanceof J.Literal && oldAttributeValue.equals(((J.Literal) it).getValue())) {
                    List<Expression> newItemsList = new ArrayList<>();
                    for (String attribute : attributeList) {
                        J.Literal newLiteral = new J.Literal(randomId(), SINGLE_SPACE, EMPTY, attribute, maybeQuoteStringArgument(annotation, attribute), null, JavaType.Primitive.String);
                        newItemsList.add(newLiteral);
                    }
                    return newItemsList;
                }
                return it;
            });
        }

        // If `appendArray` is true, add the new value(s) to the existing array (no duplicates)
        if (TRUE.equals(appendArray)) {
            List<Expression> newItemsList = new ArrayList<>();
            for (String attribute : attributeList) {
                if (attributeNameOrValIsAlreadyPresent(initializerList, singleton(attribute))) {
                    continue;
                }
                newItemsList.add(new J.Literal(randomId(), SINGLE_SPACE, EMPTY, attribute, maybeQuoteStringArgument(annotation, attribute), null, JavaType.Primitive.String));
            }
            return ListUtils.concatAll(initializerList, newItemsList);
        }

        // If no option is defined, replace the old array elements with the new elements
        List<Expression> list = ListUtils.map(initializerList, (i, it) -> {
            if (i >= attributeList.size()) {
                return null;
            }
            if (attributeNameOrValIsAlreadyPresent(it, singleton(attributeList.get(i)))) {
                return it;
            }
            return new J.Literal(randomId(), it.getPrefix(), EMPTY, attributeList.get(i), maybeQuoteStringArgument(annotation, attributeList.get(i)), null, JavaType.Primitive.String);
        });
        // and add extra new items if needed
        for (int i = initializerList.size(); i < attributeList.size(); i++) {
            list.add(new J.Literal(randomId(), SINGLE_SPACE, EMPTY, attributeList.get(i), maybeQuoteStringArgument(annotation, attributeList.get(i)), null, JavaType.Primitive.String));
        }
        return list;
    }

    private List<String> getAttributeValues() {
        if (attributeValue == null) {
            return emptyList();
        }
        if (isFullyQualifiedClass()) {
            return singletonList(getFullyQualifiedClass(attributeValue));
        }
        String attributeValueCleanedUp = attributeValue.replaceAll(""\\s+"", """").replaceAll(""[\\s+{}\""]"", """");
        return Arrays.asList(attributeValueCleanedUp.contains("","") ? attributeValueCleanedUp.split("","") : new String[]{attributeValueCleanedUp});
    }

    private String getAttributeValuesAsString() {
        return getAttributeValues().stream().map(String::valueOf).collect(joining(""\"", \"""", ""{\"""", ""\""}""));
    }

    private static boolean isAnnotationWithOnlyValueMethod(J.Annotation annotation) {
        return getMethods(annotation).size() == 1 && ""value"".equals(getMethods(annotation).get(0).getName());
    }

    private static boolean valueMatches(@Nullable Expression expression, @Nullable String oldAttributeValue) {
        if (expression == null) {
            return oldAttributeValue == null;
        } else if (oldAttributeValue == null) { // null means wildcard
            return true;
        } else if (expression instanceof J.Literal) {
            return oldAttributeValue.equals(((J.Literal) expression).getValue());
        } else if (expression instanceof J.FieldAccess) {
            J.FieldAccess fa = (J.FieldAccess) expression;
            if (!(fa.getTarget() instanceof J.Identifier)) {
                return oldAttributeValue.equals(fa.toString());
            }
            String currentValue = ((J.Identifier) fa.getTarget()).getSimpleName() + ""."" + fa.getSimpleName();
            return oldAttributeValue.equals(currentValue);
        } else if (expression instanceof J.Identifier) { // class names, static variables, ...
            if (oldAttributeValue.endsWith("".class"")) {
                String className = TypeUtils.toString(requireNonNull(expression.getType())) + "".class"";
                return className.endsWith(oldAttributeValue);
            }
            return oldAttributeValue.equals(((J.Identifier) expression).getSimpleName());
        }
        throw new IllegalArgumentException(""Unexpected expression type: "" + expression.getClass());
    }

    @Contract(""_, null -> null; _, !null -> !null"")
    private @Nullable String maybeQuoteStringArgument(J.Annotation annotation, @Nullable String attributeValue) {
        if (attributeValue != null && attributeIsString(annotation)) {
            return ""\"""" + attributeValue + ""\"""";
        }
        return attributeValue;
    }

    private boolean attributeIsArray(J.Annotation annotation) {
        return findMethod(annotation, attributeName())
                .map(it -> it.getReturnType() instanceof JavaType.Array)
                .orElse(false);
    }

    private boolean attributeIsString(J.Annotation annotation) {
        return findMethod(annotation, attributeName())
                .map(it -> TypeUtils.isOfClassType(it.getReturnType(), ""java.lang.String""))
                .orElse(false);
    }

    private static Optional<JavaType.Method> findMethod(J.Annotation annotation, String methodName) {
        for (JavaType.Method it : getMethods(annotation)) {
            if (methodName.equals(it.getName())) {
                return Optional.of(it);
            }
        }
        return Optional.empty();
    }

    private static List<JavaType.Method> getMethods(J.Annotation annotation) {
        return ((JavaType.FullyQualified) requireNonNull(annotation.getAnnotationType().getType())).getMethods();
    }

    private boolean attributeNameOrValIsAlreadyPresent(Collection<Expression> expression, Collection<?> values) {
        for (Expression e : expression) {
            if (attributeNameOrValIsAlreadyPresent(e, values)) {
                return true;
            }
        }
        return false;
    }

    private boolean attributeNameOrValIsAlreadyPresent(Expression e, Collection<?> values) {
        if (e instanceof J.Assignment) {
            J.Assignment as = (J.Assignment) e;
            if (as.getVariable() instanceof J.Identifier) {
                return ((J.Identifier) as.getVariable()).getSimpleName().equals(attributeName());
            }
        } else if (e instanceof J.Literal) {
            return values.contains(((J.Literal) e).getValue() + """");
        } else if (e instanceof J.FieldAccess) {
            return values.contains(e.toString());
        } else if (e instanceof J.NewArray) {
            List<Expression> initializer = ((J.NewArray) e).getInitializer();
            return (initializer == null && attributeValue == null) || (initializer != null && attributeNameOrValIsAlreadyPresent(initializer, values));
        }
        return false;
    }
}
","{
  ""annotationType"": ""String field""
}"
Find empty classes,Find empty classes without annotations that do not implement an interface or extend a class.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.SearchResult;

import java.time.Duration;
import java.util.Set;

import static java.util.Collections.singleton;

public class FindEmptyClasses extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find empty classes"";
    }

    @Override
    public String getDescription() {
        return ""Find empty classes without annotations that do not implement an interface or extend a class."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S2094"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(5);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (classDecl.getType() != null && JavaType.Class.Kind.Class == classDecl.getType().getKind() &&
                    (classDecl.getBody() == null || classDecl.getBody().getStatements().isEmpty()) &&
                    classDecl.getLeadingAnnotations().isEmpty() && classDecl.getExtends() == null && classDecl.getImplements() == null) {
                    return SearchResult.found(classDecl);
                }
                return super.visitClassDeclaration(classDecl, ctx);
            }
        };
    }
}
",{}
Find class hierarchy,"Discovers all class declarations within a project, recording which files they appear in, their superclasses, and interfaces. ",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.SourceFile;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.table.ClassHierarchy;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;

import static java.util.stream.Collectors.joining;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindClassHierarchy extends Recipe {
    transient ClassHierarchy classHierarchy = new ClassHierarchy(this);

    @Override
    public String getDisplayName() {
        return ""Find class hierarchy"";
    }

    @Override
    public String getDescription() {
        return ""Discovers all class declarations within a project, recording which files they appear in, their superclasses, and interfaces. "" +
               ""That information is then recorded in a data table."";
    }


    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                JavaType.FullyQualified type = cd.getType();
                if(type == null) {
                    return cd;
                }
                classHierarchy.insertRow(ctx, new ClassHierarchy.Row(
                        getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().toString(),
                        type.getFullyQualifiedName(),
                        type.getSupertype() == null ? null : type.getSupertype().getFullyQualifiedName(),
                        type.getInterfaces().isEmpty() ? null : type.getInterfaces().stream()
                                .map(JavaType.FullyQualified::getFullyQualifiedName)
                                .collect(joining("","")))
                );
                return cd;
            }
        };
    }
}
",{}
Find files compiled at a specific Java version,Finds Java source files matching a particular language level. ,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.marker.JavaVersion;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class HasJavaVersion extends Recipe {

    @Option(displayName = ""Java version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""17.X"")
    String version;

    @Option(displayName = ""Version check against target compatibility"",
            description = ""The source and target compatibility versions can be different. This option allows you to "" +
                          ""check against the target compatibility version instead of the source compatibility version."",
            example = ""17.X"",
            required = false)
    @Nullable
    Boolean checkTargetCompatibility;

    @Override
    public String getDisplayName() {
        return ""Find files compiled at a specific Java version"";
    }

    @Override
    public String getDescription() {
        return ""Finds Java source files matching a particular language level. "" +
               ""This is useful especially as a precondition for other recipes."";
    }

    @SuppressWarnings(""ConstantConditions"")
    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, null));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        VersionComparator versionComparator = requireNonNull(Semver.validate(version, null).getValue());
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree != null) {
                    return tree.getMarkers().findFirst(JavaVersion.class)
                            .filter(version -> versionComparator.isValid(null, Integer.toString(
                                    Boolean.TRUE.equals(checkTargetCompatibility) ?
                                            version.getMajorReleaseVersion() :
                                            version.getMajorVersion())))
                            .map(version -> SearchResult.found(tree))
                            .orElse(tree);
                }
                return tree;
            }
        };
    }
}
","{
  ""version"": ""String field""
}"
Find uses of deprecated methods,Find uses of deprecated methods in any API.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.table.MethodCalls;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.SearchResult;

import java.util.Iterator;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDeprecatedMethods extends Recipe {
    private static final AnnotationMatcher DEPRECATED_MATCHER = new AnnotationMatcher(""@java.lang.Deprecated"");

    transient MethodCalls deprecatedMethodCalls = new MethodCalls(this);

    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.util.List add(..)"",
            required = false)
    @Nullable
    String methodPattern;

    @Option(displayName = ""Ignore deprecated scopes"",
            description = ""When set to `true` deprecated methods used within deprecated methods or classes will be ignored."",
            required = false)
    @Nullable
    Boolean ignoreDeprecatedScopes;

    @Override
    public String getDisplayName() {
        return ""Find uses of deprecated methods"";
    }

    @Override
    public String getInstanceNameSuffix() {
        if (methodPattern != null) {
            return ""matching `"" + methodPattern + ""`"";
        }
        return super.getInstanceNameSuffix();
    }

    @Override
    public String getDescription() {
        return ""Find uses of deprecated methods in any API."";
    }

    @Override
    public Validated<Object> validate() {
        if (StringUtils.isBlank(methodPattern)) {
            return super.validate();
        }
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = methodPattern == null || methodPattern.isEmpty() ? null : new MethodMatcher(methodPattern, true);

        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @SuppressWarnings(""NullableProblems"")
            @Override
            public J visit(Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    for (JavaType.Method method : cu.getTypesInUse().getUsedMethods()) {
                        if (methodMatcher == null || methodMatcher.matches(method)) {
                            for (JavaType.FullyQualified annotation : method.getAnnotations()) {
                                if (TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                                    return SearchResult.found(cu);
                                }
                            }
                        }
                    }
                }
                return (J) tree;
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (method.getMethodType() != null) {
                    for (JavaType.FullyQualified annotation : method.getMethodType().getAnnotations()) {
                        if ((methodMatcher == null || methodMatcher.matches(method)) && TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                            if (Boolean.TRUE.equals(ignoreDeprecatedScopes)) {
                                Iterator<Cursor> cursorPath = getCursor().getPathAsCursors();
                                while (cursorPath.hasNext()) {
                                    Cursor ancestor = cursorPath.next();
                                    if (ancestor.getValue() instanceof J.MethodDeclaration && isDeprecated(ancestor)) {
                                        return m;
                                    }
                                    if (ancestor.getValue() instanceof J.ClassDeclaration && isDeprecated(ancestor)) {
                                        return m;
                                    }
                                }
                            }

                            JavaSourceFile javaSourceFile = getCursor().firstEnclosing(JavaSourceFile.class);
                            if (javaSourceFile != null) {
                                deprecatedMethodCalls.insertRow(ctx, new MethodCalls.Row(
                                        javaSourceFile.getSourcePath().toString(),
                                        method.printTrimmed(getCursor().getParentTreeCursor()),
                                        method.getMethodType().getDeclaringType().getFullyQualifiedName(),
                                        method.getSimpleName(),
                                        method.getArguments().stream()
                                                .map(Expression::getType)
                                                .map(String::valueOf)
                                                .collect(joining("", ""))
                                ));
                            }
                            m = SearchResult.found(m);
                        }
                    }
                }
                return m;
            }

            private boolean isDeprecated(Cursor cursor) {
                return service(AnnotationService.class).matches(cursor, DEPRECATED_MATCHER);
            }
        });
    }
}
",{}
Find files with a particular build tool version,Finds Java source files built with a particular build tool. ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.marker.BuildTool;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class HasBuildToolVersion extends Recipe {

    @Option(displayName = ""Build tool type"",
            description = ""The build tool to search for."",
            example = ""Maven"")
    BuildTool.Type type;

    @Option(displayName = ""Build tool version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""3.6.0-9999"")
    String version;

    @Override
    public String getDisplayName() {
        return ""Find files with a particular build tool version"";
    }

    @Override
    public String getDescription() {
        return ""Finds Java source files built with a particular build tool. "" +
               ""This is useful especially as a precondition for other recipes."";
    }

    @SuppressWarnings(""ConstantConditions"")
    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, null));
        }
        return validated;
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        VersionComparator versionComparator = requireNonNull(Semver.validate(version, null).getValue());
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree != null) {
                    return tree.getMarkers().findFirst(BuildTool.class)
                            .filter(buildTool -> buildTool.getType() == type)
                            .filter(buildTool -> versionComparator.isValid(null, buildTool.getVersion()))
                            .map(version -> SearchResult.found(tree))
                            .orElse(tree);
                }
                return tree;
            }
        };
    }
}
","{
  ""version"": ""String field""
}"
Find type mappings,Study the frequency of `J` types and their `JavaType` type attribution.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.table.TypeMappings;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypedTree;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import static java.util.Collections.emptyList;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindTypeMappings extends ScanningRecipe<Map<FindTypeMappings.TypeAssociation, Integer>> {
    transient TypeMappings typeMappingsPerSource = new TypeMappings(this);

    @Override
    public String getDisplayName() {
        return ""Find type mappings"";
    }

    @Override
    public String getDescription() {
        return ""Study the frequency of `J` types and their `JavaType` type attribution."";
    }

    @Override
    public Map<TypeAssociation, Integer> getInitialValue(ExecutionContext ctx) {
        return new HashMap<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Map<TypeAssociation, Integer> acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public @Nullable JavaType visitType(@Nullable JavaType javaType, ExecutionContext ctx) {
                Cursor cursor = getCursor();
                acc.compute(new TypeAssociation(
                                cursor.firstEnclosingOrThrow(JavaSourceFile.class).getClass(),
                                cursor.getValue().getClass(),
                                javaType == null ? null : javaType.getClass(),
                                javaType == null ?
                                        cursor.getPathAsStream()
                                                .filter(t -> t instanceof TypedTree &&
                                                             ((TypedTree) t).getType() != null)
                                                .findFirst()
                                                .map(Object::getClass)
                                                .orElse(null) :
                                        null),
                        (k, v) -> v == null ? 1 : v + 1);
                return javaType;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Map<TypeAssociation, Integer> acc, ExecutionContext ctx) {
        acc.forEach((assoc, count) -> {
            String j = assoc.getJ().getName();
            Class<?> nearJ = assoc.getNearestNonNullJ();
            typeMappingsPerSource.insertRow(ctx, new TypeMappings.Row(
                    assoc.getCompilationUnit().getEnclosingClass().getSimpleName(),
                    j.substring(j.lastIndexOf('.') + 1),
                    assoc.getJavaType() == null ? ""null"" : assoc.getJavaType().getSimpleName(),
                    count,
                    nearJ == null ? null : nearJ.getName().substring(nearJ.getName().lastIndexOf('.') + 1)
            ));
        });
        return emptyList();
    }

    @Value
    public static class TypeAssociation {
        Class<? extends JavaSourceFile> compilationUnit;

        Class<?> j;

        @Nullable
        Class<? extends JavaType> javaType;

        /**
         * When {@link #j} is null, this is the nearest non-null {@link J} type
         * in the cursor stack.
         */
        @Nullable
        Class<?> nearestNonNullJ;
    }
}
",{}
Study the size of the classpath by source set,"Emit one data table row per source set in a project, with the number of types in the source set.",Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.ScanningRecipe;
import org.openrewrite.SourceFile;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaProject;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.table.ClasspathTypeCount;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;

import static java.util.Collections.emptyList;

public class ClasspathTypeCounts extends ScanningRecipe<Set<ClasspathTypeCounts.ProjectSourceSet>> {
    private final transient ClasspathTypeCount counts = new ClasspathTypeCount(this);

    @Override
    public String getDisplayName() {
        return ""Study the size of the classpath by source set"";
    }

    @Override
    public String getDescription() {
        return ""Emit one data table row per source set in a project, with the number of types in the source set."";
    }

    @Override
    public Set<ProjectSourceSet> getInitialValue(ExecutionContext ctx) {
        return new LinkedHashSet<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Set<ProjectSourceSet> acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J preVisit(J tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaProject javaProject = tree.getMarkers().findFirst(JavaProject.class).orElse(null);
                    JavaSourceSet sourceSet = tree.getMarkers().findFirst(JavaSourceSet.class).orElse(null);
                    if (javaProject != null && sourceSet != null) {
                        acc.add(new ProjectSourceSet(javaProject, sourceSet));
                    }
                }
                stopAfterPreVisit();
                return tree;
            }
        };
    }

    @Override
    public Collection<? extends SourceFile> generate(Set<ProjectSourceSet> acc, ExecutionContext ctx) {
        for (ProjectSourceSet projectSourceSet : acc) {
            counts.insertRow(ctx, new ClasspathTypeCount.Row(
                    projectSourceSet.getJavaProject().getProjectName(),
                    projectSourceSet.getSourceSet().getName(),
                    projectSourceSet.getSourceSet().getClasspath().size()
            ));
        }
        return emptyList();
    }

    @Value
    public static class ProjectSourceSet {
        JavaProject javaProject;
        JavaSourceSet sourceSet;
    }
}
",{}
Check whether a type is **not** in use,Useful as a precondition to skip over compilation units using the argument type.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;

@Value
@EqualsAndHashCode(callSuper = false)
public class DoesNotUseType extends Recipe {

    @Option(displayName = ""Fully-qualified type name"",
            description = ""A fully-qualified type name, that is used to find matching type references. "" +
                          ""Supports glob expressions. `java..*` finds every type from every subpackage of the `java` package."",
            example = ""java.util.List"")
    String fullyQualifiedTypeName;

    @Option(displayName = ""Include implicit type references"",
            description = ""Whether to include implicit type references, such as those in method signatures."",
            required = false)
    @Nullable
    Boolean includeImplicit;

    @Override
    public String getDisplayName() {
        return ""Check whether a type is **not** in use"";
    }

    @Override
    public String getDescription() {
        return ""Useful as a precondition to skip over compilation units using the argument type."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.not(new UsesType<>(fullyQualifiedTypeName, includeImplicit));
    }
}
","{
  ""fullyQualifiedTypeName"": ""String field""
}"
Find implementing classes,Find class declarations which implement the specified type. ,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindImplementations extends Recipe {
    @Option(displayName = ""Type name"",
            description = ""The fully qualified name to search for."",
            example = ""org.openrewrite.Recipe"")
    String typeName;

    @Override
    public String getDisplayName() {
        return ""Find implementing classes"";
    }

    @Override
    public String getDescription() {
        return ""Find class declarations which implement the specified type. "" +
               ""If the specified type is a class, its subclasses will be matched. "" +
               ""If the specified type is an interface, classes which implement it will be matched."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl,
                                                            ExecutionContext ctx) {
                J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
                if (TypeUtils.isAssignableTo(typeName, cd.getType()) && !TypeUtils.isOfClassType(cd.getType(), typeName)) {
                    cd = SearchResult.found(cd);
                }
                return cd;
            }
        };
    }
}
","{
  ""typeName"": ""String field""
}"
Find within comments and literals,Find regular expression matches within comments and literals. \,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavadocVisitor;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.SearchResult;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static java.util.stream.Collectors.toList;
import static org.openrewrite.Tree.randomId;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindComments extends Recipe {

    @Option(displayName = ""Text patterns"",
            description = ""A list of regular expressions to search for."",
            example = ""-----BEGIN RSA PRIVATE KEY-----"")
    List<String> patterns;

    @Override
    public String getDisplayName() {
        return ""Find within comments and literals"";
    }

    @Override
    public String getDescription() {
        return ""Find regular expression matches within comments and literals. \""Literals\"" includes string literals, "" +
               ""character literals, and numeric literals."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(Validated.test(
                ""patterns"",
                ""Patterns must be compilable regular expressions"",
                patterns, ps -> {
                    for (String p : ps) {
                        try {
                            Pattern.compile(p);
                        } catch (PatternSyntaxException e) {
                            return false;
                        }
                    }
                    return true;
                })
        );
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        List<Pattern> compiledPatterns = patterns.stream()
                .map(Pattern::compile)
                .collect(toList());

        return new JavaIsoVisitor<ExecutionContext>() {

            private final JavadocVisitor<ExecutionContext> javadocVisitor = new JavadocVisitor<ExecutionContext>(this) {
                @Override
                public Javadoc visitText(Javadoc.Text text, ExecutionContext ctx) {
                    return match(text, text.getText());
                }
            };

            @Override
            protected JavadocVisitor<ExecutionContext> getJavadocVisitor() {
                return javadocVisitor;
            }

            @Override
            public Space visitSpace(Space space, Space.Location loc, ExecutionContext ctx) {
                return space.withComments(ListUtils.map(space.getComments(), comment -> {
                    if (comment instanceof TextComment) {
                        for (Pattern p : compiledPatterns) {
                            if (p.matcher(((TextComment) comment).getText()).find()) {
                                return comment.withMarkers(comment.getMarkers().
                                        computeByType(new SearchResult(randomId(), null), (s1, s2) -> s1 == null ? s2 : s1));
                            }
                        }
                    } else if (comment instanceof Javadoc.DocComment) {
                        return (Comment) getJavadocVisitor().visitDocComment((Javadoc.DocComment) comment, ctx);
                    }
                    return comment;
                }));
            }

            @Override
            public J.Literal visitLiteral(J.Literal literal, ExecutionContext ctx) {
                if (literal.getType() == JavaType.Primitive.Null) {
                    return literal;
                }

                J.Literal matched = literal.getValue() != null ? match(literal, literal.getValue().toString()) : literal;
                if (matched != literal) {
                    return matched;
                }

                return match(literal, literal.getValueSource());
            }

            private <T extends Tree> T match(T t, @Nullable String value) {
                if (value == null) {
                    return t;
                }

                for (Pattern p : compiledPatterns) {
                    if (p.matcher(value).find()) {
                        return SearchResult.found(t);
                    }
                }

                return t;
            }
        };
    }
}
",{}
Find files in a source set,Source sets are a way to organize your source code into logical groups. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.marker.SearchResult;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class HasSourceSet extends Recipe {
    @Option(displayName = ""Source set"",
            description = ""The source set to search for."",
            example = ""main"")
    String sourceSet;

    @Override
    public String getDisplayName() {
        return ""Find files in a source set"";
    }

    @Override
    public String getDescription() {
        return ""Source sets are a way to organize your source code into logical groups. "" +
               ""For example, Java projects commonly have a `main` source set for application code and "" +
               ""a `test` source set for test code. This recipe will find all files in a given source set."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    if (cu.getMarkers().findFirst(JavaSourceSet.class)
                            .filter(s -> s.getName().equals(sourceSet))
                            .isPresent()) {
                        return SearchResult.found(cu);
                    }
                }
                return (J) tree;
            }
        };
    }
}
","{
  ""sourceSet"": ""String field""
}"
Find files that are likely not tests,"Sources that do not contain indicators of being, or being exclusively for the use in tests. ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import org.openrewrite.*;

@Incubating(since = ""7.36.0"")
public class IsLikelyNotTest extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Find files that are likely not tests"";
    }

    @Override
    public String getDescription() {
        return ""Sources that do not contain indicators of being, or being exclusively for the use in tests. "" +
                ""This recipe is simply a negation of the `"" + IsLikelyTest.class.getName() + ""` recipe."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.not(new IsLikelyTest().getVisitor());
    }
}
",{}
Find types,Find type references by name.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.table.TypeUses;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.trait.Trait;

import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

import static java.util.stream.Collectors.toSet;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindTypes extends Recipe {
    transient TypeUses typeUses = new TypeUses(this);

    @Option(displayName = ""Fully-qualified type name"",
            description = ""A fully-qualified type name, that is used to find matching type references. "" +
                          ""Supports glob expressions. `java..*` finds every type from every subpackage of the `java` package."",
            example = ""java.util.List"")
    String fullyQualifiedTypeName;

    @Option(displayName = ""Check for assignability"",
            description = ""When enabled, find type references that are assignable to the provided type."",
            required = false)
    @Nullable
    Boolean checkAssignability;

    @Override
    public String getDisplayName() {
        return ""Find types"";
    }

    @Override
    public String getDescription() {
        return ""Find type references by name."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Pattern fullyQualifiedType = Pattern.compile(StringUtils.aspectjNameToPattern(fullyQualifiedTypeName));

        return Preconditions.check(new UsesType<>(fullyQualifiedTypeName, false), new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof JavaSourceFile || sourceFile instanceof SourceFileWithReferences;
            }

            @Override
            public @Nullable Tree visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    return new JavaSourceFileVisitor(fullyQualifiedType).visit(tree, ctx);
                } else if (tree instanceof SourceFileWithReferences) {
                    SourceFileWithReferences sourceFile = (SourceFileWithReferences) tree;
                    SourceFileWithReferences.References references = sourceFile.getReferences();
                    TypeMatcher matcher = new TypeMatcher(fullyQualifiedTypeName);
                    Set<Tree> matches = references.findMatches(matcher).stream().map(Trait::getTree).collect(toSet());
                    return new ReferenceVisitor(matches).visit(tree, ctx);
                }
                return tree;
            }
        });
    }

    @SuppressWarnings(""unused"")
    public static Set<NameTree> findAssignable(J j, String fullyQualifiedClassName) {
        return find(true, j, fullyQualifiedClassName);
    }

    public static Set<NameTree> find(J j, String fullyQualifiedClassName) {
        return find(false, j, fullyQualifiedClassName);
    }

    private static Set<NameTree> find(boolean checkAssignability, J j, String fullyQualifiedClassName) {
        Pattern fullyQualifiedType = Pattern.compile(StringUtils.aspectjNameToPattern(fullyQualifiedClassName));

        JavaIsoVisitor<Set<NameTree>> findVisitor = new JavaIsoVisitor<Set<NameTree>>() {
            @Override
            public J.Identifier visitIdentifier(J.Identifier ident, Set<NameTree> ns) {
                if (ident.getType() != null) {
                    JavaType.FullyQualified type = TypeUtils.asFullyQualified(ident.getType());
                    if (typeMatches(checkAssignability, fullyQualifiedType, type) && ident.getSimpleName().equals(type.getClassName())) {
                        ns.add(ident);
                    }
                }
                return super.visitIdentifier(ident, ns);
            }

            @Override
            public <N extends NameTree> N visitTypeName(N name, Set<NameTree> ns) {
                N n = super.visitTypeName(name, ns);
                JavaType.FullyQualified type = TypeUtils.asFullyQualified(n.getType());
                if (typeMatches(checkAssignability, fullyQualifiedType, type) &&
                    getCursor().firstEnclosing(J.Import.class) == null) {
                    ns.add(name);
                }
                return n;
            }

            @Override
            public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Set<NameTree> ns) {
                J.FieldAccess fa = super.visitFieldAccess(fieldAccess, ns);
                JavaType.FullyQualified type = TypeUtils.asFullyQualified(fa.getTarget().getType());
                if (typeMatches(checkAssignability, fullyQualifiedType, type) &&
                    ""class"".equals(fa.getName().getSimpleName())) {
                    ns.add(fieldAccess);
                }
                return fa;
            }
        };

        Set<NameTree> ts = new HashSet<>();
        findVisitor.visit(j, ts);
        return ts;
    }

    private static boolean typeMatches(boolean checkAssignability, Pattern pattern,
                                       JavaType.@Nullable FullyQualified test) {
        return test != null && (checkAssignability ?
                test.isAssignableFrom(pattern) :
                pattern.matcher(test.getFullyQualifiedName()).matches()
        );
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class ReferenceVisitor extends TreeVisitor<Tree, ExecutionContext> {
        Set<Tree> matches;

        @Override
        public Tree postVisit(@NonNull Tree tree, ExecutionContext ctx) {
            return matches.contains(tree) ? SearchResult.found(tree) : tree;
        }
    }

    private class JavaSourceFileVisitor extends JavaVisitor<ExecutionContext> {
        private final Pattern fullyQualifiedType;

        public JavaSourceFileVisitor(Pattern fullyQualifiedType) {
            this.fullyQualifiedType = fullyQualifiedType;
        }

        @Override
        public J visitIdentifier(J.Identifier ident, ExecutionContext ctx) {
            if (ident.getType() != null &&
                getCursor().firstEnclosing(J.Import.class) == null &&
                getCursor().firstEnclosing(J.FieldAccess.class) == null &&
                !(getCursor().getParentOrThrow().getValue() instanceof J.ParameterizedType) &&
                !(getCursor().getParentOrThrow().getValue() instanceof J.ArrayType)) {
                JavaType.FullyQualified type = TypeUtils.asFullyQualified(ident.getType());
                if (typeMatches(Boolean.TRUE.equals(checkAssignability), fullyQualifiedType, type) &&
                    ident.getSimpleName().equals(type.getClassName())) {
                    return found(ident, ctx);
                }
            }
            return super.visitIdentifier(ident, ctx);
        }

        @Override
        public <N extends NameTree> N visitTypeName(N name, ExecutionContext ctx) {
            N n = super.visitTypeName(name, ctx);
            JavaType.FullyQualified type = TypeUtils.asFullyQualified(n.getType());
            if (typeMatches(Boolean.TRUE.equals(checkAssignability), fullyQualifiedType, type) &&
                getCursor().firstEnclosing(J.Import.class) == null) {
                return found(n, ctx);
            }
            return n;
        }

        @Override
        public J visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess fa = (J.FieldAccess) super.visitFieldAccess(fieldAccess, ctx);
            JavaType.FullyQualified type = TypeUtils.asFullyQualified(fa.getTarget().getType());
            if (typeMatches(Boolean.TRUE.equals(checkAssignability), fullyQualifiedType, type) &&
                ""class"".equals(fa.getName().getSimpleName())) {
                return found(fa, ctx);
            }
            return fa;
        }

        private <J2 extends TypedTree> J2 found(J2 j, ExecutionContext ctx) {
            JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(j.getType());
            if (!j.getMarkers().findFirst(SearchResult.class).isPresent()) {
                // Avoid double-counting results in the data table
                typeUses.insertRow(ctx, new TypeUses.Row(
                        getCursor().firstEnclosingOrThrow(SourceFile.class).getSourcePath().toString(),
                        j.printTrimmed(getCursor().getParentTreeCursor()),
                        fqn == null ? j.getType().toString() : fqn.getFullyQualifiedName()
                ));
            }
            return SearchResult.found(j);
        }
    }
}
","{
  ""fullyQualifiedTypeName"": ""String field""
}"
Find the oldest Java version in use,The oldest Java version in use is the lowest Java ,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaVersion;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.semver.Semver;
import org.openrewrite.semver.VersionComparator;

import java.util.concurrent.atomic.AtomicReference;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class HasMinimumJavaVersion extends ScanningRecipe<AtomicReference<JavaVersion>> {
    @Option(displayName = ""Java version"",
            description = ""An exact version number or node-style semver selector used to select the version number."",
            example = ""17.X"")
    String version;

    @Option(displayName = ""Version check against target compatibility"",
            description = ""The source and target compatibility versions can be different. This option allows you to "" +
                          ""check against the target compatibility version instead of the source compatibility version."",
            example = ""17.X"",
            required = false)
    @Nullable
    Boolean checkTargetCompatibility;

    @Override
    public String getDisplayName() {
        return ""Find the oldest Java version in use"";
    }

    @Override
    public String getDescription() {
        return ""The oldest Java version in use is the lowest Java "" +
               ""version in use in any source set of any subproject of "" +
               ""a repository. It is possible that, for example, the main "" +
               ""source set of a project uses Java 8, but a test source set "" +
               ""uses Java 17. In this case, the oldest Java version in use is "" +
               ""Java 8."";
    }

    @SuppressWarnings(""ConstantConditions"")
    @Override
    public Validated<Object> validate() {
        Validated<Object> validated = super.validate();
        if (version != null) {
            validated = validated.and(Semver.validate(version, null));
        }
        return validated;
    }

    @Override
    public AtomicReference<JavaVersion> getInitialValue(ExecutionContext ctx) {
        return new AtomicReference<>();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(AtomicReference<JavaVersion> acc) {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                cu.getMarkers().findFirst(JavaVersion.class).ifPresent(javaVersion ->
                    acc.updateAndGet(current -> {
                        if (current == null || javaVersion.getMajorVersion() < current.getMajorVersion()) {
                            return javaVersion;
                        }
                        return current;
                    }));
                return cu;
            }
        };
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor(AtomicReference<JavaVersion> acc) {
        VersionComparator versionComparator = requireNonNull(Semver.validate(version, null).getValue());
        return Preconditions.check(minimumVersionInRange(acc, versionComparator), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                return cu.getMarkers().findFirst(JavaVersion.class)
                        .filter(javaVersion -> acc.get() != null && javaVersion.getMajorVersion() == acc.get().getMajorVersion())
                        .map(javaVersion -> SearchResult.found(cu, ""Java version "" + javaVersion.getMajorVersion()))
                        .orElse(cu);
            }
        });
    }

    private boolean minimumVersionInRange(AtomicReference<JavaVersion> acc, VersionComparator versionComparator) {
        return acc.get() != null && versionComparator.isValid(null, Integer.toString(
                Boolean.TRUE.equals(checkTargetCompatibility) ?
                        acc.get().getMajorReleaseVersion() :
                        acc.get().getMajorVersion()));
    }
}
","{
  ""version"": ""String field""
}"
Find literals,Find literals matching a pattern.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.SearchResult;

import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindLiterals extends Recipe {
    @Option(displayName = ""Pattern"",
            description = ""A regular expression pattern to match literals against."",
            example = ""file://"")
    String pattern;

    @Override
    public String getDisplayName() {
        return ""Find literals"";
    }

    @Override
    public String getDescription() {
        return ""Find literals matching a pattern."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(
                Validated.test(""pattern"", ""Must be a valid regular expression"", pattern,
                        p -> {
                            try {
                                Pattern.compile(p);
                                return true;
                            } catch (PatternSyntaxException e) {
                                return false;
                            }
                        })
        );
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        Pattern compiledPattern = Pattern.compile(pattern);
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Literal visitLiteral(J.Literal literal, ExecutionContext ctx) {
                if (literal.getValueSource() != null) {
                    if (literal.getValue() != null && compiledPattern.matcher(literal.getValue().toString()).matches()) {
                        return SearchResult.found(literal);
                    }
                    if (literal.getType() != JavaType.Primitive.String && compiledPattern.matcher(literal.getValueSource()).matches()) {
                        return SearchResult.found(literal);
                    }
                }
                return literal;
            }
        };
    }
}
","{
  ""pattern"": ""String field""
}"
Find source files with imports,"Locates source files that have imports matching the given type pattern, regardless of whether ",Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindImports extends Recipe {
    @Option(displayName = ""Type pattern"",
            description = ""A type pattern that is used to find matching field uses."",
            example = ""org.springframework..*"",
            required = false)
    @Nullable
    String typePattern;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    @Override
    public String getDisplayName() {
        return ""Find source files with imports"";
    }

    @Override
    public String getInstanceNameSuffix() {
        if (typePattern != null) {
            return ""matching `"" + typePattern + ""`"";
        }
        return super.getInstanceNameSuffix();
    }

    @Override
    public String getDescription() {
        return ""Locates source files that have imports matching the given type pattern, regardless of whether "" +
               ""that import is used in the code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TypeMatcher typeMatcher = new TypeMatcher(typePattern, Boolean.TRUE.equals(matchInherited));
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Import visitImport(J.Import anImport, ExecutionContext ctx) {
                if (typeMatcher.matchesPackage(anImport.getTypeName())) {
                    return SearchResult.found(anImport);
                }
                return super.visitImport(anImport, ctx);
            }
        };
    }
}
",{}
Result of method call ignored,Find locations where the result of the method call is being ignored.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class ResultOfMethodCallIgnored extends Recipe {
    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.io.File mkdir*()"")
    String methodPattern;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Result of method call ignored"";
    }

    @Override
    public String getDescription() {
        return ""Find locations where the result of the method call is being ignored."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        MethodMatcher methodMatcher = new MethodMatcher(methodPattern, matchOverrides);
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (methodMatcher.matches(method)) {
                    if (getCursor().getParentTreeCursor().getValue() instanceof J.Block) {
                        m = SearchResult.found(m);
                    }
                }
                return m;
            }
        };
    }
}
",{}
Find sources that are likely tests,"Sources that contain indicators of being, or being exclusively for the use in tests. ",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.marker.JavaSourceSet;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.marker.SearchResult;

import java.util.Locale;

import static java.util.Objects.requireNonNull;

@Incubating(since = ""7.36.0"")
public class IsLikelyTest extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Find sources that are likely tests"";
    }

    @Override
    public String getDescription() {
        return ""Sources that contain indicators of being, or being exclusively for the use in tests. "" +
               ""This recipe is not exhaustive, but is intended to be a good starting point for finding test sources. "" +
               ""Looks at the source set name, and types in use; for example looks for uses of JUnit & TestNG annotations/assertions."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.or(
                new HasSourceSet(""test"").getVisitor(),
                new HasSourceSetNameContainingTestVisitor<>(),
                new UsesType<>(""org.junit..*"", true), // Covers both JUnit 4 and 5
                new UsesType<>(""org.testng..*"", true),
                new UsesType<>(""org.hamcrest..*"", true),
                new UsesType<>(""org.mockito..*"", true),
                new UsesType<>(""org.powermock..*"", true),
                new UsesType<>(""org.assertj..*"", true),
                new UsesType<>(""spock.lang..*"", true)
        );
    }

    private static class HasSourceSetNameContainingTestVisitor<P> extends JavaIsoVisitor<P> {
        @Override
        public J visit(@Nullable Tree tree, P p) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                if (cu.getMarkers().findFirst(JavaSourceSet.class)
                        .filter(s -> s.getName().toLowerCase(Locale.ROOT).contains(""test""))
                        .isPresent()) {
                    return SearchResult.found(cu);
                }
            }
            return (J) tree;
        }
    }
}
",{}
Find fields of type,Finds declared fields matching a particular class name.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.table.FieldsOfTypeUses;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * Finds fields that have a matching type.
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class FindFieldsOfType extends Recipe {

    @Option(displayName = ""Fully-qualified type name"",
            description = ""A fully-qualified Java type name, that is used to find matching fields."",
            example = ""org.slf4j.api.Logger"")
    String fullyQualifiedTypeName;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    private final transient FieldsOfTypeUses fieldsOfTypeUses = new FieldsOfTypeUses(this);

    @Override
    public String getDisplayName() {
        return ""Find fields of type"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return ""on types `"" + fullyQualifiedTypeName + ""`"";
    }

    @Override
    public String getDescription() {
        return ""Finds declared fields matching a particular class name."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
                if (multiVariable.getTypeExpression() instanceof J.MultiCatch) {
                    return multiVariable;
                }
                if (multiVariable.getTypeExpression() != null &&
                    hasElementType(multiVariable.getTypeExpression().getType(), fullyQualifiedTypeName,
                                Boolean.TRUE.equals(matchInherited)) &&
                    isField(getCursor())) {

                    // Populate the FieldsOfTypeUses DataTable
                    for (J.VariableDeclarations.NamedVariable variable : multiVariable.getVariables()) {
                        String varType = variable.getType().toString();
                        if (variable.getInitializer() != null && variable.getInitializer().getType() != null) {
                            varType = variable.getInitializer().getType().toString();
                        }
                        fieldsOfTypeUses.insertRow(ctx, new FieldsOfTypeUses.Row(
                            getCursor().firstEnclosingOrThrow(J.CompilationUnit.class).getSourcePath().toString(),
                            variable.getSimpleName(),
                            multiVariable.getTypeExpression().getType().toString(),
                            varType,
                            multiVariable.getModifiers().stream().map(J.Modifier::toString).reduce((m1, m2) -> m1 + "" "" + m2).orElse(""""),
                            multiVariable.printTrimmed(getCursor())
                        ));
                    }
                    return SearchResult.found(multiVariable);
                }
                return multiVariable;
            }
        };
    }

    public static Set<J.VariableDeclarations> find(J j, String fullyQualifiedTypeName) {
        JavaIsoVisitor<Set<J.VariableDeclarations>> findVisitor = new JavaIsoVisitor<Set<J.VariableDeclarations>>() {
            @Override
            public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, Set<J.VariableDeclarations> vs) {
                if (multiVariable.getTypeExpression() instanceof J.MultiCatch) {
                    return multiVariable;
                }
                if (multiVariable.getTypeExpression() != null &&
                        hasElementType(multiVariable.getTypeExpression().getType(), fullyQualifiedTypeName, true)  &&
                        isField(getCursor())) {
                    vs.add(multiVariable);
                }
                return multiVariable;
            }
        };

        Set<J.VariableDeclarations> vs = new HashSet<>();
        findVisitor.visit(j, vs);
        return vs;
    }

    private static boolean isField(Cursor cursor) {
        Iterator<Object> path = cursor.getPath();
        while (path.hasNext()) {
            Object o = path.next();
            if (o instanceof J.MethodDeclaration) {
                return false;
            }
            if (o instanceof J.ClassDeclaration) {
                return true;
            }
        }
        return true;
    }

    private static boolean hasElementType(@Nullable JavaType type, String fullyQualifiedName,
                                          boolean matchOverrides) {
        if (type instanceof JavaType.Array) {
            return hasElementType(((JavaType.Array) type).getElemType(), fullyQualifiedName, matchOverrides);
        } else if (type instanceof JavaType.FullyQualified) {
            return new TypeMatcher(fullyQualifiedName, matchOverrides).matches(type);
        } else if (type instanceof JavaType.GenericTypeVariable) {
            JavaType.GenericTypeVariable generic = (JavaType.GenericTypeVariable) type;
            for (JavaType bound : generic.getBounds()) {
                if (hasElementType(bound, fullyQualifiedName, matchOverrides)) {
                    return true;
                }
            }
        }
        return false;
    }
}
","{
  ""fullyQualifiedTypeName"": ""String field""
}"
Find method declaration,Locates the declaration of a method.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindMethodDeclaration extends Recipe {

    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_DESCRIPTION,
            example = ""java.util.List add(..)"")
    String methodPattern;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Find method declaration"";
    }

    @Override
    public String getDescription() {
        return ""Locates the declaration of a method."";
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new DeclaresMethod<>(methodPattern, matchOverrides), new JavaIsoVisitor<ExecutionContext>() {
            final MethodMatcher m = new MethodMatcher(methodPattern, matchOverrides);

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                J.ClassDeclaration cd = getCursor().firstEnclosing(J.ClassDeclaration.class);
                if (cd == null) {
                    return md;
                }
                if (m.matches(md, cd)) {
                    md = SearchResult.found(md);
                }
                return md;
            }
        });
    }
}
",{}
"Find uses of deprecated classes, methods, and fields","Find deprecated uses of methods, fields, and types. Optionally ignore those classes that are inside deprecated scopes.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.Option;
import org.openrewrite.Recipe;

import java.util.Arrays;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDeprecatedUses extends Recipe {
    @Option(displayName = ""Type pattern"",
            description = ""A type pattern that is used to find deprecations from certain types."",
            example = ""org.springframework..*"",
            required = false)
    @Nullable
    String typePattern;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    @Option(displayName = ""Ignore deprecated scopes"",
            description = ""When a deprecated type is used in a deprecated method or class, ignore it."",
            required = false)
    @Nullable
    Boolean ignoreDeprecatedScopes;

    @Override
    public List<Recipe> getRecipeList() {
        return Arrays.asList(
                new FindDeprecatedMethods((typePattern == null || typePattern.isEmpty() ? null : typePattern + "" *(..)""), ignoreDeprecatedScopes),
                new FindDeprecatedClasses(typePattern, matchInherited, ignoreDeprecatedScopes),
                new FindDeprecatedFields(typePattern, matchInherited, ignoreDeprecatedScopes)
        );
    }

    @Override
    public String getDisplayName() {
        return ""Find uses of deprecated classes, methods, and fields"";
    }

    @Override
    public String getInstanceNameSuffix() {
        if (typePattern != null) {
            return ""matching `"" + typePattern + ""`"";
        }
        return super.getInstanceNameSuffix();
    }

    @Override
    public String getDescription() {
        return ""Find deprecated uses of methods, fields, and types. Optionally ignore those classes that are inside deprecated scopes."";
    }
}
",{}
Find annotations,Find all annotations matching the annotation pattern.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Set;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toSet;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindAnnotations extends Recipe {
    /**
     * An annotation pattern, expressed as a method pattern.
     * See {@link AnnotationMatcher} for syntax.
     */
    @Option(displayName = ""Annotation pattern"",
            description = ""An annotation pattern, expressed as a method pattern."",
            example = ""@java.lang.SuppressWarnings(\""deprecation\"")"")
    String annotationPattern;

    @Option(displayName = ""Match on meta annotations"",
            description = ""When enabled, matches on meta annotations of the annotation pattern."",
            required = false)
    @Nullable
    Boolean matchMetaAnnotations;

    @Override
    public String getDisplayName() {
        return ""Find annotations"";
    }

    @Override
    public String getDescription() {
        return ""Find all annotations matching the annotation pattern."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        AnnotationMatcher annotationMatcher = new AnnotationMatcher(annotationPattern, matchMetaAnnotations);
        return Preconditions.check(
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J preVisit(J tree, ExecutionContext ctx) {
                        stopAfterPreVisit();
                        JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                        for (JavaType type : cu.getTypesInUse().getTypesInUse()) {
                            if (annotationMatcher.matchesAnnotationOrMetaAnnotation(TypeUtils.asFullyQualified(type))) {
                                return SearchResult.found(cu);
                            }
                        }
                        return tree;
                    }
                },
                new JavaIsoVisitor<ExecutionContext>() {
                    @Override
                    public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                        J.Annotation a = super.visitAnnotation(annotation, ctx);
                        if (annotationMatcher.matches(annotation)) {
                            a = SearchResult.found(a);
                        }
                        return a;
                    }
                }
        );
    }

    public static Set<J.Annotation> find(J j, String annotationPattern) {
        return find(j, annotationPattern, false);
    }

    public static Set<J.Annotation> find(J j, String annotationPattern, boolean matchMetaAnnotations) {
        return TreeVisitor.collect(
                        new FindAnnotations(annotationPattern, matchMetaAnnotations).getVisitor(),
                        j,
                        new HashSet<>()
                )
                .stream()
                .filter(a -> a instanceof J.Annotation)
                .map(a -> (J.Annotation) a)
                .collect(toSet());
    }
}
",{}
Find uses of deprecated classes,"Find uses of deprecated classes, optionally ignoring those classes that are inside deprecated scopes.",Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.NameTree;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.Iterator;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDeprecatedClasses extends Recipe {

    private static final AnnotationMatcher DEPRECATED_MATCHER = new AnnotationMatcher(""@java.lang.Deprecated"");

    @Option(displayName = ""Type pattern"",
            description = ""A type pattern that is used to find matching classes."",
            example = ""org.springframework..*"",
            required = false)
    @Nullable
    String typePattern;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    @Option(displayName = ""Ignore deprecated scopes"",
            description = ""When a deprecated type is used in a deprecated method or class, ignore it."",
            required = false)
    @Nullable
    Boolean ignoreDeprecatedScopes;

    @Override
    public String getDisplayName() {
        return ""Find uses of deprecated classes"";
    }

    @Override
    public String getInstanceNameSuffix() {
        if (typePattern != null) {
            return ""matching `"" + typePattern + ""`"";
        }
        return super.getInstanceNameSuffix();
    }

    @Override
    public String getDescription() {
        return ""Find uses of deprecated classes, optionally ignoring those classes that are inside deprecated scopes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TypeMatcher typeMatcher = typePattern == null ? null : new TypeMatcher(typePattern,
                Boolean.TRUE.equals(matchInherited));

        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                for (JavaType javaType : cu.getTypesInUse().getTypesInUse()) {
                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(javaType);
                    if (fqn != null && (typeMatcher == null || typeMatcher.matches(fqn))) {
                        for (JavaType.FullyQualified annotation : fqn.getAnnotations()) {
                            if (TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                                return SearchResult.found(cu);
                            }
                        }
                    }
                }
                return cu;
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public <N extends NameTree> N visitTypeName(N nameTree, ExecutionContext ctx) {
                if (getCursor().firstEnclosing(J.Import.class) == null) {
                    JavaType.FullyQualified fqn = TypeUtils.asFullyQualified(nameTree.getType());
                    if (fqn != null && (typeMatcher == null || typeMatcher.matches(fqn))) {
                        for (JavaType.FullyQualified annotation : fqn.getAnnotations()) {
                            if (TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                                if (Boolean.TRUE.equals(ignoreDeprecatedScopes)) {
                                    Iterator<Cursor> cursorPath = getCursor().getPathAsCursors();
                                    while (cursorPath.hasNext()) {
                                        Cursor ancestor = cursorPath.next();
                                        if (ancestor.getValue() instanceof J.MethodDeclaration && isDeprecated(ancestor)) {
                                            return nameTree;
                                        }
                                        if (ancestor.getValue() instanceof J.ClassDeclaration && isDeprecated(ancestor)) {
                                            return nameTree;
                                        }
                                    }
                                }

                                return SearchResult.found(nameTree);
                            }
                        }
                    }
                }

                return nameTree;
            }

            private boolean isDeprecated(Cursor cursor) {
                return service(AnnotationService.class).matches(cursor, DEPRECATED_MATCHER);
            }
        });
    }
}
",{}
Find uses of deprecated fields,Find uses of deprecated fields in any API.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.service.AnnotationService;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.Iterator;

import static java.util.Objects.requireNonNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindDeprecatedFields extends Recipe {

    private static final AnnotationMatcher DEPRECATED_MATCHER = new AnnotationMatcher(""@java.lang.Deprecated"");

    @Option(displayName = ""Type pattern"",
            description = ""A type pattern that is used to find matching field uses."",
            example = ""org.springframework..*"",
            required = false)
    @Nullable
    String typePattern;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    @Option(displayName = ""Ignore deprecated scopes"",
            description = ""When a deprecated method is used in a deprecated method or class, ignore it."",
            required = false)
    @Nullable
    Boolean ignoreDeprecatedScopes;

    @Override
    public String getDisplayName() {
        return ""Find uses of deprecated fields"";
    }

    @Override
    public String getInstanceNameSuffix() {
        if (typePattern != null) {
            return ""matching `"" + typePattern + ""`"";
        }
        return super.getInstanceNameSuffix();
    }

    @Override
    public String getDescription() {
        return ""Find uses of deprecated fields in any API."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        TypeMatcher typeMatcher = typePattern == null ? null : new TypeMatcher(typePattern,
                Boolean.TRUE.equals(matchInherited));

        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    for (JavaType.Variable variable : cu.getTypesInUse().getVariables()) {
                        if (typeMatcher == null || typeMatcher.matches(variable.getOwner())) {
                            for (JavaType.FullyQualified annotation : variable.getAnnotations()) {
                                if (TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                                    return SearchResult.found(cu);
                                }
                            }
                        }
                    }
                }
                return (J) tree;
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
                J.Identifier i = super.visitIdentifier(identifier, ctx);
                JavaType.Variable varType = identifier.getFieldType();
                if (varType != null && (typeMatcher == null || typeMatcher.matches(varType.getOwner()))) {
                    for (JavaType.FullyQualified annotation : varType.getAnnotations()) {
                        if (TypeUtils.isOfClassType(annotation, ""java.lang.Deprecated"")) {
                            if (Boolean.TRUE.equals(ignoreDeprecatedScopes)) {
                                Iterator<Cursor> cursorPath = getCursor().getPathAsCursors();
                                while (cursorPath.hasNext()) {
                                    Cursor ancestor = cursorPath.next();
                                    if (ancestor.getValue() instanceof J.MethodDeclaration && isDeprecated(ancestor)) {
                                        return i;
                                    }
                                    if (ancestor.getValue() instanceof J.ClassDeclaration && isDeprecated(ancestor)) {
                                        return i;
                                    }
                                }
                            }

                            i = SearchResult.found(i);
                        }
                    }
                }

                return i;
            }

            private boolean isDeprecated(Cursor cursor) {
                return service(AnnotationService.class).matches(cursor, DEPRECATED_MATCHER);
            }
        });
    }
}
",{}
Find method usages,Find method calls by pattern.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.table.MethodCalls;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Set;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toSet;

/**
 * Finds matching method invocations.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class FindMethods extends Recipe {
    transient MethodCalls methodCalls = new MethodCalls(this);

    /**
     * A method pattern that is used to find matching method invocations.
     * See {@link MethodMatcher} for details on the expression's syntax.
     */
    @Option(displayName = ""Method pattern"",
            description = MethodMatcher.METHOD_PATTERN_INVOCATIONS_DESCRIPTION,
            example = ""java.util.List add(..)"")
    String methodPattern;

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Find method usages"";
    }

    @Override
    public String getDescription() {
        return ""Find method calls by pattern."";
    }

    @Override
    public String getInstanceName() {
        //noinspection ConstantValue
        if (methodPattern == null) {
            // Temporary while the defensive coding in Recipe is percolating to all
            // deployed environments.
            return getDisplayName();
        }
        return super.getInstanceName();
    }

    @Override
    public Validated<Object> validate() {
        return super.validate().and(MethodMatcher.validate(methodPattern));
    }

    @Override
    @SuppressWarnings(""ConstantConditions"")
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesMethod<>(methodPattern, matchOverrides), new JavaIsoVisitor<ExecutionContext>() {
            final MethodMatcher methodMatcher = new MethodMatcher(methodPattern, matchOverrides);

            @Override
            public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
                // In an annotation @Example(value = """") the identifier ""value"" may have a method type
                J.Identifier i = super.visitIdentifier(identifier, ctx);
                if (i.getType() instanceof JavaType.Method && methodMatcher.matches((JavaType.Method) i.getType()) &&
                    !(getCursor().getParentTreeCursor().getValue() instanceof J.MethodInvocation)) {
                    JavaType.Method m = (JavaType.Method) i.getType();
                    JavaSourceFile javaSourceFile = getCursor().firstEnclosing(JavaSourceFile.class);
                    if (javaSourceFile != null) {
                        methodCalls.insertRow(ctx, new MethodCalls.Row(
                                javaSourceFile.getSourcePath().toString(),
                                m.getName(),
                                m.getDeclaringType().getFullyQualifiedName(),
                                m.getName(),
                                m.getParameterTypes().stream()
                                        .map(String::valueOf)
                                        .collect(joining("", ""))

                        ));
                    }
                    i = SearchResult.found(i);
                }
                return i;
            }

            @Override
            public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
                J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
                if (methodMatcher.matches(method)) {
                    JavaSourceFile javaSourceFile = getCursor().firstEnclosing(JavaSourceFile.class);
                    if (javaSourceFile != null) {
                        methodCalls.insertRow(ctx, new MethodCalls.Row(
                                javaSourceFile.getSourcePath().toString(),
                                method.printTrimmed(getCursor().getParentTreeCursor()),
                                method.getMethodType().getDeclaringType().getFullyQualifiedName(),
                                method.getSimpleName(),
                                method.getArguments().stream()
                                        .map(Expression::getType)
                                        .map(String::valueOf)
                                        .collect(joining("", ""))
                        ));
                    }
                    m = SearchResult.found(m);
                }
                return m;
            }

            @Override
            public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
                J.MemberReference m = super.visitMemberReference(memberRef, ctx);
                if (methodMatcher.matches(m.getMethodType())) {
                    JavaSourceFile javaSourceFile = getCursor().firstEnclosing(JavaSourceFile.class);
                    if (javaSourceFile != null) {
                        methodCalls.insertRow(ctx, new MethodCalls.Row(
                                javaSourceFile.getSourcePath().toString(),
                                memberRef.printTrimmed(getCursor().getParentTreeCursor()),
                                memberRef.getMethodType().getDeclaringType().getFullyQualifiedName(),
                                memberRef.getMethodType().getName(),
                                memberRef.getArguments().stream()
                                        .map(Expression::getType)
                                        .map(String::valueOf)
                                        .collect(joining("", ""))
                        ));
                    }
                    m = m.withReference(SearchResult.found(m.getReference()));
                }
                return m;
            }

            @Override
            public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
                J.NewClass n = super.visitNewClass(newClass, ctx);
                if (methodMatcher.matches(newClass)) {
                    JavaSourceFile javaSourceFile = getCursor().firstEnclosing(JavaSourceFile.class);
                    if (javaSourceFile != null) {
                        methodCalls.insertRow(ctx, new MethodCalls.Row(
                                javaSourceFile.getSourcePath().toString(),
                                newClass.printTrimmed(getCursor().getParentTreeCursor()),
                                newClass.getType().toString(),
                                ""<constructor>"",
                                newClass.getArguments().stream()
                                        .map(Expression::getType)
                                        .map(String::valueOf)
                                        .collect(joining("", ""))
                        ));
                    }
                    n = SearchResult.found(n);
                }
                return n;
            }
        });
    }

    public static Set<J> find(J j, String methodPattern) {
        return find(j, methodPattern, false);
    }

    /**
     * @param j              The subtree to search.
     * @param methodPattern  A method pattern. See {@link MethodMatcher} for details about this syntax.
     * @param matchOverrides Whether to match overrides.
     * @return A set of {@link J.MethodInvocation}, {@link J.MemberReference}, and {@link J.NewClass} representing calls to this method.
     */
    public static Set<J> find(J j, String methodPattern, boolean matchOverrides) {
        FindMethods findMethods = new FindMethods(methodPattern, matchOverrides);
        findMethods.methodCalls.setEnabled(false);
        return TreeVisitor.collect(
                        findMethods.getVisitor(),
                        j,
                        new HashSet<>()
                )
                .stream()
                .filter(t -> t instanceof J.MethodInvocation || t instanceof J.MemberReference || t instanceof J.NewClass)
                .map(t -> (J) t)
                .collect(toSet());
    }

    public static Set<J.MethodDeclaration> findDeclaration(J j, String methodPattern) {
        return findDeclaration(j, methodPattern, false);
    }

    public static Set<J.MethodDeclaration> findDeclaration(J j, String methodPattern, boolean matchOverrides) {
        return TreeVisitor.collect(
                        new JavaIsoVisitor<ExecutionContext>() {
                            final MethodMatcher methodMatcher = new MethodMatcher(methodPattern, matchOverrides);

                            @Override
                            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                                J.ClassDeclaration enclosingClass = getCursor().firstEnclosing(J.ClassDeclaration.class);
                                if (enclosingClass != null && methodMatcher.matches(method, getCursor().firstEnclosingOrThrow(J.ClassDeclaration.class))) {
                                    return SearchResult.found(method);
                                } else if (methodMatcher.matches(method.getMethodType())) {
                                    return SearchResult.found(method);
                                }
                                return super.visitMethodDeclaration(method, ctx);
                            }
                        },
                        j,
                        new HashSet<>()
                )
                .stream()
                .filter(J.MethodDeclaration.class::isInstance)
                .map(J.MethodDeclaration.class::cast)
                .collect(toSet());
    }
}
",{}
Find methods with empty bodies,Find methods with empty bodies and single public no arg constructors.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Option;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;
import static java.util.stream.Collectors.toList;

@EqualsAndHashCode(callSuper = false)
@Value
public class FindEmptyMethods extends Recipe {

    @Option(displayName = ""Match on overrides"",
            description = ""When enabled, find methods that are overrides of the method pattern."",
            required = false)
    @Nullable
    Boolean matchOverrides;

    @Override
    public String getDisplayName() {
        return ""Find methods with empty bodies"";
    }

    @Override
    public String getDescription() {
        return ""Find methods with empty bodies and single public no arg constructors."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S1186"");
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
                if (classDecl.hasModifier(J.Modifier.Type.Abstract)) {
                    return classDecl;
                }

                if (hasSinglePublicNoArgsConstructor(classDecl.getBody().getStatements())) {
                    getCursor().putMessage(""CHECK_CONSTRUCTOR"", true);
                }

                return super.visitClassDeclaration(classDecl, ctx);
            }

            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                Boolean checkConstructor = null;
                if (method.isConstructor()) {
                    checkConstructor = getCursor().getNearestMessage(""CHECK_CONSTRUCTOR"") != null;
                }
                if (checkConstructor != null && checkConstructor || isEmptyMethod(method)) {
                    method = SearchResult.found(method);
                }
                return super.visitMethodDeclaration(method, ctx);
            }

            private boolean isEmptyMethod(J.MethodDeclaration method) {
                return !method.isConstructor() && !isInterfaceMethod(method) &&
                       (matchOverrides == null || !matchOverrides && !TypeUtils.isOverride(method.getMethodType()) || matchOverrides) &&
                       (method.getBody() == null || method.getBody().getStatements().isEmpty() && method.getBody().getEnd().getComments().isEmpty());
            }

            private boolean isInterfaceMethod(J.MethodDeclaration method) {
                //noinspection ConstantConditions
                return method.getMethodType() != null &&
                       method.getMethodType().getDeclaringType() != null &&
                       method.getMethodType().getDeclaringType().getKind() == JavaType.FullyQualified.Kind.Interface &&
                       !method.hasModifier(J.Modifier.Type.Default);
            }

            private boolean hasSinglePublicNoArgsConstructor(List<Statement> classStatements) {
                List<J.MethodDeclaration> constructors = classStatements.stream()
                        .filter(o -> o instanceof J.MethodDeclaration)
                        .map(o -> (J.MethodDeclaration) o)
                        .filter(J.MethodDeclaration::isConstructor)
                        .collect(toList());
                return constructors.size() == 1 &&
                       constructors.get(0).hasModifier(J.Modifier.Type.Public) &&
                       constructors.get(0).getParameters().size() == 1 &&
                       constructors.get(0).getParameters().get(0) instanceof J.Empty;
            }
        };
    }
}
",{}
Find missing type information on Java LSTs,This is a diagnostic recipe to highlight where LSTs are missing type attribution information.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavadocVisitor;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Marker;
import org.openrewrite.marker.SearchResult;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.joining;
import static org.openrewrite.java.tree.TypeUtils.isWellFormedType;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindMissingTypes extends Recipe {

    @Option(displayName = ""Check documentation"",
            description = ""When set to `true` any references in documentation (i.e. Javadoc for Java) will also be checked. Default is `false`."",
            required = false
    )
    boolean checkDocumentation;

    @Override
    public String getDisplayName() {
        return ""Find missing type information on Java LSTs"";
    }

    @Override
    public String getDescription() {
        return ""This is a diagnostic recipe to highlight where LSTs are missing type attribution information."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new FindMissingTypesVisitor(checkDocumentation);
    }

    public static List<MissingTypeResult> findMissingTypes(J j, boolean checkDocumentation) {
        J j1 = new FindMissingTypesVisitor(checkDocumentation).visit(j, new InMemoryExecutionContext());
        List<MissingTypeResult> results = new ArrayList<>();
        if (j1 != j) {
            new JavaIsoVisitor<List<MissingTypeResult>>() {
                @Override
                public <M extends Marker> M visitMarker(Marker marker, List<MissingTypeResult> missingTypeResults) {
                    if (marker instanceof SearchResult) {
                        String message = ((SearchResult) marker).getDescription();
                        String path = getCursor()
                                .getPathAsStream(j -> j instanceof J || j instanceof Javadoc)
                                .map(t -> t.getClass().getSimpleName())
                                .collect(joining(""->""));
                        J j = getCursor().firstEnclosing(J.class);
                        if (j != null) {
                            String printedTree;
                            if (getCursor().firstEnclosing(JavaSourceFile.class) != null) {
                                printedTree = j.printTrimmed(new InMemoryExecutionContext(), getCursor().getParentOrThrow());
                            } else {
                                printedTree = String.valueOf(j);
                            }
                            missingTypeResults.add(new MissingTypeResult(message, path, printedTree, j));
                        }
                    }
                    return super.visitMarker(marker, missingTypeResults);
                }
            }.visit(j1, results);
        }
        return results;
    }

    @Getter
    @AllArgsConstructor
    public static class MissingTypeResult {
        @Nullable
        String message;

        String path;
        String printedTree;
        J j;
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    static class FindMissingTypesVisitor extends JavaIsoVisitor<ExecutionContext> {

        boolean checkDocumentation;
        Set<JavaType> seenTypes = new HashSet<>();

        @Override
        public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
            // The non-nullability of J.Identifier.getType() in our AST is a white lie
            // J.Identifier.getType() is allowed to be null in places where the containing AST element fully specifies the type
            if (!isWellFormedType(identifier.getType(), seenTypes) && !isAllowedToHaveNullType(identifier)) {
                identifier = SearchResult.found(identifier, ""Identifier type is missing or malformed"");
            }
            if (identifier.getFieldType() != null && !identifier.getSimpleName().equals(identifier.getFieldType().getName())) {
                identifier = SearchResult.found(identifier, ""type information has a different variable name '"" + identifier.getFieldType().getName() + ""'"");
            }
            return identifier;
        }

        @Override
        public J.VariableDeclarations.NamedVariable visitVariable(J.VariableDeclarations.NamedVariable variable, ExecutionContext ctx) {
            J.VariableDeclarations.NamedVariable v = super.visitVariable(variable, ctx);
            if (v == variable) {
                JavaType.Variable variableType = v.getVariableType();
                if (!isWellFormedType(variableType, seenTypes) && !isAllowedToHaveUnknownType()) {
                    v = SearchResult.found(v, ""Variable type is missing or malformed"");
                } else if (variableType != null && !variableType.getName().equals(v.getSimpleName())) {
                    v = SearchResult.found(v, ""type information has a different variable name '"" + variableType.getName() + ""'"");
                }
            }
            return v;
        }

        private boolean isAllowedToHaveUnknownType() {
            Cursor parent = getCursor().getParent();
            while (parent != null && parent.getParent() != null && !(parent.getParentTreeCursor().getValue() instanceof J.ClassDeclaration)) {
                parent = parent.getParentTreeCursor();
            }
            // If the variable is declared in a class initializer, then it's allowed to have unknown type
            return parent != null && parent.getValue() instanceof J.Block;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            // If one of the method's arguments or type parameters is missing type, then the invocation very likely will too
            // Avoid over-reporting the same problem by checking the invocation only when its elements are well-formed
            if (mi == method) {
                JavaType.Method type = mi.getMethodType();
                if (!isWellFormedType(type, seenTypes)) {
                    mi = SearchResult.found(mi, ""MethodInvocation type is missing or malformed"");
                } else if (!type.getName().equals(mi.getSimpleName()) && !type.isConstructor()) {
                    mi = SearchResult.found(mi, ""type information has a different method name '"" + type.getName() + ""'"");
                }
                if (mi.getName().getType() != null && type != null && type != mi.getName().getType()) {
                    // The MethodDeclaration#name#type and the methodType field should be the same object.
                    // A different object in one implies a type has changed, either in the method signature or deeper in the type tree.
                    mi = SearchResult.found(mi, ""MethodInvocation#name#type is not the same instance as the MethodType of MethodInvocation."");
                }
                if (type != null) {
                    int argCount = 0;
                    for (Expression argument : mi.getArguments()) {
                        if (!(argument instanceof J.Empty)) {
                            argCount++;
                        }
                    }
                    int minCount = type.hasFlags(Flag.Varargs) ? type.getParameterTypes().size() - 1 : type.getParameterTypes().size();
                    if (argCount < minCount) {
                        mi = SearchResult.found(mi, ""argument count mismatch: "" + argCount + "" != "" + type.getParameterTypes().size());
                    }
                }
            }
            return mi;
        }

        @Override
        public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
            J.MemberReference mr = super.visitMemberReference(memberRef, ctx);
            JavaType.Method type = mr.getMethodType();
            if (type != null) {
                if (!isWellFormedType(type, seenTypes)) {
                    mr = SearchResult.found(mr, ""MemberReference type is missing or malformed"");
                } else if (!type.getName().equals(mr.getReference().getSimpleName()) && !type.isConstructor()) {
                    mr = SearchResult.found(mr, ""type information has a different method name '"" + type.getName() + ""'"");
                }
            } else {
                JavaType.Variable variableType = mr.getVariableType();
                if (!isWellFormedType(variableType, seenTypes)) {
                    mr = SearchResult.found(mr, ""MemberReference type is missing or malformed"");
                } else if (!variableType.getName().equals(mr.getReference().getSimpleName())) {
                    mr = SearchResult.found(mr, ""type information has a different variable name '"" + variableType.getName() + ""'"");
                }
            }
            return mr;
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = method;
            JavaType.Method type = md.getMethodType();
            if (!isWellFormedType(type, seenTypes)) {
                md = SearchResult.found(md, ""MethodDeclaration type is missing or malformed"");
            } else if (!md.getSimpleName().equals(type.getName()) && !type.isConstructor()) {
                md = SearchResult.found(md, ""type information has a different method name '"" + type.getName() + ""'"");
            }
            if (md.getName().getType() != null && type != null && type != md.getName().getType()) {
                // The MethodDeclaration#name#type and the methodType field should be the same object.
                // A different object in one implies a type has changed, either in the method signature or deeper in the type tree.
                md = SearchResult.found(md, ""MethodDeclaration#name#type is not the same instance as the MethodType of MethodDeclaration."");
            }
            return super.visitMethodDeclaration(md, ctx);
        }

        @Override
        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);
            JavaType.FullyQualified t = cd.getType();
            if (!isWellFormedType(t, seenTypes)) {
                return SearchResult.found(cd, ""ClassDeclaration type is missing or malformed"");
            }
            if (!cd.getKind().name().equals(t.getKind().name())) {
                cd = SearchResult.found(cd,
                        "" J.ClassDeclaration kind "" + cd.getKind() + "" does not match the kind in its type information "" + t.getKind());
            }
            J.CompilationUnit jc = getCursor().firstEnclosing(J.CompilationUnit.class);
            if (jc != null) {
                J.Package pkg = jc.getPackageDeclaration();
                if (pkg != null && t.getPackageName().equals(pkg.printTrimmed(getCursor()))) {
                    cd = SearchResult.found(cd,
                            "" J.ClassDeclaration package "" + pkg + "" does not match the package in its type information "" + pkg.printTrimmed(getCursor()));
                }
            }
            return cd;
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass n = super.visitNewClass(newClass, ctx);
            if (n == newClass && !isWellFormedType(n.getType(), seenTypes)) {
                n = SearchResult.found(n, ""NewClass type is missing or malformed"");
            }
            if (n.getClazz() instanceof J.Identifier && n.getClazz().getType() != null &&
                    !(n.getClazz().getType() instanceof JavaType.Class || n.getClazz().getType() instanceof JavaType.Unknown)) {
                n = SearchResult.found(n, ""NewClass#clazz is J.Identifier and the type is is not JavaType$Class."");
            }
            return n;
        }

        @Override
        public J.ParameterizedType visitParameterizedType(J.ParameterizedType type, ExecutionContext ctx) {
            J.ParameterizedType p = super.visitParameterizedType(type, ctx);
            if (p.getClazz() instanceof J.Identifier && p.getClazz().getType() != null &&
                    !(p.getClazz().getType() instanceof JavaType.Class || p.getClazz().getType() instanceof JavaType.Unknown)) {
                p = SearchResult.found(p, ""ParameterizedType#clazz is J.Identifier and the type is is not JavaType$Class."");
            }
            return p;
        }

        @Override
        protected JavadocVisitor<ExecutionContext> getJavadocVisitor() {
            return new JavadocVisitor<ExecutionContext>(this) {
                @Override
                public @Nullable Javadoc visit(@Nullable Tree tree, ExecutionContext ctx) {
                    return checkDocumentation ? super.visit(tree, ctx) : (Javadoc) tree;
                }
            };
        }

        private boolean isAllowedToHaveNullType(J.Identifier ident) {
            return inPackageDeclaration() || inImport() || isClassName() ||
                    isMethodName() || isMethodInvocationName() || isFieldAccess(ident) || isBeingDeclared(ident) || isParameterizedType(ident) ||
                    isNewClass(ident) || isTypeParameter() || isMemberReference(ident) || isCaseLabel() || isLabel() || isAnnotationField(ident) ||
                    isInJavaDoc(ident);
        }

        private boolean inPackageDeclaration() {
            return getCursor().firstEnclosing(J.Package.class) != null;
        }

        private boolean inImport() {
            return getCursor().firstEnclosing(J.Import.class) != null;
        }

        private boolean isClassName() {
            Cursor parent = getCursor().getParent();
            return parent != null && parent.getValue() instanceof J.ClassDeclaration;
        }

        private boolean isMethodName() {
            Cursor parent = getCursor().getParent();
            return parent != null && parent.getValue() instanceof J.MethodDeclaration;
        }

        private boolean isMethodInvocationName() {
            Cursor parent = getCursor().getParent();
            return parent != null && parent.getValue() instanceof J.MethodInvocation;
        }

        private boolean isFieldAccess(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof J.FieldAccess &&
                    (ident == ((J.FieldAccess) value).getName() ||
                        ident == ((J.FieldAccess) value).getTarget() && !""class"".equals(((J.FieldAccess) value).getSimpleName()));
        }

        private boolean isBeingDeclared(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof J.VariableDeclarations.NamedVariable && ident == ((J.VariableDeclarations.NamedVariable) value).getName();
        }

        private boolean isParameterizedType(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof J.ParameterizedType && ident == ((J.ParameterizedType) value).getClazz();
        }

        private boolean isNewClass(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof J.NewClass && ident == ((J.NewClass) value).getClazz();
        }

        private boolean isTypeParameter() {
            return getCursor().getParent() != null &&
                    getCursor().getParent().getValue() instanceof J.TypeParameter;
        }

        private boolean isMemberReference(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof J.MemberReference &&
                   ident == ((J.MemberReference) value).getReference();
        }

        private boolean isInJavaDoc(J.Identifier ident) {
            Tree value = getCursor().getParentTreeCursor().getValue();
            return value instanceof Javadoc.Reference &&
                    ident == ((Javadoc.Reference) value).getTree();
        }

        private boolean isCaseLabel() {
            return getCursor().getParentTreeCursor().getValue() instanceof J.Case;
        }

        private boolean isLabel() {
            return getCursor().firstEnclosing(J.Label.class) != null;
        }

        private boolean isAnnotationField(J.Identifier ident) {
            Cursor parent = getCursor().getParent();
            return parent != null && parent.getValue() instanceof J.Assignment &&
                    (ident == ((J.Assignment) parent.getValue()).getVariable() && getCursor().firstEnclosing(J.Annotation.class) != null);
        }

    }
}
",{}
Find uses of `@Repeatable` annotations,Java 8 introduced the concept of `@Repeatable` annotations.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.java.tree.TypeUtils;
import org.openrewrite.marker.SearchResult;

import static java.util.Objects.requireNonNull;

public class FindRepeatableAnnotations extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Find uses of `@Repeatable` annotations"";
    }

    @Override
    public String getDescription() {
        return ""Java 8 introduced the concept of `@Repeatable` annotations."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new JavaVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                    for (JavaType javaType : cu.getTypesInUse().getTypesInUse()) {
                        if (isRepeatable(javaType)) {
                            return SearchResult.found(cu);
                        }
                    }
                    return cu;
                }
                return (J) tree;
            }
        }, new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
                if (isRepeatable(annotation.getType())) {
                    return SearchResult.found(annotation);
                }
                return super.visitAnnotation(annotation, ctx);
            }
        });
    }

    public static boolean isRepeatable(@Nullable JavaType javaType) {
        JavaType.FullyQualified type = TypeUtils.asFullyQualified(javaType);
        if (type != null && TypeUtils.isAssignableTo(""java.lang.annotation.Annotation"", type)) {
            for (JavaType.FullyQualified ann : type.getAnnotations()) {
                if (TypeUtils.isOfClassType(ann, ""java.lang.annotation.Repeatable"")) {
                    return true;
                }
            }
        }
        return false;
    }
}
",{}
Find compile errors,Compile errors result in a particular LST structure that can be searched for.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.table.CompileErrors;
import org.openrewrite.java.tree.J;
import org.openrewrite.marker.SearchResult;

public class FindCompileErrors extends Recipe {

    transient CompileErrors report = new CompileErrors(this);

    @Override
    public String getDisplayName() {
        return ""Find compile errors"";
    }

    @Override
    public String getDescription() {
        return ""Compile errors result in a particular LST structure that can be searched for."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.Erroneous visitErroneous(J.Erroneous erroneous, ExecutionContext ctx) {
                J.CompilationUnit cu = getCursor().firstEnclosing(J.CompilationUnit.class);
                String sourceFile = cu != null ? cu.getSourcePath().toString() : ""Unknown source file"";
                String code = erroneous.print(getCursor());
                report.insertRow(ctx, new CompileErrors.Row(
                        sourceFile,
                        code
                ));
                return SearchResult.found(erroneous);
            }
        };
    }
}
",{}
Find fields,Find uses of a field.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.search;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.TypeMatcher;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaType;
import org.openrewrite.marker.SearchResult;

import java.util.HashSet;
import java.util.Set;

@Value
@EqualsAndHashCode(callSuper = false)
public class FindFields extends Recipe {
    @Option(displayName = ""Fully-qualified type name"",
            description = ""A fully-qualified Java type name, that is used to find matching fields."",
            example = ""com.fasterxml.jackson.core.json.JsonWriteFeature"")
    String fullyQualifiedTypeName;

    @Option(displayName = ""Match inherited"",
            description = ""When enabled, find types that inherit from a deprecated type."",
            required = false)
    @Nullable
    Boolean matchInherited;

    @Option(displayName = ""Field name"",
            description = ""The name of a field on the type."",
            example = ""QUOTE_FIELD_NAMES"")
    String fieldName;

    @Override
    public String getDisplayName() {
        return ""Find fields"";
    }

    @Override
    public String getInstanceNameSuffix() {
        return ""on types `"" + fullyQualifiedTypeName + ""`"";
    }

    @Override
    public String getDescription() {
        return ""Find uses of a field."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new UsesField<>(fullyQualifiedTypeName, fieldName), new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
                JavaType.Variable varType = fieldAccess.getName().getFieldType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, Boolean.TRUE.equals(matchInherited)).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    return SearchResult.found(fieldAccess);
                }
                return super.visitFieldAccess(fieldAccess, ctx);
            }

            @Override
            public J.Identifier visitIdentifier(J.Identifier identifier, ExecutionContext ctx) {
                J.Identifier i = super.visitIdentifier(identifier, ctx);
                JavaType.Variable varType = identifier.getFieldType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, Boolean.TRUE.equals(matchInherited)).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    i = SearchResult.found(i);
                }
                return i;
            }

            @Override
            public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
                J.MemberReference m = super.visitMemberReference(memberRef, ctx);
                JavaType.Variable varType = memberRef.getVariableType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, Boolean.TRUE.equals(matchInherited)).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    m = m.withReference(SearchResult.found(m.getReference()));
                }
                return m;
            }
        });
    }

    public static Set<J> find(J j, String fullyQualifiedTypeName, String fieldName) {
        JavaVisitor<Set<J>> findVisitor = new JavaIsoVisitor<Set<J>>() {
            @Override
            public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, Set<J> vs) {
                J.FieldAccess f = super.visitFieldAccess(fieldAccess, vs);
                JavaType.Variable varType = fieldAccess.getName().getFieldType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, true).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    vs.add(f);
                }
                return f;
            }

            @Override
            public J.Identifier visitIdentifier(J.Identifier identifier, Set<J> vs) {
                J.Identifier i = super.visitIdentifier(identifier, vs);
                JavaType.Variable varType = identifier.getFieldType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, true).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    vs.add(i);
                }
                return i;
            }

            @Override
            public J.MemberReference visitMemberReference(J.MemberReference memberRef, Set<J> vs) {
                J.MemberReference m = super.visitMemberReference(memberRef, vs);
                JavaType.Variable varType = memberRef.getVariableType();
                if (varType != null && new TypeMatcher(fullyQualifiedTypeName, true).matches(varType.getOwner()) &&
                    StringUtils.matchesGlob(varType.getName(), fieldName)) {
                    vs.add(m);
                }
                return m;
            }
        };

        Set<J> vs = new HashSet<>();
        findVisitor.visit(j, vs);
        return vs;
    }
}
","{
  ""fullyQualifiedTypeName"": ""String field"",
  ""fieldName"": ""String field""
}"
Calculate token length of method definitions,Locates method definitions and predicts the number of token in each.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.ai;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.table.TokenCount;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class MethodDefinitionLength extends Recipe {
    transient TokenCount tokens = new TokenCount(this);

    @Override
    public String getDisplayName() {
        return ""Calculate token length of method definitions"";
    }

    @Override
    public String getDescription() {
        return ""Locates method definitions and predicts the number of token in each."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {

        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
                J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
                J.ClassDeclaration cd = getCursor().firstEnclosing(J.ClassDeclaration.class);
                if (cd == null) {
                    return md;
                }
                int numberOfTokens = (int) (md.printTrimmed(getCursor()).length() / 3.5);
                tokens.insertRow(ctx, new TokenCount.Row(md.getSimpleName(), numberOfTokens));
                return md;
            }
        };
    }
}
",{}
Calculate token length of classes,Locates class definitions and predicts the number of token in each.,Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.ai;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.table.TokenCount;
import org.openrewrite.java.tree.J;

@Value
@EqualsAndHashCode(callSuper = false)
public class ClassDefinitionLength extends Recipe {
    transient TokenCount tokens = new TokenCount(this);

    @Override
    public String getDisplayName() {
        return ""Calculate token length of classes"";
    }

    @Override
    public String getDescription() {
        return ""Locates class definitions and predicts the number of token in each."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration clazz, ExecutionContext ctx) {
                J.ClassDeclaration cd = getCursor().firstEnclosing(J.ClassDeclaration.class);
                if (cd == null) {
                    return cd;
                }
                int numberOfTokens = (int) (cd.printTrimmed(getCursor()).length() / 3.5);
                tokens.insertRow(ctx, new TokenCount.Row(cd.getSimpleName(), numberOfTokens));
                return cd;
            }
        };
    }
}
",{}
Remove trailing whitespace,Remove any extra trailing whitespace from the end of each line.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class RemoveTrailingWhitespace extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Remove trailing whitespace"";
    }

    @Override
    public String getDescription() {
        return ""Remove any extra trailing whitespace from the end of each line."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new RemoveTrailingWhitespaceVisitor<>();
    }
}
",{}
Normalize line breaks,Consistently use either Windows style (CRLF) or Linux style (LF) line breaks. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.GeneralFormatStyle;

import static java.util.Objects.requireNonNull;
import static org.openrewrite.java.format.AutodetectGeneralFormatStyle.autodetectGeneralFormatStyle;

public class NormalizeLineBreaks extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Normalize line breaks"";
    }

    @Override
    public String getDescription() {
        return ""Consistently use either Windows style (CRLF) or Linux style (LF) line breaks. "" +
               ""If no `GeneralFormatStyle` is specified this will use whichever style of line endings are more common."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new LineBreaksFromCompilationUnitStyle();
    }

    private static class LineBreaksFromCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                GeneralFormatStyle generalFormatStyle = ((SourceFile) cu).getStyle(GeneralFormatStyle.class);
                if (generalFormatStyle == null) {
                    generalFormatStyle = autodetectGeneralFormatStyle(cu);
                }
                doAfterVisit(new NormalizeLineBreaksVisitor<>(generalFormatStyle));
            }
            return (J) tree;
        }
    }
}
",{}
Normalize format,Move whitespace to the outermost LST element possible.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

/**
 * Ensures that whitespace is on the outermost AST element possible.
 */
public class NormalizeFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Normalize format"";
    }

    @Override
    public String getDescription() {
        return ""Move whitespace to the outermost LST element possible."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new NormalizeFormatVisitor<>();
    }
}
",{}
Wrapping and braces,Format line wraps and braces in Java code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.WrappingAndBracesStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

import java.time.Duration;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

import static java.util.Objects.requireNonNull;

public class WrappingAndBraces extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Wrapping and braces"";
    }

    @Override
    public String getDescription() {
        return ""Format line wraps and braces in Java code."";
    }

    @Override
    public Set<String> getTags() {
        return new LinkedHashSet<>(Arrays.asList(""RSPEC-S121"", ""RSPEC-S2681"", ""RSPEC-S3972"", ""RSPEC-S3973""));
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(10);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new WrappingAndBracesCompilationUnitStyle();
    }

    private static class WrappingAndBracesCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                WrappingAndBracesStyle style = ((SourceFile) cu).getStyle(WrappingAndBracesStyle.class);
                if (style == null) {
                    style = IntelliJ.wrappingAndBraces();
                }
                return new WrappingAndBracesVisitor<>(style).visit(cu, ctx);
            }
            return (J) tree;
        }
    }

    public static <J2 extends J> J2 formatWrappingAndBraces(J j, Cursor cursor) {
        SourceFile sourceFile = cursor.firstEnclosingOrThrow(SourceFile.class);
        WrappingAndBracesStyle style = Style.from(WrappingAndBracesStyle.class, sourceFile);
        //noinspection unchecked
        return (J2) new WrappingAndBracesVisitor<>(style == null ? IntelliJ.wrappingAndBraces() : style)
                .visitNonNull(j, 0, cursor);
    }
}
",{}
Typecast parentheses padding,Fixes whitespace padding between a typecast type identifier and the enclosing left and right parenthesis. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.Checkstyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.SpacesStyle;
import org.openrewrite.java.style.TypecastParenPadStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import java.util.Optional;

import static java.util.Objects.requireNonNull;

public class TypecastParenPad extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Typecast parentheses padding"";
    }

    @Override
    public String getDescription() {
        return ""Fixes whitespace padding between a typecast type identifier and the enclosing left and right parenthesis. "" +
               ""For example, when configured to remove spacing, `( int ) 0L;` becomes `(int) 0L;`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TypecastParenPadVisitor();
    }

    private static class TypecastParenPadVisitor extends JavaIsoVisitor<ExecutionContext> {
        SpacesStyle spacesStyle;
        TypecastParenPadStyle typecastParenPadStyle;

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                SourceFile cu = (SourceFile) requireNonNull(tree);
                spacesStyle = Optional.ofNullable(cu.getStyle(SpacesStyle.class)).orElse(IntelliJ.spaces());
                typecastParenPadStyle = Optional.ofNullable(cu.getStyle(TypecastParenPadStyle.class)).orElse(Checkstyle.typecastParenPadStyle());

                spacesStyle = spacesStyle.withWithin(spacesStyle.getWithin().withTypeCastParentheses(typecastParenPadStyle.getSpace()));
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J.TypeCast visitTypeCast(J.TypeCast typeCast, ExecutionContext ctx) {
            J.TypeCast tc = super.visitTypeCast(typeCast, ctx);
            return (J.TypeCast) new SpacesVisitor<>(spacesStyle, null, null, tc)
                    .visitNonNull(tc, ctx, getCursor().getParentTreeCursor().fork());
        }
    }

}
",{}
Pad empty `for` loop components,Fixes padding on empty `for` loop iterators and initializers to match Checkstyle policies.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.EmptyForInitializerPadStyle;
import org.openrewrite.java.style.EmptyForIteratorPadStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.Statement;
import org.openrewrite.marker.SearchResult;
import org.openrewrite.style.Style;

import java.util.List;

import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static org.openrewrite.Tree.randomId;

public class PadEmptyForLoopComponents extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Pad empty `for` loop components"";
    }

    @Override
    public String getDescription() {
        return ""Fixes padding on empty `for` loop iterators and initializers to match Checkstyle policies."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return Preconditions.check(new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    SourceFile cu = (SourceFile) requireNonNull(tree);
                    if (cu.getStyle(EmptyForIteratorPadStyle.class) != null || cu.getStyle(EmptyForInitializerPadStyle.class) != null) {
                        return cu.withMarkers(cu.getMarkers().add(new SearchResult(randomId(), null)));
                    }
                    return (JavaSourceFile) cu;
                }
                return (J) tree;
            }
        }, new JavaIsoVisitor<ExecutionContext>() {
            @Nullable
            EmptyForIteratorPadStyle emptyForIteratorPadStyle;

            @Nullable
            EmptyForInitializerPadStyle emptyForInitializerPadStyle;

            @Override
            public J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    SourceFile cu = (SourceFile) requireNonNull(tree);
                    emptyForInitializerPadStyle = Style.from(EmptyForInitializerPadStyle.class, cu);
                    emptyForIteratorPadStyle = Style.from(EmptyForIteratorPadStyle.class, cu);
                }
                return super.visit(tree, ctx);
            }

            @Override
            public J.ForLoop visitForLoop(J.ForLoop forLoop, ExecutionContext ctx) {
                J.ForLoop fl = super.visitForLoop(forLoop, ctx);
                List<Statement> updates = forLoop.getControl().getUpdate();
                if (emptyForIteratorPadStyle != null && updates.size() == 1 && updates.get(0) instanceof J.Empty) {
                    Statement update = updates.get(0);
                    if (emptyForIteratorPadStyle.getSpace() && update.getPrefix().getWhitespace().isEmpty()) {
                        update = update.withPrefix(update.getPrefix().withWhitespace("" ""));
                    } else if (!emptyForIteratorPadStyle.getSpace() && !update.getPrefix().getWhitespace().isEmpty()) {
                        update = update.withPrefix(update.getPrefix().withWhitespace(""""));
                    }
                    fl = fl.withControl(fl.getControl().withUpdate(singletonList(update)));
                }

                List<Statement> init = forLoop.getControl().getInit();
                if (emptyForInitializerPadStyle != null && init.get(0) instanceof J.Empty) {
                    if (emptyForInitializerPadStyle.getSpace() && init.get(0).getPrefix().getWhitespace().isEmpty()) {
                        init = ListUtils.mapFirst(init, i -> i.withPrefix(i.getPrefix().withWhitespace("" "")));
                    } else if (!emptyForInitializerPadStyle.getSpace() && !init.get(0).getPrefix().getWhitespace().isEmpty()) {
                        init = ListUtils.mapFirst(init, i -> i.withPrefix(i.getPrefix().withWhitespace("""")));
                    }
                    fl = fl.withControl(fl.getControl().withInit(init));
                }
                return fl;
            }
        });
    }
}
",{}
Normalize to tabs or spaces,Consistently use either tabs or spaces in indentation.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.TabsAndIndentsStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import static java.util.Objects.requireNonNull;

public class NormalizeTabsOrSpaces extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Normalize to tabs or spaces"";
    }

    @Override
    public String getDescription() {
        return ""Consistently use either tabs or spaces in indentation."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                TabsAndIndentsStyle style = ((SourceFile) cu).getStyle(TabsAndIndentsStyle.class);
                if (style == null) {
                    style = IntelliJ.tabsAndIndents();
                }
                return new NormalizeTabsOrSpacesVisitor<>(style).visit(cu, ctx);
            }
            return (J) tree;
        }
    }
}
",{}
Tabs and indents,Format tabs and indents in Java code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.SpacesStyle;
import org.openrewrite.java.style.TabsAndIndentsStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

import java.util.Optional;

import static java.util.Objects.requireNonNull;

public class TabsAndIndents extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Tabs and indents"";
    }

    @Override
    public String getDescription() {
        return ""Format tabs and indents in Java code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new TabsAndIndentsFromCompilationUnitStyle();
    }

    private static class TabsAndIndentsFromCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, cu, IntelliJ::tabsAndIndents);
                SpacesStyle spacesStyle = Optional.ofNullable(Style.from(SpacesStyle.class, cu)).orElse(IntelliJ.spaces());
                return new TabsAndIndentsVisitor<>(style, spacesStyle).visit(tree, ctx);
            }
            return (J) tree;
        }
    }

    public static <J2 extends J> J2 formatTabsAndIndents(J j, Cursor cursor) {
        SourceFile cu = cursor.firstEnclosingOrThrow(SourceFile.class);
        TabsAndIndentsStyle style = Style.from(TabsAndIndentsStyle.class, cu, IntelliJ::tabsAndIndents);
        SpacesStyle spacesStyle = Optional.ofNullable(Style.from(SpacesStyle.class, cu)).orElse(IntelliJ.spaces());
        //noinspection unchecked
        return (J2) new TabsAndIndentsVisitor<>(style, spacesStyle)
                .visitNonNull(j, 0, cursor);
    }
}
",{}
Blank lines,Add and/or remove blank lines.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.BlankLinesStyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import static java.util.Objects.requireNonNull;

public class BlankLines extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Blank lines"";
    }

    @Override
    public String getDescription() {
        return ""Add and/or remove blank lines."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new BlankLinesFromCompilationUnitStyle();
    }

    private static class BlankLinesFromCompilationUnitStyle extends JavaIsoVisitor<ExecutionContext> {
        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                JavaSourceFile cu = (JavaSourceFile) requireNonNull(tree);
                BlankLinesStyle style = cu.getStyle(BlankLinesStyle.class);
                if (style == null) {
                    style = IntelliJ.blankLines();
                }
                return new BlankLinesVisitor<>(style).visit(cu, ctx);
            }
            return (J) tree;
        }
    }

    public static <J2 extends J> J2 formatBlankLines(J j, Cursor cursor) {
        BlankLinesStyle style = cursor.firstEnclosingOrThrow(SourceFile.class)
                .getStyle(BlankLinesStyle.class);
        //noinspection unchecked
        return (J2) new BlankLinesVisitor<>(style == null ? IntelliJ.blankLines() : style)
                .visitNonNull(j, 0, cursor);
    }
}
",{}
Format Java code,Format Java code using a standard comprehensive set of Java formatting recipes.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;

public class AutoFormat extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Format Java code"";
    }

    @Override
    public String getDescription() {
        return ""Format Java code using a standard comprehensive set of Java formatting recipes."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new AutoFormatVisitor<>(null);
    }
}
",{}
Single line comments begin with a whitespace,Write `// hi` instead of `//hi`.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.Space;
import org.openrewrite.java.tree.TextComment;

public class SingleLineComments extends Recipe {
    @Override
    public String getDisplayName() {
        return ""Single line comments begin with a whitespace"";
    }

    @Override
    public String getDescription() {
        return ""Write `// hi` instead of `//hi`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public Space visitSpace(Space space, Space.Location loc, ExecutionContext ctx) {
                return space.withComments(ListUtils.map(space.getComments(), c -> {
                    if (!c.isMultiline()) {
                        TextComment tc = (TextComment) c;
                        String commentText = tc.getText();
                        if (!commentText.isEmpty() && !commentText.startsWith("" "")) {
                            return tc.withText("" "" + commentText);
                        }
                    }
                    return c;
                }));
            }
        };
    }
}
",{}
Method parameter padding,Fixes whitespace padding between the identifier of a method definition or method invocation and the left parenthesis of the parameter list. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.Checkstyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.MethodParamPadStyle;
import org.openrewrite.java.style.SpacesStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

import java.util.Optional;

import static java.util.Objects.requireNonNull;

public class MethodParamPad extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Method parameter padding"";
    }

    @Override
    public String getDescription() {
        return ""Fixes whitespace padding between the identifier of a method definition or method invocation and the left parenthesis of the parameter list. "" +
               ""For example, when configured to remove spacing, `someMethodInvocation (x);` becomes `someMethodInvocation(x)`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new MethodParamPadVisitor();
    }

    private static class MethodParamPadVisitor extends JavaIsoVisitor<ExecutionContext> {
        SpacesStyle spacesStyle;
        MethodParamPadStyle methodParamPadStyle;

        @Override
        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
            // This visitor causes problems for Groovy sources as the `SpacesVisitor` is not aware of Groovy
            return sourceFile instanceof J.CompilationUnit;
        }

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                SourceFile cu = (SourceFile) requireNonNull(tree);
                spacesStyle = Optional.ofNullable(cu.getStyle(SpacesStyle.class)).orElse(IntelliJ.spaces());
                methodParamPadStyle = Optional.ofNullable(Style.from(MethodParamPadStyle.class, cu)).orElse(Checkstyle.methodParamPadStyle());

                spacesStyle = spacesStyle.withBeforeParentheses(
                        spacesStyle.getBeforeParentheses()
                                .withMethodDeclaration(methodParamPadStyle.getSpace())
                                .withMethodCall(methodParamPadStyle.getSpace())
                );
                return super.visit(cu, ctx);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J.MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            J.MethodDeclaration md = super.visitMethodDeclaration(method, ctx);
            if (!methodParamPadStyle.getAllowLineBreaks() && md.getPadding().getParameters().getBefore().getWhitespace().contains(""\n"")) {
                md = md.getPadding().withParameters(
                        md.getPadding().getParameters().withBefore(
                                md.getPadding().getParameters().getBefore().withWhitespace("""")
                        )
                );
            }
            if (!md.getParameters().isEmpty()) {
                md = (J.MethodDeclaration) new SpacesVisitor<>(spacesStyle, null, null, md.getParameters().get(0))
                        .visitNonNull(md, ctx, getCursor().getParentTreeCursor().fork());
            }
            return md;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation mi = super.visitMethodInvocation(method, ctx);
            if (!methodParamPadStyle.getAllowLineBreaks() && mi.getPadding().getArguments().getBefore().getWhitespace().contains(""\n"")) {
                mi = mi.getPadding().withArguments(
                        mi.getPadding().getArguments().withBefore(
                                mi.getPadding().getArguments().getBefore().withWhitespace("""")
                        )
                );
            }
            return (J.MethodInvocation) new SpacesVisitor<>(spacesStyle, null, null, mi)
                    .visitNonNull(mi, ctx, getCursor().getParentTreeCursor().fork());
        }

        @Override
        public J.NewClass visitNewClass(J.NewClass newClass, ExecutionContext ctx) {
            J.NewClass nc = super.visitNewClass(newClass, ctx);
            if (!methodParamPadStyle.getAllowLineBreaks()) {
                nc.getPadding().getArguments();
                if (nc.getPadding().getArguments().getBefore().getWhitespace().contains(""\n"")) {
                    nc = nc.getPadding().withArguments(
                            nc.getPadding().getArguments().withBefore(
                                    nc.getPadding().getArguments().getBefore().withWhitespace("""")
                            )
                    );
                }
            }
            return (J.NewClass) new SpacesVisitor<>(spacesStyle, null, null, nc)
                    .visitNonNull(nc, ctx, getCursor().getParentTreeCursor().fork());
        }
    }
}
",{}
No whitespace before,Removes unnecessary whitespace preceding a token. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

import static java.util.Objects.requireNonNull;

public class NoWhitespaceBefore extends Recipe {
    @Override
    public String getDisplayName() {
        return ""No whitespace before"";
    }

    @Override
    public String getDescription() {
        return ""Removes unnecessary whitespace preceding a token. "" +
               ""A linebreak before a token will be removed unless `allowLineBreaks` is set to `true`."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new NoWhitespaceBeforeVisitor();
    }

    private static class NoWhitespaceBeforeVisitor extends JavaIsoVisitor<ExecutionContext> {
        SpacesStyle spacesStyle;
        NoWhitespaceBeforeStyle noWhitespaceBeforeStyle;

        @Nullable
        EmptyForInitializerPadStyle emptyForInitializerPadStyle;

        @Nullable
        EmptyForIteratorPadStyle emptyForIteratorPadStyle;

        @Override
        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
            // This visitor causes problems for Groovy sources as method invocations without parentheses get squashed
            return sourceFile instanceof J.CompilationUnit;
        }

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                SourceFile cu = (SourceFile) requireNonNull(tree);
                spacesStyle = Style.from(SpacesStyle.class, cu, IntelliJ::spaces);
                noWhitespaceBeforeStyle = Style.from(NoWhitespaceBeforeStyle.class, cu, Checkstyle::noWhitespaceBeforeStyle);
                emptyForInitializerPadStyle = Style.from(EmptyForInitializerPadStyle.class, cu);
                emptyForIteratorPadStyle = Style.from(EmptyForIteratorPadStyle.class, cu);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess f = super.visitFieldAccess(fieldAccess, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getDot())) {
                if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getAllowLineBreaks()) && f.getPadding().getName().getBefore().getWhitespace().contains(""\n"")) {
                    return f;
                }
                if (f.getPadding().getName().getBefore().getWhitespace().contains("" "")) {
                    f = f.getPadding().withName(f.getPadding().getName().withBefore(
                            f.getPadding().getName().getBefore().withWhitespace("""")
                    ));
                }
            }
            return f;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getDot())) {
                if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getAllowLineBreaks()) && m.getPadding().getSelect() != null && m.getPadding().getSelect().getAfter().getWhitespace().contains(""\n"")) {
                    return m;
                }
                if (m.getPadding().getSelect() != null && m.getPadding().getSelect().getAfter().getWhitespace().contains("" "")) {
                    m = m.getPadding().withSelect(m.getPadding().getSelect().withAfter(
                            m.getPadding().getSelect().getAfter().withWhitespace("""")
                    ));
                }
            }
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getComma())) {
                m = (J.MethodInvocation) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(m, ctx);
            }
            return m;
        }

        @Override
        public J.ForLoop visitForLoop(J.ForLoop forLoop, ExecutionContext ctx) {
            J.ForLoop f = super.visitForLoop(forLoop, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getSemi())) {
                f = (J.ForLoop) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(f, ctx);
            }
            return f;
        }

        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            J.VariableDeclarations vd = super.visitVariableDeclarations(multiVariable, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getComma())) {
                if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getAllowLineBreaks()) && vd.getPadding().getVariables().stream().anyMatch(v -> v.getAfter().getWhitespace().contains(""\n""))) {
                    return vd;
                }
                vd = vd.getPadding().withVariables(ListUtils.map(vd.getPadding().getVariables(), v -> {
                    return v.withAfter(v.getAfter().withWhitespace(""""));
                }));
            }
            return vd;
        }

        @Override
        public J.Unary visitUnary(J.Unary unary, ExecutionContext ctx) {
            J.Unary u = super.visitUnary(unary, ctx);
            J.Unary.Type op = u.getOperator();
            if ((Boolean.TRUE.equals(noWhitespaceBeforeStyle.getPostInc()) && op == J.Unary.Type.PostIncrement) ||
                (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getPostDec() && op == J.Unary.Type.PostDecrement))) {
                if (Boolean.FALSE.equals(noWhitespaceBeforeStyle.getAllowLineBreaks()) && u.getPadding().getOperator().getBefore().getWhitespace().contains(""\n"")) {
                    u = u.getPadding().withOperator(u.getPadding().getOperator().withBefore(u.getPadding().getOperator().getBefore().withWhitespace("""")));
                }
                u = (J.Unary) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(u, ctx);
            }
            return u;
        }

        @Override
        public J.ParameterizedType visitParameterizedType(J.ParameterizedType type, ExecutionContext ctx) {
            J.ParameterizedType p = super.visitParameterizedType(type, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getGenericStart())) {
                if (p.getPadding().getTypeParameters() != null) {
                    p = p.getPadding().withTypeParameters(p.getPadding().getTypeParameters().withBefore(
                            p.getPadding().getTypeParameters().getBefore().withWhitespace("""")
                    ));
                }
            }
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getGenericEnd())) {
                if (p.getPadding().getTypeParameters() != null) {
                    p = p.getPadding().withTypeParameters(p.getPadding().getTypeParameters().getPadding().withElements(
                            ListUtils.map(p.getPadding().getTypeParameters().getPadding().getElements(), e -> {
                                return e.withAfter(e.getAfter().withWhitespace(""""));
                            })
                    ));
                }
            }
            return p;
        }

        @Override
        public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
            J.MemberReference m = super.visitMemberReference(memberRef, ctx);
            if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getMethodRef())) {
                if (Boolean.TRUE.equals(noWhitespaceBeforeStyle.getAllowLineBreaks()) && m.getPadding().getContaining().getAfter().getWhitespace().contains(""\n"")) {
                    return m;
                }
                m = m.getPadding().withContaining(m.getPadding().getContaining().withAfter(
                        m.getPadding().getContaining().getAfter().withWhitespace("""")
                ));
            }
            return m;
        }

    }

}
",{}
No whitespace after,Removes unnecessary whitespace appearing after a token. ,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

import static java.util.Objects.requireNonNull;

public class NoWhitespaceAfter extends Recipe {
    @Override
    public String getDisplayName() {
        return ""No whitespace after"";
    }

    @Override
    public String getDescription() {
        return ""Removes unnecessary whitespace appearing after a token. "" +
               ""A linebreak after a token is allowed unless `allowLineBreaks` is set to `false`, in which case it will be removed."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new NoWhitespaceAfterVisitor();
    }

    private static class NoWhitespaceAfterVisitor extends JavaIsoVisitor<ExecutionContext> {
        SpacesStyle spacesStyle;
        NoWhitespaceAfterStyle noWhitespaceAfterStyle;

        @Nullable
        EmptyForInitializerPadStyle emptyForInitializerPadStyle;

        @Nullable
        EmptyForIteratorPadStyle emptyForIteratorPadStyle;

        @Override
        public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
            // This visitor causes problems for Groovy sources as method invocations without parentheses get squashed
            return sourceFile instanceof J.CompilationUnit;
        }

        @Override
        public J visit(@Nullable Tree tree, ExecutionContext ctx) {
            if (tree instanceof JavaSourceFile) {
                SourceFile cu = (SourceFile) requireNonNull(tree);
                spacesStyle = Style.from(SpacesStyle.class, cu, IntelliJ::spaces);
                noWhitespaceAfterStyle = Style.from(NoWhitespaceAfterStyle.class, cu, Checkstyle::noWhitespaceAfterStyle);
                emptyForInitializerPadStyle = Style.from(EmptyForInitializerPadStyle.class, cu);
                emptyForIteratorPadStyle = Style.from(EmptyForIteratorPadStyle.class, cu);
            }
            return super.visit(tree, ctx);
        }

        @Override
        public J.TypeCast visitTypeCast(J.TypeCast typeCast, ExecutionContext ctx) {
            J.TypeCast t = super.visitTypeCast(typeCast, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getTypecast())) {
                t = (J.TypeCast) new SpacesVisitor<>(spacesStyle.withOther(spacesStyle.getOther().withAfterTypeCast(false)), emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(t, ctx);
            }
            return t;
        }

        @Override
        public J.MemberReference visitMemberReference(J.MemberReference memberRef, ExecutionContext ctx) {
            J.MemberReference m = super.visitMemberReference(memberRef, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getMethodRef())) {
                m = (J.MemberReference) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(m, ctx);
            }
            return m;
        }

        @Override
        public J.Annotation visitAnnotation(J.Annotation annotation, ExecutionContext ctx) {
            J.Annotation a = super.visitAnnotation(annotation, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getAnnotation())) {
                a = a.withAnnotationType(a.getAnnotationType().withPrefix(
                        a.getAnnotationType().getPrefix().withWhitespace("""")
                ));
            }
            return a;
        }

        @Override
        public J.ArrayType visitArrayType(J.ArrayType arrayType, ExecutionContext ctx) {
            J.ArrayType a = super.visitArrayType(arrayType, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getArrayDeclarator())) {
                if (a.getDimension() != null && a.getDimension().getBefore().getWhitespace().contains("" "")) {
                    if (a.getAnnotations() == null || a.getAnnotations().isEmpty()) {
                        a = a.withDimension(a.getDimension().withBefore(a.getDimension().getBefore().withWhitespace("""")));
                    }
                }
            }
            return a;
        }

        @Override
        public J.NewArray visitNewArray(J.NewArray newArray, ExecutionContext ctx) {
            J.NewArray n = super.visitNewArray(newArray, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getArrayInitializer())) {
                n = (J.NewArray) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(n, ctx);
            }
            return n;
        }

        @Override
        public J.ArrayAccess visitArrayAccess(J.ArrayAccess arrayAccess, ExecutionContext ctx) {
            J.ArrayAccess a = super.visitArrayAccess(arrayAccess, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getIndexOperation())) {
                a = a.withDimension(a.getDimension().withPrefix(a.getDimension().getPrefix().withWhitespace("""")));
            }
            return a;
        }

        @Override
        public J.Unary visitUnary(J.Unary unary, ExecutionContext ctx) {
            J.Unary u = super.visitUnary(unary, ctx);
            J.Unary.Type op = u.getOperator();
            if ((Boolean.TRUE.equals(noWhitespaceAfterStyle.getInc()) && op == J.Unary.Type.PreIncrement) ||
                (Boolean.TRUE.equals(noWhitespaceAfterStyle.getDec()) && op == J.Unary.Type.PreDecrement) ||
                (Boolean.TRUE.equals(noWhitespaceAfterStyle.getBnoc()) && op == J.Unary.Type.Complement) ||
                (Boolean.TRUE.equals(noWhitespaceAfterStyle.getLnot()) && op == J.Unary.Type.Not) ||
                (Boolean.TRUE.equals(noWhitespaceAfterStyle.getUnaryPlus()) && op == J.Unary.Type.Positive) ||
                (Boolean.TRUE.equals(noWhitespaceAfterStyle.getUnaryMinus()) && op == J.Unary.Type.Negative)
            ) {
                u = (J.Unary) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(u, ctx);
            }
            return u;
        }

        @Override
        public J.FieldAccess visitFieldAccess(J.FieldAccess fieldAccess, ExecutionContext ctx) {
            J.FieldAccess f = super.visitFieldAccess(fieldAccess, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getDot())) {
                if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getAllowLineBreaks()) && f.getName().getPrefix().getWhitespace().contains(""\n"")) {
                    return f;
                }
                if (f.getName().getPrefix().getWhitespace().contains("" "")) {
                    f = f.withName(f.getName().withPrefix(
                            f.getName().getPrefix().withWhitespace("""")
                    ));
                }
            }
            return f;
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, ExecutionContext ctx) {
            J.MethodInvocation m = super.visitMethodInvocation(method, ctx);
            if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getDot())) {
                if (Boolean.TRUE.equals(noWhitespaceAfterStyle.getAllowLineBreaks()) && m.getName().getPrefix().getWhitespace().contains(""\n"")) {
                    return m;
                }
                m = m.withName(m.getName().withPrefix(
                        m.getName().getPrefix().withWhitespace("""")
                ));
                m = (J.MethodInvocation) new SpacesVisitor<>(spacesStyle, emptyForInitializerPadStyle, emptyForIteratorPadStyle).visitNonNull(m, ctx);
            }
            return m;
        }
    }
}
",{}
End files with a single newline,Some tools work better when files end with an empty line.,Java,"/*
 * Copyright 2021 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.Recipe;
import org.openrewrite.Tree;
import org.openrewrite.TreeVisitor;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.internal.StringUtils;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.Comment;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.java.tree.Space;
import org.openrewrite.style.GeneralFormatStyle;
import org.openrewrite.style.Style;

import java.time.Duration;
import java.util.List;
import java.util.Set;

import static java.util.Collections.singleton;
import static org.openrewrite.java.format.AutodetectGeneralFormatStyle.autodetectGeneralFormatStyle;

public class EmptyNewlineAtEndOfFile extends Recipe {
    @Override
    public String getDisplayName() {
        return ""End files with a single newline"";
    }

    @Override
    public String getDescription() {
        return ""Some tools work better when files end with an empty line."";
    }

    @Override
    public Set<String> getTags() {
        return singleton(""RSPEC-S113"");
    }

    @Override
    public Duration getEstimatedEffortPerOccurrence() {
        return Duration.ofMinutes(1);
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) tree;
                    GeneralFormatStyle generalFormatStyle = Style.from(GeneralFormatStyle.class, cu, () -> autodetectGeneralFormatStyle(cu));
                    String lineEnding = generalFormatStyle.newLine();

                    Space eof = cu.getEof();
                    if (StringUtils.isBlank(eof.getLastWhitespace()) &&
                        eof.getLastWhitespace().chars().filter(c -> c == '\n').count() != 1) {
                        List<Comment> comments = eof.getComments();
                        if (comments.isEmpty()) {
                            return cu.withEof(Space.format(lineEnding));
                        } else {
                            return cu.withEof(cu.getEof().withComments(ListUtils.mapLast(comments, it -> it.withSuffix(lineEnding))));
                        }
                    }
                    return cu;
                }
                return (J) tree;
            }
        };
    }
}
",{}
Spaces,Format whitespace in Java code.,Java,"/*
 * Copyright 2020 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.format;

import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.style.EmptyForInitializerPadStyle;
import org.openrewrite.java.style.EmptyForIteratorPadStyle;
import org.openrewrite.java.style.IntelliJ;
import org.openrewrite.java.style.SpacesStyle;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.style.Style;

public class Spaces extends Recipe {

    @Override
    public String getDisplayName() {
        return ""Spaces"";
    }

    @Override
    public String getDescription() {
        return ""Format whitespace in Java code."";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new JavaIsoVisitor<ExecutionContext>() {
            @Override
            public boolean isAcceptable(SourceFile sourceFile, ExecutionContext ctx) {
                return sourceFile instanceof J.CompilationUnit;
            }

            @Override
            public @Nullable J visit(@Nullable Tree tree, ExecutionContext ctx) {
                if (tree instanceof JavaSourceFile) {
                    JavaSourceFile cu = (JavaSourceFile) tree;
                    SpacesStyle style = cu.getStyle(SpacesStyle.class);
                    if (style == null) {
                        style = IntelliJ.spaces();
                    }
                    return new SpacesVisitor<>(style, cu.getStyle(EmptyForInitializerPadStyle.class),
                            cu.getStyle(EmptyForIteratorPadStyle.class)).visit(cu, ctx);
                }
                return super.visit(tree, ctx);
            }
        };
    }

    public static <J2 extends J> J2 formatSpaces(J j, Cursor cursor) {
        SourceFile cu = cursor.firstEnclosingOrThrow(SourceFile.class);
        SpacesStyle style = cu.getStyle(SpacesStyle.class);
        //noinspection unchecked
        return (J2) new SpacesVisitor<>(style == null ? IntelliJ.spaces() : style,
                Style.from(EmptyForInitializerPadStyle.class, cu),
                Style.from(EmptyForIteratorPadStyle.class, cu)).visitNonNull(j, 0, cursor);
    }
}
",{}
Verify cursor well-formed,This recipe verifies that the cursor is well-formed.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite;

import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.openrewrite.internal.RecipeRunException;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;
import org.openrewrite.test.RewriteTest;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.openrewrite.java.Assertions.java;

class RepeatTest implements RewriteTest {

    /**
     * This visitor verifies that the cursor is well-formed.
     */
    static class VerifyCursorWellFormed<P> extends JavaVisitor<P> {
        @Override
        public J preVisit(J tree, P p) {
            assertNotNull(getCursor().firstEnclosing(JavaSourceFile.class), ""JavaSourceFile should be accessible"");
            assertNotEquals(getCursor().getParentOrThrow().getValue(), tree, ""Tree should not be the same as its parent"");
            return tree;
        }
    }

    static class VerifyCursorWellFormedInRepeat extends JavaVisitor<ExecutionContext> {
        @Override
        public J preVisit(J tree, ExecutionContext ctx) {
            return (J) Repeat.repeatUntilStable(new VerifyCursorWellFormed<>()).visitNonNull(tree, ctx, getCursor().getParentTreeCursor());
        }
    }

    @Test
    void repeatInPreVisit() {
        rewriteRun(
          spec -> spec.recipe(RewriteTest.toRecipe(VerifyCursorWellFormedInRepeat::new)),
          java(""class A {}"")
        );
    }

    public static class VerifyCursorWellFormedRecipe extends Recipe {
        @Override
        public String getDisplayName() {
            return ""Verify cursor well-formed"";
        }

        @Override
        public String getDescription() {
            return ""This recipe verifies that the cursor is well-formed."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return Repeat.repeatUntilStable(new VerifyCursorWellFormed<>());
        }
    }

    @Test
    void repeatInRecipe() {
        rewriteRun(
          spec -> spec.recipe(new VerifyCursorWellFormedRecipe()),
          java(""class A {}"")
        );
    }

    static class VisitorThatFailsToSetCursor extends JavaVisitor<ExecutionContext> {
        @Override
        public @Nullable J preVisit(J tree, ExecutionContext ctx) {
            return (J) Repeat.repeatUntilStable(new JavaVisitor<>()).visitNonNull(tree, ctx);
        }
    }

    @Test
    void repeatValidatesCursorIsPassed() {
        AssertionError assertionError = assertThrows(AssertionError.class, () ->
            rewriteRun(
              spec -> spec.recipe(RewriteTest.toRecipe(VisitorThatFailsToSetCursor::new)),
              java(""class A {}"")
            ));
        assertThat(assertionError).cause().isInstanceOf(RecipeRunException.class);
        RecipeRunException e = (RecipeRunException) assertionError.getCause();
        assertThat(e.getMessage())
          .contains(
            ""Repeat visitor called on a non-source file tree without a cursor pointing to the root of the tree. "" +
            ""Passed tree type: `org.openrewrite.java.tree.J$ClassDeclaration`. "" +
            ""This is likely a bug in the calling code. "" +
            ""Use a `visit` method that accepts a cursor instead.""
          );
    }
}
",{}
Mixed constructor,"A recipe with more than one constructor, with one marked as the primary.",Java,"/*
 * Copyright 2023 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import com.fasterxml.jackson.annotation.JsonCreator;
import org.openrewrite.Recipe;

public class MixedConstructorRecipe extends Recipe {
    public MixedConstructorRecipe() {
        this(true);
    }

    @JsonCreator
    public MixedConstructorRecipe(boolean opt) {
    }

    @Override
    public String getDisplayName() {
        return ""Mixed constructor"";
    }

    @Override
    public String getDescription() {
        return ""A recipe with more than one constructor, with one marked as the primary."";
    }
}
",{}
Extract interface,Extract to an interface named `ITest`.,Java,"/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.AllArgsConstructor;
import org.junit.jupiter.api.Test;
import org.openrewrite.*;
import org.openrewrite.java.tree.J;
import org.openrewrite.test.RewriteTest;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import static org.openrewrite.Tree.randomId;
import static org.openrewrite.java.Assertions.java;

class ExtractInterfaceTest implements RewriteTest {

    @AllArgsConstructor
    private static class ExtractTestInterface extends ScanningRecipe<AtomicReference<J.CompilationUnit>> {
        @Override
        public String getDisplayName() {
            return ""Extract interface"";
        }

        @Override
        public String getDescription() {
            return ""Extract to an interface named `ITest`."";
        }

        @Override
        public AtomicReference<J.CompilationUnit> getInitialValue(ExecutionContext ctx) {
            return new AtomicReference<>();
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getScanner(AtomicReference<J.CompilationUnit> acc) {
            return new JavaIsoVisitor<>() {
                @Override
                public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
                    acc.set(cu.withId(randomId()));
                    return cu;
                }
            };
        }

        @Override
        public Collection<? extends SourceFile> generate(AtomicReference<J.CompilationUnit> acc, ExecutionContext ctx) {
            return List.of((SourceFile) new ExtractInterface.CreateInterface(""org.openrewrite.interfaces.ITest"")
              .visitNonNull(acc.get(), ctx));
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor(AtomicReference<J.CompilationUnit> acc) {
            return new ExtractInterface.ImplementAndAddOverrideAnnotations(""org.openrewrite.interfaces.ITest"");
        }
    }

    @DocumentExample
    @Test
    void extractInterface() {
        rewriteRun(
          spec -> spec.recipe(new ExtractTestInterface()).cycles(1).expectedCyclesThatMakeChanges(1),
          java(
            """"""
              package org.openrewrite;

              class Test {
                  int f;

                  public Test() {
                  }

                  public final int test() {
                      return 0;
                  }

                  private int privateTest() {
                  }

                  public static int staticTest() {
                  }
              }
              """""",
            """"""
              package org.openrewrite;

              import org.openrewrite.interfaces.ITest;

              class Test implements ITest {
                  int f;

                  public Test() {
                  }

                  @Override
                  public final int test() {
                      return 0;
                  }

                  private int privateTest() {
                  }

                  public static int staticTest() {
                  }
              }
              """"""
          ),
          java(
            doesNotExist(),
            """"""
              package org.openrewrite.interfaces;

              interface ITest {

                  int test();
              }
              """""",
            spec -> spec.path(""org/openrewrite/interfaces/ITest.java"")
          )
        );
    }
}
",{}
Finalize local variables,Adds the `final` modifier keyword to local variables which are not reassigned.,Java,"/*
 * Copyright 2024 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.openrewrite.*;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.Space;
import org.openrewrite.marker.Markers;
import org.openrewrite.test.RecipeSpec;
import org.openrewrite.test.RewriteTest;
import org.openrewrite.test.TypeValidation;

import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Collections.emptyList;
import static org.openrewrite.java.Assertions.java;
import static org.openrewrite.java.Assertions.version;

class FinalizeLocalVariablesTest implements RewriteTest {
    @Override
    public void defaults(RecipeSpec spec) {
        spec.recipe(new FinalizeLocalVariables());
    }

    @Issue(""https://github.com/openrewrite/rewrite/issues/3744"")
    @ParameterizedTest
    @ValueSource(ints = { 11, 17, 21 })
    void missingTypePlusVarNotMissingSpace(int javaVersion) {
        rewriteRun(
          s -> s.typeValidationOptions(TypeValidation.none()),
          //language=java
          version(
            java(
              """"""
                import foo.Unknown;
                class Bar {
                    void test(Unknown b) {
                        var a = b;
                    }
                }
                """""",
              """"""
                import foo.Unknown;
                class Bar {
                    void test(Unknown b) {
                        final var a = b;
                    }
                }
                """"""
            ), javaVersion
          )
        );
    }

    @Issue(""https://github.com/openrewrite/rewrite/issues/3744"")
    @ParameterizedTest
    @ValueSource(ints = { 11, 17, 21 })
    void explicitTypePlusVarNotMissingSpace(int javaVersion) {
        rewriteRun(
          s -> s.typeValidationOptions(TypeValidation.none()),
          //language=java
          version(
            java(
              """"""
                class Bar {
                    void test(String b) {
                        var a = b;
                    }
                }
                """""",
              """"""
                class Bar {
                    void test(String b) {
                        final var a = b;
                    }
                }
                """"""
            ), javaVersion
          )
        );
    }

    public static class FinalizeLocalVariables extends Recipe {
        @Override
        public String getDisplayName() {
            return ""Finalize local variables"";
        }

        @Override
        public String getDescription() {
            return ""Adds the `final` modifier keyword to local variables which are not reassigned."";
        }

        @Override
        public TreeVisitor<?, ExecutionContext> getVisitor() {
            return new JavaIsoVisitor<>() {
                @Override
                public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable,
                                                                        ExecutionContext ctx) {
                    J.VariableDeclarations mv = super.visitVariableDeclarations(multiVariable, ctx);

                    // if this already has ""final"", we don't need to bother going any further; we're done
                    if (mv.hasModifier(J.Modifier.Type.Final)) {
                        return mv;
                    }

                    // consider uninitialized local variables non-final
                    if (mv.getVariables().stream().anyMatch(nv -> nv.getInitializer() == null)) {
                        return mv;
                    }

                    if (isDeclaredInForLoopControl(getCursor())) {
                        return mv;
                    }

                    // ignore fields (aka ""instance variable"" or ""class variable"")
                    if (mv.getVariables().stream().anyMatch(v -> v.isField(getCursor()))) {
                        return mv;
                    }

                    // ignores anonymous class fields, contributed code for issue #t
                    if (this.getCursorToParentScope(this.getCursor()).getValue() instanceof J.NewClass) {
                        return mv;
                    }

                    if (mv.getVariables().stream()
                          .noneMatch(v -> {
                              Cursor declaringCursor = v.getDeclaringScope(getCursor());
                              return FindAssignmentReferencesToVariable.find(declaringCursor.getValue(), v)
                                                                       .get();
                          })) {
                        mv = autoFormat(
                          mv.withModifiers(
                            ListUtils.concat(mv.getModifiers(),
                                             new J.Modifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY, null,
                                                            J.Modifier.Type.Final, emptyList()))
                          ), ctx);
                    }

                    return mv;
                }

                private Cursor getCursorToParentScope(final Cursor cursor) {
                    return cursor.dropParentUntil(
                      is -> is instanceof J.NewClass || is instanceof J.ClassDeclaration);
                }
            };
        }

        private boolean isDeclaredInForLoopControl(Cursor cursor) {
            return cursor.getParentTreeCursor()
                         .getValue() instanceof J.ForLoop.Control;
        }

        @EqualsAndHashCode(callSuper = false)
        @Value
        private static class FindAssignmentReferencesToVariable extends JavaIsoVisitor<AtomicBoolean> {

            J.VariableDeclarations.NamedVariable variable;

            /**
             * @param j        The subtree to search.
             * @param variable A {@link J.VariableDeclarations.NamedVariable} to check for any reassignment calls.
             * @return An {@link AtomicBoolean} that is true if the variable has been reassigned and false otherwise.
             */
            static AtomicBoolean find(J j, J.VariableDeclarations.NamedVariable variable) {
                return new FindAssignmentReferencesToVariable(variable)
                  .reduce(j, new AtomicBoolean());
            }

            @Override
            public J.Assignment visitAssignment(J.Assignment assignment, AtomicBoolean hasAssignment) {
                if (hasAssignment.get()) {
                    return assignment;
                }
                J.Assignment a = super.visitAssignment(assignment, hasAssignment);
                if (a.getVariable() instanceof J.Identifier) {
                    J.Identifier i = (J.Identifier) a.getVariable();
                    if (i.getSimpleName().equals(variable.getSimpleName())) {
                        hasAssignment.set(true);
                    }
                }
                return a;
            }

            @Override
            public J.AssignmentOperation visitAssignmentOperation(J.AssignmentOperation assignOp,
                                                                  AtomicBoolean hasAssignment) {
                if (hasAssignment.get()) {
                    return assignOp;
                }

                J.AssignmentOperation a = super.visitAssignmentOperation(assignOp, hasAssignment);
                if (a.getVariable() instanceof J.Identifier) {
                    J.Identifier i = (J.Identifier) a.getVariable();
                    if (i.getSimpleName().equals(variable.getSimpleName())) {
                        hasAssignment.set(true);
                    }
                }
                return a;
            }

            @Override
            public J.Unary visitUnary(J.Unary unary, AtomicBoolean hasAssignment) {
                if (hasAssignment.get()) {
                    return unary;
                }

                J.Unary u = super.visitUnary(unary, hasAssignment);
                if (u.getOperator().isModifying() && u.getExpression() instanceof J.Identifier) {
                    J.Identifier i = (J.Identifier) u.getExpression();
                    if (i.getSimpleName().equals(variable.getSimpleName())) {
                        hasAssignment.set(true);
                    }
                }
                return u;
            }
        }
    }
}
",{}
